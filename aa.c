// Copyright (c) 2008-2018, Ashot Apakian
// All rights reserved.
/*-----------------------------------------------------------------------*/
 #include "aa.h"
 #include <fcntl.h>

 #ifdef  _MSC_VER
 #pragma comment(lib,"gdi32.lib")
 #pragma comment(lib,"wsock32.lib")
 #pragma comment(lib,"advapi32.lib")
 #pragma comment(lib,"shell32.lib")
 #pragma comment(lib,"comdlg32.lib")
 #pragma comment(lib,"winmm.lib")
 #pragma comment(lib,"vfw32.lib")
 #pragma comment(lib,"kernel32.lib")
 #pragma comment(lib,"user32.lib")
 #endif

/*-----------------------------------------------------------------------*/
 V aaDummyFunction1                    (){} // this function is the first function offset, useful for aaFuncInfoGet
/*-----------------------------------------------------------------------*/

 #define aa_USE_GLOBAL_MUTEX           0
 CRITICAL_SECTION                      global_mutex;
 S jmp_buf aa_jmp_buf;

/*-----------------------------------------------------------------------*/

 H aa_last_line_executed               =__LINE__;

 #define aa_VERSION                    273

/*-----------------------------------------------------------------------*/

 #define aa_SHOW_PROFILE               0
 #define aa_SHOW_VERBOSE               0

/*-----------------------------------------------------------------------*/

 #define WAGO

 #define Boop
 #define aa_SHOW_DIAG_LINES            85000

 #define aaLogStructSize(obj)          aaLog(-555,"%-24s : %-5u bytes",#obj,sizeof(obj))

 #if aa_SHOW_PROFILE==1
 #define aa_DIAGNOSE                   YES
 H aa_diag_var;
 H aa_diag_hi;
 H aa_diag_lo;
 H aa_diag_cycle[aa_SHOW_DIAG_LINES];
 Q aa_diag_hits[aa_SHOW_DIAG_LINES];
 H aa_diag_line[aa_SHOW_DIAG_LINES];
 C aa_diag_text[aa_SHOW_DIAG_LINES][55];
 #define aa_DIAG_IGNORECRASH(name,cp)  aa_last_line_executed=__LINE__;                     \
                                       if(aa.is_ready==YES&&aa.is_diag_paused==NO)         \
                                       {                                                   \
                                       if(aa_diag_hits[__LINE__]==0)                       \
                                        {                                                  \
                                        strcpy(aa_diag_text[__LINE__],name);               \
                                        aa_diag_line[__LINE__]=__LINE__;                   \
                                        }                                                  \
                                       aa_diag_hits[__LINE__]++;                           \
                                       aa_diag_cycle[__LINE__]=aa.core_system.cycle;       \
                                       aa_diag_lo++;                                       \
                                       if(aa_diag_lo==1000) { aa_diag_hi++; aa_diag_lo=0; }\
                                       }
 #define aa_ZIAG(name)                 aa_DIAG_IGNORECRASH(name,NO)
 #define aa_CPAG(name)                 aa_DIAG_IGNORECRASH(name,YES)
 #else
 #define aa_DIAGNOSE                   NO
  #ifdef __GNUC__
  #define aa_ZIAG(name)
  #define aa_DIAG_IGNORECRASH(name)
  #define aa_CPAG(name) aaCrashPusher()
  #else
  #define aa_ZIAG(name)
  #define aa_DIAG_IGNORECRASH(name)
  #define aa_CPAG(name) aaCrashPusher()
  #endif
 #endif


 #if aa_SHOW_VERBOSE==1
 #define logg(...)                     aa_CoreSystemLog(__LINE__,__VA_ARGS__)
 #define prevent_warning(obj)          if(obj) {}
 #else
  #ifdef __GNUC__
  #define logg(...)
  #else
  //#define logg(x)                       /##/
  #endif
 #define prevent_warning(obj)          Boop
 #endif


/*-----------------------------------------------------------------------*/


 B WinFileTimeToSysTime                (FILETIME*filetime,_systime*systime);
 B WinSystemTimeToSysTime              (SYSTEMTIME*systemtime,_systime*systime);
 B WinSystemTimeFromSysTime            (SYSTEMTIME*systemtime,_systime*systime);
 B WinSystemTimeCopy                   (SYSTEMTIME*systemtime,SYSTEMTIME*ssystemtime);
 B WinErrorStringGet                   (VP string,H line);
 B WinSockAddrSet                      (struct sockaddr_in*addr,W family,H ip,W port);
 B WinPointCopy                        (POINT*point,POINT*spoint);
 B WinPointSet                         (POINT*point,N x,N y);
 B WinPointToCord                      (POINT*point,_cord*cord);
 B WinRectSet                          (RECT*rect,N x,N y,H w,H h);
 B WinRectToRect                       (RECT*rect,_rect*rect2);
 B WinRectCopy                         (RECT*rect,RECT*srect);
 B WinRectFromRect                     (RECT*rect,_rect*srect);
 B WinBmpInfoSet                       (BITMAPINFO*bmi,H w,H h,B bits,B negheight);
 B WinWaveHdrSet                       (WAVEHDR*hdr,LPSTR dat,H buflen,B bytesrec,H user,H flags);
 B WinWaveFormatExSet                  (WAVEFORMATEX*wfx,W tag,H sampssec,W channels,W bits,W cbsize);
 B WinWaveFormatExFromAudioMode        (WAVEFORMATEX*wfx,_audiomode*audiomode);
 B WinWaveFormatExToAudioMode          (WAVEFORMATEX*wfx,_audiomode*audiomode);
 B WinWaveFormatExToString             (WAVEFORMATEX*wfx,VP string);
 B WinWndClassExSet                    (WNDCLASSEX*wndclsex,W style,WNDPROC proc,VP classname);
 B WinCapParmsInit                     (VP caparms);


 structure
 {
 H cb;
 H majmin[2];
 H build;
 H platform;
 TCHAR txt[128];
 W spack[2];
 W smask;
 B type;
 B rsvd;
 }
 _mswinver;

/*-----------------------------------------------------------------------*/



 structure
 {
 DWORD  cb;
 DWORD  PageFaultCount;
 SIZE_T PeakWorkingSetSize;
 SIZE_T WorkingSetSize;
 SIZE_T QuotaPeakPagedPoolUsage;
 SIZE_T QuotaPagedPoolUsage;
 SIZE_T QuotaPeakNonPagedPoolUsage;
 SIZE_T QuotaNonPagedPoolUsage;
 SIZE_T PagefileUsage;
 SIZE_T PeakPagefileUsage;
 SIZE_T PrivateUsage;
 }
 PROCESS_MEMORY_COUNTERS;

 structure
 {
 H dwSize;
 H cntUsage;
 H th32ProcessID;
 ULONG*th32DefaultHeapID;
 H th32ModuleID;
 H cntThreads;
 H th32ParentProcessID;
 LONG pcPriClassBase;
 H dwFlags;
 TCHAR szExeFile[MAX_PATH];
 }
 PROCENTRY32;


 structure
 {
 W Length;
 W MaximumLength;
 PWSTR Buffer;
 }
 UNICODE_STRING;

 structure
 {
 N ExitStatus;
 VP PebBaseAddress;
 HP AffinityMask;
 N BasePriority;
 HP UniqueProcessId;
 HP ParentProcessId;
 }
 PROCESS_BASIC_INFORMATION;


 structure
 {
 H dwSize;
 H th32ModuleID;
 H th32ProcessID;
 H GlblcntUsage;
 H ProccntUsage;
 BP modBaseAddr;
 H modBaseSize;
 HMODULE hModule;
 TCHAR szModule[256];
 TCHAR szExePath[MAX_PATH];
 }
 MODULEENTRY32;



 structure
 {
 DWORD dwSize;
 DWORD cntUsage;
 DWORD th32ThreadID;
 DWORD th32OwnerProcessID;
 LONG  tpBasePri;
 LONG  tpDeltaPri;
 DWORD dwFlags;
 }
 THREADENTRY32;


 structure
 {
 DWORD cb;
 TCHAR DeviceName[32];
 TCHAR DeviceString[128];
 DWORD StateFlags;
 TCHAR DeviceID[128];
 TCHAR DeviceKey[128];
 }
 aa_DISPLAY_DEVICE;



 structure
 {
 H cb_size;
 RECT r_moni;
 RECT w_work;
 H flags;
 TCHAR szDevice[CCHDEVICENAME];
 }
 aa_MONITOR_INFO;


 #define aa_DISDEV_ATTACHED_TO_DESKTOP 0x00000001
 #define aa_DISDEV_MULTI_DRIVER        0x00000002
 #define aa_DISDEV_PRIMARY_DEVICE      0x00000004
 #define aa_DISDEV_MIRRORING_DRIVER    0x00000008
 #define aa_DISDEV_VGA_COMPATIBLE      0x00000010
 #define aa_DISDEV_REMOVABLE           0x00000020
 #define aa_DISDEV_MODESPRUNED         0x08000000

 #define aa_DISDEV_ENUM_CURRENT_STNGS  -1
 #define aa_DISDEV_ENUM_REGISTRY_STNGS -2

 #define aa_DISDEV_DM_POSITION         0x20
 #define aa_DISDEV_CDS_SET_PRIMARY     0x10
 #define aa_DISDEV_CDS_NORESET         0x10000000

 T BOOL   (CALLBACK*MONENUMPROC)       (HANDLE,HDC,LPRECT,LPARAM);

 T BOOL   (WINAPI *setDllDirectory)    (CP);

 T BOOL   (WINAPI *getSystemTimes)     (FILETIME*,FILETIME*,FILETIME*);
 T BOOL   (WINAPI *getProcessTimes)    (HANDLE,FILETIME*,FILETIME*,FILETIME*,FILETIME*);
 T BOOL   (WINAPI *process32First)     (HANDLE,PROCENTRY32*);
 T BOOL   (WINAPI *process32Next)      (HANDLE,PROCENTRY32*);
 T BOOL   (WINAPI *thread32First)      (HANDLE,THREADENTRY32*);
 T BOOL   (WINAPI *thread32Next)       (HANDLE,THREADENTRY32*);
 T HANDLE (WINAPI *create32Snapshot)   (DWORD,DWORD);
 T BOOL   (WINAPI *module32First)      (HANDLE,MODULEENTRY32*);
 T BOOL   (WINAPI *module32Next)       (HANDLE,MODULEENTRY32*);
 T BOOL   (WINAPI *trycritical)        (LPCRITICAL_SECTION);
 T BOOL   (WINAPI *createprocwithlogin)(LPCWSTR,LPCWSTR,LPCWSTR,DWORD,LPCWSTR,LPWSTR,DWORD,LPVOID,LPCWSTR,LPSTARTUPINFOW,LPPROCESS_INFORMATION);
 T DWORD  (WINAPI *setlayeredwinattrs) (HWND,DWORD,BYTE,DWORD);
 T VOID   (WINAPI *disableGhosting)    (VOID);
 T BOOL   (WINAPI *printwindow)        (HWND,HDC,UINT);
 T BOOL   (WINAPI *enumdisplaydevs)    (LPCTSTR lpDevice,DWORD iDevNum,aa_DISPLAY_DEVICE*lpDisplayDevice,DWORD dwFlags);
 T BOOL   (WINAPI *enumDisplayMonitors)(HDC hDC,LPCRECT recclip,MONENUMPROC eproc,LPARAM data);
 T BOOL   (WINAPI *getMonitorInfoEx)   (HANDLE,aa_MONITOR_INFO*);
 T DWORD  (WINAPI *getModuleFileNameEx)(HANDLE,HMODULE,LPTSTR,DWORD);
 T DWORD  (WINAPI *getProcessFileName) (HANDLE,LPTSTR,DWORD);
 T BOOL   (WINAPI *getProcessMemoryInfo)(HANDLE,PROCESS_MEMORY_COUNTERS*,DWORD);
 T BOOL   (WINAPI *getOpenFileName)    (OPENFILENAME*);
 T DWORD  (NTAPI  *NTQueryInformationProcess) (HANDLE,DWORD,PVOID,DWORD,PDWORD);


 BOOL CALLBACK MonitorEproc            (HANDLE hmon,HDC hdc,LPRECT rcmon,LPARAM data)
 {
 NP hp,varptr;
 N i;

 varptr=(NP)data;
 i=varptr[0];
 if(i>=64) { return FALSE; }
 aaCast(hp,NP,&varptr[1+(i*6)]);
 hp[0]=(N)hmon;
 hp[1]=(N)hdc;
 hp[2]=(N)rcmon->left;
 hp[3]=(N)rcmon->top;
 hp[4]=(N)rcmon->right;
 hp[5]=(N)rcmon->bottom;
 i++;
 varptr[0]=i;
 return TRUE;
 }

/*-----------------------------------------------------------------------*/


 C ret_string_text[256][20];
 CP ret_string[256];
 HWND aa_hwnd_ignore[16]={0}; // first index is count of hwnds



 structure
 {
 H msg;
 B str[45];
 }
 _aa_winmsg;


 _aa_winmsg                            aa_winmsg[]={
 {0x0000,"NULL"},{0x0001,"CREATE"},{0x0002,"DESTROY"},{0x0003,"MOVE"},
 {0x0005,"SIZE"},{0x0006,"ACTIVATE"},{0x0007,"SETFOCUS"},{0x0008,"KILLFOCUS"},
 {0x000A,"ENABLE"},{0x000B,"SETREDRAW"},{0x000C,"SETTEXT"},{0x000D,"GETTEXT"},
 {0x000E,"GETTEXTLENGTH"},{0x000F,"PAINT"},{0x0010,"CLOSE"},{0x0011,"QUERYENDSESSION"},
 {0x0012,"QUIT"},{0x0013,"QUERYOPEN"},{0x0014,"ERASEBKGND"},{0x0015,"SYSCOLORCHANGE"},
 {0x0016,"ENDSESSION"},{0x0018,"SHOWWINDOW"},{0x001A,"WININICHANGE"},{WM_WININICHANGE,"SETTINGCHANGE"},
 {0x001B,"DEVMODECHANGE"},{0x001C,"ACTIVATEAPP"},{0x001D,"FONTCHANGE"},{0x001E,"TIMECHANGE"},
 {0x001F,"CANCELMODE"},{0x0020,"SETCURSOR"},{0x0021,"MOUSEACTIVATE"},{0x0022,"CHILDACTIVATE"},
 {0x0023,"QUEUESYNC"},{0x0024,"GETMINMAXINFO"},{0x0026,"PAINTICON"},{0x0027,"ICONERASEBKGND"},
 {0x0028,"NEXTDLGCTL"},{0x002A,"SPOOLERSTATUS"},{0x002B,"DRAWITEM"},{0x002C,"MEASUREITEM"},
 {0x002D,"DELETEITEM"},{0x002E,"VKEYTOITEM"},{0x002F,"CHARTOITEM"},{0x0030,"SETFONT"},
 {0x0031,"GETFONT"},{0x0032,"SETHOTKEY"},{0x0033,"GETHOTKEY"},{0x0037,"QUERYDRAGICON"},
 {0x0039,"COMPAREITEM"},{0x003D,"GETOBJECT"},{0x0041,"COMPACTING"},{0x0044,"COMMNOTIFY"},
 {0x0046,"WINDOWPOSCHANGING"},{0x0047,"WINDOWPOSCHANGED"},{0x0048,"POWER"},{0x004A,"COPYDATA"},
 {0x004B,"CANCELJOURNAL"},{0x004E,"NOTIFY"},{0x0050,"INPUTLANGCHANGEREQUEST"},{0x0051,"INPUTLANGCHANGE"},
 {0x0052,"TCARD"},{0x0053,"HELP"},{0x0054,"USERCHANGED"},{0x0055,"NOTIFYFORMAT"},
 {0x007B,"CONTEXTMENU"},{0x007C,"STYLECHANGING"},{0x007D,"STYLECHANGED"},{0x007E,"DISPLAYCHANGE"},
 {0x007F,"GETICON"},{0x0080,"SETICON"},{0x0081,"NCCREATE"},{0x0082,"NCDESTROY"},
 {0x0083,"NCCALCSIZE"},{0x0084,"NCHITTEST"},{0x0085,"NCPAINT"},{0x0086,"NCACTIVATE"},
 {0x0087,"GETDLGCODE"},{0x0088,"SYNCPAINT"},{0x00A0,"NCMOUSEMOVE"},{0x00A1,"NCLBUTTONDOWN"},
 {0x00A2,"NCLBUTTONUP"},{0x00A3,"NCLBUTTONDBLCLK"},{0x00A4,"NCRBUTTONDOWN"},{0x00A5,"NCRBUTTONUP"},
 {0x00A6,"NCRBUTTONDBLCLK"},{0x00A7,"NCMBUTTONDOWN"},{0x00A8,"NCMBUTTONUP"},{0x00A9,"NCMBUTTONDBLCLK"},
 //{0x0100,"KEYFIRST"},
 {0x0100,"KEYDOWN"},{0x0101,"KEYUP"},
 {0x0102,"CHAR"},{0x0103,"DEADCHAR"},
 {0x0104,"SYSKEYDOWN"},{0x0105,"SYSKEYUP"},
 {0x0106,"SYSCHAR"},{0x0107,"SYSDEADCHAR"},
 {0x0108,"KEYLAST"},
 {0x010D,"IME_STARTCOMPOSITION"},{0x010E,"IME_ENDCOMPOSITION"},
 {0x010F,"IME_COMPOSITION"},{0x010F,"IME_KEYLAST"},{0x0110,"INITDIALOG"},{0x0111,"COMMAND"},
 {0x0112,"SYSCOMMAND"},{0x0113,"TIMER"},{0x0114,"HSCROLL"},{0x0115,"VSCROLL"},
 {0x0116,"INITMENU"},{0x0117,"INITMENUPOPUP"},{0x011F,"MENUSELECT"},{0x0120,"MENUCHAR"},
 {0x0121,"ENTERIDLE"},{0x0122,"MENURBUTTONUP"},{0x0123,"MENUDRAG"},{0x0124,"MENUGETOBJECT"},
 {0x0125,"UNINITMENUPOPUP"},{0x0126,"MENUCOMMAND"},{0x0132,"CTLCOLORMSGBOX"},{0x0133,"CTLCOLOREDIT"},
 {0x0134,"CTLCOLORLISTBOX"},{0x0135,"CTLCOLORBTN"},{0x0136,"CTLCOLORDLG"},{0x0137,"CTLCOLORSCROLLBAR"},
 {0x0138,"CTLCOLORSTATIC"},{0x0200,"MOUSEFIRST"},{0x0200,"MOUSEMOVE"},{0x0201,"LBUTTONDOWN"},
 {0x0202,"LBUTTONUP"},{0x0203,"LBUTTONDBLCLK"},{0x0204,"RBUTTONDOWN"},{0x0205,"RBUTTONUP"},
 {0x0206,"RBUTTONDBLCLK"},{0x0207,"MBUTTONDOWN"},{0x0208,"MBUTTONUP"},{0x0209,"MBUTTONDBLCLK"},
 {0x020A,"MOUSEWHEEL"},{0x020A,"MOUSELAST"},{0x0209,"MOUSELAST"},{0x0210,"PARENTNOTIFY"},
 {0x0211,"ENTERMENULOOP"},{0x0212,"EXITMENULOOP"},{0x0213,"NEXTMENU"},{0x0214,"SIZING"},
 {0x0215,"CAPTURECHANGED"},{0x0216,"MOVING"},{0x0218,"POWERBROADCAST"},{0x0219,"DEVICECHANGE"},
 {0x0220,"MDICREATE"},{0x0221,"MDIDESTROY"},{0x0222,"MDIACTIVATE"},{0x0223,"MDIRESTORE"},
 {0x0224,"MDINEXT"},{0x0225,"MDIMAXIMIZE"},{0x0226,"MDITILE"},{0x0227,"MDICASCADE"},
 {0x0228,"MDIICONARRANGE"},{0x0229,"MDIGETACTIVE"},{0x0230,"MDISETMENU"},{0x0231,"ENTERSIZEMOVE"},
 {0x0232,"EXITSIZEMOVE"},{0x0233,"DROPFILES"},{0x0234,"MDIREFRESHMENU"},{0x0281,"IME_SETCONTEXT"},
 {0x0282,"IME_NOTIFY"},{0x0283,"IME_CONTROL"},{0x0284,"IME_COMPOSITIONFULL"},{0x0285,"IME_SELECT"},
 {0x0286,"IME_CHAR"},{0x0288,"IME_REQUEST"},{0x0290,"IME_KEYDOWN"},{0x0291,"IME_KEYUP"},
 {0x02A1,"MOUSEHOVER"},{0x02A3,"MOUSELEAVE"},{0x0300,"CUT"},{0x0301,"COPY"},
 {0x0302,"PASTE"},{0x0303,"CLEAR"},{0x0304,"UNDO"},{0x0305,"RENDERFORMAT"},
 {0x0306,"RENDERALLFORMATS"},{0x0307,"DESTROYCLIPBOARD"},{0x0308,"DRAWCLIPBOARD"},{0x0309,"PAINTCLIPBOARD"},
 {0x030A,"VSCROLLCLIPBOARD"},{0x030B,"SIZECLIPBOARD"},{0x030C,"ASKCBFORMATNAME"},{0x030D,"CHANGECBCHAIN"},
 {0x030E,"HSCROLLCLIPBOARD"},{0x030F,"QUERYNEWPALETTE"},{0x0310,"PALETTEISCHANGING"},{0x0311,"PALETTECHANGED"},
 {0x0312,"HOTKEY"},{0x0317,"PRINT"},{0x0318,"PRINTCLIENT"},{0x0358,"HANDHELDFIRST"},
 {0x035F,"HANDHELDLAST"},{0x0360,"AFXFIRST"},{0x037F,"AFXLAST"},{0x0380,"PENWINFIRST"},
 {0x038F,"PENWINLAST"},{0x8000,"APP"},{0x0400,"USER"}
 };



 #define aa_COREPREVMS_CpuLoadGet      0
 #define aa_COREPREVMS_NetYield        1


 structure
 {
 HINSTANCE this_instance;
 HINSTANCE prev_instance;
 H discovery_message_id;
 B aa_trace_file[513];
 B aa_crash_file[513];
 B built[50];
 B via_shortcut;
 B module_filename[_1K];
 B module_path[_1K];
 C command_line[_2K];
 N command_show;
 HMODULE kernel_module;
 HMODULE comdlg_module;
 HMODULE user_module;
 HMODULE advapi_module;
 HMODULE psapi_module;
 HMODULE ntdll_module;
 setDllDirectory SetDllDirectory;

 getSystemTimes GetSystemTimes;
 getProcessTimes GetProcessTimes;
 process32First Process32First;
 process32Next Process32Next;
 thread32First Thread32First;
 thread32Next Thread32Next;

 create32Snapshot Create32Snapshot;
 module32First Module32First;
 module32Next Module32Next;
 trycritical TryEnterCriticalSection;
 createprocwithlogin CreateProcWithLogin;
 setlayeredwinattrs SetLayeredWindowAttributes;
 disableGhosting DisableProcessWindowsGhosting;
 printwindow PrintWindow;
 enumdisplaydevs EnumDisplayDevices;
 enumDisplayMonitors EnumDisplayMonitors;
 getMonitorInfoEx GetMonitorInfoEx;
 getModuleFileNameEx GetModuleFileNameEx;
 getProcessMemoryInfo GetProcessMemoryInfo;
 getProcessFileName GetProcessFileName;
 getOpenFileName GetOpenFileName;
 NTQueryInformationProcess ntQueryInformationProcess;

 Q perf_frequency;
 Q perf_frequency_ms;
 Q prev_msrunning[32];
 H launch_tik;
 H version;
 B in_debugger;
 B in_remote_debugger;
 HANDLE process_handle;
 H process_id;
 HANDLE thread_handle;
 H thread_id;
 C class_name[257];
 WNDCLASSEX class_data;
 HANDLE softice_handle;
 B wm_quit_received;
 H wm_quit_exitcode;
 B is_exitcode_set;
 H set_exitcode;
 HDC display_dc;
 Q last_yield_msrunning;
 Q subt_yield_msrunning;
 Q cycle;
 Q wm_msg_count_total;
 Q wm_msg_count_surfaced;
 Q wm_msg_count_unhandled;
 Q wm_msg_count_erasebg;
 Q wm_msg_count_paint;
 HANDLE limiter_mutex_handle;
 Q limiter_last_counter;
 V(*LimiterMessageProc)(H,VP);
 V(*CopyDataProc)(HWND,HWND,H,H,VP);
 H master_log_entries;
 B master_log_state;
 B is_debugf_log_write;
 B debugf_log_write_style;
 B debugf_prefix[129];
 VP debugf_proc;
 //B(*debugf_proc)(VP fmt,...);
 H aamain_tik;
 H aamain_elapsed;
 Q aamain_perftik;
 Q aamain_perfelapsed;
 B is_morph_pending;
 PROCESS_INFORMATION morph_pi;
 B is_restart_on_crash;
 H crash_msrunning_required;
 H routine_proc_count;
 V (*RoutineProcYield[64])(VP);
 VP RoutineParmYield[64];
 V (*RoutineProcStop[64])(VP);
 VP RoutineParmStop[64];
 H note_killer_id;
 B(*SleepFunction)(Q ms);
 B is_console_attached;
 B is_console_ever_attached;
 B is_console_crlf_needed;
 }
 _aa_coresystem;


 B aa_CoreSystemHistory                (H line,VP fmt,...);
 B aa_CoreSystemLog                    (H style,VP fmt,...);
 B aa_CoreSystemLogStateSet            (B state);
 B aa_CoreSystemStart                  (HINSTANCE thisinst,HINSTANCE previnst,LPSTR cmdline,Z cmdshow);
 B aa_CoreSystemSleepStandard          (Q microsecs);
 B aa_CoreSystemSleepPrecise           (Q microsecs);
 V aa_CoreSystemStop                   (V);
 B aa_CoreSystemWindowsMsgToString     (UINT msg,VP str);
 K aa_CoreSystemProc                   (HWND wnd,UINT msg,WPARAM wparm,LPARAM lparm);
 B aa_CoreSystemCpuLoadGet             (V);
 Q aa_CoreSystemTikPrecise             (V);
 B aa_CoreSystemTime                   (V);
 B aa_CoreSystemTimer                  (H index,B prefresh,B postfresh,Q ms);
 B aa_CoreSystemLoop                   (V);


/*-----------------------------------------------------------------------*/


 #define VAL_memd                      1684890989
 #define VAL_cyhz                      2053667171
 #define VAL_data                      1635017060
 #define VAL_miqu                      1970366829
 #define VAL_misk                      1802725741
 #define VAL_timr                      1919773044
 #define VAL_prof                      1718579824
 #define VAL_nrtt                      1953788526
 #define VAL_txen                      1852143732
 #define VAL_biqd                      1902602594
 #define VAL_task                      1802723700
 #define VAL_funt                      1953396070
 #define VAL_upar                      1918988405
 #define VAL_inif                      1718185577
 #define VAL_fprm                      1836216422
 #define VAL_http                      1886680168
 #define VAL_pars                      1936875888
 #define VAL_achn                      2092992221
 #define VAL_msql                      2336875888


 #define aa_MEMMODULE_MAGIC            VAL_memd
 #define aa_DATA_MAGIC                 VAL_data
 #define aa_MINIQUE_MAGIC              VAL_miqu
 #define aa_MINISTACK_MAGIC            VAL_misk
 #define aa_TIMER_MAGIC                VAL_timr
 #define aa_PROFILER_MAGIC             VAL_prof
 #define aa_RTT_MAGIC                  VAL_nrtt
 #define aa_BIQUAD_MAGIC               VAL_biqd
 #define aa_TASK_MAGIC                 VAL_task
 #define aa_FILEUNIT_MAGIC             VAL_funt
 #define aa_UPDATEAREA_MAGIC           VAL_upar
 #define aa_INI_MAGIC                  VAL_inif
 #define aa_HTTP_MAGIC                 VAL_http
 #define aa_PARSE_MAGIC                VAL_pars

/*-----------------------------------------------------------------------*/


 B aa_geo_country_code[251][3]=        { "--","AP","EU","AD","AE","AF","AG","AI","AL","AM","AN","AO","AQ","AR","AS","AT","AU","AW","AZ","BA","BB",
                                         "BD","BE","BF","BG","BH","BI","BJ","BM","BN","BO","BR","BS","BT","BV","BW","BY","BZ","CA","CC","CD",
                                         "CF","CG","CH","CI","CK","CL","CM","CN","CO","CR","CU","CV","CX","CY","CZ","DE","DJ","DK","DM","DO",
                                         "DZ","EC","EE","EG","EH","ER","ES","ET","FI","FJ","FK","FM","FO","FR","FX","GA","GB","GD","GE","GF",
                                         "GH","GI","GL","GM","GN","GP","GQ","GR","GS","GT","GU","GW","GY","HK","HM","HN","HR","HT","HU","ID",
                                         "IE","IL","IN","IO","IQ","IR","IS","IT","JM","JO",
                                         "JP","KE","KG","KH","KI","KM","KN","KP","KR","KW",
                                         "KY","KZ","LA","LB","LC","LI","LK","LR","LS","LT",
                                         "LU","LV","LY","MA","MC","MD","MG","MH","MK","ML",
                                         "MM","MN","MO","MP","MQ","MR","MS","MT","MU","MV",
                                         "MW","MX","MY","MZ","NA","NC","NE","NF","NG","NI",
                                         "NL","NO","NP","NR","NU","NZ","OM","PA","PE","PF",
                                         "PG","PH","PK","PL","PM","PN","PR","PS","PT","PW",
                                         "PY","QA","RE","RO","RU","RW","SA","SB","SC","SD",
                                         "SE","SG","SH","SI","SJ","SK","SL","SM","SN","SO",
                                         "SR","ST","SV","SY","SZ","TC","TD","TF","TG","TH",
                                         "TJ","TK","TM","TN","TO","TL","TR","TT","TV","TW",
                                         "TZ","UA","UG","UM","US","UY","UZ","VA","VC","VE",
                                         "VG","VI","VN","VU","WF","WS","YE","YT","RS","ZA",
                                         "ZM","ME","ZW","A1","A2","O1","AX","GG","IM","JE"};


 CP aa_geo_country_name[251]=          { "N/A","Asia/Pacific Region","Europe","Andorra","United Arab Emirates","Afghanistan","Antigua and Barbuda","Anguilla","Albania","Armenia","Netherlands Antilles",
                                         "Angola","Antarctica","Argentina","American Samoa","Austria","Australia","Aruba","Azerbaijan","Bosnia and Herzegovina","Barbados",
                                         "Bangladesh","Belgium","Burkina Faso","Bulgaria","Bahrain","Burundi","Benin","Bermuda","Brunei Darussalam","Bolivia",
                                         "Brazil","Bahamas","Bhutan","Bouvet Island","Botswana","Belarus","Belize","Canada","Cocos (Keeling) Islands","Congo, The Democratic Republic of the",
                                         "Central African Republic","Congo","Switzerland","Cote D'Ivoire","Cook Islands","Chile","Cameroon","China","Colombia","Costa Rica",
                                         "Cuba","Cape Verde","Christmas Island","Cyprus","Czech Republic","Germany","Djibouti","Denmark","Dominica","Dominican Republic",
                                         "Algeria","Ecuador","Estonia","Egypt","Western Sahara","Eritrea","Spain","Ethiopia","Finland","Fiji",
                                         "Falkland Islands (Malvinas)","Micronesia, Federated States of","Faroe Islands","France","France, Metropolitan","Gabon","United Kingdom","Grenada","Georgia","French Guiana",
                                         "Ghana","Gibraltar","Greenland","Gambia","Guinea","Guadeloupe","Equatorial Guinea","Greece","South Georgia and the South Sandwich Islands","Guatemala",
                                         "Guam","Guinea-Bissau","Guyana","Hong Kong","Heard Island and McDonald Islands","Honduras","Croatia","Haiti","Hungary","Indonesia",
                                         "Ireland","Israel","India","British Indian Ocean Territory","Iraq","Iran, Islamic Republic of","Iceland","Italy","Jamaica","Jordan",
                                         "Japan","Kenya","Kyrgyzstan","Cambodia","Kiribati","Comoros","Saint Kitts and Nevis","Korea, Democratic People's Republic of","Korea, Republic of","Kuwait",
                                         "Cayman Islands","Kazakhstan","Lao People's Democratic Republic","Lebanon","Saint Lucia","Liechtenstein","Sri Lanka","Liberia","Lesotho","Lithuania",
                                         "Luxembourg","Latvia","Libyan Arab Jamahiriya","Morocco","Monaco","Moldova, Republic of","Madagascar","Marshall Islands","Macedonia","Mali",
                                         "Myanmar","Mongolia","Macau","Northern Mariana Islands","Martinique","Mauritania","Montserrat","Malta","Mauritius","Maldives",
                                         "Malawi","Mexico","Malaysia","Mozambique","Namibia","New Caledonia","Niger","Norfolk Island","Nigeria","Nicaragua",
                                         "Netherlands","Norway","Nepal","Nauru","Niue","New Zealand","Oman","Panama","Peru","French Polynesia",
                                         "Papua New Guinea","Philippines","Pakistan","Poland","Saint Pierre and Miquelon","Pitcairn Islands","Puerto Rico","Palestinian Territory","Portugal","Palau",
                                         "Paraguay","Qatar","Reunion","Romania","Russian Federation","Rwanda","Saudi Arabia","Solomon Islands","Seychelles","Sudan",
                                         "Sweden","Singapore","Saint Helena","Slovenia","Svalbard and Jan Mayen","Slovakia","Sierra Leone","San Marino","Senegal","Somalia","Suriname",
                                         "Sao Tome and Principe","El Salvador","Syrian Arab Republic","Swaziland","Turks and Caicos Islands","Chad","French Southern Territories","Togo","Thailand",
                                         "Tajikistan","Tokelau","Turkmenistan","Tunisia","Tonga","Timor-Leste","Turkey","Trinidad and Tobago","Tuvalu","Taiwan",
                                         "Tanzania, United Republic of","Ukraine","Uganda","United States Minor Outlying Islands","United States","Uruguay","Uzbekistan","Holy See (Vatican City State)","Saint Vincent and the Grenadines","Venezuela",
                                         "Virgin Islands, British","Virgin Islands, U.S.","Vietnam","Vanuatu","Wallis and Futuna","Samoa","Yemen","Mayotte","Serbia","South Africa",
                                         "Zambia","Montenegro","Zimbabwe","Anonymous Proxy","Satellite Provider","Other","Aland Islands","Guernsey","Isle of Man","Jersey"};

 B aa_geo_continent[251][3]=           { "--","AS","EU","EU","AS","AS","SA","SA","EU","AS","SA",
                                         "AF","AN","SA","OC","EU","OC","SA","AS","EU","SA",
                                         "AS","EU","AF","EU","AS","AF","AF","SA","AS","SA",
                                         "SA","SA","AS","AF","AF","EU","SA","NA","AS","AF",
                                         "AF","AF","EU","AF","OC","SA","AF","AS","SA","SA",
                                         "SA","AF","AS","AS","EU","EU","AF","EU","SA","SA",
                                         "AF","SA","EU","AF","AF","AF","EU","AF","EU","OC",
                                         "SA","OC","EU","EU","EU","AF","EU","SA","AS","SA",
                                         "AF","EU","SA","AF","AF","SA","AF","EU","SA","SA",
                                         "OC","AF","SA","AS","AF","SA","EU","SA","EU","AS",
                                         "EU","AS","AS","AS","AS","AS","EU","EU","SA","AS",
                                         "AS","AF","AS","AS","OC","AF","SA","AS","AS","AS",
                                         "SA","AS","AS","AS","SA","EU","AS","AF","AF","EU",
                                         "EU","EU","AF","AF","EU","EU","AF","OC","EU","AF",
                                         "AS","AS","AS","OC","SA","AF","SA","EU","AF","AS",
                                         "AF","NA","AS","AF","AF","OC","AF","OC","AF","SA",
                                         "EU","EU","AS","OC","OC","OC","AS","SA","SA","OC",
                                         "OC","AS","AS","EU","SA","OC","SA","AS","EU","OC",
                                         "SA","AS","AF","EU","AS","AF","AS","OC","AF","AF",
                                         "EU","AS","AF","EU","EU","EU","AF","EU","AF","AF",
                                         "SA","AF","SA","AS","AF","SA","AF","AF","AF","AS",
                                         "AS","OC","AS","AF","OC","AS","AS","SA","OC","AS",
                                         "AF","EU","AF","OC","NA","SA","AS","EU","SA","SA",
                                         "SA","SA","AS","OC","OC","OC","AS","AF","EU","AF",
                                         "AF","EU","AF","--","--","--","EU","EU","EU","EU"};


/*-----------------------------------------------------------------------*/

 CP aa_common_name[2][26]=             {
                                       {"Alistar","Bob","Craig","David","Eddy","Fred","Greg","Harry",
                                        "Ian","John","Ken","Larry","Mike","Norman","Oscar","Pete",
                                        "Quincy","Ron","Steve","Tom","Urving","Victor","William","Xeo","Yuri","Zach"},
                                       {"Angel","Betty","Carol","Dianne","Eliza","Fiona","Grace","Helen",
                                        "Irene","Janene","Kathy","Lisa","Mindy","Nancy","Olivia","Penny","Qeisha",
                                        "Rachael","Sarah","Tanya","Ursela","Vera","Wendy","Xeisha","Yvonne","Zoey"}
                                       };

/*-----------------------------------------------------------------------*/

 CP aa_musicnote[12]=                  {"C","C#","D","D#","E","F","F#","G","G#","A","A#","B"};
 B  aa_hexchar[16]=                    {'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'};
 B  aa_base58char[58]=                 {'1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','G',
                                        'H','J','K','L','M','N','P','Q','R','S','T','U','V','W','X','Y',
                                        'Z','a','b','c','d','e','f','g','h','i','j','k','m','n','o','p',
                                        'q','r','s','t','u','v','w','x','y','z'};

/*-----------------------------------------------------------------------*/

 B aa_starchar[4]=                     {'|','/','-','\\'};

 CP aa_timemonth[12]=                  {"Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"};
 CP aa_timemonthex[12]=                {"January","Febuary","March","April","May","June","July","August","September","October","November","December"};
 CP aa_timeday[7]=                     {"Sun","Mon","Tue","Wed","Thu","Fri","Sat"};
 CP aa_timedayex[7]=                   {"Sunday","Monday","Tueday","Wednesday","Thursday","Friday","Saturday"};


 structure
 {
 Q base;
 Q elapsed;
 Q lapse;
 }
 _aa_timerhard;


 structure
 {
 H last_tik;
 D cpu_mhz;
 B is_timezone_ready;
 N timezone_bias;
 B is_dls;
 B is_std;
 N timezone_bias_total;
 B timezone_string[_1K];
 _aa_timerhard hard[100];
 }
 _aa_timersystem;


 B aa_TimerSystemStart                 (V);
 B aa_TimerSystemCpuSpeedGet           (V);
 B aa_TimerSystemTimezoneGet           (V);
 V aa_TimerSystemStop                  (V);


/*-----------------------------------------------------------------------*/


 #define qsMAXSTACK                    (sizeof(size_t)*CHAR_BIT)
 #define qsEXCHANGE(a,b,size)          {Z s; ZP ai,bi; CP ac,bc; \
                                        ai=(ZP)a; bi=(ZP)b; for(s=sizeof(Z); s<=size; s+=sizeof(Z)) { Z t=*ai; *ai++=*bi; *bi++=t; } \
                                        ac=(CP)ai; bc=(CP)bi; for(s=s-sizeof(Z)+1; s<=size;s++) { C t=*ac; *ac++=*bc; *bc++=t; } }

/*-----------------------------------------------------------------------*/

 #define aa_MEMORY_OPCODE_SAFETY       32

 #define aa_MEMORYCRC_POLYNOMIAL       0x04C11DB7
 #define aa_MEMORYCRC_POLYNOMIALb      0x1EDC6F41
 #define aa_MEMORYCRC_POLYNOMIAL64     0xC96C5795D7870F42;

 #define aa_MEMORYTEMP_User             0
 #define aa_MEMORYTEMP_UdpPktRet       10
 #define aa_MEMORYTEMP_DynAppendf      11
 #define aa_MEMORYTEMP_Debugf          12
 #define aa_MEMORYTEMP_StrExplode      13
 #define aa_MEMORYTEMP_Log             14
 #define aa_MEMORYTEMP_SurfaceScroll   15
 #define aa_MEMORYTEMP_IcmpProc        16
 #define aa_MEMORYTEMP_SniffProc       17
 #define aa_MEMORYTEMP_StrReverse      18
 #define aa_MEMORYTEMP_StrMultSpaces   19
 #define aa_MEMORYTEMP_StrEncode       20
 #define aa_MEMORYTEMP_StrDecode       21
 #define aa_MEMORYTEMP_StringDecodeA   22
 #define aa_MEMORYTEMP_StringDecodeB   23
 #define aa_MEMORYTEMP_StrAppendf      24
 #define aa_MEMORYTEMP_StrCopyf        25
 #define aa_MEMORYTEMP_StrNCopyf       26
 #define aa_MEMORYTEMP_StrAppendCopyf  27
 #define aa_MEMORYTEMP_CgiWritef       28
 #define aa_MEMORYTEMP_CgiRead         29
 #define aa_MEMORYTEMP_CallWritef      30
 #define aa_MEMORYTEMP_CallMirror      31
 #define aa_MEMORYTEMP_FileWritef      32
 #define aa_MEMORYTEMP_StrHash         33
 #define aa_MEMORYTEMP_ClipWritef      34
 #define aa_MEMORYTEMP_IcmpWritef      35
 #define aa_MEMORYTEMP_SniffPktRet     36
 #define aa_MEMORYTEMP_Base64          37
 #define aa_MEMORYTEMP_JsonDumpA       38
 #define aa_MEMORYTEMP_JsonDumpB       39
 #define aa_MEMORYTEMP_ProcessList     40
 #define aa_MEMORYTEMP_ProcessTcp      41
 #define aa_MEMORYTEMP_OrderSort       42
 #define aa_MEMORYTEMP_OrderBlob       43
 #define aa_MEMORYTEMP_StrCopyfLen     44
 #define aa_MEMORYTEMP_QueFind         45
 #define aa_MEMORYTEMP_SurfaceConvolve 46
 #define aa_MEMORYTEMP_aaf             47
 #define aa_MEMORYTEMP_QueStrap        48
 #define aa_MEMORYTEMP_SystemLogf      49
 #define aa_MEMORYTEMP_SystemLogf2     50


 #define aa_MEM_NOTALIND(eex,eey)      (((N)eex&(sizeof(N)-1))|((N)eey&(sizeof(N)-1)))
 #define aa_MEM_BIGBLOCKSIZE           (sizeof(N)<<2)
 #define aa_MEM_LITTLEBLOCKSIZE        (sizeof(N))
 #define aa_MEM_TOO_SMALL(LEN)         ((LEN)<(N)aa_MEM_BIGBLOCKSIZE)



 structure
 {
 H magic;
 B is_protected;
 B is_user;
 B is_locked;
 B mini_type;
 H mini_index;
 H realloc_count;
 H bytes;
 H table_index;
 C name[32];
 BP actual_ptr;
 H actual_len;
 }
 _aa_memoryheader;



 structure
 {
 _memorystatus status;
 _memorytable table;
 H table_pf;
 PROCESS_MEMORY_COUNTERS pmc;
 Q crc64_table[256];
 H crc_table[256];
 H run_bytes;
 BP temp_mem[256];
 H temp_bytes[256];
 H temp_hits[256];
 H temp_allocs[256];
 H temp_reallocs[256];
 BP cdecl_ram;
 H alloc_calls;
 H realloc_calls;
 H release_calls;
 }
 _aa_memorysystem;


 B aa_MemorySystemStart                (V);
 V aa_MemorySystemStop                 (V);
 V aa_MemorySystemDump                 (V);
 B aa_MemoryAllocate                   (PP mem,H bytes,VP name,B lock);
 B aa_MemoryReAllocate                 (PP mem,H bytes);
 B aa_MemoryProtect                    (VP mem,B state);
 B aa_MemoryRelease                    (VP mem);
 B aa_MemoryTemp                       (PP mem,H bytes,B level);

 H tot_v_alloc=0;
 H tot_v_free=0;
 H tot_v_protect=0;

/*-----------------------------------------------------------------------*/

 // apx 300meg of pages possible (300x256x4096)

 #define USE_PAGE_CRITICAL_SECTION     YES-1

 #define aa_PAGE_BASE_HANDLE           92932
 #define aa_PAGE_MAX_BOOKS             512  // was 2048
 #define aa_PAGE_PER_BOOK              256 // must be 256 ( i think, otherwise, crashes may occwr )
 #define aa_PAGE_BYTES                 _16K // was 4k


 structure
 {
 BP mem;
 B in_use[aa_PAGE_PER_BOOK];
 B protection[aa_PAGE_PER_BOOK];
 C name[aa_PAGE_PER_BOOK][13];
 H usage;
 }
 _aa_pagebook;


 structure
 {
 H bytes_per_page;
 H bytes_per_book;
 H bytes_accessable;
 H pages_per_system;
 H books_per_system;
 _aa_pagebook*book;
 H pages_commited;
 H pages_allocated;
 CRITICAL_SECTION mutex;
 }
 _aa_pagesystem;


 B aa_PageSystemStart                  (V);
 V aa_PageSystemStop                   (V);
 B aa_PageAllocate                     (HP handle,PP mem,VP name);
 B aa_PageRelease                      (H handle);
 B aa_PageProtect                      (H handle,B state);
 B aa_PageStatus                       (H handle,PP mem,BP isprotected,BP isuser);
 B aa_PageArrayIo                      (HP harray,H hcount,H offset,H bytes,VP data,B writemode);
 B aa_PageArrayFill                    (HP harray,H hcount,H offset,H bytes,B val);


/*-----------------------------------------------------------------------*/

 #define aa_OBJ_MAX_PER_ID             1000000
 #define aa_OBJ_BASE_HANDLE            3292932

 structure
 {
 B in_use;
 B is_protected;
 Q sesh;
 }
 _aa_objectinstanceheader;


 structure
 {
 H instance_limit;
 H instance_count;
 H instance_slots;
 H instance_bytes;
 H instance_initial;
 B name[33];
 BP instance_mem;
 B(*Destructor)(H handle);
 H sesh_counter;
 }
 _aa_object;


 structure
 {
 _aa_object object[256];
 B id_head;
 Q object_check_count[256];
 H sesh_counter;
 H total_count;
 }
 _aa_objectsystem;



 B aa_ObjectSystemStart                (V);
 V aa_ObjectSystemStop                 (V);
 B aa_ObjectDefine                     (B id,H bytes,H limit,H initial,B(*Destructor)(H),VP name);
 B aa_ObjectUndefine                   (B id);
 B aa_ObjectCreate                     (B id,HP handle,PP mem);
 B aa_ObjectCheck                      (B id,H handle,PP mem,BP isprotected);
 B aa_ObjectProtect                    (B id,H handle,B state);
 B aa_ObjectDestroy                    (B id,H handle);
 B aa_ObjectIdNew                      (BP id);
 B aa_ObjectNext                       (B id,HP handle,PP mem,HP iterationcounter);
 B aa_ObjectFromHandle                 (BP id,H handle);
 B aa_ObjectHandleToIndex              (B id,H handle,HP index);
 B aa_ObjectIndexToHandle              (B id,H index,HP handle);

/*-----------------------------------------------------------------------*/


 structure
 {
 B is_manual_reset;
 B is_signaled;
 HANDLE handle;
 }
 _aa_event;


 B aa_EventDefine                      (_aa_event*event,B manualreset,B startsignaled,VP fmt,...);
 B aa_EventUndefine                    (_aa_event*event);
 B aa_EventSignal                      (_aa_event*event);
 B aa_EventIsSignaled                  (_aa_event*event);
 B aa_EventReset                       (_aa_event*event);



/*-----------------------------------------------------------/----------------------------------*/

 #define aa_MathTwister_MM             397
 #define aa_MathTwister_MATRIX_A       0x9908b0dfUL
 #define aa_MathTwister_UPPER_MASK     0x80000000UL
 #define aa_MathTwister_LOWER_MASK     0x7fffffffUL


 #define VAL_II                        18761
 #define VAL_MM                        19789

 D aa_muly_table[10]=                  {0.50,0.75,1.25,1.50,1.75,1.95,2.00,2.10,2.25,2.50};


 inline N aaDoubleToLong               (D d)
 {
 #define aa_DLD_MAGIC                  (((65536.0*65536.0*16.0)+32768.0)*65536.0)
 D dt=d+aa_DLD_MAGIC;
 return(*(NP)&dt)-0x80000000;
 }



 inline V aaDoubleToDwords             (D d,HP lopart,HP hipart)
 {
 H xh,xl;
 D dh,dl;

 dh=d/_4Bd;
 xh=(H)dh;
 dl=(D)xh*_4Bd;
 dl=d-dl;
 xl=(H)dl;
 if(lopart) { *lopart=xl; }
 if(hipart) { *hipart=xh; }
 }



 inline V aaDoubleToLongs              (D d,NP lopart,NP hipart)
 {
 N xh,xl;
 D dh,dl;

 dh=d/_4Bd;
 xh=(N)dh;
 dl=(D)xh*_4Bd;
 dl=d-dl;
 xl=(N)dl;
 if(lopart) { *lopart=xl; }
 if(hipart) { *hipart=xh; }
 }


 B aa_math_scan_zigzag[64]=
 {
 0,1,8,16,9,2,3,10,17,24,32,25,18,11,4,5,12,19,26,33,40,48,41,34,27,20,13,6,7,14,21,28,
 35,42,49,56,57,50,43,36,29,22,15,23,30,37,44,51,58,59,52,45,38,31,39,46,53,60,61,54,47,55,62,63
 };


 B aa_math_scan_zigzag_jpeg[64]=
 {
 0,1,5,6,14,15,27,28,2,4,7,13,16,26,29,42,3,8,12,17,25,30,41,43,9,11,18,24,31,40,44,53,
 10,19,23,32,39,45,52,54,20,22,33,38,46,51,55,60,21,34,37,47,50,56,59,61,35,36,48,49,57,58,62,63
 };


 H aa_math_system_smallprime[10000]=
 {
 3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,
 127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,
 251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,
 389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,
 541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,
 677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,
 839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997,
 1009,1013,1019,1021,1031,1033,1039,1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,
 1117,1123,1129,1151,1153,1163,1171,1181,1187,1193,1201,1213,1217,1223,1229,1231,1237,1249,
 1259,1277,1279,1283,1289,1291,1297,1301,1303,1307,1319,1321,1327,1361,1367,1373,1381,1399,
 1409,1423,1427,1429,1433,1439,1447,1451,1453,1459,1471,1481,1483,1487,1489,1493,1499,1511,
 1523,1531,1543,1549,1553,1559,1567,1571,1579,1583,1597,1601,1607,1609,1613,1619,1621,1627,
 1637,1657,1663,1667,1669,1693,1697,1699,1709,1721,1723,1733,1741,1747,1753,1759,1777,1783,
 1787,1789,1801,1811,1823,1831,1847,1861,1867,1871,1873,1877,1879,1889,1901,1907,1913,1931,
 1933,1949,1951,1973,1979,1987,1993,1997,1999,2003,2011,2017,2027,2029,2039,2053,2063,2069,
 2081,2083,2087,2089,2099,2111,2113,2129,2131,2137,2141,2143,2153,2161,2179,2203,2207,2213,
 2221,2237,2239,2243,2251,2267,2269,2273,2281,2287,2293,2297,2309,2311,2333,2339,2341,2347,
 2351,2357,2371,2377,2381,2383,2389,2393,2399,2411,2417,2423,2437,2441,2447,2459,2467,2473,
 2477,2503,2521,2531,2539,2543,2549,2551,2557,2579,2591,2593,2609,2617,2621,2633,2647,2657,
 2659,2663,2671,2677,2683,2687,2689,2693,2699,2707,2711,2713,2719,2729,2731,2741,2749,2753,
 2767,2777,2789,2791,2797,2801,2803,2819,2833,2837,2843,2851,2857,2861,2879,2887,2897,2903,
 2909,2917,2927,2939,2953,2957,2963,2969,2971,2999,3001,3011,3019,3023,3037,3041,3049,3061,
 3067,3079,3083,3089,3109,3119,3121,3137,3163,3167,3169,3181,3187,3191,3203,3209,3217,3221,
 3229,3251,3253,3257,3259,3271,3299,3301,3307,3313,3319,3323,3329,3331,3343,3347,3359,3361,
 3371,3373,3389,3391,3407,3413,3433,3449,3457,3461,3463,3467,3469,3491,3499,3511,3517,3527,
 3529,3533,3539,3541,3547,3557,3559,3571,3581,3583,3593,3607,3613,3617,3623,3631,3637,3643,
 3659,3671,3673,3677,3691,3697,3701,3709,3719,3727,3733,3739,3761,3767,3769,3779,3793,3797,
 3803,3821,3823,3833,3847,3851,3853,3863,3877,3881,3889,3907,3911,3917,3919,3923,3929,3931,
 3943,3947,3967,3989,4001,4003,4007,4013,4019,4021,4027,4049,4051,4057,4073,4079,4091,4093,
 4099,4111,4127,4129,4133,4139,4153,4157,4159,4177,4201,4211,4217,4219,4229,4231,4241,4243,
 4253,4259,4261,4271,4273,4283,4289,4297,4327,4337,4339,4349,4357,4363,4373,4391,4397,4409,
 4421,4423,4441,4447,4451,4457,4463,4481,4483,4493,4507,4513,4517,4519,4523,4547,4549,4561,
 4567,4583,4591,4597,4603,4621,4637,4639,4643,4649,4651,4657,4663,4673,4679,4691,4703,4721,
 4723,4729,4733,4751,4759,4783,4787,4789,4793,4799,4801,4813,4817,4831,4861,4871,4877,4889,
 4903,4909,4919,4931,4933,4937,4943,4951,4957,4967,4969,4973,4987,4993,4999,5003,5009,5011,
 5021,5023,5039,5051,5059,5077,5081,5087,5099,5101,5107,5113,5119,5147,5153,5167,5171,5179,
 5189,5197,5209,5227,5231,5233,5237,5261,5273,5279,5281,5297,5303,5309,5323,5333,5347,5351,
 5381,5387,5393,5399,5407,5413,5417,5419,5431,5437,5441,5443,5449,5471,5477,5479,5483,5501,
 5503,5507,5519,5521,5527,5531,5557,5563,5569,5573,5581,5591,5623,5639,5641,5647,5651,5653,
 5657,5659,5669,5683,5689,5693,5701,5711,5717,5737,5741,5743,5749,5779,5783,5791,5801,5807,
 5813,5821,5827,5839,5843,5849,5851,5857,5861,5867,5869,5879,5881,5897,5903,5923,5927,5939,
 5953,5981,5987,6007,6011,6029,6037,6043,6047,6053,6067,6073,6079,6089,6091,6101,6113,6121,
 6131,6133,6143,6151,6163,6173,6197,6199,6203,6211,6217,6221,6229,6247,6257,6263,6269,6271,
 6277,6287,6299,6301,6311,6317,6323,6329,6337,6343,6353,6359,6361,6367,6373,6379,6389,6397,
 6421,6427,6449,6451,6469,6473,6481,6491,6521,6529,6547,6551,6553,6563,6569,6571,6577,6581,
 6599,6607,6619,6637,6653,6659,6661,6673,6679,6689,6691,6701,6703,6709,6719,6733,6737,6761,
 6763,6779,6781,6791,6793,6803,6823,6827,6829,6833,6841,6857,6863,6869,6871,6883,6899,6907,
 6911,6917,6947,6949,6959,6961,6967,6971,6977,6983,6991,6997,7001,7013,7019,7027,7039,7043,
 7057,7069,7079,7103,7109,7121,7127,7129,7151,7159,7177,7187,7193,7207,7211,7213,7219,7229,
 7237,7243,7247,7253,7283,7297,7307,7309,7321,7331,7333,7349,7351,7369,7393,7411,7417,7433,
 7451,7457,7459,7477,7481,7487,7489,7499,7507,7517,7523,7529,7537,7541,7547,7549,7559,7561,
 7573,7577,7583,7589,7591,7603,7607,7621,7639,7643,7649,7669,7673,7681,7687,7691,7699,7703,
 7717,7723,7727,7741,7753,7757,7759,7789,7793,7817,7823,7829,7841,7853,7867,7873,7877,7879,
 7883,7901,7907,7919,7927,7933,7937,7949,7951,7963,7993,8009,8011,8017,8039,8053,8059,8069,
 8081,8087,8089,8093,8101,8111,8117,8123,8147,8161,8167,8171,8179,8191,8209,8219,8221,8231,
 8233,8237,8243,8263,8269,8273,8287,8291,8293,8297,8311,8317,8329,8353,8363,8369,8377,8387,
 8389,8419,8423,8429,8431,8443,8447,8461,8467,8501,8513,8521,8527,8537,8539,8543,8563,8573,
 8581,8597,8599,8609,8623,8627,8629,8641,8647,8663,8669,8677,8681,8689,8693,8699,8707,8713,
 8719,8731,8737,8741,8747,8753,8761,8779,8783,8803,8807,8819,8821,8831,8837,8839,8849,8861,
 8863,8867,8887,8893,8923,8929,8933,8941,8951,8963,8969,8971,8999,9001,9007,9011,9013,9029,
 9041,9043,9049,9059,9067,9091,9103,9109,9127,9133,9137,9151,9157,9161,9173,9181,9187,9199,
 9203,9209,9221,9227,9239,9241,9257,9277,9281,9283,9293,9311,9319,9323,9337,9341,9343,9349,
 9371,9377,9391,9397,9403,9413,9419,9421,9431,9433,9437,9439,9461,9463,9467,9473,9479,9491,
 9497,9511,9521,9533,9539,9547,9551,9587,9601,9613,9619,9623,9629,9631,9643,9649,9661,9677,
 9679,9689,9697,9719,9721,9733,9739,9743,9749,9767,9769,9781,9787,9791,9803,9811,9817,9829,
 9833,9839,9851,9857,9859,9871,9883,9887,9901,9907,9923,9929,9931,9941,9949,9967,9973,10007,
 10009,10037,10039,10061,10067,10069,10079,10091,10093,10099,10103,10111,10133,10139,10141,
 10151,10159,10163,10169,10177,10181,10193,10211,10223,10243,10247,10253,10259,10267,10271,
 10273,10289,10301,10303,10313,10321,10331,10333,10337,10343,10357,10369,10391,10399,10427,
 10429,10433,10453,10457,10459,10463,10477,10487,10499,10501,10513,10529,10531,10559,10567,
 10589,10597,10601,10607,10613,10627,10631,10639,10651,10657,10663,10667,10687,10691,10709,
 10711,10723,10729,10733,10739,10753,10771,10781,10789,10799,10831,10837,10847,10853,10859,
 10861,10867,10883,10889,10891,10903,10909,10937,10939,10949,10957,10973,10979,10987,10993,
 11003,11027,11047,11057,11059,11069,11071,11083,11087,11093,11113,11117,11119,11131,11149,
 11159,11161,11171,11173,11177,11197,11213,11239,11243,11251,11257,11261,11273,11279,11287,
 11299,11311,11317,11321,11329,11351,11353,11369,11383,11393,11399,11411,11423,11437,11443,
 11447,11467,11471,11483,11489,11491,11497,11503,11519,11527,11549,11551,11579,11587,11593,
 11597,11617,11621,11633,11657,11677,11681,11689,11699,11701,11717,11719,11731,11743,11777,
 11779,11783,11789,11801,11807,11813,11821,11827,11831,11833,11839,11863,11867,11887,11897,
 11903,11909,11923,11927,11933,11939,11941,11953,11959,11969,11971,11981,11987,12007,12011,
 12037,12041,12043,12049,12071,12073,12097,12101,12107,12109,12113,12119,12143,12149,12157,
 12161,12163,12197,12203,12211,12227,12239,12241,12251,12253,12263,12269,12277,12281,12289,
 12301,12323,12329,12343,12347,12373,12377,12379,12391,12401,12409,12413,12421,12433,12437,
 12451,12457,12473,12479,12487,12491,12497,12503,12511,12517,12527,12539,12541,12547,12553,
 12569,12577,12583,12589,12601,12611,12613,12619,12637,12641,12647,12653,12659,12671,12689,
 12697,12703,12713,12721,12739,12743,12757,12763,12781,12791,12799,12809,12821,12823,12829,
 12841,12853,12889,12893,12899,12907,12911,12917,12919,12923,12941,12953,12959,12967,12973,
 12979,12983,13001,13003,13007,13009,13033,13037,13043,13049,13063,13093,13099,13103,13109,
 13121,13127,13147,13151,13159,13163,13171,13177,13183,13187,13217,13219,13229,13241,13249,
 13259,13267,13291,13297,13309,13313,13327,13331,13337,13339,13367,13381,13397,13399,13411,
 13417,13421,13441,13451,13457,13463,13469,13477,13487,13499,13513,13523,13537,13553,13567,
 13577,13591,13597,13613,13619,13627,13633,13649,13669,13679,13681,13687,13691,13693,13697,
 13709,13711,13721,13723,13729,13751,13757,13759,13763,13781,13789,13799,13807,13829,13831,
 13841,13859,13873,13877,13879,13883,13901,13903,13907,13913,13921,13931,13933,13963,13967,
 13997,13999,14009,14011,14029,14033,14051,14057,14071,14081,14083,14087,14107,14143,14149,
 14153,14159,14173,14177,14197,14207,14221,14243,14249,14251,14281,14293,14303,14321,14323,
 14327,14341,14347,14369,14387,14389,14401,14407,14411,14419,14423,14431,14437,14447,14449,
 14461,14479,14489,14503,14519,14533,14537,14543,14549,14551,14557,14561,14563,14591,14593,
 14621,14627,14629,14633,14639,14653,14657,14669,14683,14699,14713,14717,14723,14731,14737,
 14741,14747,14753,14759,14767,14771,14779,14783,14797,14813,14821,14827,14831,14843,14851,
 14867,14869,14879,14887,14891,14897,14923,14929,14939,14947,14951,14957,14969,14983,15013,
 15017,15031,15053,15061,15073,15077,15083,15091,15101,15107,15121,15131,15137,15139,15149,
 15161,15173,15187,15193,15199,15217,15227,15233,15241,15259,15263,15269,15271,15277,15287,
 15289,15299,15307,15313,15319,15329,15331,15349,15359,15361,15373,15377,15383,15391,15401,
 15413,15427,15439,15443,15451,15461,15467,15473,15493,15497,15511,15527,15541,15551,15559,
 15569,15581,15583,15601,15607,15619,15629,15641,15643,15647,15649,15661,15667,15671,15679,
 15683,15727,15731,15733,15737,15739,15749,15761,15767,15773,15787,15791,15797,15803,15809,
 15817,15823,15859,15877,15881,15887,15889,15901,15907,15913,15919,15923,15937,15959,15971,
 15973,15991,16001,16007,16033,16057,16061,16063,16067,16069,16073,16087,16091,16097,16103,
 16111,16127,16139,16141,16183,16187,16189,16193,16217,16223,16229,16231,16249,16253,16267,
 16273,16301,16319,16333,16339,16349,16361,16363,16369,16381,16411,16417,16421,16427,16433,
 16447,16451,16453,16477,16481,16487,16493,16519,16529,16547,16553,16561,16567,16573,16603,
 16607,16619,16631,16633,16649,16651,16657,16661,16673,16691,16693,16699,16703,16729,16741,
 16747,16759,16763,16787,16811,16823,16829,16831,16843,16871,16879,16883,16889,16901,16903,
 16921,16927,16931,16937,16943,16963,16979,16981,16987,16993,17011,17021,17027,17029,17033,
 17041,17047,17053,17077,17093,17099,17107,17117,17123,17137,17159,17167,17183,17189,17191,
 17203,17207,17209,17231,17239,17257,17291,17293,17299,17317,17321,17327,17333,17341,17351,17359,17377,17383,17387,17389,
 17393,17401,17417,17419,17431,17443,17449,17467,17471,17477,17483,17489,17491,17497,17509,17519,17539,17551,17569,17573,
 17579,17581,17597,17599,17609,17623,17627,17657,17659,17669,17681,17683,17707,17713,17729,17737,17747,17749,17761,17783,
 17789,17791,17807,17827,17837,17839,17851,17863,17881,17891,17903,17909,17911,17921,17923,17929,17939,17957,17959,17971,
 17977,17981,17987,17989,18013,18041,18043,18047,18049,18059,18061,18077,18089,18097,18119,18121,18127,18131,18133,18143,
 18149,18169,18181,18191,18199,18211,18217,18223,18229,18233,18251,18253,18257,18269,18287,18289,18301,18307,18311,18313,
 18329,18341,18353,18367,18371,18379,18397,18401,18413,18427,18433,18439,18443,18451,18457,18461,18481,18493,18503,18517,
 18521,18523,18539,18541,18553,18583,18587,18593,18617,18637,18661,18671,18679,18691,18701,18713,18719,18731,18743,18749,
 18757,18773,18787,18793,18797,18803,18839,18859,18869,18899,18911,18913,18917,18919,18947,18959,18973,18979,19001,19009,
 19013,19031,19037,19051,19069,19073,19079,19081,19087,19121,19139,19141,19157,19163,19181,19183,19207,19211,19213,19219,
 19231,19237,19249,19259,19267,19273,19289,19301,19309,19319,19333,19373,19379,19381,19387,19391,19403,19417,19421,19423,
 19427,19429,19433,19441,19447,19457,19463,19469,19471,19477,19483,19489,19501,19507,19531,19541,19543,19553,19559,19571,
 19577,19583,19597,19603,19609,19661,19681,19687,19697,19699,19709,19717,19727,19739,19751,19753,19759,19763,19777,19793,
 19801,19813,19819,19841,19843,19853,19861,19867,19889,19891,19913,19919,19927,19937,19949,19961,19963,19973,19979,19991,
 19993,19997,20011,20021,20023,20029,20047,20051,20063,20071,20089,20101,20107,20113,20117,20123,20129,20143,20147,20149,
 20161,20173,20177,20183,20201,20219,20231,20233,20249,20261,20269,20287,20297,20323,20327,20333,20341,20347,20353,20357,
 20359,20369,20389,20393,20399,20407,20411,20431,20441,20443,20477,20479,20483,20507,20509,20521,20533,20543,20549,20551,
 20563,20593,20599,20611,20627,20639,20641,20663,20681,20693,20707,20717,20719,20731,20743,20747,20749,20753,20759,20771,
 20773,20789,20807,20809,20849,20857,20873,20879,20887,20897,20899,20903,20921,20929,20939,20947,20959,20963,20981,20983,
 21001,21011,21013,21017,21019,21023,21031,21059,21061,21067,21089,21101,21107,21121,21139,21143,21149,21157,21163,21169,
 21179,21187,21191,21193,21211,21221,21227,21247,21269,21277,21283,21313,21317,21319,21323,21341,21347,21377,21379,21383,
 21391,21397,21401,21407,21419,21433,21467,21481,21487,21491,21493,21499,21503,21517,21521,21523,21529,21557,21559,21563,
 21569,21577,21587,21589,21599,21601,21611,21613,21617,21647,21649,21661,21673,21683,21701,21713,21727,21737,21739,21751,
 21757,21767,21773,21787,21799,21803,21817,21821,21839,21841,21851,21859,21863,21871,21881,21893,21911,21929,21937,21943,
 21961,21977,21991,21997,22003,22013,22027,22031,22037,22039,22051,22063,22067,22073,22079,22091,22093,22109,22111,22123,
 22129,22133,22147,22153,22157,22159,22171,22189,22193,22229,22247,22259,22271,22273,22277,22279,22283,22291,22303,22307,
 22343,22349,22367,22369,22381,22391,22397,22409,22433,22441,22447,22453,22469,22481,22483,22501,22511,22531,22541,22543,
 22549,22567,22571,22573,22613,22619,22621,22637,22639,22643,22651,22669,22679,22691,22697,22699,22709,22717,22721,22727,
 22739,22741,22751,22769,22777,22783,22787,22807,22811,22817,22853,22859,22861,22871,22877,22901,22907,22921,22937,22943,
 22961,22963,22973,22993,23003,23011,23017,23021,23027,23029,23039,23041,23053,23057,23059,23063,23071,23081,23087,23099,
 23117,23131,23143,23159,23167,23173,23189,23197,23201,23203,23209,23227,23251,23269,23279,23291,23293,23297,23311,23321,
 23327,23333,23339,23357,23369,23371,23399,23417,23431,23447,23459,23473,23497,23509,23531,23537,23539,23549,23557,23561,
 23563,23567,23581,23593,23599,23603,23609,23623,23627,23629,23633,23663,23669,23671,23677,23687,23689,23719,23741,23743,
 23747,23753,23761,23767,23773,23789,23801,23813,23819,23827,23831,23833,23857,23869,23873,23879,23887,23893,23899,23909,
 23911,23917,23929,23957,23971,23977,23981,23993,24001,24007,24019,24023,24029,24043,24049,24061,24071,24077,24083,24091,
 24097,24103,24107,24109,24113,24121,24133,24137,24151,24169,24179,24181,24197,24203,24223,24229,24239,24247,24251,24281,
 24317,24329,24337,24359,24371,24373,24379,24391,24407,24413,24419,24421,24439,24443,24469,24473,24481,24499,24509,24517,
 24527,24533,24547,24551,24571,24593,24611,24623,24631,24659,24671,24677,24683,24691,24697,24709,24733,24749,24763,24767,
 24781,24793,24799,24809,24821,24841,24847,24851,24859,24877,24889,24907,24917,24919,24923,24943,24953,24967,24971,24977,
 24979,24989,25013,25031,25033,25037,25057,25073,25087,25097,25111,25117,25121,25127,25147,25153,25163,25169,25171,25183,
 25189,25219,25229,25237,25243,25247,25253,25261,25301,25303,25307,25309,25321,25339,25343,25349,25357,25367,25373,25391,
 25409,25411,25423,25439,25447,25453,25457,25463,25469,25471,25523,25537,25541,25561,25577,25579,25583,25589,25601,25603,
 25609,25621,25633,25639,25643,25657,25667,25673,25679,25693,25703,25717,25733,25741,25747,25759,25763,25771,25793,25799,
 25801,25819,25841,25847,25849,25867,25873,25889,25903,25913,25919,25931,25933,25939,25943,25951,25969,25981,25997,25999,
 26003,26017,26021,26029,26041,26053,26083,26099,26107,26111,26113,26119,26141,26153,26161,26171,26177,26183,26189,26203,
 26209,26227,26237,26249,26251,26261,26263,26267,26293,26297,26309,26317,26321,26339,26347,26357,26371,26387,26393,26399,
 26407,26417,26423,26431,26437,26449,26459,26479,26489,26497,
 26501,26513,26539,26557,26561,26573,26591,26597,26627,26633,26641,26647,26669,26681,26683,26687,26693,26699,26701,26711,
 26713,26717,26723,26729,26731,26737,26759,26777,26783,26801,26813,26821,26833,26839,26849,26861,26863,26879,26881,26891,
 26893,26903,26921,26927,26947,26951,26953,26959,26981,26987,26993,27011,27017,27031,27043,27059,27061,27067,27073,27077,
 27091,27103,27107,27109,27127,27143,27179,27191,27197,27211,27239,27241,27253,27259,27271,27277,27281,27283,27299,27329,
 27337,27361,27367,27397,27407,27409,27427,27431,27437,27449,27457,27479,27481,27487,27509,27527,27529,27539,27541,27551,
 27581,27583,27611,27617,27631,27647,27653,27673,27689,27691,27697,27701,27733,27737,27739,27743,27749,27751,27763,27767,
 27773,27779,27791,27793,27799,27803,27809,27817,27823,27827,27847,27851,27883,27893,27901,27917,27919,27941,27943,27947,
 27953,27961,27967,27983,27997,28001,28019,28027,28031,28051,28057,28069,28081,28087,28097,28099,28109,28111,28123,28151,
 28163,28181,28183,28201,28211,28219,28229,28277,28279,28283,28289,28297,28307,28309,28319,28349,28351,28387,28393,28403,
 28409,28411,28429,28433,28439,28447,28463,28477,28493,28499,28513,28517,28537,28541,28547,28549,28559,28571,28573,28579,
 28591,28597,28603,28607,28619,28621,28627,28631,28643,28649,28657,28661,28663,28669,28687,28697,28703,28711,28723,28729,
 28751,28753,28759,28771,28789,28793,28807,28813,28817,28837,28843,28859,28867,28871,28879,28901,28909,28921,28927,28933,
 28949,28961,28979,29009,29017,29021,29023,29027,29033,29059,29063,29077,29101,29123,29129,29131,29137,29147,29153,29167,
 29173,29179,29191,29201,29207,29209,29221,29231,29243,29251,29269,29287,29297,29303,29311,29327,29333,29339,29347,29363,
 29383,29387,29389,29399,29401,29411,29423,29429,29437,29443,29453,29473,29483,29501,29527,29531,29537,29567,29569,29573,
 29581,29587,29599,29611,29629,29633,29641,29663,29669,29671,29683,29717,29723,29741,29753,29759,29761,29789,29803,29819,
 29833,29837,29851,29863,29867,29873,29879,29881,29917,29921,29927,29947,29959,29983,29989,30011,30013,30029,30047,30059,
 30071,30089,30091,30097,30103,30109,30113,30119,30133,30137,30139,30161,30169,30181,30187,30197,30203,30211,30223,30241,
 30253,30259,30269,30271,30293,30307,30313,30319,30323,30341,30347,30367,30389,30391,30403,30427,30431,30449,30467,30469,
 30491,30493,30497,30509,30517,30529,30539,30553,30557,30559,30577,30593,30631,30637,30643,30649,30661,30671,30677,30689,
 30697,30703,30707,30713,30727,30757,30763,30773,30781,30803,30809,30817,30829,30839,30841,30851,30853,30859,30869,30871,
 30881,30893,30911,30931,30937,30941,30949,30971,30977,30983,31013,31019,31033,31039,31051,31063,31069,31079,31081,31091,
 31121,31123,31139,31147,31151,31153,31159,31177,31181,31183,
 31189,31193,31219,31223,31231,31237,31247,31249,31253,31259,31267,31271,31277,31307,31319,31321,31327,31333,31337,31357,
 31379,31387,31391,31393,31397,31469,31477,31481,31489,31511,31513,31517,31531,31541,31543,31547,31567,31573,31583,31601,
 31607,31627,31643,31649,31657,31663,31667,31687,31699,31721,31723,31727,31729,31741,31751,31769,31771,31793,31799,31817,
 31847,31849,31859,31873,31883,31891,31907,31957,31963,31973,31981,31991,32003,32009,32027,32029,32051,32057,32059,32063,
 32069,32077,32083,32089,32099,32117,32119,32141,32143,32159,32173,32183,32189,32191,32203,32213,32233,32237,32251,32257,
 32261,32297,32299,32303,32309,32321,32323,32327,32341,32353,32359,32363,32369,32371,32377,32381,32401,32411,32413,32423,
 32429,32441,32443,32467,32479,32491,32497,32503,32507,32531,32533,32537,32561,32563,32569,32573,32579,32587,32603,32609,
 32611,32621,32633,32647,32653,32687,32693,32707,32713,32717,32719,32749,32771,32779,32783,32789,32797,32801,32803,32831,
 32833,32839,32843,32869,32887,32909,32911,32917,32933,32939,32941,32957,32969,32971,32983,32987,32993,32999,33013,33023,
 33029,33037,33049,33053,33071,33073,33083,33091,33107,33113,33119,33149,33151,33161,33179,33181,33191,33199,33203,33211,
 33223,33247,33287,33289,33301,33311,33317,33329,33331,33343,33347,33349,33353,33359,33377,33391,33403,33409,33413,33427,
 33457,33461,33469,33479,33487,33493,33503,33521,33529,33533,33547,33563,33569,33577,33581,33587,33589,33599,33601,33613,
 33617,33619,33623,33629,33637,33641,33647,33679,33703,33713,33721,33739,33749,33751,33757,33767,33769,33773,33791,33797,
 33809,33811,33827,33829,33851,33857,33863,33871,33889,33893,33911,33923,33931,33937,33941,33961,33967,33997,34019,34031,
 34033,34039,34057,34061,34123,34127,34129,34141,34147,34157,34159,34171,34183,34211,34213,34217,34231,34253,34259,34261,
 34267,34273,34283,34297,34301,34303,34313,34319,34327,34337,34351,34361,34367,34369,34381,34403,34421,34429,34439,34457,
 34469,34471,34483,34487,34499,34501,34511,34513,34519,34537,34543,34549,34583,34589,34591,34603,34607,34613,34631,34649,
 34651,34667,34673,34679,34687,34693,34703,34721,34729,34739,34747,34757,34759,34763,34781,34807,34819,34841,34843,34847,
 34849,34871,34877,34883,34897,34913,34919,34939,34949,34961,34963,34981,35023,35027,35051,35053,35059,35069,35081,35083,
 35089,35099,35107,35111,35117,35129,35141,35149,35153,35159,35171,35201,35221,35227,35251,35257,35267,35279,35281,35291,
 35311,35317,35323,35327,35339,35353,35363,35381,35393,35401,35407,35419,35423,35437,35447,35449,35461,35491,35507,35509,
 35521,35527,35531,35533,35537,35543,35569,35573,35591,35593,
 35597,35603,35617,35671,35677,35729,35731,35747,35753,35759,35771,35797,35801,35803,35809,35831,35837,35839,35851,35863,
 35869,35879,35897,35899,35911,35923,35933,35951,35963,35969,35977,35983,35993,35999,36007,36011,36013,36017,36037,36061,
 36067,36073,36083,36097,36107,36109,36131,36137,36151,36161,36187,36191,36209,36217,36229,36241,36251,36263,36269,36277,
 36293,36299,36307,36313,36319,36341,36343,36353,36373,36383,36389,36433,36451,36457,36467,36469,36473,36479,36493,36497,
 36523,36527,36529,36541,36551,36559,36563,36571,36583,36587,36599,36607,36629,36637,36643,36653,36671,36677,36683,36691,
 36697,36709,36713,36721,36739,36749,36761,36767,36779,36781,36787,36791,36793,36809,36821,36833,36847,36857,36871,36877,
 36887,36899,36901,36913,36919,36923,36929,36931,36943,36947,36973,36979,36997,37003,37013,37019,37021,37039,37049,37057,
 37061,37087,37097,37117,37123,37139,37159,37171,37181,37189,37199,37201,37217,37223,37243,37253,37273,37277,37307,37309,
 37313,37321,37337,37339,37357,37361,37363,37369,37379,37397,37409,37423,37441,37447,37463,37483,37489,37493,37501,37507,
 37511,37517,37529,37537,37547,37549,37561,37567,37571,37573,37579,37589,37591,37607,37619,37633,37643,37649,37657,37663,
 37691,37693,37699,37717,37747,37781,37783,37799,37811,37813,37831,37847,37853,37861,37871,37879,37889,37897,37907,37951,
 37957,37963,37967,37987,37991,37993,37997,38011,38039,38047,38053,38069,38083,38113,38119,38149,38153,38167,38177,38183,
 38189,38197,38201,38219,38231,38237,38239,38261,38273,38281,38287,38299,38303,38317,38321,38327,38329,38333,38351,38371,
 38377,38393,38431,38447,38449,38453,38459,38461,38501,38543,38557,38561,38567,38569,38593,38603,38609,38611,38629,38639,
 38651,38653,38669,38671,38677,38693,38699,38707,38711,38713,38723,38729,38737,38747,38749,38767,38783,38791,38803,38821,
 38833,38839,38851,38861,38867,38873,38891,38903,38917,38921,38923,38933,38953,38959,38971,38977,38993,39019,39023,39041,
 39043,39047,39079,39089,39097,39103,39107,39113,39119,39133,39139,39157,39161,39163,39181,39191,39199,39209,39217,39227,
 39229,39233,39239,39241,39251,39293,39301,39313,39317,39323,39341,39343,39359,39367,39371,39373,39383,39397,39409,39419,
 39439,39443,39451,39461,39499,39503,39509,39511,39521,39541,39551,39563,39569,39581,39607,39619,39623,39631,39659,39667,
 39671,39679,39703,39709,39719,39727,39733,39749,39761,39769,39779,39791,39799,39821,39827,39829,39839,39841,39847,39857,
 39863,39869,39877,39883,39887,39901,39929,39937,39953,39971,39979,39983,39989,40009,40013,40031,40037,40039,40063,40087,
 40093,40099,40111,40123,40127,40129,40151,40153,40163,40169,40177,40189,40193,40213,40231,40237,40241,40253,40277,40283,
 40289,40343,40351,40357,40361,40387,40423,40427,40429,40433,40459,40471,40483,40487,40493,40499,40507,40519,40529,40531,
 40543,40559,40577,40583,40591,40597,40609,40627,40637,40639,40693,40697,40699,40709,40739,40751,40759,40763,40771,40787,
 40801,40813,40819,40823,40829,40841,40847,40849,40853,40867,40879,40883,40897,40903,40927,40933,40939,40949,40961,40973,
 40993,41011,41017,41023,41039,41047,41051,41057,41077,41081,
 41113,41117,41131,41141,41143,41149,41161,41177,41179,41183,41189,41201,41203,41213,41221,41227,41231,41233,41243,41257,
 41263,41269,41281,41299,41333,41341,41351,41357,41381,41387,41389,41399,41411,41413,41443,41453,41467,41479,41491,41507,
 41513,41519,41521,41539,41543,41549,41579,41593,41597,41603,41609,41611,41617,41621,41627,41641,41647,41651,41659,41669,
 41681,41687,41719,41729,41737,41759,41761,41771,41777,41801,41809,41813,41843,41849,41851,41863,41879,41887,41893,41897,
 41903,41911,41927,41941,41947,41953,41957,41959,41969,41981,41983,41999,42013,42017,42019,42023,42043,42061,42071,42073,
 42083,42089,42101,42131,42139,42157,42169,42179,42181,42187,42193,42197,42209,42221,42223,42227,42239,42257,42281,42283,
 42293,42299,42307,42323,42331,42337,42349,42359,42373,42379,42391,42397,42403,42407,42409,42433,42437,42443,42451,42457,
 42461,42463,42467,42473,42487,42491,42499,42509,42533,42557,42569,42571,42577,42589,42611,42641,42643,42649,42667,42677,
 42683,42689,42697,42701,42703,42709,42719,42727,42737,42743,42751,42767,42773,42787,42793,42797,42821,42829,42839,42841,
 42853,42859,42863,42899,42901,42923,42929,42937,42943,42953,42961,42967,42979,42989,43003,43013,43019,43037,43049,43051,
 43063,43067,43093,43103,43117,43133,43151,43159,43177,43189,43201,43207,43223,43237,43261,43271,43283,43291,43313,43319,
 43321,43331,43391,43397,43399,43403,43411,43427,43441,43451,43457,43481,43487,43499,43517,43541,43543,43573,43577,43579,
 43591,43597,43607,43609,43613,43627,43633,43649,43651,43661,43669,43691,43711,43717,43721,43753,43759,43777,43781,43783,
 43787,43789,43793,43801,43853,43867,43889,43891,43913,43933,43943,43951,43961,43963,43969,43973,43987,43991,43997,44017,
 44021,44027,44029,44041,44053,44059,44071,44087,44089,44101,44111,44119,44123,44129,44131,44159,44171,44179,44189,44201,
 44203,44207,44221,44249,44257,44263,44267,44269,44273,44279,44281,44293,44351,44357,44371,44381,44383,44389,44417,44449,
 44453,44483,44491,44497,44501,44507,44519,44531,44533,44537,44543,44549,44563,44579,44587,44617,44621,44623,44633,44641,
 44647,44651,44657,44683,44687,44699,44701,44711,44729,44741,44753,44771,44773,44777,44789,44797,44809,44819,44839,44843,
 44851,44867,44879,44887,44893,44909,44917,44927,44939,44953,44959,44963,44971,44983,44987,45007,45013,45053,45061,45077,
 45083,45119,45121,45127,45131,45137,45139,45161,45179,45181,
 45191,45197,45233,45247,45259,45263,45281,45289,45293,45307,45317,45319,45329,45337,45341,45343,45361,45377,45389,45403,
 45413,45427,45433,45439,45481,45491,45497,45503,45523,45533,45541,45553,45557,45569,45587,45589,45599,45613,45631,45641,
 45659,45667,45673,45677,45691,45697,45707,45737,45751,45757,45763,45767,45779,45817,45821,45823,45827,45833,45841,45853,
 45863,45869,45887,45893,45943,45949,45953,45959,45971,45979,45989,46021,46027,46049,46051,46061,46073,46091,46093,46099,
 46103,46133,46141,46147,46153,46171,46181,46183,46187,46199,46219,46229,46237,46261,46271,46273,46279,46301,46307,46309,
 46327,46337,46349,46351,46381,46399,46411,46439,46441,46447,46451,46457,46471,46477,46489,46499,46507,46511,46523,46549,
 46559,46567,46573,46589,46591,46601,46619,46633,46639,46643,
 46649,46663,46679,46681,46687,46691,46703,46723,46727,46747,46751,46757,46769,46771,46807,46811,46817,46819,46829,46831,
 46853,46861,46867,46877,46889,46901,46919,46933,46957,46993,46997,47017,47041,47051,47057,47059,47087,47093,47111,47119,
 47123,47129,47137,47143,47147,47149,47161,47189,47207,47221,47237,47251,47269,47279,47287,47293,47297,47303,47309,47317,
 47339,47351,47353,47363,47381,47387,47389,47407,47417,47419,47431,47441,47459,47491,47497,47501,47507,47513,47521,47527,
 47533,47543,47563,47569,47581,47591,47599,47609,47623,47629,47639,47653,47657,47659,47681,47699,47701,47711,47713,47717,
 47737,47741,47743,47777,47779,47791,47797,47807,47809,47819,47837,47843,47857,47869,47881,47903,47911,47917,47933,47939,
 47947,47951,47963,47969,47977,47981,48017,48023,48029,48049,48073,48079,48091,48109,48119,48121,48131,48157,48163,48179,
 48187,48193,48197,48221,48239,48247,48259,48271,48281,48299,48311,48313,48337,48341,48353,48371,48383,48397,48407,48409,
 48413,48437,48449,48463,48473,48479,48481,48487,48491,48497,48523,48527,48533,48539,48541,48563,48571,48589,48593,48611,
 48619,48623,48647,48649,48661,48673,48677,48679,48731,48733,48751,48757,48761,48767,48779,48781,48787,48799,48809,48817,
 48821,48823,48847,48857,48859,48869,48871,48883,48889,48907,48947,48953,48973,48989,48991,49003,49009,49019,49031,49033,
 49037,49043,49057,49069,49081,49103,49109,49117,49121,49123,49139,49157,49169,49171,49177,49193,49199,49201,49207,49211,
 49223,49253,49261,49277,49279,49297,49307,49331,49333,49339,49363,49367,49369,49391,49393,49409,49411,49417,49429,49433,
 49451,49459,49463,49477,49481,49499,49523,49529,49531,49537,49547,49549,49559,49597,49603,49613,49627,49633,49639,49663,
 49667,49669,49681,49697,49711,49727,49739,49741,49747,49757,49783,49787,49789,49801,49807,49811,49823,49831,49843,49853,
 49871,49877,49891,49919,49921,49927,49937,49939,49943,49957,49991,49993,49999,50021,50023,50033,50047,50051,50053,50069,
 50077,50087,50093,50101,50111,50119,50123,50129,50131,50147,50153,50159,50177,50207,50221,50227,50231,50261,50263,50273,
 50287,50291,50311,50321,50329,50333,50341,50359,50363,50377,50383,50387,50411,50417,50423,50441,50459,50461,50497,50503,
 50513,50527,50539,50543,50549,50551,50581,50587,50591,50593,50599,50627,50647,50651,50671,50683,50707,50723,50741,50753,
 50767,50773,50777,50789,50821,50833,50839,50849,50857,50867,50873,50891,50893,50909,50923,50929,50951,50957,50969,50971,
 50989,50993,51001,51031,51043,51047,51059,51061,51071,51109,51131,51133,51137,51151,51157,51169,51193,51197,51199,51203,
 51217,51229,51239,51241,51257,51263,51283,51287,51307,51329,51341,51343,51347,51349,51361,51383,51407,51413,51419,51421,
 51427,51431,51437,51439,51449,51461,51473,51479,51481,51487,51503,51511,51517,51521,51539,51551,51563,51577,51581,51593,
 51599,51607,51613,51631,51637,51647,51659,51673,51679,51683,51691,51713,51719,51721,51749,51767,51769,51787,51797,51803,
 51817,51827,51829,51839,51853,51859,51869,51871,51893,51899,51907,51913,51929,51941,51949,51971,51973,51977,51991,52009,
 52021,52027,52051,52057,52067,52069,52081,52103,52121,52127,52147,52153,52163,52177,52181,52183,52189,52201,52223,52237,
 52249,52253,52259,52267,52289,52291,52301,52313,52321,52361,52363,52369,52379,52387,52391,52433,52453,52457,52489,52501,
 52511,52517,52529,52541,52543,52553,52561,52567,52571,52579,52583,52609,52627,52631,52639,52667,52673,52691,52697,52709,
 52711,52721,52727,52733,52747,52757,52769,52783,52807,52813,52817,52837,52859,52861,52879,52883,52889,52901,52903,52919,
 52937,52951,52957,52963,52967,52973,52981,52999,53003,53017,53047,53051,53069,53077,53087,53089,53093,53101,53113,53117,
 53129,53147,53149,53161,53171,53173,53189,53197,53201,53231,53233,53239,53267,53269,53279,53281,53299,53309,53323,53327,
 53353,53359,53377,53381,53401,53407,53411,53419,53437,53441,53453,53479,53503,53507,53527,53549,53551,53569,53591,53593,
 53597,53609,53611,53617,53623,53629,53633,53639,53653,53657,53681,53693,53699,53717,53719,53731,53759,53773,53777,53783,
 53791,53813,53819,53831,53849,53857,53861,53881,53887,53891,53897,53899,53917,53923,53927,53939,53951,53959,53987,53993,
 54001,54011,54013,54037,54049,54059,54083,54091,54101,54121,54133,54139,54151,54163,54167,54181,54193,54217,54251,54269,
 54277,54287,54293,54311,54319,54323,54331,54347,54361,54367,54371,54377,54401,54403,54409,54413,54419,54421,54437,54443,
 54449,54469,54493,54497,54499,54503,54517,54521,54539,54541,54547,54559,54563,54577,54581,54583,54601,54617,54623,54629,
 54631,54647,54667,54673,54679,54709,54713,54721,54727,54751,54767,54773,54779,54787,54799,54829,54833,54851,54869,54877,
 54881,54907,54917,54919,54941,54949,54959,54973,54979,54983,55001,55009,55021,55049,55051,55057,55061,55073,55079,55103,
 55109,55117,55127,55147,55163,55171,55201,55207,55213,55217,55219,55229,55243,55249,55259,55291,55313,55331,55333,55337,
 55339,55343,55351,55373,55381,55399,55411,55439,55441,55457,55469,55487,55501,55511,55529,55541,55547,55579,55589,55603,
 55609,55619,55621,55631,55633,55639,55661,55663,55667,55673,55681,55691,55697,55711,55717,55721,55733,55763,55787,55793,
 55799,55807,55813,55817,55819,55823,55829,55837,55843,55849,55871,55889,55897,55901,55903,55921,55927,55931,55933,55949,
 55967,55987,55997,56003,56009,56039,56041,56053,56081,56087,56093,56099,56101,56113,56123,56131,56149,56167,56171,56179,
 56197,56207,56209,56237,56239,56249,56263,56267,56269,56299,56311,56333,56359,56369,56377,56383,56393,56401,56417,56431,
 56437,56443,56453,56467,56473,56477,56479,56489,56501,56503,56509,56519,56527,56531,56533,56543,56569,56591,56597,56599,
 56611,56629,56633,56659,56663,56671,56681,56687,56701,56711,56713,56731,56737,56747,56767,56773,56779,56783,56807,56809,
 56813,56821,56827,56843,56857,56873,56891,56893,56897,56909,56911,56921,56923,56929,56941,56951,56957,56963,56983,56989,
 56993,56999,57037,57041,57047,57059,57073,57077,57089,57097,57107,57119,57131,57139,57143,57149,57163,57173,57179,57191,
 57193,57203,57221,57223,57241,57251,57259,57269,57271,57283,57287,57301,57329,57331,57347,57349,57367,57373,57383,57389,
 57397,57413,57427,57457,57467,57487,57493,57503,57527,57529,57557,57559,57571,57587,57593,57601,57637,57641,57649,57653,
 57667,57679,57689,57697,57709,57713,57719,57727,57731,57737,57751,57773,57781,57787,57791,57793,57803,57809,57829,57839,
 57847,57853,57859,57881,57899,57901,57917,57923,57943,57947,57973,57977,57991,58013,58027,58031,58043,58049,58057,58061,
 58067,58073,58099,58109,58111,58129,58147,58151,58153,58169,58171,58189,58193,58199,58207,58211,58217,58229,58231,58237,
 58243,58271,58309,58313,58321,58337,58363,58367,58369,58379,58391,58393,58403,58411,58417,58427,58439,58441,58451,58453,
 58477,58481,58511,58537,58543,58549,58567,58573,58579,58601,58603,58613,58631,58657,58661,58679,58687,58693,58699,58711,
 58727,58733,58741,58757,58763,58771,58787,58789,58831,58889,58897,58901,58907,58909,58913,58921,58937,58943,58963,58967,
 58979,58991,58997,59009,59011,59021,59023,59029,59051,59053,59063,59069,59077,59083,59093,59107,59113,59119,59123,59141,
 59149,59159,59167,59183,59197,59207,59209,59219,59221,59233,
 59239,59243,59263,59273,59281,59333,59341,59351,59357,59359,59369,59377,59387,59393,59399,59407,59417,59419,59441,59443,
 59447,59453,59467,59471,59473,59497,59509,59513,59539,59557,59561,59567,59581,59611,59617,59621,59627,59629,59651,59659,
 59663,59669,59671,59693,59699,59707,59723,59729,59743,59747,59753,59771,59779,59791,59797,59809,59833,59863,59879,59887,
 59921,59929,59951,59957,59971,59981,59999,60013,60017,60029,60037,60041,60077,60083,60089,60091,60101,60103,60107,60127,
 60133,60139,60149,60161,60167,60169,60209,60217,60223,60251,
 60257,60259,60271,60289,60293,60317,60331,60337,60343,60353,
 60373,60383,60397,60413,60427,60443,60449,60457,60493,60497,
 60509,60521,60527,60539,60589,60601,60607,60611,60617,60623,
 60631,60637,60647,60649,60659,60661,60679,60689,60703,60719,
 60727,60733,60737,60757,60761,60763,60773,60779,60793,60811,60821,60859,60869,60887,60889,60899,60901,60913,60917,60919,
 60923,60937,60943,60953,60961,61001,61007,61027,61031,61043,61051,61057,61091,61099,61121,61129,61141,61151,61153,61169,
 61211,61223,61231,61253,61261,61283,61291,61297,61331,61333,61339,61343,61357,61363,61379,61381,61403,61409,61417,61441,
 61463,61469,61471,61483,61487,61493,61507,61511,61519,61543,61547,61553,61559,61561,61583,61603,61609,61613,61627,61631,
 61637,61643,61651,61657,61667,61673,61681,61687,61703,61717,61723,61729,61751,61757,61781,61813,61819,61837,61843,61861,
 61871,61879,61909,61927,61933,61949,61961,61967,61979,61981,61987,61991,62003,62011,62017,62039,62047,62053,62057,62071,
 62081,62099,62119,62129,62131,62137,62141,62143,62171,62189,62191,62201,62207,62213,62219,62233,62273,62297,62299,62303,
 62311,62323,62327,62347,62351,62383,62401,62417,62423,62459,62467,62473,62477,62483,62497,62501,62507,62533,62539,62549,
 62563,62581,62591,62597,62603,62617,62627,62633,62639,62653,62659,62683,62687,62701,62723,62731,62743,62753,62761,62773,
 62791,62801,62819,62827,62851,62861,62869,62873,62897,62903,62921,62927,62929,62939,62969,62971,62981,62983,62987,62989,
 63029,63031,63059,63067,63073,63079,63097,63103,63113,63127,63131,63149,63179,63197,63199,63211,63241,63247,63277,63281,
 63299,63311,63313,63317,63331,63337,63347,63353,63361,63367,63377,63389,63391,63397,63409,63419,63421,63439,63443,63463,
 63467,63473,63487,63493,63499,63521,63527,63533,63541,63559,63577,63587,63589,63599,63601,63607,63611,63617,63629,63647,
 63649,63659,63667,63671,63689,63691,63697,63703,63709,63719,63727,63737,63743,63761,63773,63781,63793,63799,63803,63809,
 63823,63839,63841,63853,63857,63863,63901,63907,63913,63929,63949,63977,63997,64007,64013,64019,64033,64037,64063,64067,
 64081,64091,64109,64123,64151,64153,64157,64171,64187,64189,64217,64223,64231,64237,64271,64279,64283,64301,64303,64319,
 64327,64333,64373,64381,64399,64403,64433,64439,64451,64453,
 64483,64489,64499,64513,64553,64567,64577,64579,64591,64601,64609,64613,64621,64627,64633,64661,64663,64667,64679,64693,
 64709,64717,64747,64763,64781,64783,64793,64811,64817,64849,64853,64871,64877,64879,64891,64901,64919,64921,64927,64937,
 64951,64969,64997,65003,65011,65027,65029,65033,65053,65063,65071,65089,65099,65101,65111,65119,65123,65129,65141,65147,
 65167,65171,65173,65179,65183,65203,65213,65239,65257,65267,65269,65287,65293,65309,65323,65327,65353,65357,65371,65381,
 65393,65407,65413,65419,65423,65437,65447,65449,65479,65497,65519,65521,65537,65539,65543,65551,65557,65563,65579,65581,
 65587,65599,65609,65617,65629,65633,65647,65651,65657,65677,65687,65699,65701,65707,65713,65717,65719,65729,65731,65761,
 65777,65789,65809,65827,65831,65837,65839,65843,65851,65867,65881,65899,65921,65927,65929,65951,65957,65963,65981,65983,
 65993,66029,66037,66041,66047,66067,66071,66083,66089,66103,66107,66109,66137,66161,66169,66173,66179,66191,66221,66239,
 66271,66293,66301,66337,66343,66347,66359,66361,66373,66377,66383,66403,66413,66431,66449,66457,66463,66467,66491,66499,
 66509,66523,66529,66533,66541,66553,66569,66571,66587,66593,66601,66617,66629,66643,66653,66683,66697,66701,66713,66721,
 66733,66739,66749,66751,66763,66791,66797,66809,66821,66841,
 66851,66853,66863,66877,66883,66889,66919,66923,66931,66943,66947,66949,66959,66973,66977,67003,67021,67033,67043,67049,
 67057,67061,67073,67079,67103,67121,67129,67139,67141,67153,67157,67169,67181,67187,67189,67211,67213,67217,67219,67231,
 67247,67261,67271,67273,67289,67307,67339,67343,67349,67369,67391,67399,67409,67411,67421,67427,67429,67433,67447,67453,
 67477,67481,67489,67493,67499,67511,67523,67531,67537,67547,67559,67567,67577,67579,67589,67601,67607,67619,67631,67651,
 67679,67699,67709,67723,67733,67741,67751,67757,67759,67763,67777,67783,67789,67801,67807,67819,67829,67843,67853,67867,
 67883,67891,67901,67927,67931,67933,67939,67943,67957,67961,67967,67979,67987,67993,68023,68041,68053,68059,68071,68087,
 68099,68111,68113,68141,68147,68161,68171,68207,68209,68213,68219,68227,68239,68261,68279,68281,68311,68329,68351,68371,
 68389,68399,68437,68443,68447,68449,68473,68477,68483,68489,68491,68501,68507,68521,68531,68539,68543,68567,68581,68597,
 68611,68633,68639,68659,68669,68683,68687,68699,68711,68713,68729,68737,68743,68749,68767,68771,68777,68791,68813,68819,
 68821,68863,68879,68881,68891,68897,68899,68903,68909,68917,68927,68947,68963,68993,69001,69011,69019,69029,69031,69061,
 69067,69073,69109,69119,69127,69143,69149,69151,69163,69191,69193,69197,69203,69221,69233,69239,69247,69257,69259,69263,
 69313,69317,69337,69341,69371,69379,69383,69389,69401,69403,69427,69431,69439,69457,69463,69467,69473,69481,69491,69493,
 69497,69499,69539,69557,69593,69623,69653,69661,69677,69691,69697,69709,69737,69739,69761,69763,69767,69779,69809,69821,
 69827,69829,69833,69847,69857,69859,69877,69899,69911,69929,69931,69941,69959,69991,69997,70001,70003,70009,70019,70039,
 70051,70061,70067,70079,70099,70111,70117,70121,70123,70139,70141,70157,70163,70177,70181,70183,70199,70201,70207,70223,
 70229,70237,70241,70249,70271,70289,70297,70309,70313,70321,70327,70351,70373,70379,70381,70393,70423,70429,70439,70451,
 70457,70459,70481,70487,70489,70501,70507,70529,70537,70549,
 70571,70573,70583,70589,70607,70619,70621,70627,70639,70657,70663,70667,70687,70709,70717,70729,70753,70769,70783,70793,
 70823,70841,70843,70849,70853,70867,70877,70879,70891,70901,70913,70919,70921,70937,70949,70951,70957,70969,70979,70981,
 70991,70997,70999,71011,71023,71039,71059,71069,71081,71089,71119,71129,71143,71147,71153,71161,71167,71171,71191,71209,
 71233,71237,71249,71257,71261,71263,71287,71293,71317,71327,71329,71333,71339,71341,71347,71353,71359,71363,71387,71389,
 71399,71411,71413,71419,71429,71437,71443,71453,71471,71473,71479,71483,71503,71527,71537,71549,71551,71563,71569,71593,
 71597,71633,71647,71663,71671,71693,71699,71707,71711,71713,71719,71741,71761,71777,71789,71807,71809,71821,71837,71843,
 71849,71861,71867,71879,71881,71887,71899,71909,71917,71933,71941,71947,71963,71971,71983,71987,71993,71999,72019,72031,
 72043,72047,72053,72073,72077,72089,72091,72101,72103,72109,72139,72161,72167,72169,72173,72211,72221,72223,72227,72229,
 72251,72253,72269,72271,72277,72287,72307,72313,72337,72341,72353,72367,72379,72383,72421,72431,72461,72467,72469,72481,
 72493,72497,72503,72533,72547,72551,72559,72577,72613,72617,72623,72643,72647,72649,72661,72671,72673,72679,72689,72701,
 72707,72719,72727,72733,72739,72763,72767,72797,72817,72823,72859,72869,72871,72883,72889,72893,72901,72907,72911,72923,
 72931,72937,72949,72953,72959,72973,72977,72997,73009,73013,73019,73037,73039,73043,73061,73063,73079,73091,73121,73127,
 73133,73141,73181,73189,73237,73243,73259,73277,73291,73303,73309,73327,73331,73351,73361,73363,73369,73379,73387,73417,
 73421,73433,73453,73459,73471,73477,73483,73517,73523,73529,73547,73553,73561,73571,73583,73589,73597,73607,73609,73613,
 73637,73643,73651,73673,73679,73681,73693,73699,73709,73721,73727,73751,73757,73771,73783,73819,73823,73847,73849,73859,
 73867,73877,73883,73897,73907,73939,73943,73951,73961,73973,73999,74017,74021,74027,74047,74051,74071,74077,74093,74099,
 74101,74131,74143,74149,74159,74161,74167,74177,74189,74197,74201,74203,74209,74219,74231,74257,74279,74287,74293,74297,
 74311,74317,74323,74353,74357,74363,74377,74381,74383,74411,74413,74419,74441,74449,74453,74471,74489,74507,74509,74521,
 74527,74531,74551,74561,74567,74573,74587,74597,74609,74611,74623,74653,74687,74699,74707,74713,74717,74719,74729,74731,
 74747,74759,74761,74771,74779,74797,74821,74827,74831,74843,74857,74861,74869,74873,74887,74891,74897,74903,74923,74929,
 74933,74941,74959,75011,75013,75017,75029,75037,75041,75079,75083,75109,75133,75149,75161,75167,75169,75181,75193,75209,
 75211,75217,75223,75227,75239,75253,75269,75277,75289,75307,75323,75329,75337,75347,75353,75367,75377,75389,75391,75401,
 75403,75407,75431,75437,75479,75503,75511,75521,75527,75533,75539,75541,75553,75557,75571,75577,75583,75611,75617,75619,
 75629,75641,75653,75659,75679,75683,75689,75703,75707,75709,75721,75731,75743,75767,75773,75781,75787,75793,75797,75821,
 75833,75853,75869,75883,75913,75931,75937,75941,75967,75979,75983,75989,75991,75997,76001,76003,76031,76039,76079,76081,
 76091,76099,76103,76123,76129,76147,76157,76159,76163,76207,76213,76231,76243,76249,76253,76259,76261,76283,76289,76303,
 76333,76343,76367,76369,76379,76387,76403,76421,76423,76441,76463,76471,76481,76487,76493,76507,76511,76519,76537,76541,
 76543,76561,76579,76597,76603,76607,76631,76649,76651,76667,76673,76679,76697,76717,76733,76753,76757,76771,76777,76781,
 76801,76819,76829,76831,76837,76847,76871,76873,76883,76907,76913,76919,76943,76949,76961,76963,76991,77003,77017,77023,
 77029,77041,77047,77069,77081,77093,77101,77137,77141,77153,77167,77171,77191,77201,77213,77237,77239,77243,77249,77261,
 77263,77267,77269,77279,77291,77317,77323,77339,77347,77351,77359,77369,77377,77383,77417,77419,77431,77447,77471,77477,
 77479,77489,77491,77509,77513,77521,77527,77543,77549,77551,77557,77563,77569,77573,77587,77591,77611,77617,77621,77641,
 77647,77659,77681,77687,77689,77699,77711,77713,77719,77723,77731,77743,77747,77761,77773,77783,77797,77801,77813,77839,
 77849,77863,77867,77893,77899,77929,77933,77951,77969,77977,77983,77999,78007,78017,78031,78041,78049,78059,78079,78101,
 78121,78137,78139,78157,78163,78167,78173,78179,78191,78193,78203,78229,78233,78241,78259,78277,78283,78301,78307,78311,
 78317,78341,78347,78367,78401,78427,78437,78439,78467,78479,78487,78497,78509,78511,78517,78539,78541,78553,78569,78571,
 78577,78583,78593,78607,78623,78643,78649,78653,78691,78697,78707,78713,78721,78737,78779,78781,78787,78791,78797,78803,
 78809,78823,78839,78853,78857,78877,78887,78889,78893,78901,
 78919,78929,78941,78977,78979,78989,79031,79039,79043,79063,79087,79103,79111,79133,79139,79147,79151,79153,79159,79181,
 79187,79193,79201,79229,79231,79241,79259,79273,79279,79283,79301,79309,79319,79333,79337,79349,79357,79367,79379,79393,
 79397,79399,79411,79423,79427,79433,79451,79481,79493,79531,79537,79549,79559,79561,79579,79589,79601,79609,79613,79621,
 79627,79631,79633,79657,79669,79687,79691,79693,79697,79699,79757,79769,79777,79801,79811,79813,79817,79823,79829,79841,
 79843,79847,79861,79867,79873,79889,79901,79903,79907,79939,79943,79967,79973,79979,79987,79997,79999,80021,80039,80051,
 80071,80077,80107,80111,80141,80147,80149,80153,80167,80173,80177,80191,80207,80209,80221,80231,80233,80239,80251,80263,
 80273,80279,80287,80309,80317,80329,80341,80347,80363,80369,80387,80407,80429,80447,80449,80471,80473,80489,80491,80513,
 80527,80537,80557,80567,80599,80603,80611,80621,80627,80629,80651,80657,80669,80671,80677,80681,80683,80687,80701,80713,
 80737,80747,80749,80761,80777,80779,80783,80789,80803,80809,80819,80831,80833,80849,80863,80897,80909,80911,80917,80923,
 80929,80933,80953,80963,80989,81001,81013,81017,81019,81023,81031,81041,81043,81047,81049,81071,81077,81083,81097,81101,
 81119,81131,81157,81163,81173,81181,81197,81199,81203,81223,81233,81239,81281,81283,81293,81299,81307,81331,81343,81349,
 81353,81359,81371,81373,81401,81409,81421,81439,81457,81463,81509,81517,81527,81533,81547,81551,81553,81559,81563,81569,
 81611,81619,81629,81637,81647,81649,81667,81671,81677,81689,81701,81703,81707,81727,81737,81749,81761,81769,81773,81799,
 81817,81839,81847,81853,81869,81883,81899,81901,81919,81929,81931,81937,81943,81953,81967,81971,81973,82003,82007,82009,
 82013,82021,82031,82037,82039,82051,82067,82073,82129,82139,82141,82153,82163,82171,82183,82189,82193,82207,82217,82219,
 82223,82231,82237,82241,82261,82267,82279,82301,82307,82339,82349,82351,82361,82373,82387,82393,82421,82457,82463,82469,
 82471,82483,82487,82493,82499,82507,82529,82531,82549,82559,82561,82567,82571,82591,82601,82609,82613,82619,82633,82651,
 82657,82699,82721,82723,82727,82729,82757,82759,82763,82781,82787,82793,82799,82811,82813,82837,82847,82883,82889,82891,
 82903,82913,82939,82963,82981,82997,83003,83009,83023,83047,83059,83063,83071,83077,83089,83093,83101,83117,83137,83177,
 83203,83207,83219,83221,83227,83231,83233,83243,83257,83267,83269,83273,83299,83311,83339,83341,83357,83383,83389,83399,
 83401,83407,83417,83423,83431,83437,83443,83449,83459,83471,
 83477,83497,83537,83557,83561,83563,83579,83591,83597,83609,83617,83621,83639,83641,83653,83663,83689,83701,83717,83719,
 83737,83761,83773,83777,83791,83813,83833,83843,83857,83869,83873,83891,83903,83911,83921,83933,83939,83969,83983,83987,
 84011,84017,84047,84053,84059,84061,84067,84089,84121,84127,84131,84137,84143,84163,84179,84181,84191,84199,84211,84221,
 84223,84229,84239,84247,84263,84299,84307,84313,84317,84319,84347,84349,84377,84389,84391,84401,84407,84421,84431,84437,
 84443,84449,84457,84463,84467,84481,84499,84503,84509,84521,84523,84533,84551,84559,84589,84629,84631,84649,84653,84659,
 84673,84691,84697,84701,84713,84719,84731,84737,84751,84761,84787,84793,84809,84811,84827,84857,84859,84869,84871,84913,
 84919,84947,84961,84967,84977,84979,84991,85009,85021,85027,85037,85049,85061,85081,85087,85091,85093,85103,85109,85121,
 85133,85147,85159,85193,85199,85201,85213,85223,85229,85237,
 85243,85247,85259,85297,85303,85313,85331,85333,85361,85363,85369,85381,85411,85427,85429,85439,85447,85451,85453,85469,
 85487,85513,85517,85523,85531,85549,85571,85577,85597,85601,85607,85619,85621,85627,85639,85643,85661,85667,85669,85691,
 85703,85711,85717,85733,85751,85781,85793,85817,85819,85829,85831,85837,85843,85847,85853,85889,85903,85909,85931,85933,
 85991,85999,86011,86017,86027,86029,86069,86077,86083,86111,86113,86117,86131,86137,86143,86161,86171,86179,86183,86197,
 86201,86209,86239,86243,86249,86257,86263,86269,86287,86291,86293,86297,86311,86323,86341,86351,86353,86357,86369,86371,
 86381,86389,86399,86413,86423,86441,86453,86461,86467,86477,86491,86501,86509,86531,86533,86539,86561,86573,86579,86587,
 86599,86627,86629,86677,86689,86693,86711,86719,86729,86743,86753,86767,86771,86783,86813,86837,86843,86851,86857,86861,
 86869,86923,86927,86929,86939,86951,86959,86969,86981,86993,87011,87013,87037,87041,87049,87071,87083,87103,87107,87119,
 87121,87133,87149,87151,87179,87181,87187,87211,87221,87223,87251,87253,87257,87277,87281,87293,87299,87313,87317,87323,
 87337,87359,87383,87403,87407,87421,87427,87433,87443,87473,87481,87491,87509,87511,87517,87523,87539,87541,87547,87553,
 87557,87559,87583,87587,87589,87613,87623,87629,87631,87641,87643,87649,87671,87679,87683,87691,87697,87701,87719,87721,
 87739,87743,87751,87767,87793,87797,87803,87811,87833,87853,87869,87877,87881,87887,87911,87917,87931,87943,87959,87961,
 87973,87977,87991,88001,88003,88007,88019,88037,88069,88079,88093,88117,88129,88169,88177,88211,88223,88237,88241,88259,
 88261,88289,88301,88321,88327,88337,88339,88379,88397,88411,88423,88427,88463,88469,88471,88493,88499,88513,88523,88547,
 88589,88591,88607,88609,88643,88651,88657,88661,88663,88667,88681,88721,88729,88741,88747,88771,88789,88793,88799,88801,
 88807,88811,88813,88817,88819,88843,88853,88861,88867,88873,88883,88897,88903,88919,88937,88951,88969,88993,88997,89003,
 89009,89017,89021,89041,89051,89057,89069,89071,89083,89087,89101,89107,89113,89119,89123,89137,89153,89189,89203,89209,
 89213,89227,89231,89237,89261,89269,89273,89293,89303,89317,89329,89363,89371,89381,89387,89393,89399,89413,89417,89431,
 89443,89449,89459,89477,89491,89501,89513,89519,89521,89527,89533,89561,89563,89567,89591,89597,89599,89603,89611,89627,
 89633,89653,89657,89659,89669,89671,89681,89689,89753,89759,89767,89779,89783,89797,89809,89819,89821,89833,89839,89849,
 89867,89891,89897,89899,89909,89917,89923,89939,89959,89963,89977,89983,89989,90001,90007,90011,90017,90019,90023,90031,
 90053,90059,90067,90071,90073,90089,90107,90121,90127,90149,90163,90173,90187,90191,90197,90199,90203,90217,90227,90239,
 90247,90263,90271,90281,90289,90313,90353,90359,90371,90373,90379,90397,90401,90403,90407,90437,90439,90469,90473,90481,
 90499,90511,90523,90527,90529,90533,90547,90583,90599,90617,90619,90631,90641,90647,90659,90677,90679,90697,90703,90709,
 90731,90749,90787,90793,90803,90821,90823,90833,90841,90847,90863,90887,90901,90907,90911,90917,90931,90947,90971,90977,
 90989,90997,91009,91019,91033,91079,91081,91097,91099,91121,91127,91129,91139,91141,91151,91153,91159,91163,91183,91193,
 91199,91229,91237,91243,91249,91253,91283,91291,91297,91303,91309,91331,91367,91369,91373,91381,91387,91393,91397,91411,
 91423,91433,91453,91457,91459,91463,91493,91499,91513,91529,91541,91571,91573,91577,91583,91591,91621,91631,91639,91673,
 91691,91703,91711,91733,91753,91757,91771,91781,91801,91807,91811,91813,91823,91837,91841,91867,91873,91909,91921,91939,
 91943,91951,91957,91961,91967,91969,91997,92003,92009,92033,92041,92051,92077,92083,92107,92111,92119,92143,92153,92173,
 92177,92179,92189,92203,92219,92221,92227,92233,92237,92243,92251,92269,92297,92311,92317,92333,92347,92353,92357,92363,
 92369,92377,92381,92383,92387,92399,92401,92413,92419,92431,92459,92461,92467,92479,92489,92503,92507,92551,92557,92567,
 92569,92581,92593,92623,92627,92639,92641,92647,92657,92669,92671,92681,92683,92693,92699,92707,92717,92723,92737,92753,
 92761,92767,92779,92789,92791,92801,92809,92821,92831,92849,92857,92861,92863,92867,92893,92899,92921,92927,92941,92951,
 92957,92959,92987,92993,93001,93047,93053,93059,93077,93083,
 93089,93097,93103,93113,93131,93133,93139,93151,93169,93179,93187,93199,93229,93239,93241,93251,93253,93257,93263,93281,
 93283,93287,93307,93319,93323,93329,93337,93371,93377,93383,93407,93419,93427,93463,93479,93481,93487,93491,93493,93497,
 93503,93523,93529,93553,93557,93559,93563,93581,93601,93607,93629,93637,93683,93701,93703,93719,93739,93761,93763,93787,
 93809,93811,93827,93851,93871,93887,93889,93893,93901,93911,93913,93923,93937,93941,93949,93967,93971,93979,93983,93997,
 94007,94009,94033,94049,94057,94063,94079,94099,94109,94111,94117,94121,94151,94153,94169,94201,94207,94219,94229,94253,
 94261,94273,94291,94307,94309,94321,94327,94331,94343,94349,94351,94379,94397,94399,94421,94427,94433,94439,94441,94447,
 94463,94477,94483,94513,94529,94531,94541,94543,94547,94559,94561,94573,94583,94597,94603,94613,94621,94649,94651,94687,
 94693,94709,94723,94727,94747,94771,94777,94781,94789,94793,94811,94819,94823,94837,94841,94847,94849,94873,94889,94903,
 94907,94933,94949,94951,94961,94993,94999,95003,95009,95021,95027,95063,95071,95083,95087,95089,95093,95101,95107,95111,
 95131,95143,95153,95177,95189,95191,95203,95213,95219,95231,95233,95239,95257,95261,95267,95273,95279,95287,95311,95317,
 95327,95339,95369,95383,95393,95401,95413,95419,95429,95441,95443,95461,95467,95471,95479,95483,95507,95527,95531,95539,
 95549,95561,95569,95581,95597,95603,95617,95621,95629,95633,95651,95701,95707,95713,95717,95723,95731,95737,95747,95773,
 95783,95789,95791,95801,95803,95813,95819,95857,95869,95873,95881,95891,95911,95917,95923,95929,95947,95957,95959,95971,
 95987,95989,96001,96013,96017,96043,96053,96059,96079,96097,96137,96149,96157,96167,96179,96181,96199,96211,96221,96223,
 96233,96259,96263,96269,96281,96289,96293,96323,96329,96331,96337,96353,96377,96401,96419,96431,96443,96451,96457,96461,
 96469,96479,96487,96493,96497,96517,96527,96553,96557,96581,96587,96589,96601,96643,96661,96667,96671,96697,96703,96731,
 96737,96739,96749,96757,96763,96769,96779,96787,96797,96799,96821,96823,96827,96847,96851,96857,96893,96907,96911,96931,
 96953,96959,96973,96979,96989,96997,97001,97003,97007,97021,97039,97073,97081,97103,97117,97127,97151,97157,97159,97169,
 97171,97177,97187,97213,97231,97241,97259,97283,97301,97303,97327,97367,97369,97373,97379,97381,97387,97397,97423,97429,
 97441,97453,97459,97463,97499,97501,97511,97523,97547,97549,97553,97561,97571,97577,97579,97583,97607,97609,97613,97649,
 97651,97673,97687,97711,97729,97771,97777,97787,97789,97813,97829,97841,97843,97847,97849,97859,97861,97871,97879,97883,
 97919,97927,97931,97943,97961,97967,97973,97987,98009,98011,
 98017,98041,98047,98057,98081,98101,98123,98129,98143,98179,98207,98213,98221,98227,98251,98257,98269,98297,98299,98317,
 98321,98323,98327,98347,98369,98377,98387,98389,98407,98411,98419,98429,98443,98453,98459,98467,98473,98479,98491,98507,
 98519,98533,98543,98561,98563,98573,98597,98621,98627,98639,98641,98663,98669,98689,98711,98713,98717,98729,98731,98737,
 98773,98779,98801,98807,98809,98837,98849,98867,98869,98873,98887,98893,98897,98899,98909,98911,98927,98929,98939,98947,
 98953,98963,98981,98993,98999,99013,99017,99023,99041,99053,99079,99083,99089,99103,99109,99119,99131,99133,99137,99139,
 99149,99173,99181,99191,99223,99233,99241,99251,99257,99259,99277,99289,99317,99347,99349,99367,99371,99377,99391,99397,
 99401,99409,99431,99439,99469,99487,99497,99523,99527,99529,99551,99559,99563,99571,99577,99581,99607,99611,99623,99643,
 99661,99667,99679,99689,99707,99709,99713,99719,99721,99733,99761,99767,99787,99793,99809,99817,99823,99829,99833,99839,
 99859,99871,99877,99881,99901,99907,99923,99929,99961,99971,99989,99991,100003,100019,100043,100049,100057,100069,100103,100109,
 100129,100151,100153,100169,100183,100189,100193,100207,100213,100237,100267,100271,100279,100291,100297,100313,100333,100343,100357,100361,
 100363,100379,100391,100393,100403,100411,100417,100447,100459,100469,100483,100493,100501,100511,100517,100519,100523,100537,100547,100549,
 100559,100591,100609,100613,100621,100649,100669,100673,100693,100699,100703,100733,100741,100747,100769,100787,100799,100801,100811,100823,
 100829,100847,100853,100907,100913,100927,100931,100937,100943,100957,100981,100987,100999,101009,101021,101027,101051,101063,101081,101089,
 101107,101111,101113,101117,101119,101141,101149,101159,101161,101173,101183,101197,101203,101207,101209,101221,101267,101273,101279,101281,
 101287,101293,101323,101333,101341,101347,101359,101363,101377,101383,101399,101411,101419,101429,101449,101467,101477,101483,101489,101501,
 101503,101513,101527,101531,101533,101537,101561,101573,101581,101599,101603,101611,101627,101641,101653,101663,101681,101693,101701,101719,
 101723,101737,101741,101747,101749,101771,101789,101797,101807,101833,101837,101839,101863,101869,101873,101879,101891,101917,101921,101929,
 101939,101957,101963,101977,101987,101999,102001,102013,102019,102023,102031,102043,102059,102061,102071,102077,102079,102101,102103,102107,
 102121,102139,102149,102161,102181,102191,102197,102199,102203,102217,102229,102233,102241,102251,102253,102259,102293,102299,102301,102317,
 102329,102337,102359,102367,102397,102407,102409,102433,102437,102451,102461,102481,102497,102499,102503,102523,102533,102539,102547,102551,
 102559,102563,102587,102593,102607,102611,102643,102647,102653,102667,102673,102677,102679,102701,102761,102763,102769,102793,102797,102811,
 102829,102841,102859,102871,102877,102881,102911,102913,102929,102931,102953,102967,102983,103001,103007,103043,103049,103067,103069,103079,
 103087,103091,103093,103099,103123,103141,103171,103177,103183,103217,103231,103237,103289,103291,103307,103319,103333,103349,103357,103387,
 103391,103393,103399,103409,103421,103423,103451,103457,103471,103483,103511,103529,103549,103553,103561,103567,103573,103577,103583,103591,
 103613,103619,103643,103651,103657,103669,103681,103687,103699,103703,103723,103769,103787,103801,103811,103813,103837,103841,103843,103867,
 103889,103903,103913,103919,103951,103963,103967,103969,103979,103981,103991,103993,103997,104003,104009,104021,104033,104047,104053,104059,
 104087,104089,104107,104113,104119,104123,104147,104149,104161,104173,104179,104183,104207,104231,104233,104239,104243,104281,104287,104297,
 104309,104311,104323,104327,104347,104369,104381,104383,104393,104399,104417,104459,104471,104473,104479,104491,104513,104527,104537,104543,
 104549,104551,104561,104579,104593,104597,104623,104639,104651,104659,104677,104681,104683,104693,104701,104707,104711,104717,104723,104729,104743,
 };




 structure
 {
 _twister twister;
 D four_billion;
 D ten_million;
 D one_million;
 I dct_iclip[1024];
 IP dct_iclip_ptr;
 }
 _aa_mathsystem;


 B aa_MathSystemStart                  (V);
 V aa_MathSystemStop                   (V);
 B aa_MathRandomGet                    (VP buf,H bytes);


/*----------------------------------------------------------*/



 structure
 {
 H magic;
 B state;
 Q id;
 H page_index;
 H block_index;
 }
 _aa_poolblockstub;


 structure
 {
 H blocks_allocated;
 H blocks_inuse;
 H block_pf;
 BP block_memory;
 BP block_state;
 }
 _aa_poolpage;


 structure
 {
 H self_handle;
 _poolstatus status;
 Q id_counter;
 H pages_topup_amount;
 H pages_topup_threshold;
 H pages_full;
 H page_pf;
 H pages_allocated;
 _aa_poolpage*page;
 }
 _aa_poolobject;


 structure
 {
 B object_id;
 }
 _aa_poolsystem;


 B aa_PoolSystemStart                  (V);
 V aa_PoolSystemStop                   (V);
 B aa_PoolSystemAddPages               (PP ptr,H qty);


/*---------------------------------------------------------*/

 structure
 {
 H self_handle;
 CRITICAL_SECTION mutex;
 HANDLE handle;
 _aa_event event;
 H id;
 _threadstatus status;
 }
 _aa_threadobject;


 structure
 {
 B object_id;
 }
 _aa_threadsystem;


 B aa_ThreadSystemStart                (V);
 V aa_ThreadSystemStop                 (V);

/*-----------------------------------------------------------------------*/

 structure
 {
 H self_handle;
 STARTUPINFO si;
 STARTUPINFOW siw;
 SECURITY_ATTRIBUTES sa;
 SECURITY_DESCRIPTOR sd;
 PROCESS_INFORMATION pi;
 _processstatus status;
 PUSER_INFO_1 user_info;
 H ms_root;
 _timer crash_tm;
 H crash_tm_counter;
 }
 _aa_processobject;


 structure
 {
 B object_id;
 }
 _aa_processsystem;


 B aa_ProcessSystemStart               (V);
 V aa_ProcessSystemStop                (V);
 B aa_ProcessSystemCreate              (HP handle,VP processfilename,VP commandline,B clmode,B inherit,B startpaused,B detach,B newroot,W showcmd,B isconsole,VP desktop);
 BOOL CALLBACK aa_ProcessSystemEnum    (HWND hwnd,LPARAM lParam);
 H aa_ProcessCrashTester               (VP parm);

/*-----------------------------------------------------------------------*/

 structure
 {
 H self_handle;
 _winenumstatus status;
 H slots;
 BP mem;
 H thread_handle;
 _threadstatus thread_status;
 H sleep_cycle;
 }
 _aa_winenumobject;



 structure
 {
 B object_id;
 }
 _aa_winenumsystem;


 B aa_WinEnumSystemStart               (V);
 V aa_WinEnumSystemStop                (V);
 BOOL CALLBACK aa_WinEnumProc          (HWND hwnd,LPARAM lparm);

/*-----------------------------------------------------------------------*/

 structure
 {
 H self_handle;
 _dynbufstatus status;
 H write_bit_pos;
 H read_bit_pos;
 }
 _aa_dynbufobject;


 structure
 {
 B object_id;
 }
 _aa_dynbufsystem;


 B aa_DynbufSystemStart                (V);
 V aa_DynbufSystemStop                 (V);
 B aa_DynbufSystemExtend               (PP ptr,H by);

/*-----------------------------------------------------------------------*/


 structure
 {
 H mode;
 H off;
 H chars;
 }
 _crlfdecoder;


/*-----------------------------------------------------------------------*/


 structure
 {
 H self_handle;
 H head,tail;
 _questatus status;
 H pages_allocated;
 H slots_allocated;
 HP pge_slot;
 B crlf_state;
 H line_peek_offset;
 H line_chars;
 }
 _aa_queobject;


 structure
 {
 B object_id;
 }
 _aa_quesystem;


 B aa_QueSystemStart                   (V);
 V aa_QueSystemStop                    (V);
 B aa_QueSystemExtendPageSlots         (PP mem,H by);

/*-----------------------------------------------------------------------*/

 #define aa_HUFF_HEAP_SIZE              ((sizeof(D)*257)+(((sizeof(VP)*4)+sizeof(D)+sizeof(H))*(257*3))+((sizeof(H)+sizeof(H))*257))


 struct _aahuff_node
 {
 struct _aahuff_node*lr[2];
 struct _aahuff_node*qprev;
 struct _aahuff_node*qnext;
 D prob;
 H c;
 };



 structure
 {
 H code;
 H bits;
 }
 _aahuff_enctable;


 V aa_huffmanWriteTreeAndMakeTable     (BP out,HP outbitctr,H outlen,_aahuff_enctable*et,H code,Y bits,struct _aahuff_node *t);
 B aa_huffmanReadTree                  (BP in,HP inbitctr,H inlen,BP *heapptr,BP heapend,struct _aahuff_node**hnptr);
 H aa_huffmanCompress                  (BP in,H inlen,BP out,H outlen,VP huffheap);
 H aa_huffmanDecompress                (BP in,H inlen,BP out,H outlen,VP huffheap,H hs);


/*-----------------------------------------------------------------------*/


 #define aa_LZ4_compressBound(isize)   (isize+(isize/255)+16)

 // MEMORY_USAGE :
 // Memory usage formula : N->2^N Bytes (examples : 10 -> 1KB; 12 -> 4KB ; 16 -> 64KB; 20 -> 1MB; etc.)
 // Increasing memory usage improves compression ratio
 // Reduced memory usage can improve speed, due to cache effect
 // Default value is 14, for 16KB, which nicely fits into Intel x86

 #define aa_LZ4_MEMORY_USAGE           14
 #define aa_LZ4_NOTCOMPRESSIBLE_DETLEV 6
 #define aa_LZ4_ARCH64                 0

 #define expect(expr,value)            (expr)
 #define likely(expr)                  expect((expr)!=0,1)
 #define unlikely(expr)                expect((expr)!=0,0)

 structure { u16 v; }                  aa_LZ4_U16_S;
 structure { u32 v; }                  aa_LZ4_U32_S;

 #define aa_LZ4_A32(x)                 (((aa_LZ4_U32_S *)(x))->v)
 #define aa_LZ4_A16(x)                 (((aa_LZ4_U16_S *)(x))->v)

 #define aa_LZ4_MINMATCH               4
 #define aa_LZ4_HASH_LOG               (aa_LZ4_MEMORY_USAGE-2)
 #define aa_LZ4_HASHTABLESIZE          (1<<aa_LZ4_HASH_LOG)
 #define aa_LZ4_HASH_MASK              (aa_LZ4_HASHTABLESIZE-1)

 #define aa_LZ4_SKIPSTRENGTH           (aa_LZ4_NOTCOMPRESSIBLE_DETLEV>2?aa_LZ4_NOTCOMPRESSIBLE_DETLEV:2)
 #define aa_LZ4_STACKLIMIT             13
 #define aa_LZ4_HEAPMODE               (aa_LZ4_HASH_LOG>aa_LZ4_STACKLIMIT)
 #define aa_LZ4_COPYLENGTH             8
 #define aa_LZ4_LASTLITERALS           5
 #define aa_LZ4_MFLIMIT                (aa_LZ4_COPYLENGTH+aa_LZ4_MINMATCH)
 #define aa_LZ4_MINLENGTH              (aa_LZ4_MFLIMIT+1)

 #define aa_LZ4_MAXD_LOG               16
 #define aa_LZ4_MAX_DISTANCE           ((1<<aa_LZ4_MAXD_LOG)-1)

 #define aa_LZ4_ML_BITS                4
 #define aa_LZ4_ML_MASK                ((1U<<aa_LZ4_ML_BITS)-1)
 #define aa_LZ4_RUN_BITS               (8-aa_LZ4_ML_BITS)
 #define aa_LZ4_RUN_MASK               ((1U<<aa_LZ4_RUN_BITS)-1)

 #define aa_LZ4_STEPSIZE               4
 #define aa_LZ4_UARCH                  u32
 #define aa_LZ4_AARCH                  aa_LZ4_A32
 #define aa_LZ4_COPYSTEP(s,d)	aa_LZ4_A32(d)=aa_LZ4_A32(s); d+=4; s+=4;
 #define aa_LZ4_COPYPACKET(s,d)	aa_LZ4_COPYSTEP(s,d); aa_LZ4_COPYSTEP(s,d);
 #define aa_LZ4_SECURECOPY	aa_LZ4_WILDCOPY
 #define aa_LZ4_INITBASE(base)         const int base=0

 #define aa_LZ4_READ_LE_16(d,s,p)      { d=(s)-aa_LZ4_A16(p); }
 #define aa_LZ4_WRITE_LE_16(p,v)       { aa_LZ4_A16(p)=v; p+=2; }

 #define aa_LZ4_HASH_FUNCTION(i)	(((i)*2654435761U)>>((aa_LZ4_MINMATCH*8)-aa_LZ4_HASH_LOG))
 #define aa_LZ4_HASH_VALUE(p)	aa_LZ4_HASH_FUNCTION(aa_LZ4_A32(p))
 #define aa_LZ4_WILDCOPY(s,d,e)	do { aa_LZ4_COPYPACKET(s,d) } while (d<e);
 #define aa_LZ4_BLINDCOPY(s,d,l)	{ BP e=(d)+l; aa_LZ4_WILDCOPY(s,d,e); d=e; }

 #define aa_LZ4_64KLIMIT               ((1<<16)+(aa_LZ4_MFLIMIT-1))
 #define aa_LZ4_HASHLOG64K             (aa_LZ4_HASH_LOG+1)
 #define aa_LZ4_HASH64KTABLESIZE       (1U<<aa_LZ4_HASHLOG64K)
 #define aa_LZ4_HASH64K_FUNCTION(i)	(((i)*2654435761U)>>((aa_LZ4_MINMATCH*8)-aa_LZ4_HASHLOG64K))
 #define aa_LZ4_HASH64K_VALUE(p)	aa_LZ4_HASH64K_FUNCTION(aa_LZ4_A32(p))


 Z aa_LZ4_compressCtx                  (PP ctx,VP source,VP dest,Z isize,Z maxOutputSize);
 Z aa_LZ4_compress64kCtx               (PP ctx,VP source,VP dest,Z isize,Z maxOutputSize);
 Z aa_LZ4_uncompressEx                 (VP source,VP dest,Z osize);


/*-----------------------------------------------------------------------*/

 Z aa_LZ4_compressCtx                  (PP ctx,VP source,VP dest,Z isize,Z maxOutputSize)
 {
 BP HashTable[aa_LZ4_HASHTABLESIZE]={0};
 BP ip=(BP) source;
 aa_LZ4_INITBASE(base);
 BP anchor=ip;
 BP iend=ip+isize;
 BP mflimit=iend-aa_LZ4_MFLIMIT;
 BP op=(BP)dest;
 BP oend=op+maxOutputSize;
 BP forwardIp,ref,token;
 BP src,dst;
 Z step,findMatchAttempts,lastRun,len,length,skipStrength=aa_LZ4_SKIPSTRENGTH;
 u32 forwardH,h;

 src=(BP)source;
 dst=(BP)dest;
 if(isize<aa_LZ4_MINLENGTH) goto _last_literals;
 (V)ctx;
 HashTable[aa_LZ4_HASH_VALUE(ip)]=ip-base;
 ip++; forwardH=aa_LZ4_HASH_VALUE(ip);
 for(;;)
  {
  findMatchAttempts=(1U<<skipStrength)+3;
  forwardIp=ip;
  do
   {
   h=forwardH;
   step=findMatchAttempts++>>skipStrength;
   ip=forwardIp;
   forwardIp=ip+step;
   if unlikely(forwardIp>mflimit) { goto _last_literals; }
   forwardH=aa_LZ4_HASH_VALUE(forwardIp);
   ref=base+HashTable[h];
   HashTable[h]=ip-base;
   }
  while((ref<ip-aa_LZ4_MAX_DISTANCE)||(aa_LZ4_A32(ref)!=aa_LZ4_A32(ip)));
  while((ip>anchor)&&(ref>(BP)src)&&unlikely(ip[-1]==ref[-1])) { ip--; ref--; }
  length=ip-anchor;
  token=op++;
  if unlikely(op+length+(2+1+aa_LZ4_LASTLITERALS)+(length>>8)>=oend) return 0;
  if(length>=(Z)aa_LZ4_RUN_MASK)
   {
   *token=(aa_LZ4_RUN_MASK<<aa_LZ4_ML_BITS);
   len=length-aa_LZ4_RUN_MASK;
   for(;len>254;len-=255) *op++=255;
   *op++=(B)len;
   }
  else *token=(length<<aa_LZ4_ML_BITS);
  aa_LZ4_BLINDCOPY(anchor,op,length);
_next_match:
 aa_LZ4_WRITE_LE_16(op,ip-ref);
 ip+=aa_LZ4_MINMATCH;ref+=aa_LZ4_MINMATCH;
 anchor=ip;
 while likely(ip<(iend-aa_LZ4_LASTLITERALS)-(aa_LZ4_STEPSIZE-1))
  {
  aa_LZ4_UARCH diff=aa_LZ4_AARCH(ref)^aa_LZ4_AARCH(ip);
  if(!diff) { ip+=aa_LZ4_STEPSIZE; ref+=aa_LZ4_STEPSIZE; continue; }
  ip+=(__builtin_ctz(diff)>>3);
  goto _endCount;
  }
 if(aa_LZ4_ARCH64)
  {
  if((ip<((iend-aa_LZ4_LASTLITERALS)-3))&&(aa_LZ4_A32(ref)==aa_LZ4_A32(ip))) { ip+=4; ref+=4; }
  }
 if((ip<((iend-aa_LZ4_LASTLITERALS)-1))&&(aa_LZ4_A16(ref)==aa_LZ4_A16(ip))) { ip+=2; ref+=2; }
 if((ip<(iend-aa_LZ4_LASTLITERALS))&&(*ref==*ip)) ip++;
 _endCount:
 len=(ip-anchor);
 if(len>=(Z)aa_LZ4_ML_MASK)
  {
  *token+=aa_LZ4_ML_MASK;
  len-=aa_LZ4_ML_MASK;
  for(;len>509; len-=510) { *op++=255; *op++=255; }
  if(len>254) { len-=255; *op++=255; }
  *op++=(B)len;
  }
 else *token+=len;
 if(ip>mflimit) { anchor=ip;  break; }
 HashTable[aa_LZ4_HASH_VALUE(ip-2)]=ip-2-base;
 ref=base+HashTable[aa_LZ4_HASH_VALUE(ip)];
 HashTable[aa_LZ4_HASH_VALUE(ip)]=ip-base;
 if((ref>ip-(aa_LZ4_MAX_DISTANCE+1))&&(aa_LZ4_A32(ref)==aa_LZ4_A32(ip))) { token=op++; *token=0;goto _next_match; }
 anchor=ip++;
 forwardH=aa_LZ4_HASH_VALUE(ip);
 }
 _last_literals:
  {
  lastRun=iend-anchor;
  if(((BP)op-dst)+lastRun+1+((lastRun-15)/255)>=maxOutputSize) return 0;
  if(lastRun>=(Z)aa_LZ4_RUN_MASK)
   {
   *op++=(aa_LZ4_RUN_MASK<<aa_LZ4_ML_BITS);
   lastRun-=aa_LZ4_RUN_MASK;
   for(;lastRun>254;lastRun-=255) *op++=255;
   *op++=(B)lastRun;
   }
  else *op++=(lastRun<<aa_LZ4_ML_BITS);
  aaMemoryCopy(op,iend-anchor,anchor);
  op+=iend-anchor;
  }
 return (Z)(((BP)op)-dst);
 }









 Z aa_LZ4_compress64kCtx               (PP ctx,VP source,VP dest,Z isize,Z maxOutputSize)
 {
 u16 HashTable[aa_LZ4_HASH64KTABLESIZE]={0};
 BP ip=(BP) source;
 BP anchor=ip;
 BP base=ip;
 BP iend=ip+isize;
 BP mflimit=iend-aa_LZ4_MFLIMIT;
 BP op=(BP)dest;
 BP oend=op+maxOutputSize;
 Z lastRun,step,len,length,findMatchAttempts,skipStrength=aa_LZ4_SKIPSTRENGTH;
 BP ref,token,forwardIp;
 BP src,dst;
 u32 forwardH,h;

 src=(BP)source;
 dst=(BP)dest;
 if(isize<aa_LZ4_MINLENGTH) goto _last_literals;
 (V)ctx;
 ip++; forwardH=aa_LZ4_HASH64K_VALUE(ip);
 for(;;)
  {
  findMatchAttempts=(1U<<skipStrength)+3;
  forwardIp=ip;
  do
   {
   h=forwardH;
   step=findMatchAttempts++>>skipStrength;
   ip=forwardIp;
   forwardIp=ip+step;
   if(forwardIp>mflimit) { goto _last_literals; }
   forwardH=aa_LZ4_HASH64K_VALUE(forwardIp);
   ref=base+HashTable[h];
   HashTable[h]=ip-base;
   }
  while(aa_LZ4_A32(ref)!=aa_LZ4_A32(ip));
  while((ip>anchor)&&(ref>(BP)src)&&(ip[-1]==ref[-1])) { ip--; ref--; }
  length=ip-anchor;
  token=op++;
  if unlikely(op+length+(2+1+aa_LZ4_LASTLITERALS)+(length>>8)>=oend) return 0;
  if(length>=(Z)aa_LZ4_RUN_MASK)
   {
   *token=(aa_LZ4_RUN_MASK<<aa_LZ4_ML_BITS);
   len=length-aa_LZ4_RUN_MASK;
   for(; len>254; len-=255) *op++=255; *op++=(B)len;
   }
  else *token=(length<<aa_LZ4_ML_BITS);
  aa_LZ4_BLINDCOPY(anchor,op,length);
 _next_match:
  aa_LZ4_WRITE_LE_16(op,ip-ref);
  ip+=aa_LZ4_MINMATCH; ref+=aa_LZ4_MINMATCH;
  anchor=ip;
  while(ip<(iend-aa_LZ4_LASTLITERALS)-(aa_LZ4_STEPSIZE-1))
   {
   aa_LZ4_UARCH diff=aa_LZ4_AARCH(ref)^aa_LZ4_AARCH(ip);
   if(!diff) { ip+=aa_LZ4_STEPSIZE; ref+=aa_LZ4_STEPSIZE; continue; }
   ip+=(__builtin_ctz(diff)>>3);
   goto _endCount;
   }
  if(aa_LZ4_ARCH64)
   {
   if((ip<((iend-aa_LZ4_LASTLITERALS)-3))&&(aa_LZ4_A32(ref)==aa_LZ4_A32(ip))) { ip+=4; ref+=4; }
   }
  if((ip<((iend-aa_LZ4_LASTLITERALS)-1))&&(aa_LZ4_A16(ref)==aa_LZ4_A16(ip))) { ip+=2; ref+=2; }
  if((ip<(iend-aa_LZ4_LASTLITERALS))&&(*ref==*ip)) ip++;
 _endCount:
 len=(ip-anchor);
 if(len>=(Z)aa_LZ4_ML_MASK)
  {
  *token+=aa_LZ4_ML_MASK;
  len-=aa_LZ4_ML_MASK;
  for(; len>509; len-=510) { *op++=255; *op++=255; }
  if(len>254) { len-=255; *op++=255; }
  *op++=(B)len;
  }
 else *token+=len;
 if(ip>mflimit) { anchor=ip;  break; }
 HashTable[aa_LZ4_HASH64K_VALUE(ip-2)]=ip-2-base;
 ref=base+HashTable[aa_LZ4_HASH64K_VALUE(ip)];
 HashTable[aa_LZ4_HASH64K_VALUE(ip)]=ip-base;
 if(aa_LZ4_A32(ref)==aa_LZ4_A32(ip)) { token=op++; *token=0;goto _next_match; }
 anchor=ip++;
 forwardH=aa_LZ4_HASH64K_VALUE(ip);
 }
 _last_literals:
  {
  lastRun=iend-anchor;
  if(((BP)op-dst)+lastRun+1+((lastRun)>>8)>=maxOutputSize) return 0;
  if(lastRun>=(Z)aa_LZ4_RUN_MASK)
   {
   *op++=(aa_LZ4_RUN_MASK<<aa_LZ4_ML_BITS);
   lastRun-=aa_LZ4_RUN_MASK;
   for(; lastRun>254; lastRun-=255) *op++=255;
   *op++=(B)lastRun;
   }
  else *op++=(lastRun<<aa_LZ4_ML_BITS);
  aaMemoryCopy(op,iend-anchor,anchor);
  op+=iend-anchor;
  }
 return (Z)(((BP)op)-dst);
 }






 Z aa_LZ4_uncompressEx                 (VP source,VP dest,Z osize)
 {
 BP ip=(BP)source;
 BP op=(BP)dest;
 BP oend=op+osize;
 BP ref,cpy;
 B token;
 Z len,length,dec2;
 BP src,dst;
 size_t dec[]={0,3,2,3,0,0,0,0};

 src=(BP)source;
 dst=(BP)dest;
 while(1)
  {
  token=*ip++;
  if((length=(token>>aa_LZ4_ML_BITS))==aa_LZ4_RUN_MASK)  { for(;(len=*ip++)==255;length+=255){} length+=len; }
  cpy=op+length;
  if unlikely(cpy>oend-aa_LZ4_COPYLENGTH)
   {
   if(cpy>oend) goto _output_error;
   aaMemoryCopy(op,length,ip);
   ip+=length;
   break;
   }
  aa_LZ4_WILDCOPY(ip,op,cpy); ip-=(op-cpy); op=cpy;
  aa_LZ4_READ_LE_16(ref,cpy,ip); ip+=2;
  if(ref<(BP)dst) goto _output_error;
  if((length=(token&aa_LZ4_ML_MASK))==aa_LZ4_ML_MASK) { for(;*ip==255;length+=255) {ip++;} length+=*ip++; }
  if unlikely(op-ref<aa_LZ4_STEPSIZE)
   {
   dec2=0;
   *op++=*ref++;  *op++=*ref++; *op++=*ref++; *op++=*ref++;
   ref-=dec[op-ref];
   aa_LZ4_A32(op)=aa_LZ4_A32(ref); op+=aa_LZ4_STEPSIZE-4;
   ref-=dec2;
   }
  else
   {
   aa_LZ4_COPYSTEP(ref,op);
   }
  cpy=op+length-(aa_LZ4_STEPSIZE-4);
  if(cpy>oend-aa_LZ4_COPYLENGTH)
   {
   if(cpy>oend) goto _output_error;
   aa_LZ4_SECURECOPY(ref,op,(oend-aa_LZ4_COPYLENGTH));
   while(op<cpy) *op++=*ref++;
   op=cpy;
   if(op==oend) break;
   continue;
   }
  aa_LZ4_SECURECOPY(ref,op,cpy);
  op=cpy;
  }
 return (Z)(((BP)ip)-src);
_output_error:
 return (Z)(-(((BP)ip)-src));
 }


/*-----------------------------------------------------------------------*/

 B aa_Base64Char[64]=                  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

 C aa_chartype[128]=                   {
                                       // NUL SOH STX ETX EOT ENQ ACK BEL  BS  HT  LF  VT  FF  CR  SO  SI
                                           0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 32, 32, 32, 32, 32, 1 , 1 ,
                                       // DLE DC1 DC2 DC3 DC4 NAK SYN ETB CAN  EM SUB ESC  FS  GS  RS  US
                                           1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ,
                                       // SP   !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
                                           32, 1 , 1 , 1 , 1 , 3 , 1 , 1 , 1 , 1 , 7 , 1 , 1 , 1 , 1 , 1 ,
                                       //  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
                                           9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 1 , 1 , 1 , 1 , 1 , 1 ,
                                       //  @   A   B   C   D   E   F   G   H   I   J   K   N   M   N   O
                                           1 , 1 , 1 , 1 , 19, 26, 77, 26, 51, 96, 1 , 1 , 48, 1 , 44, 66,
                                       //  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
                                           1 , 1 , 1 , 1 , 1 , 80, 1 , 1 , 30, 1 , 1 , 95, 1 , 95, 1 , 1 ,
                                       //  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
                                           1 , 1 , 1 , 98, 19, 26, 26, 26, 51, 96, 1 , 1 , 22, 1 , 11,66 ,
                                       //  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~  DEL
                                           59, 1 , 1 , 4 , 1 , 80, 1 , 1 , 30, 1 , 1 , 1 , 1 , 1 , 1 , 1 ,
                                       };




/*-----------------------------------------------------------------------*/

 #define aa_NET_RECENT_FREQ            1.0
 #define aa_NET_CLIENT_CALL_MAXEXTRA   _512K
 #define aa_NET_CGI_CLIENT_MAXBUF      _8K
 #define aa_NET_SOMAXCONN              1024
 #define aa_NET_MAX_DNS_OBJECTS        2048
 #define aa_NET_MAX_UDP_OBJECTS        _32K
 #define aa_NET_MAX_TCP_CALLS          _64K
 #define aa_NET_MAX_TCP_PORTS          _2K


 S CP aa_mime_type[64][2]=
 {
 { "c",    "text/x-csrc" },
 { "c++",  "text/x-c++src" },
 { "cpp",  "text/x-c++src" },
 { "h",    "text/x-chdr" },
 { "hpp",  "text/x-chdr" },
 { "html", "text/html" },
 { "htm",  "text/html" },
 { "js",   "application/javascript" },
 { "shtml","text/html" },
 { "css",  "text/css" },
 { "txt",  "text/plain" },
 { "pl",   "text/plain" },
 { "php",  "text/html" },
 { "mdb",  "application/msaccess" },
 { "xls",  "application/msexcel" },
 { "doc",  "application/msword" },
 { "bin",  "application/octet-stream" },
 { "exe",  "application/octet-stream" },
 { "exe",  "application/x-msdownload" },
 { "ogg",  "application/ogg" },
 { "pdf",  "application/pdf" },
 { "rtf",  "application/rtf" },
 { "tgz",  "application/x-compressed" },
 { "gz",   "application/x-compressed" },
 { "z",    "application/x-compress" },
 { "swf",  "application/x-shockwave-flash" },
 { "tar",  "application/x-tar" },
 { "rar",  "application/x-rar-compressed" },
 { "zip",  "application/x-zip-compressed" },
 { "xml",  "application/xml" },
 { "ra",   "audio/x-pn-realaudio" },
 { "ram",  "audio/x-pn-realaudio" },
 { "wav",  "audio/x-wav" },
 { "bmp",  "image/bmp"},
 { "tif",  "image/tiff"},
 { "tiff", "image/tiff"},
 { "gif",  "image/gif" },
 { "jpeg", "image/jpeg" },
 { "jpe",  "image/jpeg" },
 { "jpg",  "image/jpeg" },
 { "png",  "image/png" },
 { "ico",  "image/x-icon" },
 { "wav",  "audio/x-wav"},
 { "mid",  "audio/mid"},
 { "aif",  "audio/x-aif"},
 { "aiff", "audio/x-aiff"},
 { "avi",  "video/avi" },
 { "mp3",  "video/mpeg" },
 { "mpeg", "video/mpeg" },
 { "mpg",  "video/mpeg" },
 { "flv",  "video/x-flv" },
 { "avi",  "video/x-msvideo" },
 { "qt",   "video/quicktime" },
 { "mov",  "video/quicktime" },
 { "",     "" }
 };


/*-----------------------------------------------------------------------*/


 #ifndef SO_EXCLUSIVEADDRUSE
 #define SO_EXCLUSIVEADDRUSE           ((Z)(~SO_REUSEADDR))
 #endif


 #define T_A                           1
 #define T_NS                          2
 #define T_CNAME                       5
 #define T_SOA                         6
 #define T_WKS                         11
 #define T_PTR                         12
 #define T_MX                          15
 #define T_TXT                         16
 #define T_ALL                         255


 structure
 {
 u16 id;
 u8 rd     :1;
 u8 tc     :1;
 u8 aa     :1;
 u8 opcode :4;
 u8 qr     :1;
 u8 rcode  :4;
 u8 cd     :1;
 u8 ad     :1;
 u8 z      :1;
 u8 ra     :1;
 u16 q_count;
 u16 ans_count;
 u16 auth_count;
 u16 add_count;
 }
 _DNS_HEADER;


 structure
 {
 u16 qtype;
 u16 qclass;
 }
 _DNS_QUESTION;


 structure
 {
 u16 type;
 u16 _class;
 u32 ttl;
 u16 data_len;
 }
 _DNS_R_DATA;



 structure
 {
 B name[_1K];
 _DNS_R_DATA*resource;
 H rdata_off;
 B rdata[_1K];
 Z pref;
 }
 _DNS_RES_RECORD;



 structure
 {
 B mname[_1K];
 B rname[_1K];
 H serial;
 H refresh;
 H retry;
 H expire;
 H minimum;
 }
 _DNS_SOA;




 structure
 {
 H self_handle;
 H stage;
 HANDLE resolver_handle;
 B host_ent[MAXGETHOSTSTRUCT];
 _dnsstatus status;
 _udpunit udp;
 _udppkt o_pkt;
 _udppkt i_pkt;
 H ms_tik;
 W id_match;
 _timer tm;
 H timeout;
 B buf[65536];
 B dnsName[_1K];
 H dnsName_sl;
 H outlen;
 _DNS_RES_RECORD answers[20],auth[20],addit[20];
 }
 _aa_netdnsobject;



 structure
 {
 H self_handle;
 _sniffstatus status;
 H rcve_que;
 SOCKET sock;
 H ms_root;
 H inactive_ms_root;
 H calc_timer_cycle;
 }
 _aa_netsniffobject;





 structure
 {
 H self_handle;
 _icmpstatus status;
 H rcve_que;
 H xmit_que;
 SOCKET sock;
 H ms_root;
 H inactive_ms_root;
 H calc_timer_cycle;
 }
 _aa_neticmpobject;



 structure
 {
 H self_handle;
 _udpstatus status;
 H rcve_que;
 H xmit_que;
 SOCKET sock;
 H ms_root;
 H cycle;
 H inactive_ms_root;
 H rcve_pkts_total_recent;
 H xmit_pkts_total_recent;
 H rcve_bytes_total_recent;
 H xmit_bytes_total_recent;
 H rcve_pkts_total_previous;
 H xmit_pkts_total_previous;
 H rcve_bytes_total_previous;
 H xmit_bytes_total_previous;
 _profiler recent_profiler;
 _profiler xmit_profiler;
 _profiler xmit_profiler_direct;
 H last_total_pkts_sent;
 H calc_timer_cycle;
 H sub_tik;
 B user_data[256];
 }
 _aa_netudpobject;



 structure
 {
 H self_handle;
 H stage;
 _stunclientstatus status;
 H root_ms;
 H attempt;
 _netrtt rtt;
 H test_num;
 B tid[16];
 H udp_handle;
 B is_udp_created;
 }
 _aa_netstunclientobject;





 structure
 {
 H self_handle;
 B socket_used;
 SOCKET sock;
 _tcpportstatus status;
 H next_call_counter;
 H manage_iterator;
 }
 _aa_nettcpportobject;



 structure
 {
 H stage;
 _memoryunit in;
 H p_off;
 }
 _aa_nettcpcalltls;



 structure
 {
 H self_handle;
 B socket_used;
 B is_shutdown;
 B is_dns;
 H dns_handle;
 SOCKET sock;
 SOCKET port_sock;
 H xmit_que;
 H rcve_que;
 H ms_root;
 H inactive_rcve_ms_root;
 H inactive_xmit_ms_root;
 H local_closed_ms_root;
 H remote_closed_ms_root;
 B user_data[256];
 _tcpcallstatus status;
 B crlf_state;
 H line_peek_offset;
 H line_chars;
 B is_rcve_backoff;
 B is_xmit_backoff;
 B is_xmit_slowdown;
 _aa_nettcpcalltls tlssys;
 B system_data[256];
 }
 _aa_nettcpcallobject;



 structure
 {
 Y syn:1;
 Y ack:1;
 Y eak:1;
 Y rst:1;
 Y nul:1;
 Y chk:1;
 Y tcs:1;
 Y zer:1;
 Y hlen:8;
 B seq_num;
 B ack_num;
 W crc;
 }
 _aa_netrudpheader;



 structure
 {
 Y csrc_count:4;
 Y extension:1;
 Y padding:1;
 Y version:2;
 Y type:7;
 Y marker:1;
 W seq;
 H timestamp;
 H ssrc;
 }
 _aa_netrtpheader;




 structure
 {
 B vihl;
 B tos;
 I totlen;
 I id;
 I flagoff;
 B ttl;
 B protocol;
 W checksum;
 struct in_addr src_ip;
 struct in_addr dst_ip;
 }
 _aa_netipheader;



 structure
 {
 B type;
 B code;
 W crc;
 W id;
 W seq;
 }
 _aa_neticmpheader;



 structure
 {
 B is_open;
 HINSTANCE module_handle;
 H (WINAPI*GetTcpTable) (MIB_TCPTABLE*pTcpTable,PDWORD dwsize,BOOL order);
 H (WINAPI*GetUdpTable) (MIB_UDPTABLE*pTcpTable,PDWORD dwsize,BOOL order);
 _netportlist list;
 H u_len;
 H t_len;
 BP mem;
 }
 _aa_netportlist;



 structure
 {
 H self_handle;
 _cgiclientstatus status;
 PROCESS_INFORMATION pi;
 STARTUPINFO si;
 B is_running;
 //_threadunit thread;
 H obj_handle;
 HANDLE out_read;
 HANDLE in_write;
 HANDLE std_input;
 HANDLE err_handle;
 H tid;
 _queunit c2s_que;
 _queunit s2c_que;
 H ms_root;
 H inactive_rcve_ms_root;
 H inactive_xmit_ms_root;
 H inactive_line_ms_root;
 H tmp_cy;
 }
 _aa_netcgiclientobject;



 structure
 {
 H self_handle;
 _serverstatus status;
 }
 _aa_netserverobject;





 structure
 {
 WSADATA ws_data;
 H sniff_message_id;
 H icmp_message_id;
 H dns_message_id;
 H tcp_message_id;
 C class_name[257];
 WNDCLASSEX class_data;
 HWND window;
 B dns_object_id;
 B sniff_object_id;
 B icmp_object_id;
 B udp_object_id;
 B stunclient_object_id;
 B tcpport_object_id;
 B tcpcall_object_id;
 B client_object_id;
 B cgiclient_object_id;
 B server_object_id;
 H next_public_ip_counter;
 H next_tcpcall_counter;
 H next_clientcall_counter;
 H yield_tcpcall_counter;
 H yield_udp_counter;
 B local_email_checked;
 B local_email_count;
 B local_email[4][65];
 _netstatus net_status;
 _udppkt tmp_udp_pkt;
 B tmpbuf[70000];
 _aa_netportlist port_list;
 //H sub_yield_tik[3];
 _list dns_cache;
 }
 _aa_netsystem;



 B aa_NetSystemStart                   (V);
 V aa_NetSystemStop                    (V);
 B aa_NetSystemLocalEmailCheck         (V);
 B aa_NetSystemResolveIpPortPair       (SOCKET sock,HP locip,WP locport,HP remip,WP remport);
 B aa_NetSystemFindDnsByResolverHandle (HP handle,PP mem,HANDLE resolverhandle);
 B aa_NetSystemFindSniffBySock         (HP handle,PP mem,SOCKET sock);
 B aa_NetSystemFindIcmpBySock          (HP handle,PP mem,SOCKET sock);
 B aa_NetSystemFindPortBySock          (HP handle,PP mem,SOCKET sock);
 B aa_NetSystemFSystemFindCallBySock   (HP handle,PP mem,SOCKET sock,B mustbeincall,B mustbeoutcall);
 B aa_NetSystemFindCallByPortSock      (HP handle,PP mem,SOCKET sock);
 B aa_NetSystemFindUdpByAddress        (HP handle,PP mem,H ip,W port);
 B aa_NetSystemLocalHostGet            (HP localip,H count);
 B aa_NetSystemTcpCallCreate           (HP handle,H ip,W port,H sip,W sport);
 B aa_NetSystemNextTcpCall             (HP handle,PP ptr,W matchport,HP iterationcounter);
 B aa_NetSystemProcessTcp              (PP mem);
 B aa_NetSystemCalculateUdpTimers      (PP mem);
 B aa_NetSystemProcessUdp              (PP mem);
 B aa_NetSystemProcessSniff            (PP mem);
 B aa_NetSystemProcessIcmp             (PP mem,B doread,B dowrite);
 K aa_NetSystemProc                    (HWND wnd,UINT msg,WPARAM wparm,LPARAM lparm);
 B aa_NetSystemYield                   (V);
 B aa_NetCgiClientUpdate               (H handle);
 B aa_NetCgiClientPseudoThread         (H handle);
 V aa_NetDnsYield                      (PP mem);
 V aa_NetDnsFromFormat                 (VP outhost);
 V aa_NetDnsToFormat                   (VP outdns);
 V aa_NetDnsReadName                   (BP reader,BP buffer,ZP count,BP name);
 B aa_NetTls2201Write                  (PP obtr);
 B aa_NetTlsYield                      (PP obtr);


/*-----------------------------------------------------------------------*/


 B aa_fontdos[2048]=
 {
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3c,0x42,0xa5,0x81,0xa5,0x99,0x42,0x3c,0x3c,0x7e,0xdb,0xff,0xdb,0xe7,0x7e,0x3c,0x6c,0xfe,0xfe,0xfe,0x7c,0x38,0x10,0x00,
 0x10,0x38,0x7c,0xfe,0x7c,0x38,0x10,0x00,0x38,0x38,0xd6,0xfe,0xd6,0x10,0x38,0x00,0x10,0x38,0x7c,0xfe,0x7c,0x10,0x38,0x00,0x00,0x00,0x18,0x3c,0x3c,0x18,0x00,0x00,
 0xff,0xff,0xe7,0xc3,0xc3,0xe7,0xff,0xff,0x00,0x3c,0x66,0x42,0x42,0x66,0x3c,0x00,0xff,0xc3,0x99,0xbd,0xbd,0x99,0xc3,0xff,0xf0,0xc0,0xa0,0x9e,0x1b,0x1b,0x0e,0x00,
 0x3c,0x66,0x66,0x3c,0x18,0x7e,0x18,0x00,0x10,0x30,0x70,0x50,0x10,0x18,0x1c,0x0c,0xfc,0x84,0xfc,0x84,0xc4,0xe6,0x67,0x03,0x10,0xd6,0x38,0xee,0x38,0xd6,0x10,0x00,
 0x01,0x07,0x1f,0x7f,0x1f,0x07,0x01,0x00,0x80,0xe0,0xf8,0xfe,0xf8,0xe0,0x80,0x00,0x10,0x38,0x7c,0x10,0x7c,0x38,0x10,0x00,0x66,0x66,0x66,0x66,0x66,0x00,0x66,0x00,
 0xfe,0xdb,0xdb,0xde,0xd8,0xd8,0xd8,0x00,0x7c,0xc6,0x1c,0x64,0x4c,0x70,0xc6,0x7c,0x00,0x00,0x00,0x00,0x7e,0x7e,0x7e,0x00,0x18,0x3c,0x7e,0x18,0x7e,0x3c,0x18,0x7e,
 0x18,0x3c,0x7e,0x18,0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x18,0x7e,0x3c,0x18,0x00,0x00,0x20,0x60,0xfe,0x60,0x20,0x00,0x00,0x00,0x08,0x0c,0xfe,0x0c,0x08,0x00,0x00,
 0x00,0x00,0x06,0x06,0x06,0xfe,0x00,0x00,0x00,0x24,0x66,0xff,0x66,0x24,0x00,0x00,0x00,0x00,0x10,0x38,0x7c,0xfe,0x00,0x00,0x00,0x00,0xfe,0x7c,0x38,0x10,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x3c,0x3c,0x18,0x18,0x00,0x18,0x00,0x6c,0x6c,0x6c,0x00,0x00,0x00,0x00,0x00,0x6c,0x6c,0xfe,0x6c,0xfe,0x6c,0x6c,0x00,
 0x10,0x7c,0x16,0x7c,0xd0,0x7c,0x10,0x00,0x86,0xc6,0x60,0x30,0x18,0xcc,0xc6,0x00,0x38,0x6c,0x38,0x9c,0x76,0x66,0xdc,0x00,0x30,0x30,0x18,0x00,0x00,0x00,0x00,0x00,
 0x30,0x18,0x0c,0x0c,0x0c,0x18,0x30,0x00,0x18,0x30,0x60,0x60,0x60,0x30,0x18,0x00,0x00,0x24,0x18,0x7e,0x18,0x24,0x00,0x00,0x00,0x18,0x18,0x7e,0x18,0x18,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x0c,0x00,0x00,0x00,0x7e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x80,0xc0,0x60,0x30,0x18,0x0c,0x06,0x00,
 0x7c,0xc6,0xd6,0xd6,0xd6,0xc6,0x7c,0x00,0x30,0x38,0x3c,0x30,0x30,0x30,0xfc,0x00,0x3c,0x66,0x60,0x30,0x18,0x0c,0x7e,0x00,0x3c,0x66,0x60,0x38,0x60,0x66,0x3c,0x00,
 0x60,0x70,0x78,0x6c,0xfe,0x60,0x60,0x00,0xfe,0x06,0x7e,0xc0,0xc0,0xc6,0x7c,0x00,0x78,0x0c,0x06,0x7e,0xc6,0xc6,0x7c,0x00,0xfe,0xc6,0x60,0x30,0x18,0x18,0x18,0x00,
 0x7c,0xc6,0xc6,0x7c,0xc6,0xc6,0x7c,0x00,0x7c,0xc6,0xc6,0xfc,0xc0,0x60,0x3c,0x00,0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x0c,
 0x60,0x30,0x18,0x0c,0x18,0x30,0x60,0x00,0x00,0x00,0x7e,0x00,0x00,0x7e,0x00,0x00,0x0c,0x18,0x30,0x60,0x30,0x18,0x0c,0x00,0x3c,0x66,0x30,0x18,0x18,0x00,0x18,0x00,
 0x7c,0xc6,0xf6,0xf6,0xf6,0x06,0xfc,0x00,0x38,0x6c,0xc6,0xc6,0xfe,0xc6,0xc6,0x00,0x7e,0xc6,0xc6,0x7e,0xc6,0xc6,0x7e,0x00,0x7c,0xc6,0x06,0x06,0x06,0xc6,0x7c,0x00,
 0x3e,0x66,0xc6,0xc6,0xc6,0x66,0x3e,0x00,0x7e,0x06,0x06,0x3e,0x06,0x06,0x7e,0x00,0x7e,0x06,0x06,0x3e,0x06,0x06,0x06,0x00,0x7c,0xc6,0x06,0xf6,0xc6,0xc6,0xfc,0x00,
 0xc6,0xc6,0xc6,0xfe,0xc6,0xc6,0xc6,0x00,0x7e,0x18,0x18,0x18,0x18,0x18,0x7e,0x00,0xf0,0x60,0x60,0x60,0x60,0x66,0x3c,0x00,0xc6,0x66,0x36,0x1e,0x36,0x66,0xc6,0x00,
 0x06,0x06,0x06,0x06,0x06,0x06,0xfe,0x00,0xc6,0xee,0xfe,0xd6,0xd6,0xc6,0xc6,0x00,0xc6,0xce,0xde,0xf6,0xe6,0xc6,0xc6,0x00,0x7c,0xc6,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,
 0x7e,0xc6,0xc6,0x7e,0x06,0x06,0x06,0x00,0x7c,0xc6,0xc6,0xc6,0xb6,0x66,0xdc,0x00,0x7e,0xc6,0xc6,0x7e,0x36,0x66,0xc6,0x00,0x7c,0xc6,0x06,0x7c,0xc0,0xc6,0x7c,0x00,
 0xff,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,0xc6,0xc6,0xc6,0x6c,0x6c,0x38,0x38,0x00,0xc6,0xc6,0xd6,0xd6,0xfe,0xee,0xc6,0x00,
 0xc6,0xc6,0x6c,0x38,0x6c,0xc6,0xc6,0x00,0xc3,0xc3,0x66,0x3c,0x18,0x18,0x18,0x00,0xfe,0xc0,0x60,0x38,0x0c,0x06,0xfe,0x00,0x3c,0x0c,0x0c,0x0c,0x0c,0x0c,0x3c,0x00,
 0x03,0x06,0x0c,0x18,0x30,0x60,0xc0,0x00,0x3c,0x30,0x30,0x30,0x30,0x30,0x3c,0x00,0x18,0x3c,0x66,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,
 0x18,0x18,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7c,0xc0,0xfc,0xc6,0xfc,0x00,0x06,0x06,0x76,0xce,0xc6,0xce,0x76,0x00,0x00,0x00,0x7c,0xc6,0x06,0xc6,0x7c,0x00,
 0xc0,0xc0,0xdc,0xe6,0xc6,0xe6,0xdc,0x00,0x00,0x00,0x7c,0xc6,0xfe,0x06,0xfc,0x00,0x70,0xd8,0x18,0x7c,0x18,0x18,0x18,0x00,0x00,0x00,0xdc,0xe6,0xe6,0xdc,0xc0,0x7c,
 0x06,0x06,0x76,0xce,0xc6,0xc6,0xc6,0x00,0x18,0x00,0x1c,0x18,0x18,0x18,0x3c,0x00,0x60,0x00,0x70,0x60,0x60,0x60,0x66,0x3c,0x0c,0x0c,0xcc,0x6c,0x3c,0x6c,0xcc,0x00,
 0x1c,0x18,0x18,0x18,0x18,0x18,0x3c,0x00,0x00,0x00,0x6e,0xd6,0xd6,0xd6,0xd6,0x00,0x00,0x00,0x76,0xce,0xc6,0xc6,0xc6,0x00,0x00,0x00,0x7c,0xc6,0xc6,0xc6,0x7c,0x00,
 0x00,0x00,0x76,0xce,0xce,0x76,0x06,0x06,0x00,0x00,0xdc,0xe6,0xe6,0xdc,0xc0,0xc0,0x00,0x00,0xf6,0x0e,0x06,0x06,0x06,0x00,0x00,0x00,0xfc,0x06,0x7c,0xc0,0x7e,0x00,
 0x18,0x18,0x7c,0x18,0x18,0xd8,0x70,0x00,0x00,0x00,0xc6,0xc6,0xc6,0xe6,0xdc,0x00,0x00,0x00,0xc6,0xc6,0x6c,0x6c,0x38,0x00,0x00,0x00,0xc6,0xd6,0xd6,0xee,0x44,0x00,
 0x00,0x00,0xc6,0x6c,0x38,0x6c,0xc6,0x00,0x00,0x00,0xc6,0xc6,0xe6,0xdc,0xc0,0x7c,0x00,0x00,0xfc,0x60,0x30,0x18,0xfc,0x00,0x70,0x18,0x18,0x0e,0x18,0x18,0x70,0x00,
 0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x00,0x0e,0x18,0x18,0x70,0x18,0x18,0x0e,0x00,0xdc,0x76,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x38,0x6c,0xc6,0xc6,0xfe,0x00,0x00,
 0x78,0xcc,0x06,0x06,0xcc,0x38,0x60,0x38,0x6c,0x00,0xc6,0xc6,0xc6,0xe6,0xdc,0x00,0xf0,0x00,0x7c,0xc6,0xfe,0x06,0xfc,0x00,0x7c,0x82,0x7c,0xc0,0xfc,0xc6,0xfc,0x00,
 0x6c,0x00,0x7c,0xc0,0xfc,0xc6,0xfc,0x00,0x1e,0x00,0x7c,0xc0,0xfc,0xc6,0xfc,0x00,0x38,0x28,0x7c,0xc0,0xfc,0xc6,0xfc,0x00,0x00,0x00,0x7c,0x06,0x06,0x7c,0x30,0x18,
 0x7c,0x82,0x7c,0xc6,0xfe,0x06,0xfc,0x00,0x6c,0x00,0x7c,0xc6,0xfe,0x06,0xfc,0x00,0x1e,0x00,0x7c,0xc6,0xfe,0x06,0xfc,0x00,0x6c,0x00,0x38,0x30,0x30,0x30,0x78,0x00,
 0x7c,0xc6,0x38,0x30,0x30,0x30,0x78,0x00,0x1c,0x00,0x38,0x30,0x30,0x30,0x78,0x00,0xc6,0x38,0x6c,0xc6,0xfe,0xc6,0xc6,0x00,0x38,0x6c,0x38,0x6c,0xc6,0xfe,0xc6,0x00,
 0xf0,0x00,0xfc,0x0c,0x7c,0x0c,0xfc,0x00,0x00,0x00,0x76,0xd8,0xfe,0x1b,0xfe,0x00,0xf8,0x3c,0x36,0xfe,0x36,0x36,0xf6,0x00,0x7c,0x82,0x7c,0xc6,0xc6,0xc6,0x7c,0x00,
 0x6c,0x00,0x7c,0xc6,0xc6,0xc6,0x7c,0x00,0x1e,0x00,0x7c,0xc6,0xc6,0xc6,0x7c,0x00,0x7c,0x82,0x00,0xc6,0xc6,0xe6,0xdc,0x00,0x1e,0x00,0xc6,0xc6,0xc6,0xe6,0xdc,0x00,
 0x6c,0x00,0xc6,0xc6,0xe6,0xdc,0xc0,0x7c,0xc6,0x7c,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,0x6c,0x00,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,0x30,0x30,0xfc,0x06,0x06,0xfc,0x30,0x30,
 0x38,0x6c,0x0c,0x1e,0x0c,0xce,0x7e,0x00,0x66,0x66,0x3c,0x18,0x7e,0x18,0x7e,0x18,0x3e,0x66,0x66,0x1e,0x66,0xf6,0x66,0xe6,0x70,0xd8,0x18,0x7c,0x18,0x18,0x1b,0x0e,
 0xf0,0x00,0x7c,0xc0,0xfc,0xc6,0xfc,0x00,0xf0,0x00,0x38,0x30,0x30,0x30,0x78,0x00,0xf0,0x00,0x7c,0xc6,0xc6,0xc6,0x7c,0x00,0xf0,0x00,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,
 0xdc,0x76,0x00,0x76,0xce,0xc6,0xc6,0x00,0xdc,0x76,0xce,0xde,0xf6,0xe6,0xc6,0x00,0x3c,0x36,0x36,0x6c,0x00,0x7e,0x00,0x00,0x3c,0x66,0x66,0x3c,0x00,0x7e,0x00,0x00,
 0x18,0x00,0x18/0x18,0x0c,0x66,0x3c,0x00,0x00,0x00,0x00,0x7e,0x06,0x06,0x00,0x00,0x00,0x00,0x00,0x7e,0x60,0x60,0x00,0x00,0xc3,0x63,0x33,0x1b,0x6c,0xc6,0x63,0xf0,
 0xc3,0x63,0x33,0xdb,0xec,0xf6,0xfb,0xc0,0x18,0x00,0x18,0x18,0x3c,0x3c,0x18,0x00,0x00,0xd8,0x6c,0x36,0x6c,0xd8,0x00,0x00,0x00,0x36,0x6c,0xd8,0x6c,0x36,0x00,0x00,
 0x44,0x11,0x44,0x11,0x44,0x11,0x44,0x11,0xaa,0x55,0xaa,0x55,0xaa,0x55,0xaa,0x55,0xbb,0xee,0xbb,0xee,0xbb,0xee,0xbb,0xee,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
 0x10,0x10,0x10,0x1f,0x10,0x10,0x10,0x10,0x10,0x10,0x1f,0x10,0x1f,0x10,0x10,0x10,0x28,0x28,0x28,0x2f,0x28,0x28,0x28,0x28,0x00,0x00,0x00,0x3f,0x28,0x28,0x28,0x28,
 0x00,0x00,0x1f,0x10,0x1f,0x10,0x10,0x10,0x28,0x28,0x2f,0x20,0x2f,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x00,0x00,0x3f,0x20,0x2f,0x28,0x28,0x28,
 0x28,0x28,0x2f,0x20,0x3f,0x00,0x00,0x00,0x28,0x28,0x28,0x3f,0x00,0x00,0x00,0x00,0x10,0x10,0x1f,0x10,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x1f,0x10,0x10,0x10,0x10,
 0x10,0x10,0x10,0xf0,0x00,0x00,0x00,0x00,0x10,0x10,0x10,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0xf0,0x10,0x10,0x10,0x10,
 0x00,0x00,0x00,0xff,0x00,0x00,0x00,0x00,0x10,0x10,0x10,0xff,0x10,0x10,0x10,0x10,0x10,0x10,0xf0,0x10,0xf0,0x10,0x10,0x10,0x28,0x28,0x28,0xe8,0x28,0x28,0x28,0x28,
 0x28,0x28,0xe8,0x08,0xf8,0x00,0x00,0x00,0x00,0x00,0xf8,0x08,0xe8,0x28,0x28,0x28,0x28,0x28,0xef,0x00,0xff,0x00,0x00,0x00,0x00,0x00,0xff,0x00,0xef,0x28,0x28,0x28,
 0x28,0x28,0xe8,0x08,0xe8,0x28,0x28,0x28,0x00,0x00,0xff,0x00,0xff,0x00,0x00,0x00,0x28,0x28,0xef,0x00,0xef,0x28,0x28,0x28,0x10,0x10,0xff,0x00,0xff,0x00,0x00,0x00,
 0x28,0x28,0x28,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x00,0xff,0x10,0x10,0x10,0x00,0x00,0x00,0xff,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0xf8,0x00,0x00,0x00,0x00,
 0x10,0x10,0xf0,0x10,0xf0,0x00,0x00,0x00,0x00,0x00,0xf0,0x10,0xf0,0x10,0x10,0x10,0x00,0x00,0x00,0xf8,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0xff,0x28,0x28,0x28,0x28,
 0x10,0x10,0xff,0x10,0xff,0x10,0x10,0x10,0x10,0x10,0x10,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0x10,0x10,0x10,0x10,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
 0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,
 0x00,0x00,0xdc,0x56,0x26,0x56,0xdc,0x00,0x78,0xcc,0x6c,0xcc,0xcc,0xcc,0x6c,0x0c,0xfe,0xc6,0x06,0x06,0x06,0x06,0x06,0x00,0x00,0xfc,0xfe,0x48,0x48,0x4c,0xc6,0x00,
 0xfe,0x8c,0x18,0x30,0x18,0x8c,0xfe,0x00,0x00,0x00,0xfc,0x26,0x66,0x66,0x3c,0x00,0x00,0x00,0xcc,0xcc,0xcc,0xdc,0x6c,0x06,0x00,0x00,0xfc,0x36,0x30,0x30,0x30,0x00,
 0x38,0x10,0x7c,0xc6,0x7c,0x10,0x38,0x00,0x38,0x6c,0xc6,0xfe,0xc6,0x6c,0x38,0x00,0x38,0x6c,0xc6,0xc6,0x6c,0x6c,0xee,0x00,0x70,0x18,0x30,0x78,0xcc,0xcc,0x78,0x00,
 0x00,0x6e,0xdd,0x99,0xbb,0x76,0x00,0x00,0x60,0x20,0x7c,0xd6,0xd6,0x7c,0x08,0x0c,0xf0,0x18,0x0c,0xfc,0x0c,0x18,0xf0,0x00,0x7c,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0x00,
 0x00,0x7e,0x00,0x7e,0x00,0x7e,0x00,0x00,0x18,0x18,0x7e,0x18,0x18,0x00,0x7e,0x00,0x0e,0x38,0xe0,0x38,0x0e,0x00,0xfe,0x00,0xe0,0x38,0x0e,0x38,0xe0,0x00,0xfe,0x00,
 0x70,0xd8,0xd8,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x1b,0x1b,0x0e,0x18,0x18,0x00,0x7e,0x00,0x18,0x18,0x00,0x00,0xdc,0x76,0x00,0xdc,0x76,0x00,0x00,
 0x3c,0x66,0x66,0x3c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0xf0,0x30,0x30,0x30,0x36,0x3c,0x38,0x30,
 0x36,0x6e,0x66,0x66,0x66,0x00,0x00,0x00,0x3c,0x66,0x38,0x0c,0x7e,0x00,0x00,0x00,0x00,0x00,0x3c,0x3c,0x3c,0x3c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 };




 structure
 {
 W maj_ver,min_ver;
 W num_tables;
 W search_range;
 W entry_selector;
 W range_shift;
 }
 _aa_ttfoffsettable;


 structure
 {
 C tag[4];
 H crc,off,len;
 }
 _aa_ttftabledirectory;


 structure
 {
 W selector;
 W count;
 W offset;
 }
 _aa_ttfnametableheader;


 structure
 {
 W platform_id,encoding_id,lang_id,name_id;
 W str_len,str_off;
 }
 _aa_ttfnamerecord;



 structure
 {
 H self_handle;
 _fontstatus status;
 _size size;
 H instance;
 }
 _aa_fontobject;


 structure
 {
 B object_id;
 H font_4x8;
 H font_4x16;
 H font_8x8;
 H font_8x16;
 H font_8x32;
 H font_16x16;
 H font_16x32;
 _cell font_pixel;
 }
 _aa_fontsystem;



 H font_4x8=0;
 H font_4x16=0;
 H font_8x8=0;
 H font_8x16=0;
 H font_8x32=0;
 H font_16x16=0;
 H font_16x32=0;


 K aa_FontCallBack                     (ENUMLOGFONT FAR*lpelf,NEWTEXTMETRIC FAR*lpntm,Z FontType,LPARAM lParam);
 B aa_FontSystemStart                  (V);
 V aa_FontSystemStop                   (V);
 B aa_FontSystemPixelSlotsExpand       (V);
 B aa_FontSystemFind                   (HP handle,VP facettf,H resnum,N logw,N logh,B weight,B italic,B underline,B smoothed,H charset);



/*-----------------------------------------------------------------------*/

 #define DISPLAY_DEVICE_ACTIVE         0x00000001
 #define DISPLAY_DEVICE_ATTACHED       0x00000002
 #define DIGCF_PRESENT	             0x00000002
 #define DICS_FLAG_GLOBAL              1
 #define DIREG_DEV                     0x00000001
 #define NAME_SIZE                     200


 structure
 {
 DWORD cbSize;
 GUID  ClassGuid;
 DWORD DevInst;
 ULONG_PTR Reserved;
 }
 SP_DEVINFO_DATA;


 structure
 {
 DWORD cbSize;
 GUID  InterfaceClassGuid;
 DWORD Flags;
 ULONG_PTR Reserved;
 }
 SP_DEVICE_INTERFACE_DATA;


 DLL_IMPORT BOOL WINAPI                SetupDiEnumDeviceInfo(VP,DWORD,SP_DEVINFO_DATA*);
 DLL_IMPORT VP   WINAPI                SetupDiGetClassDevsA(GUID*,PCSTR,HWND,DWORD);
 DLL_IMPORT VP   WINAPI                SetupDiGetClassDevsW(GUID*,PCWSTR,HWND,DWORD);
 DLL_IMPORT VP   WINAPI                SetupDiGetClassDevsExA(GUID*,PCSTR,HWND,DWORD,VP,PCSTR,PVOID);
 DLL_IMPORT VP   WINAPI                SetupDiGetClassDevsExW(GUID*,PCWSTR,HWND,DWORD,VP,PCWSTR,PVOID);
 DLL_IMPORT HKEY WINAPI                SetupDiOpenDeviceInterfaceRegKey(VP,SP_DEVICE_INTERFACE_DATA*,DWORD,REGSAM);
 DLL_IMPORT HKEY WINAPI                SetupDiOpenDevRegKey(VP,SP_DEVINFO_DATA*,DWORD,DWORD,DWORD,REGSAM);
 DLL_IMPORT BOOL WINAPI                SetupDiDestroyDeviceInfoList(VP);

 GUID GUID_CLASS_MONITOR               ={0x4d36e96e,0xe325,0x11ce,{0xbf,0xc1,0x08,0x00,0x2b,0xe1,0x03,0x18}};



 #define CTLCODE(dtype,func,meth,acs)  (((dtype)<<16)|((acs)<<14)|((func)<<2)|(meth))
 #define IOVIDSET_DISPLAY_BRIGHT       CTLCODE(0x00000023,0x127,0,0)
 #define IOVIDQRY_DISPLAY_BRIGHT       CTLCODE(0x00000023,0x126,0,0)
 #define IOVIDQRY_SUPPORTED_BRIGHT     CTLCODE(0x00000023,0x125,0,0)

 T BOOL   (WINAPI *getDeviceGammaRamp) (HDC hDC,LPVOID lpRamp);
 T BOOL   (WINAPI *setDeviceGammaRamp) (HDC hDC,LPVOID lpRamp);


 structure
 {
 B is_revert;
 HANDLE gdi32_module;
 getDeviceGammaRamp GetDeviceGammaRamp;
 setDeviceGammaRamp SetDeviceGammaRamp;
 _displayinfo di;
 }
 _aa_displaysystem;

 B aa_DisplaySystemStart               (V);
 V aa_DisplaySystemStop                (V);
 B aa_DisplaySystemLoadModules         (V);

 B aa_DisplayGetMonitorSizeFromEDID    (HKEY hDevRegKey,WP WidthMm,WP HeightMm);
 B aa_DisplayGetSizeForDevID           (CP TargetDevID,WP WidthMm,WP HeightMm);

/*-----------------------------------------------------------------------*/

 E { PNG_BADFORMAT,PNG_RGB8,PNG_RGB16,PNG_RGBA8,PNG_RGBA16,PNG_LUMINANCE1,PNG_LUMINANCE2,PNG_LUMINANCE4,
     PNG_LUMINANCE8,PNG_LUMINANCE_ALPHA1,PNG_LUMINANCE_ALPHA2,PNG_LUMINANCE_ALPHA4,PNG_LUMINANCE_ALPHA8 };
 E { PNG_ERROR=-1,PNG_DECODED=0,PNG_HEADER=1,PNG_NEW=2};
 E { PNG_LUM=0,PNG_RGB=2,PNG_LUMA=4,PNG_RGBA=6};

 #define PNG_MAKE_BYTE(b)              ((b)&0xFF)
 #define PNG_MAKE_DWORD(a,b,c,d)       ((PNG_MAKE_BYTE(a)<<24)|(PNG_MAKE_BYTE(b)<<16)|(PNG_MAKE_BYTE(c)<<8)|PNG_MAKE_BYTE(d))
 #define PNG_MAKE_DWORD_PTR(p)         PNG_MAKE_DWORD((p)[0],(p)[1],(p)[2],(p)[3])
 #define PNG_CHUNK_IHDR                PNG_MAKE_DWORD('I','H','D','R')
 #define PNG_CHUNK_IDAT                PNG_MAKE_DWORD('I','D','A','T')
 #define PNG_CHUNK_IEND                PNG_MAKE_DWORD('I','E','N','D')
 #define PNG_FIRST_LENGTH_CODE_INDEX   257
 #define PNG_LAST_LENGTH_CODE_INDEX    285
 #define PNG_NUM_DEFLATE_CODE_SYMBOLS  288
 #define PNG_NUM_DISTANCE_SYMBOLS      32
 #define PNG_NUM_CODE_LENGTH_CODES     19
 #define PNG_MAX_SYMBOLS               288
 #define PNG_DEFLATE_CODE_BITLEN       15
 #define PNG_DISTANCE_BITLEN           15
 #define PNG_CODE_LENGTH_BITLEN        7
 #define PNG_MAX_BIT_LENGTH            15
 #define PNG_DEFLATE_CODE_BUFFER_SIZE  (PNG_NUM_DEFLATE_CODE_SYMBOLS*2)
 #define PNG_DISTANCE_BUFFER_SIZE      (PNG_NUM_DISTANCE_SYMBOLS*2)
 #define PNG_CODE_LENGTH_BUFFER_SIZE   (PNG_NUM_DISTANCE_SYMBOLS*2)
 #define PNG_SET_ERROR(upng,code)      do { (upng)->error=(code); (upng)->error_line=__LINE__; } while (0)

 #define PNG_HEADER_OFFSET_IHDR        0x0C
 #define PNG_HEADER_SIZE_IHDR          0x11
 #define PNG_HEADER_OFFSET_WIDTH       0x10
 #define PNG_HEADER_OFFSET_HEIGHT      0x14
 #define PNG_HEADER_OFFSET_FORMAT      0x19
 #define PNG_HEADER_OFFSET_IHDR_CRC    0x1D
 #define PNG_HEADER_OFFSET_IDAT_SIZE   0x21
 #define PNG_HEADER_OFFSET_IDAT_DATA   0x29


 structure { BP buffer;H size;C owning; } upng_source;

 structure
 {
 H width,height;
 B color_type;
 H components;
 H bpp;
 H color_depth;
 B format;
 BP buffer;
 H size;
 B error;
 H error_line;
 B state;
 upng_source source;
 }
 upng_t;



 structure pnghufftree
 {
 HP tree2d;
 H maxbitlen;
 H numcodes;
 }
 pnghufftree;



 B aa_png_header[43]="\x89PNG\r\n\x1A\n\0\0\0\rIHDR\0\0\0\0\0\0\0\0\x08\0\0\0\0\0\0\0\0\0\0\0\0IDAT\x78\x01";
 B aa_png_trailer[12]="\0\0\0\0IEND\xAE\x42\x60\x82";

 H PNG_LENGTH_BASE[29]={3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258};
 H PNG_LENGTH_EXTRA[29]={0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};
 H PNG_DISTANCE_BASE[30]={1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577};
 H PNG_DISTANCE_EXTRA[30]={0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};
 H PNG_CLCL[PNG_NUM_CODE_LENGTH_CODES]={ 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };

 H PNG_FIXED_DEFLATE_CODE_TREE[PNG_NUM_DEFLATE_CODE_SYMBOLS*2]={
 289,370,290,307,546,291,561,292,293,300,294,297,295,296,0,1,2,3,298,299,4,5,6,7,301,304,302,303,8,9,10,11,305,306,12,
 13,14,15,308,339,309,324,310,317,311,314,312,313,16,17,18,19,315,316,20,21,22,23,318,321,319,320,24,25,26,27,322,323,
 28,29,30,31,325,332,326,329,327,328,32,33,34,35,330,331,36,37,38,39,333,336,334,335,40,41,42,43,337,338,44,45,46,47,
 340,355,341,348,342,345,343,344,48,49,50,51,346,347,52,53,54,55,349,352,350,351,56,57,58,59,353,354,60,61,62,63,356,
 363,357,360,358,359,64,65,66,67,361,362,68,69,70,71,364,367,365,366,72,73,74,75,368,369,76,77,78,79,371,434,372,
 403,373,388,374,381,375,378,376,377,80,81,82,83,379,380,84,85,86,87,382,385,383,384,88,89,90,91,386,387,92,93,94,95,
 389,396,390,393,391,392,96,97,98,99,394,395,100,101,102,103,397,400,398,399,104,105,106,107,401,402,108,109,110,111,404,
 419,405,412,406,409,407,408,112,113,114,115,410,411,116,117,118,119,413,416,414,415,120,121,122,123,417,418,124,125,126,
 127,420,427,421,424,422,423,128,129,130,131,425,426,132,133,134,135,428,431,429,430,136,137,138,139,432,433,140,141,142,
 143,435,483,436,452,568,437,438,445,439,442,440,441,144,145,146,147,443,444,148,149,150,151,446,449,447,448,152,153,154,
 155,450,451,156,157,158,159,453,468,454,461,455,458,456,457,160,161,162,163,459,460,164,165,166,167,462,465,463,464,168,
 169,170,171,466,467,172,173,174,175,469,476,470,473,471,472,176,177,178,179,474,475,180,181,182,183,477,480,478,479,184,
 185,186,187,481,482,188,189,190,191,484,515,485,500,486,493,487,490,488,489,192,193,194,195,491,492,196,197,198,199,494,
 497,495,496,200,201,202,203,498,499,204,205,206,207,501,508,502,505,503,504,208,209,210,211,506,507,212,213,214,215,509,
 512,510,511,216,217,218,219,513,514,220,221,222,223,516,531,517,524,518,521,519,520,224,225,226,227,522,523,228,229,230,
 231,525,528,526,527,232,233,234,235,529,530,236,237,238,239,532,539,533,536,534,535,240,241,242,243,537,538,244,245,246,
 247,540,543,541,542,248,249,250,251,544,545,252,253,254,255,547,554,548,551,549,550,256,257,258,259,552,553,260,261,262,
 263,555,558,556,557,264,265,266,267,559,560,268,269,270,271,562,565,563,564,272,273,274,275,566,567,276,277,278,279,569,
 572,570,571,280,281,282,283,573,574,284,285,286,287,0,0};

 H PNG_FIXED_DISTANCE_TREE[PNG_NUM_DISTANCE_SYMBOLS*2]={33,48,34,41,35,38,36,37,0,1,2,3,39,40,4,5,6,7,42,45,43,
 44,8,9,10,11,46,47,12,13,14,15,49,56,50,53,51,52,16,17,18,19,54,55,20,21,22,23,57,60,58,59,24,25,26,27,61,62,28,29,30,31,0,0};

 B aa_PngFromImage                     (VP imgdata,N width,N height,N stride,VP outbuf,N maxout,HP outbytes);


/*-----------------------------------------------------------------------*/


 structure
 {
 BP data;
 Z width,height;
 Z x_pos,y_pos;
 }
 _jpegchunk;


 structure
 {
 B data[512];
 Y bit_size;
 }
 _jpegbuf;


 structure
 {
 W length;
 B data[338];
 W img_w_off;
 W img_h_off;
 }
 _jpeghdr;


 structure
 {
 H magic;
 W img_w,img_h;
 W x_pos,y_pos;
 I prev_y1dc,prev_y2dc;
 I prev_crdc,prev_cbdc;
 B eoi;
 Z blocks_n;
 _jpeghdr header;
 C quant[64];
 _jpegchunk chunk;
 _jpegbuf buffy;
 _memoryunit yuv;
 _memoryunit out;
 H out_len;
 }
 _jpegctx;



 B aa_JpegChunkNext                    (_jpegchunk*chunk);
 V aa_JpegChunkCopyY1                  (_jpegchunk*chunk,IP destination);
 V aa_JpegChunkCopyY2                  (_jpegchunk*chunk,IP destination);
 V aa_JpegChunkCopyCr                  (_jpegchunk*chunk,IP destination);
 V aa_JpegChunkCopyCb                  (_jpegchunk*chunk,IP destination);

 V aa_JpegAdd                          (_jpegbuf*buffer,Y bits,B bits_n);
 V aa_JpegAddAC                        (_jpegbuf*buffer,WP table,B run,I value);
 V aa_JpegAddDC                        (_jpegbuf*buffer,WP table,I value);

 V aa_JpegEncode                       (_jpegctx*jpegctx,IP last_dc,WP dc_table,WP ac_table,IP block);
 V aa_JpegQuantize                     (_jpegctx*jpegctx,IP block);
 Z aa_JpegWrite                        (_jpegctx*jpegctx,BP buffer,Z buffer_size);

 B aa_JpegNew                          (_jpegctx*jpegctx);
 B aa_JpegDelete                       (_jpegctx*jpegctx);
 B aa_JpegCompress                     (_jpegctx*jpegctx,B quality,H w,H h,VP img);

/*-----------------------------------------------------------------------*/

 structure
 {
 B bits,code;
 }
 _jpegdecvlccode;

 structure
 {
 Z cid;
 Z ssx,ssy;
 Z width,height;
 Z stride;
 Z qtsel;
 Z actabsel,dctabsel;
 Z dcpred;
 BP pixels;
 }
 _jpegdeccomponent;

 structure
 {
 B error;
 BP pos;
 Z size;
 Z length;
 Z width,height;
 Z mbwidth,mbheight;
 Z mbsizex,mbsizey;
 Z ncomp;
 _jpegdeccomponent comp[3];
 Z qtused,qtavail;
 B qtab[4][64];
 _jpegdecvlccode vlctab[4][65536];
 Z buf,bufbits;
 Z block[64];
 Z rstinterval;
 BP rgb;
 BP user_supplied_rgb;
 }
 _jpegdecctx;


 #define aa_JPEGDEC_W1                 2841
 #define aa_JPEGDEC_W2                 2676
 #define aa_JPEGDEC_W3                 2408
 #define aa_JPEGDEC_W5                 1609
 #define aa_JPEGDEC_W6                 1108
 #define aa_JPEGDEC_W7                 565

 #define aa_JpegDec_Throw(c,e)         do { c->error=e; return;   } while (0)
 #define aa_JpegDec_CheckError(c)      do { if (c->error) return; } while (0)

 V aa_JpegDecRowIDCT                   (_jpegdecctx*jpegdecctx,ZP blk);
 V aa_JpegDecColIDCT                   (_jpegdecctx*jpegdecctx,ZP blk,BP out,Z stride);
 Z aa_JpegDecShowBits                  (_jpegdecctx*jpegdecctx,Z bits);
 Z aa_JpegDecGetBits                   (_jpegdecctx*jpegdecctx,Z bits);
 W aa_JpegDecDecode16                  (_jpegdecctx*jpegdecctx,BP pos);
 V aa_JpegDecDecodeLength              (_jpegdecctx*jpegdecctx);
 V aa_JpegDecSkipMarker                (_jpegdecctx*jpegdecctx);
 V aa_JpegDecDecodeSOF                 (_jpegdecctx*jpegdecctx);
 V aa_JpegDecDecodeDHT                 (_jpegdecctx*jpegdecctx);
 V aa_JpegDecDecodeDQT                 (_jpegdecctx*jpegdecctx);
 V aa_JpegDecDecodeDRI                 (_jpegdecctx*jpegdecctx);
 Z aa_JpegDecGetVLC                    (_jpegdecctx*jpegdecctx,_jpegdecvlccode*vlc,BP code);
 V aa_JpegDecDecodeBlock               (_jpegdecctx*jpegdecctx,_jpegdeccomponent*c,BP out);
 V aa_JpegDecDecodeScan                (_jpegdecctx*jpegdecctx);
 V aa_JpegDecUpSample                  (_jpegdecctx*jpegdecctx,_jpegdeccomponent*c);
 V aa_JpegDecConvert                   (_jpegdecctx*jpegdecctx);

 B aa_JpegDecNew                       (_jpegdecctx*jpegdecctx,BP usersuppliedrgb);
 B aa_JpegDecDelete                    (_jpegdecctx*jpegdecctx);
 B aa_JpegDecDecompress                (_jpegdecctx*jpegdecctx,VP jpeg,Z size);



/*-----------------------------------------------------------------------*/

 B aa_PathPixelProc                    (VP handle,N x,N y,_rgba*pn);
 B aa_PathExtend                       (_path*path,H need);

/*-----------------------------------------------------------------------*/

 #define WM_SURFACE_SYSTRAY_MSG        (WM_USER+41)
 #define aa_WARP_SHIFTS                15
 #define aa_WARP_THRESH                (1<<aa_WARP_SHIFTS)

 #define RGB_Y_OUT                     1.164
 #define B_U_OUT                       2.018
 #define Y_ADD_OUT                     16
 #define G_U_OUT                       0.391
 #define G_V_OUT                       0.813
 #define U_ADD_OUT                     128
 #define R_V_OUT                       1.596
 #define V_ADD_OUT                     128
 #define SCALEBITS_OUT                 13
 #define FIX_OUT(x)                    ((W)((x)*(1L<<SCALEBITS_OUT)+0.5))


 #define RGB2YUV_SHIFT                 8
 #define YV_BY                         ((Z)( 0.098*(1<<RGB2YUV_SHIFT)+0.5))
 #define YV_BV                         ((Z)(-0.071*(1<<RGB2YUV_SHIFT)+0.5))
 #define YV_BU                         ((Z)( 0.439*(1<<RGB2YUV_SHIFT)+0.5))
 #define YV_GY                         ((Z)( 0.504*(1<<RGB2YUV_SHIFT)+0.5))
 #define YV_GV                         ((Z)(-0.368*(1<<RGB2YUV_SHIFT)+0.5))
 #define YV_GU                         ((Z)(-0.291*(1<<RGB2YUV_SHIFT)+0.5))
 #define YV_RY                         ((Z)( 0.257*(1<<RGB2YUV_SHIFT)+0.5))
 #define YV_RV                         ((Z)( 0.439*(1<<RGB2YUV_SHIFT)+0.5))
 #define YV_RU                         ((Z)(-0.148*(1<<RGB2YUV_SHIFT)+0.5))






 structure
 {
 H self_handle;
 _surfacestatus status;
 B(*PixelGet)(VP surfobj,N x,N y,_rgba*p1);
 B(*PixelPut)(VP surfobj,N x,N y,_rgba*p1);
 B(*PixelSet)(VP surfobj,N x,N y,_rgba*p1);
 H spot_id_counter;
 _rect rect_save;
 _rect save_rect;
 B save_buf[_4K];
 _rgba*rgba_mem;
 _rgba*memb;
 B in_blit;
 }
 _aa_surfaceobject;




 structure
 {
 B object_id;
 B yuva_tables_init;
 N RGB_Y_tab[256];
 N B_U_tab[256];
 N G_U_tab[256];
 N G_V_tab[256];
 N R_V_tab[256];
 }
 _aa_surfacesystem;


 structure
 {
 W type;
 H size;
 W rsvd1,rsvd2;
 H off_bits;
 }
 _aa_surfacebmpfilehdr;


 structure
 {
 H width,height;
 W bits;
 H compression;
 }
 _aa_surfacebmpinfohdr;


 structure
 {
 H width,height;
 W planes,bits;
 H compression,imgsize;
 H xpixpermeter,ypixpermeter;
 H clrused,clrimportant;
 }
 _aa_surfacewinbmpinfohdr;



 structure
 {
 W width,height;
 W planes,bits;
 }
 _aa_surfaceos2bmpinfohdr;



 structure
 {
 W byte_order;
 W id_42;
 H offset;
 }
 _aa_surfacetiffhdr;



 structure
 {
 W rsvd,type;
 W count;
 }
 _aa_surfaceiconhdr;




 structure
 {
 B wid,hit;
 B colors,rsvd;
 W planes,bps;
 H size,offset;
 }
 _aa_surfaceiconentry;



 structure
 {
 B id_length;
 B pal_type;
 B img_type;
 W first_color;
 W pal_colors;
 B pal_entry_size;
 W left;
 W top;
 W width;
 W height;
 B bpp;
 B flags;
 }
 _aa_surfacetgahdr;




 structure
 {
 Y b:5;
 Y g:5;
 Y r:5;
 Y a:1;
 }
 _aa_pen16;


 structure
 {
 B b;
 B g;
 B r;
 }
 _aa_pen24;



 B aa_SurfaceSystemStart               (V);
 V aa_SurfaceSystemStop                (V);
 B aa_SurfaceSystemFindSurfaceByHwnd   (HP handle,PP mem,HWND hwnd);

 V aa_SurfaceSystemYuvTablesInit       (V);

 B aa_SurfaceDecodeTgaRle              (NP duppixcount,NP blockcount,HP off,VP mem,B bits,_rgba*p1);

 B aa_SurfaceSortSpots                 (PP mem);

/*-----------------------------------------------------------------------*/


 W QRENC_NUM_ERROR_CORRECTION_CODEWORDS[4][40]=
 {
 { 10,16,26,36,48,64,72,88,110,130,150,176,198,216,240,280,308,338,364,416,442,476,504,560,588,644,700,728,784,812,868,924,980,1036,1064,1120,1204,1260,1316,1372},
 {  7,10,15,20,26,36,40,48,60,72,80,96,104,120,132,144,168,180,196,224,224,252,270,300,312,336,360,390,420,450,480,510,540,570,570,600,630,660,720,750},
 { 17,28,44,64,88,112,130,156,192,224,264,308,352,384,432,480,532,588,650,700,750,816,900,960,1050,1110,1200,1260,1350,1440,1530,1620,1710,1800,1890,1980,2100,2220,2310,2430},
 { 13,22,36,52,72,96,108,132,160,192,224,260,288,320,360,408,448,504,546,600,644,690,750,810,870,952,1020,1050,1140,1200,1290,1350,1440,1530,1590,1680,1770,1860,1950,2040},
 };

 B QRENC_NUM_ERROR_CORRECTION_BLOCKS[4][40]=
 {
 { 1,1,1,2,2,4,4,4,5,5,5,8,9,9,10,10,11,13,14,16,17,17,18,20,21,23,25,26,28,29,31,33,35,37,38,40,43,45,47,49},
 { 1,1,1,1,1,2,2,2,2,4,4,4,4,4,6,6,6,6,7,8,8,9,9,10,12,12,12,13,14,15,16,17,18,19,19,20,21,22,24,25},
 { 1,1,2,4,4,4,5,6,8,8,11,11,16,16,18,16,19,21,25,25,25,34,30,32,35,37,40,42,45,48,51,54,57,60,63,66,70,74,77,81},
 { 1,1,2,2,4,4,6,6,8,8,8,10,12,16,12,17,16,18,21,20,23,23,25,27,29,34,34,35,38,40,43,45,48,51,53,56,59,62,65,68},
 };

 W QRENC_NUM_RAW_DATA_MODULES[40]=
 {
 208,359,567,807,1079,1383,1568,1936,2336,2768,3232,3728,4256,4651,5243,5867,6523,7211,7931,8683,9252,10068,10916,11796,12708,13652,14628,15371,16411,17483,18587,19723,20891,22091,23008,24272,25568,26896,28256,29648
 };


/*-----------------------------------------------------------------------*/


 structure
 {
 Y bitOffsetOrWidth;
 W capacityBytes;
 BP data;
 }
 _qrencoderbucket;


/*-----------------------------------------------------------------------*/

 Z aa_QrEncGetAlphanumeric             (C c)
 {
 if (c>='0'&&c<='9') { return (c-'0'); }
 if (c>='A'&&c<='Z') { return (c-'A'+10); }
 switch (c)
  {
  case ' ': return 36;
  case '$': return 37;
  case '%': return 38;
  case '*': return 39;
  case '+': return 40;
  case '-': return 41;
  case '.': return 42;
  case '/': return 43;
  case ':': return 44;
  }
 return -1;
 }


 B aa_QrEncIsAlphanumeric              (CP text,W length)
 {
 while(length!=0)
  {
  if(aa_QrEncGetAlphanumeric(text[--length])==-1) { return NO; }
  }
 return YES;
 }


 B aa_QrEncIsNumeric                   (CP text,W length)
 {
 C c;
 while(length!=0)
  {
  c=text[--length];
  if(c<'0'||c>'9') { return NO; }
  }
 return YES;
 }




 C aa_QrEncGetModeBits                 (B version,B mode)
 {
 C result;
 Y modeInfo=0x7bbb80a;

 if(version>9)  { modeInfo>>=9; }
 if(version>26) { modeInfo>>=9; }
 result=8+((modeInfo>>(3*mode))&0x07);
 if(result==15) { result=16; }
 return result;
 }





 W aa_QrEncBucketGetGridSizeBytes      (B size)
 {
 return(((size*size)+7)/8);
 }


 W aa_QrEncBucketGetBufferSizeBytes    (Y bits)
 {
 return((bits+7)/8);
 }


 V aa_QrEncBucketInitBuffer            (_qrencoderbucket*bitBuffer,BP data,Z capacityBytes)
 {
 bitBuffer->bitOffsetOrWidth=0;
 bitBuffer->capacityBytes=capacityBytes;
 bitBuffer->data=data;
 aaMemoryFill(data,bitBuffer->capacityBytes,0);
 }



 V aa_QrEncBucketInitGrid              (_qrencoderbucket*bitGrid,BP data,B size)
 {
 bitGrid->bitOffsetOrWidth=size;
 bitGrid->capacityBytes=aa_QrEncBucketGetGridSizeBytes(size);
 bitGrid->data=data;
 aaMemoryFill(data,bitGrid->capacityBytes,0);
 }



 V aa_QrEncBucketAppendBits            (_qrencoderbucket*bitBuffer,Y val,B length)
 {
 Y offset;
 Z i;
 offset=bitBuffer->bitOffsetOrWidth;
 for(i=length-1;i>=0;i--,offset++)
  {
  bitBuffer->data[offset>>3]|=((val>>i)&1)<<(7-(offset & 7));
  }
 bitBuffer->bitOffsetOrWidth=offset;
 }



 V aa_QrEncBucketSetBit                (_qrencoderbucket*bitGrid,B x,B y,B on)
 {
 Y offset;
 B mask;
 offset=y*bitGrid->bitOffsetOrWidth+x;
 mask=1<<(7-(offset & 0x07));
 if(on) { bitGrid->data[offset>>3]|=mask;  }
 else   { bitGrid->data[offset>>3]&=~mask; }
 }


 V aa_QrEncBucketInvertBit             (_qrencoderbucket*bitGrid,B x,B y,B invert)
 {
 Y offset=y*bitGrid->bitOffsetOrWidth+x;
 B mask=1<<(7-(offset&0x07));
 B on=((bitGrid->data[offset>>3]&(1<<(7-(offset&0x07))))!=0);
 if(on^invert) { bitGrid->data[offset>>3]|=mask;  }
 else          { bitGrid->data[offset>>3]&=~mask; }
 }



 B aa_QrEncBucketGetBit                (_qrencoderbucket*bitGrid,B x,B y)
 {
 Y offset=y*bitGrid->bitOffsetOrWidth+x;
 return (bitGrid->data[offset>>3]&(1<<(7-(offset&0x07))))!=0;
 }




 V aa_QrEncBucketApplyMask             (_qrencoderbucket*modules,_qrencoderbucket*isFunction,B mask)
 {
 B invert;
 N x,y;
 B size=modules->bitOffsetOrWidth;

 for(y=0;y<size;y++)
  {
  for(x=0;x<size;x++)
   {
   if(aa_QrEncBucketGetBit(isFunction,x,y)) { continue; }
   invert=0;
   switch (mask)
    {
    case 0:  invert=(x+y)%2==0;            break;
    case 1:  invert=y%2==0;                break;
    case 2:  invert=x%3==0;                break;
    case 3:  invert=(x+y)%3==0;            break;
    case 4:  invert=(x/3+y/2)%2==0;        break;
    case 5:  invert=x*y%2+x*y%3==0;        break;
    case 6:  invert=(x*y%2+x*y%3)%2==0;    break;
    case 7:  invert=((x+y)%2+x*y%3)%2==0;  break;
    }
   aa_QrEncBucketInvertBit(modules,x,y,invert);
   }
  }
 }




 V aa_QrEncBucketSetFunctionModule     (_qrencoderbucket*modules,_qrencoderbucket*isFunction,B x,B y,B on)
 {
 aa_QrEncBucketSetBit(modules,x,y,on);
 aa_QrEncBucketSetBit(isFunction,x,y,TRUE);
 }



 V aa_QrEncBucketDrawFinderPattern     (_qrencoderbucket*modules,_qrencoderbucket*isFunction,B x,B y)
 {
 Y dist,size=modules->bitOffsetOrWidth;
 Z i,j,xx,yy;

 for(i=-4;i<=4;i++)
  {
  for(j=-4;j<=4;j++)
   {
   dist=max(abs(i),abs(j));
   xx=x+j;
   yy=y+i;
   if(0<=xx&&xx<(Z)size&&0<=yy&&yy<(Z)size)
    {
    aa_QrEncBucketSetFunctionModule(modules,isFunction,xx,yy,dist!=2&&dist!=4);
    }
   }
  }
 }


 V aa_QrEncBucketDrawAlignmentPattern  (_qrencoderbucket*modules,_qrencoderbucket*isFunction,B x,B y)
 {
 N i,j;
 for(i=-2;i<=2;i++)
  {
  for(j=-2;j<=2;j++)
   {
   aa_QrEncBucketSetFunctionModule(modules,isFunction,x+j,y+i,max(abs(i),abs(j))!=1);
   }
  }
 }


 V aa_QrEncBucketDrawFormatBits        (_qrencoderbucket*modules,_qrencoderbucket*isFunction,B ecc,B mask)
 {
 Y data,rem;
 Z i,size;

 size=modules->bitOffsetOrWidth;
 data=ecc<<3|mask;
 rem=data;
 for(i=0;i<10;i++) { rem=(rem<<1)^((rem>>9)*0x537);    }
 data=data<<10|rem;
 data^=0x5412;
 for(i=0;i<=5;i++) {  aa_QrEncBucketSetFunctionModule(modules,isFunction,8,i,((data>>i)&1)!=0);    }
 aa_QrEncBucketSetFunctionModule(modules,isFunction,8,7,((data>>6)&1)!=0);
 aa_QrEncBucketSetFunctionModule(modules,isFunction,8,8,((data>>7)&1)!=0);
 aa_QrEncBucketSetFunctionModule(modules,isFunction,7,8,((data>>8)&1)!=0);
 for(i=9;i<15; i++) {  aa_QrEncBucketSetFunctionModule(modules,isFunction,14-i,8,((data>>i)&1)!=0);      }
 for(i=0;i<=7; i++) {  aa_QrEncBucketSetFunctionModule(modules,isFunction,size-1-i,8,((data>>i)&1)!=0);  }
 for(i=8;i<15; i++) {  aa_QrEncBucketSetFunctionModule(modules,isFunction,8,size-15+i,((data>>i)&1)!=0); }
 aa_QrEncBucketSetFunctionModule(modules,isFunction,8,size-8,TRUE);
 }


 V aa_QrEncBucketDrawVersion           (_qrencoderbucket*modules,_qrencoderbucket*isFunction,B version)
 {
 Y rem,data;
 B i,a,b,bit;
 Z size=modules->bitOffsetOrWidth;
 if(version<7) { return; }
 rem=version;
 for(i=0;i<12;i++)
  {
  rem=(rem<<1)^((rem>>11)*0x1F25);
  }
 data=version<<12|rem;
 for(i=0;i<18;i++)
  {
  bit=((data>>i)&1)!=0;
  a=size-11+i%3;
  b=i/3;
  aa_QrEncBucketSetFunctionModule(modules,isFunction,a,b,bit);
  aa_QrEncBucketSetFunctionModule(modules,isFunction,b,a,bit);
  }
 }



 V aa_QrEncBucketDrawFunctionPatterns  (_qrencoderbucket*modules,_qrencoderbucket*isFunction,B version,B ecc)
 {
 B i,j,size,pos;
 B step,alignCount;
 B alignPositionIndex;
 B alignPosition[100];

 size=modules->bitOffsetOrWidth;
 for(i=0;i<size;i++)
  {
  aa_QrEncBucketSetFunctionModule(modules,isFunction,6,i,i%2==0);
  aa_QrEncBucketSetFunctionModule(modules,isFunction,i,6,i%2==0);
  }
 aa_QrEncBucketDrawFinderPattern(modules,isFunction,3,3);
 aa_QrEncBucketDrawFinderPattern(modules,isFunction,size-4,3);
 aa_QrEncBucketDrawFinderPattern(modules,isFunction,3,size-4);
 if(version>1)
  {
  alignCount=version/7+2;
  if(version!=32) {    step=(version*4+alignCount*2+1)/(2*alignCount-2)*2; }
  else            {    step=26;      }
  alignPositionIndex=alignCount-1;
  alignPosition[0]=6;
  size=version*4+17;
  for(i=0,pos=size-7;i<alignCount-1;i++,pos-=step) {   alignPosition[alignPositionIndex--]=pos;        }
  for(i=0;i<alignCount;i++)
   {
   for(j=0;j<alignCount;j++)
    {
    if((i==0&&j==0)||(i==0&&j==alignCount-1)||(i==alignCount-1&&j==0)) {    continue;     }
    aa_QrEncBucketDrawAlignmentPattern(modules,isFunction,alignPosition[i],alignPosition[j]);
//    else                                                               {    aa_QrEncBucketDrawAlignmentPattern(modules,isFunction,alignPosition[i],alignPosition[j]);               }
    }
   }
  }
 aa_QrEncBucketDrawFormatBits(modules,isFunction,ecc,0);
 aa_QrEncBucketDrawVersion(modules,isFunction,version);
 }




 V aa_QrEncBucketDrawCodewords         (_qrencoderbucket*modules,_qrencoderbucket*isFunction,_qrencoderbucket*codewords)
 {
 Y bitLength=codewords->bitOffsetOrWidth;
 BP data=codewords->data;
 B size=modules->bitOffsetOrWidth;
 B vert,x,upwards,y;
 Z right,j;
 Y i=0;

 for(right=size-1;right>=1;right-=2)
  {
  if(right==6) { right=5; }
  for(vert=0;vert<size;vert++)
   {
   for(j=0;j<2;j++)
    {
    x=right-j;
    upwards=((right&2)==0)^(x<6);
    y=upwards?size-1-vert:vert;
    if(!aa_QrEncBucketGetBit(isFunction,x,y)&&i<bitLength) {  aa_QrEncBucketSetBit(modules,x,y,((data[i>>3]>>(7-(i&7)))&1)!=0);     i++;                }
    }
   }
  }
 }



 Y aa_QrEncBucketGetPenaltyScore       (_qrencoderbucket*modules)
 {
 B x,y,size;
 B colorX,cx,runX;
 B colorY,cy,runY;
 B color;
 W black,total,k;
 W bitsRow,bitsCol;
 B colorUL,colorUR,colorL;
 Y result=0;

 size=modules->bitOffsetOrWidth;
 for(y=0;y<size;y++)
  {
  colorX=aa_QrEncBucketGetBit(modules,0,y);
  for(x=1,runX=1;x<size;x++)
   {
   cx=aa_QrEncBucketGetBit(modules,x,y);
   if(cx!=colorX) { colorX=cx;  runX=1;   }
   else
    {
    runX++;
    if(runX==5) {  result+=3;  }    else
    if(runX>5)  {  result++;   }
    }
   }
  }
 for(x=0;x<size;x++)
  {
  colorY=aa_QrEncBucketGetBit(modules,x,0);
  for(y=1,runY=1;y<size;y++)
   {
   cy=aa_QrEncBucketGetBit(modules,x,y);
   if(cy!=colorY) {  colorY=cy;       runY=1;    }
   else
    {
    runY++;
    if(runY==5) {  result+=3; }  else
    if(runY>5)  {  result++;  }
    }
   }
  }
 black=0;
 for(y=0;y<size;y++)
  {
  bitsRow=0;
  bitsCol=0;
  for(x=0;x<size;x++)
   {
   color=aa_QrEncBucketGetBit(modules,x,y);
   if(x>0&&y>0)
    {
    colorUL=aa_QrEncBucketGetBit(modules,x-1,y-1);
    colorUR=aa_QrEncBucketGetBit(modules,x,y-1);
    colorL=aa_QrEncBucketGetBit(modules,x-1,y);
    if(color==colorUL&&color==colorUR&&color==colorL) { result+=3;  }
    }
   bitsRow=((bitsRow<<1)&0x7FF)|color;
   bitsCol=((bitsCol<<1)&0x7FF)|aa_QrEncBucketGetBit(modules,y,x);
   if(x>=10)
    {
    if(bitsRow==0x05D||bitsRow==0x5D0) {    result+=40;    }
    if(bitsCol==0x05D||bitsCol==0x5D0) {    result+=40;    }
    }
   if(color) { black++; }
   }
  }
 total=size*size;
 for(k=0;black*20<(9-k)*total||black*20>(11+k)*total;k++) {    result+=10;    }
 return result;
 }






 B aa_QrEncRsMultiply                  (B x,B y)
 {
 W z=0;
 Z i;
 for(i=7;i>=0;i--)
  {
  z=(z<<1)^((z>>7)*0x11D);
  z^=((y>>i)&1)*x;
  }
 return z;
 }



 V aa_QrEncRsInit                      (B degree,BP coeff)
 {
 W root=1;
 B i,j;
 aaMemoryFill(coeff,degree,0);
 coeff[degree-1]=1;
 for(i=0;i<degree;i++)
  {
  for(j=0;j<degree;j++)
   {
   coeff[j]=aa_QrEncRsMultiply(coeff[j],root);
   if(j+1<degree) {  coeff[j]^=coeff[j+1];  }
   }
  root=(root<<1)^((root>>7)*0x11D);
  }
 }




 V aa_QrEncRsGetRemainder              (B degree,BP coeff,BP data,B length,BP result,B stride)
 {
 B i,j,factor;

 for(i=0;i<length;i++)
  {
  factor=data[i]^result[0];
  for(j=1;j<degree;j++)
   {
   result[(j-1)*stride]=result[j*stride];
   }
  result[(degree-1)*stride]=0;
  for(j=0;j<degree;j++)
   {
   result[j*stride]^=aa_QrEncRsMultiply(coeff[j],factor);
   }
  }
 }







 B aa_QrEncEncodeDataCodewords         (_qrencoderbucket*dataCodewords,BP text,W length,B version)
 {
 B accumCount;
 W accumData,i;
 B mode=2;

 if(aa_QrEncIsNumeric((CP)text,length))
  {
  mode=0;
  aa_QrEncBucketAppendBits(dataCodewords,1<<0,4);
  aa_QrEncBucketAppendBits(dataCodewords,length,aa_QrEncGetModeBits(version,0));
  accumData=0;
  accumCount=0;
  for(i=0;i<length;i++)
   {
   accumData=accumData*10+((C)(text[i])-'0');
   accumCount++;
   if(accumCount==3)
    {
    aa_QrEncBucketAppendBits(dataCodewords,accumData,10);
    accumData=0;
    accumCount=0;
    }
   }
  if(accumCount>0) { aa_QrEncBucketAppendBits(dataCodewords,accumData,accumCount*3+1);     }
  }
 else
 if(aa_QrEncIsAlphanumeric((CP)text,length))
  {
  mode=1;
  aa_QrEncBucketAppendBits(dataCodewords,1<<1,4);
  aa_QrEncBucketAppendBits(dataCodewords,length,aa_QrEncGetModeBits(version,1));
  accumData=0;
  accumCount=0;
  for(i=0;i<length;i++)
   {
   accumData=accumData*45+aa_QrEncGetAlphanumeric((C)(text[i]));
   accumCount++;
   if(accumCount==2)
    {
    aa_QrEncBucketAppendBits(dataCodewords,accumData,11);
    accumData=0;
    accumCount=0;
    }
   }
  if(accumCount>0) {    aa_QrEncBucketAppendBits(dataCodewords,accumData,6);        }
  }
 else
  {
  aa_QrEncBucketAppendBits(dataCodewords,1<<2,4);
  aa_QrEncBucketAppendBits(dataCodewords,length,aa_QrEncGetModeBits(version,2));
  for(i=0;i<length;i++) {     aa_QrEncBucketAppendBits(dataCodewords,(C)(text[i]),8);        }
  }
 return mode;
 }



 V aa_QrEncPerformErrorCorrection      (B version,B ecc,_qrencoderbucket*data)
 {
 B numBlocks=QRENC_NUM_ERROR_CORRECTION_BLOCKS[ecc][version-1];
 W totalEcc=QRENC_NUM_ERROR_CORRECTION_CODEWORDS[ecc][version-1];
 W moduleCount=QRENC_NUM_RAW_DATA_MODULES[version-1];
 B blockEccLen=totalEcc/numBlocks;
 B numShortBlocks=numBlocks-moduleCount/8%numBlocks;
 B shortBlockLen=moduleCount/8/numBlocks;
 B shortDataBlockLen=shortBlockLen-blockEccLen;
 B result[data->capacityBytes];
 BP dataBytes;
 W index,offset=0;
 B blockSize;
 B blockNum,i,stride,coeff[blockEccLen];

 aaMemoryFill(result,sizeof(result),0);
 aa_QrEncRsInit(blockEccLen,coeff);
 dataBytes=data->data;
 for(i=0;i<shortDataBlockLen;i++)
  {
  index=i;
  stride=shortDataBlockLen;
  for(blockNum=0;blockNum<numBlocks;blockNum++)
   {
   result[offset++]=dataBytes[index];
   if(blockNum==numShortBlocks) { stride++; }
   index+=stride;
   }
  }
 index=shortDataBlockLen*(numShortBlocks+1);
 stride=shortDataBlockLen;
 for(blockNum=0;blockNum<numBlocks-numShortBlocks;blockNum++)
  {
  result[offset++]=dataBytes[index];
  if (blockNum==0) { stride++; }
  index += stride;
  }
 blockSize=shortDataBlockLen;
 for(blockNum=0;blockNum<numBlocks;blockNum++)
  {
  if(blockNum==numShortBlocks) { blockSize++; }
  aa_QrEncRsGetRemainder(blockEccLen,coeff,dataBytes,blockSize,&result[offset+blockNum],numBlocks);
  dataBytes+=blockSize;
  }
 aaMemoryCopy(data->data,data->capacityBytes,result);
 data->bitOffsetOrWidth=moduleCount;
 }





 N aa_QrEncGetBufferSize               (B version)
 {
 return aa_QrEncBucketGetGridSizeBytes(4*version+17);
 }




/*-----------------------------------------------------------------------*/

 #define QRDEC_SUCCESS                 0

 #define QRDEC_ECC_LEVEL_M             0
 #define QRDEC_ECC_LEVEL_L             1
 #define QRDEC_ECC_LEVEL_H             2
 #define QRDEC_ECC_LEVEL_Q             3

 #define QRDEC_DATA_TYPE_NUMERIC       1
 #define QRDEC_DATA_TYPE_ALPHA         2
 #define QRDEC_DATA_TYPE_BYTE          4
 #define QRDEC_DATA_TYPE_KANJI         8

 #define QRDEC_ECI_ISO_8859_1          1
 #define QRDEC_ECI_IBM437              2
 #define QRDEC_ECI_ISO_8859_2          4
 #define QRDEC_ECI_ISO_8859_3          5
 #define QRDEC_ECI_ISO_8859_4          6
 #define QRDEC_ECI_ISO_8859_5          7
 #define QRDEC_ECI_ISO_8859_6          8
 #define QRDEC_ECI_ISO_8859_7          9
 #define QRDEC_ECI_ISO_8859_8          10
 #define QRDEC_ECI_ISO_8859_9          11
 #define QRDEC_ECI_WINDOWS_874         13
 #define QRDEC_ECI_ISO_8859_13         15
 #define QRDEC_ECI_ISO_8859_15         17
 #define QRDEC_ECI_SHIFT_JIS           20
 #define QRDEC_ECI_UTF_8               26

 #define QRDEC_PIXEL_WHITE	0
 #define QRDEC_PIXEL_BLACK	1
 #define QRDEC_PIXEL_REGION	2

 #define QRDEC_MAX_BITMAP              3917
 #define QRDEC_MAX_PAYLOAD             8896
 #define QRDEC_MAX_REGIONS	254
 #define QRDEC_MAX_CAPSTONES	32
 #define QRDEC_MAX_GRIDS		8
 #define QRDEC_MAX_VERSION             40
 #define QRDEC_MAX_ALIGNMENT           7
 #define QRDEC_MAX_POLY                64

 #define QRDEC_PERSPECTIVE_PARAMS	8

 #define QRDEC_FORMAT_MAX_ERROR        3
 #define QRDEC_FORMAT_SYNDROMES        (QRDEC_FORMAT_MAX_ERROR*2)
 #define QRDEC_FORMAT_BITS             15

 #define QRDEC_FLOOD_FILL_MAX_DEPTH    4096

 #define QRDEC_THRESHOLD_S_MIN         1
 #define QRDEC_THRESHOLD_S_DEN         8
 #define QRDEC_THRESHOLD_T             5


 structure
 {
 _cord corners[4];
 Z size;
 B cell_bitmap[QRDEC_MAX_BITMAP];
 }
 _qrdecodercode;



 structure
 {
 Z version;
 Z ecc_level;
 Z mask;
 Z data_type;
 B payload[QRDEC_MAX_PAYLOAD];
 Z payload_len;
 Y eci;
 }
 _qrdecoderdata;


 structure
 {
 _cord seed;
 Z count;
 Z capstone;
 }
 _qrdecoderregion;


 structure
 {
 Z ring;
 Z stone;
 _cord corners[4];
 _cord center;
 D c[QRDEC_PERSPECTIVE_PARAMS];
 Z qr_grid;
 }
 _qrdecodercapstone;



 structure
 {
 Z caps[3];
 Z align_region;
 _cord align;
 _cord tpep[3];
 Z hscan;
 Z vscan;
 Z grid_size;
 D c[QRDEC_PERSPECTIVE_PARAMS];
 }
 _qrdecodergrid;




 structure
 {
 Z bs,dw,ns;
 }
 _qrdecoderrsparams;

 structure
 {
 Z data_bytes;
 Z apat[QRDEC_MAX_ALIGNMENT];
 _qrdecoderrsparams ecc[4];
 }
 _qrdecoderversioninfo;

 structure
 {
 Z index;
 D distance;
 }
 _qrdecoderneighbour;

 structure
 {
 _qrdecoderneighbour n[QRDEC_MAX_CAPSTONES];
 Z count;
 }
 _qrdecoderneighbourlist;

 structure
 {
 Z p;
 BP log,exp;
 }
 _qrdecodergaloisfield;


 structure
 {
 B raw[QRDEC_MAX_PAYLOAD];
 Z data_bits;
 Z ptr;
 B data[QRDEC_MAX_PAYLOAD];
 }
 _qrdecoderdatastream;

 structure
 {
 _cord ref;
 Z scores[4];
 _cord *corners;
 }
 _qrdecoderpolygonscoredata;


 structure
 {
 Z num_regions;
 _qrdecoderregion regions[QRDEC_MAX_REGIONS];
 Z num_capstones;
 _qrdecodercapstone capstones[QRDEC_MAX_CAPSTONES];
 Z num_grids;
 _qrdecodergrid grids[QRDEC_MAX_GRIDS];
 }
 _qrdecoderctx;


/*-----------------------------------------------------------------------*/


 _qrdecoderversioninfo qrdecoder_version_db[QRDEC_MAX_VERSION+1] =
 {
 {0},
 {.data_bytes=26,   .apat={0},                      .ecc={{.bs=26,.dw=16,.ns=1}, {.bs=26, .dw=19, .ns=1},  {.bs=26,.dw=9,.ns=1},  {.bs=26,.dw=13,.ns=1}}},
 {.data_bytes=44,   .apat={6,18,0},                 .ecc={{.bs=44,.dw=28,.ns=1}, {.bs=44, .dw=34, .ns=1},  {.bs=44,.dw=16,.ns=1}, {.bs=44,.dw=22,.ns=1}}},
 {.data_bytes=70,   .apat={6,22,0},                 .ecc={{.bs=70,.dw=44,.ns=1}, {.bs=70, .dw=55, .ns=1},  {.bs=35,.dw=13,.ns=2}, {.bs=35,.dw=17,.ns=2}}},
 {.data_bytes=100,  .apat={6,26,0},                 .ecc={{.bs=50,.dw=32,.ns=2}, {.bs=100,.dw=80, .ns=1},  {.bs=25,.dw=9,.ns=4},  {.bs=50,.dw=24,.ns=2}}},
 {.data_bytes=134,  .apat={6,30,0},                 .ecc={{.bs=67,.dw=43,.ns=2}, {.bs=134,.dw=108,.ns=1},  {.bs=33,.dw=11,.ns=2}, {.bs=33,.dw=15,.ns=2}}},
 {.data_bytes=172,  .apat={6,34,0},                 .ecc={{.bs=43,.dw=27,.ns=4}, {.bs=86, .dw=68, .ns=2},  {.bs=43,.dw=15,.ns=4}, {.bs=43,.dw=19,.ns=4}}},
 {.data_bytes=196,  .apat={6,22,38,0},              .ecc={{.bs=49,.dw=31,.ns=4}, {.bs=98, .dw=78, .ns=2},  {.bs=39,.dw=13,.ns=4}, {.bs=32,.dw=14,.ns=2}}},
 {.data_bytes=242,  .apat={6,24,42,0},              .ecc={{.bs=60,.dw=38,.ns=2}, {.bs=121,.dw=97, .ns=2},  {.bs=40,.dw=14,.ns=4}, {.bs=40,.dw=18,.ns=4}}},
 {.data_bytes=292,  .apat={6,26,46,0},              .ecc={{.bs=58,.dw=36,.ns=3}, {.bs=146,.dw=116,.ns=2},  {.bs=36,.dw=12,.ns=4}, {.bs=36,.dw=16,.ns=4}}},
 {.data_bytes=346,  .apat={6,28,50,0},              .ecc={{.bs=69,.dw=43,.ns=4}, {.bs=86, .dw=68, .ns=2},  {.bs=43,.dw=15,.ns=6}, {.bs=43,.dw=19,.ns=6}}}, // 10
 {.data_bytes=404,  .apat={6,30,54,0},              .ecc={{.bs=80,.dw=50,.ns=1}, {.bs=101,.dw=81, .ns=4},  {.bs=36,.dw=12,.ns=3}, {.bs=50,.dw=22,.ns=4}}},
 {.data_bytes=466,  .apat={6,32,58,0},              .ecc={{.bs=58,.dw=36,.ns=6}, {.bs=116,.dw=92, .ns=2},  {.bs=42,.dw=14,.ns=7}, {.bs=46,.dw=20,.ns=4}}},
 {.data_bytes=532,  .apat={6,34,62,0},              .ecc={{.bs=59,.dw=37,.ns=8}, {.bs=133,.dw=107,.ns=4},  {.bs=33,.dw=11,.ns=12},{.bs=44,.dw=20,.ns=8}}},
 {.data_bytes=581,  .apat={6,26,46,66,0},           .ecc={{.bs=64,.dw=40,.ns=4}, {.bs=145,.dw=115,.ns=3},  {.bs=36,.dw=12,.ns=11},{.bs=36,.dw=16,.ns=11}}},
 {.data_bytes=655,  .apat={6,26,48,70,0},           .ecc={{.bs=65,.dw=41,.ns=5}, {.bs=109,.dw=87, .ns=5},  {.bs=36,.dw=12,.ns=11},{.bs=54,.dw=24,.ns=5}}},
 {.data_bytes=733,  .apat={6,26,50,74,0},           .ecc={{.bs=73,.dw=45,.ns=7}, {.bs=122,.dw=98, .ns=5},  {.bs=45,.dw=15,.ns=3}, {.bs=43,.dw=19,.ns=15}}},
 {.data_bytes=815,  .apat={6,30,54,78,0},           .ecc={{.bs=74,.dw=46,.ns=10},{.bs=135,.dw=107,.ns=1},  {.bs=42,.dw=14,.ns=2}, {.bs=50,.dw=22,.ns=1}}},
 {.data_bytes=901,  .apat={6,30,56,82,0},           .ecc={{.bs=69,.dw=43,.ns=9}, {.bs=150,.dw=120,.ns=5},  {.bs=42,.dw=14,.ns=2}, {.bs=50,.dw=22,.ns=17}}},
 {.data_bytes=991,  .apat={6,30,58,86,0},           .ecc={{.bs=70,.dw=44,.ns=3}, {.bs=141,.dw=113,.ns=3},  {.bs=39,.dw=13,.ns=9}, {.bs=47,.dw=21,.ns=17}}},
 {.data_bytes=1085, .apat={6,34,62,90,0},           .ecc={{.bs=67,.dw=41,.ns=3}, {.bs=135,.dw=107,.ns=3},  {.bs=43,.dw=15,.ns=15},{.bs=54,.dw=24,.ns=15}}}, // 20
 {.data_bytes=1156, .apat={6,28,50,72,92,0},        .ecc={{.bs=68,.dw=42,.ns=17},{.bs=144,.dw=116,.ns=4},  {.bs=46,.dw=16,.ns=19},{.bs=50,.dw=22,.ns=17}}},
 {.data_bytes=1258, .apat={6,26,50,74,98,0},        .ecc={{.bs=74,.dw=46,.ns=17},{.bs=139,.dw=111,.ns=2},  {.bs=37,.dw=13,.ns=34},{.bs=54,.dw=24,.ns=7}}},
 {.data_bytes=1364, .apat={6,30,54,78,102,0},       .ecc={{.bs=75,.dw=47,.ns=4}, {.bs=151,.dw=121,.ns=4},  {.bs=45,.dw=15,.ns=16},{.bs=54,.dw=24,.ns=11}}},
 {.data_bytes=1474, .apat={6,28,54,80,106,0},       .ecc={{.bs=73,.dw=45,.ns=6}, {.bs=147,.dw=117,.ns=6},  {.bs=46,.dw=16,.ns=30},{.bs=54,.dw=24,.ns=11}}},
 {.data_bytes=1588, .apat={6,32,58,84,110,0},       .ecc={{.bs=75,.dw=47,.ns=8}, {.bs=132,.dw=106,.ns=8},  {.bs=45,.dw=15,.ns=22},{.bs=54,.dw=24,.ns=7}}},
 {.data_bytes=1706, .apat={6,30,58,86,114,0},       .ecc={{.bs=74,.dw=46,.ns=19},{.bs=142,.dw=114,.ns=10}, {.bs=46,.dw=16,.ns=33},{.bs=50,.dw=22,.ns=28}}},
 {.data_bytes=1828, .apat={6,34,62,90,118,0},       .ecc={{.bs=73,.dw=45,.ns=22},{.bs=152,.dw=122,.ns=8},  {.bs=45,.dw=15,.ns=12},{.bs=53,.dw=23,.ns=8}}},
 {.data_bytes=1921, .apat={6,26,50,74,98,122,0},    .ecc={{.bs=73,.dw=45,.ns=3}, {.bs=147,.dw=117,.ns=3},  {.bs=45,.dw=15,.ns=11},{.bs=54,.dw=24,.ns=4}}},
 {.data_bytes=2051, .apat={6,30,54,78,102,126,0},   .ecc={{.bs=73,.dw=45,.ns=21},{.bs=146,.dw=116,.ns=7},  {.bs=45,.dw=15,.ns=19},{.bs=53,.dw=23,.ns=1}}},
 {.data_bytes=2185, .apat={6,26,52,78,104,130,0},   .ecc={{.bs=75,.dw=47,.ns=19},{.bs=145,.dw=115,.ns=5},  {.bs=45,.dw=15,.ns=23},{.bs=54,.dw=24,.ns=15}}}, // 30
 {.data_bytes=2323, .apat={6,30,56,82,108,134,0},   .ecc={{.bs=74,.dw=46,.ns=2}, {.bs=145,.dw=115,.ns=13}, {.bs=45,.dw=15,.ns=23},{.bs=54,.dw=24,.ns=42}}},
 {.data_bytes=2465, .apat={6,34,60,86,112,138,0},   .ecc={{.bs=74,.dw=46,.ns=10},{.bs=145,.dw=115,.ns=17}, {.bs=45,.dw=15,.ns=19},{.bs=54,.dw=24,.ns=10}}},
 {.data_bytes=2611, .apat={6,30,58,86,114,142,0},   .ecc={{.bs=74,.dw=46,.ns=14},{.bs=145,.dw=115,.ns=17}, {.bs=45,.dw=15,.ns=11},{.bs=54,.dw=24,.ns=29}}},
 {.data_bytes=2761, .apat={6,34,62,90,118,146,0},   .ecc={{.bs=74,.dw=46,.ns=14},{.bs=145,.dw=115,.ns=13}, {.bs=46,.dw=16,.ns=59},{.bs=54,.dw=24,.ns=44}}},
 {.data_bytes=2876, .apat={6,30,54,78,102,126,150}, .ecc={{.bs=75,.dw=47,.ns=12},{.bs=151,.dw=121,.ns=12}, {.bs=45,.dw=15,.ns=22},{.bs=54,.dw=24,.ns=39}}},
 {.data_bytes=3034, .apat={6,24,50,76,102,128,154}, .ecc={{.bs=75,.dw=47,.ns=6}, {.bs=151,.dw=121,.ns=6},  {.bs=45,.dw=15,.ns=2}, {.bs=54,.dw=24,.ns=46}}},
 {.data_bytes=3196, .apat={6,28,54,80,106,132,158}, .ecc={{.bs=74,.dw=46,.ns=29},{.bs=152,.dw=122,.ns=17}, {.bs=45,.dw=15,.ns=24},{.bs=54,.dw=24,.ns=49}}},
 {.data_bytes=3362, .apat={6,32,58,84,110,136,162}, .ecc={{.bs=74,.dw=46,.ns=13},{.bs=152,.dw=122,.ns=4},  {.bs=45,.dw=15,.ns=42},{.bs=54,.dw=24,.ns=48}}},
 {.data_bytes=3532, .apat={6,26,54,82,110,138,166}, .ecc={{.bs=75,.dw=47,.ns=40},{.bs=147,.dw=117,.ns=20}, {.bs=45,.dw=15,.ns=10},{.bs=54,.dw=24,.ns=43}}},
 {.data_bytes=3706, .apat={6,30,58,86,114,142,170}, .ecc={{.bs=75,.dw=47,.ns=18},{.bs=148,.dw=118,.ns=19}, {.bs=45,.dw=15,.ns=20},{.bs=54,.dw=24,.ns=34}}}
 };



 B qr_decoder_gf16_exp[16]={0x01,0x02,0x04,0x08,0x03,0x06,0x0c,0x0b,0x05,0x0a,0x07,0x0e,0x0f,0x0d,0x09,0x01 };
 B qr_decoder_gf16_log[16]={0x00,0x0f,0x01,0x04,0x02,0x08,0x05,0x0a,0x03,0x0e,0x09,0x07,0x06,0x0d,0x0b,0x0c };
 S _qrdecodergaloisfield gf16={ .p=15, .log=qr_decoder_gf16_log, .exp=qr_decoder_gf16_exp };


 B qr_decoder_gf256_exp[256]=
 {
 0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1d,0x3a,0x74,0xe8,0xcd,0x87,0x13,0x26,0x4c,0x98,0x2d,0x5a,0xb4,0x75,0xea,0xc9,0x8f,0x03,0x06,0x0c,0x18,0x30,0x60,0xc0,
 0x9d,0x27,0x4e,0x9c,0x25,0x4a,0x94,0x35,0x6a,0xd4,0xb5,0x77,0xee,0xc1,0x9f,0x23,0x46,0x8c,0x05,0x0a,0x14,0x28,0x50,0xa0,0x5d,0xba,0x69,0xd2,0xb9,0x6f,0xde,0xa1,
 0x5f,0xbe,0x61,0xc2,0x99,0x2f,0x5e,0xbc,0x65,0xca,0x89,0x0f,0x1e,0x3c,0x78,0xf0,0xfd,0xe7,0xd3,0xbb,0x6b,0xd6,0xb1,0x7f,0xfe,0xe1,0xdf,0xa3,0x5b,0xb6,0x71,0xe2,
 0xd9,0xaf,0x43,0x86,0x11,0x22,0x44,0x88,0x0d,0x1a,0x34,0x68,0xd0,0xbd,0x67,0xce,0x81,0x1f,0x3e,0x7c,0xf8,0xed,0xc7,0x93,0x3b,0x76,0xec,0xc5,0x97,0x33,0x66,0xcc,
 0x85,0x17,0x2e,0x5c,0xb8,0x6d,0xda,0xa9,0x4f,0x9e,0x21,0x42,0x84,0x15,0x2a,0x54,0xa8,0x4d,0x9a,0x29,0x52,0xa4,0x55,0xaa,0x49,0x92,0x39,0x72,0xe4,0xd5,0xb7,0x73,
 0xe6,0xd1,0xbf,0x63,0xc6,0x91,0x3f,0x7e,0xfc,0xe5,0xd7,0xb3,0x7b,0xf6,0xf1,0xff,0xe3,0xdb,0xab,0x4b,0x96,0x31,0x62,0xc4,0x95,0x37,0x6e,0xdc,0xa5,0x57,0xae,0x41,
 0x82,0x19,0x32,0x64,0xc8,0x8d,0x07,0x0e,0x1c,0x38,0x70,0xe0,0xdd,0xa7,0x53,0xa6,0x51,0xa2,0x59,0xb2,0x79,0xf2,0xf9,0xef,0xc3,0x9b,0x2b,0x56,0xac,0x45,0x8a,0x09,
 0x12,0x24,0x48,0x90,0x3d,0x7a,0xf4,0xf5,0xf7,0xf3,0xfb,0xeb,0xcb,0x8b,0x0b,0x16,0x2c,0x58,0xb0,0x7d,0xfa,0xe9,0xcf,0x83,0x1b,0x36,0x6c,0xd8,0xad,0x47,0x8e,0x01
 };

 B qr_decoder_gf256_log[256]=
 {
 0x00,0xff,0x01,0x19,0x02,0x32,0x1a,0xc6,0x03,0xdf,0x33,0xee,0x1b,0x68,0xc7,0x4b,0x04,0x64,0xe0,0x0e,0x34,0x8d,0xef,0x81,0x1c,0xc1,0x69,0xf8,0xc8,0x08,0x4c,0x71,
 0x05,0x8a,0x65,0x2f,0xe1,0x24,0x0f,0x21,0x35,0x93,0x8e,0xda,0xf0,0x12,0x82,0x45,0x1d,0xb5,0xc2,0x7d,0x6a,0x27,0xf9,0xb9,0xc9,0x9a,0x09,0x78,0x4d,0xe4,0x72,0xa6,
 0x06,0xbf,0x8b,0x62,0x66,0xdd,0x30,0xfd,0xe2,0x98,0x25,0xb3,0x10,0x91,0x22,0x88,0x36,0xd0,0x94,0xce,0x8f,0x96,0xdb,0xbd,0xf1,0xd2,0x13,0x5c,0x83,0x38,0x46,0x40,
 0x1e,0x42,0xb6,0xa3,0xc3,0x48,0x7e,0x6e,0x6b,0x3a,0x28,0x54,0xfa,0x85,0xba,0x3d,0xca,0x5e,0x9b,0x9f,0x0a,0x15,0x79,0x2b,0x4e,0xd4,0xe5,0xac,0x73,0xf3,0xa7,0x57,
 0x07,0x70,0xc0,0xf7,0x8c,0x80,0x63,0x0d,0x67,0x4a,0xde,0xed,0x31,0xc5,0xfe,0x18,0xe3,0xa5,0x99,0x77,0x26,0xb8,0xb4,0x7c,0x11,0x44,0x92,0xd9,0x23,0x20,0x89,0x2e,
 0x37,0x3f,0xd1,0x5b,0x95,0xbc,0xcf,0xcd,0x90,0x87,0x97,0xb2,0xdc,0xfc,0xbe,0x61,0xf2,0x56,0xd3,0xab,0x14,0x2a,0x5d,0x9e,0x84,0x3c,0x39,0x53,0x47,0x6d,0x41,0xa2,
 0x1f,0x2d,0x43,0xd8,0xb7,0x7b,0xa4,0x76,0xc4,0x17,0x49,0xec,0x7f,0x0c,0x6f,0xf6,0x6c,0xa1,0x3b,0x52,0x29,0x9d,0x55,0xaa,0xfb,0x60,0x86,0xb1,0xbb,0xcc,0x3e,0x5a,
 0xcb,0x59,0x5f,0xb0,0x9c,0xa9,0xa0,0x51,0x0b,0xf5,0x16,0xeb,0x7a,0x75,0x2c,0xd7,0x4f,0xae,0xd5,0xe9,0xe6,0xe7,0xad,0xe8,0x74,0xd6,0xf4,0xea,0xa8,0x50,0x58,0xaf
 };



 _qrdecodergaloisfield gf256={ .p=255, .log=qr_decoder_gf256_log, .exp=qr_decoder_gf256_exp };

/*-----------------------------------------------------------------------*/


 V aa_QrDecPolyAdd                     (BP dst,BP src,B c,Z shift,_qrdecodergaloisfield*gf)
 {
 Z i,log_c,p;
 B v;

 log_c=gf->log[c];
 if(!c) return;
 for(i=0;i<QRDEC_MAX_POLY;i++)
  {
  p=i+shift;
  v=src[i];
  if(p<0||p>=QRDEC_MAX_POLY)	continue;
  if(!v) continue;
  dst[p]^=gf->exp[(gf->log[v]+log_c)%gf->p];
  }
 }


 B aa_QrDecPolyEval                    (BP s,B x,_qrdecodergaloisfield*gf)
 {
 Z i;
 B c,sum=0;
 B log_x=gf->log[x];

 if(!x) return s[0];
 for(i=0;i<QRDEC_MAX_POLY;i++)
  {
  c=s[i];
  if(!c) continue;
  sum^=gf->exp[(gf->log[c]+log_x*i)%gf->p];
  }
 return sum;
 }




 V aa_QrDecBerlekampMassey             (BP s,Z qN,_qrdecodergaloisfield*gf,BP sigma)
 {
 B TT[QRDEC_MAX_POLY];
 B qC[QRDEC_MAX_POLY];
 B qB[QRDEC_MAX_POLY];
 Z qL=0;
 Z m=1;
 B b=1;
 B mult,d;
 Z n,i;

 aaMemoryFill(qB,sizeof(qB),0);
 aaMemoryFill(qC,sizeof(qC),0);
 qB[0]=1;
 qC[0]=1;
 for(n=0;n<qN;n++)
  {
  d=s[n];
  for(i=1;i<=qL;i++)
   {
   if(!(qC[i]&&s[n-i]))	continue;
   d^=gf->exp[(gf->log[qC[i]]+gf->log[s[n-i]])%gf->p];
   }
  mult=gf->exp[(gf->p-gf->log[b]+gf->log[d])%gf->p];
  if(!d) { m++; }
  else
  if(qL*2<=n)
   {
   aaMemoryCopy(TT,sizeof(TT),qC);
   aa_QrDecPolyAdd(qC,qB,mult,m,gf);
   aaMemoryCopy(qB,sizeof(qB),TT);
   qL=n+1-qL;
   b=d;
   m=1;
   }
  else
   {
   aa_QrDecPolyAdd(qC,qB,mult,m,gf);
   m++;
   }
  }
 aaMemoryCopy(sigma,QRDEC_MAX_POLY,qC);
 }




 Z aa_QrDecBlockSyndromes              (BP data,Z bs,Z npar,BP s)
 {
 B c;
 Z j,i,nonzero=0;

 aaMemoryFill(s,QRDEC_MAX_POLY,0);
 for(i=0;i<npar;i++)
  {
  for(j=0;j<bs;j++)
   {
   c=data[bs-j-1];
   if(!c)continue;
   s[i]^=qr_decoder_gf256_exp[((int)qr_decoder_gf256_log[c]+i*j)%255];
   }
  if(s[i])	nonzero=1;
  }
 //if(!nonzero) { return RET_NO; }
 return nonzero;
 }



 V aa_QrDecElocPoly                    (BP omega,BP s,BP sigma,Z npar)
 {
 Z i,j;
 B b,a,log_a;

 aaMemoryFill(omega,QRDEC_MAX_POLY,0);
 for(i=0;i<npar;i++)
  {
  a=sigma[i];
  log_a=qr_decoder_gf256_log[a];
  if(!a)	continue;
  for(j=0;j+1<QRDEC_MAX_POLY;j++)
   {
   b=s[j+1];
   if(i+j>=npar)	break;
   if(!b)	continue;
   omega[i+j]^=qr_decoder_gf256_exp[(log_a+qr_decoder_gf256_log[b])%255];
   }
  }
 }




 B aa_QrDecCorrectBlock                (BP data,_qrdecoderrsparams*ecc)
 {
 Z i,npar=ecc->bs-ecc->dw;
 B s[QRDEC_MAX_POLY],sigma[QRDEC_MAX_POLY],sigma_deriv[QRDEC_MAX_POLY],omega[QRDEC_MAX_POLY];
 B xinv,sd_x,omega_x,error;

 if(!aa_QrDecBlockSyndromes(data,ecc->bs,npar,s))		return QRDEC_SUCCESS;
 aa_QrDecBerlekampMassey(s,npar,&gf256,sigma);
 aaMemoryFill(sigma_deriv,QRDEC_MAX_POLY,0);
 for(i=0;i+1<QRDEC_MAX_POLY;i+=2)	sigma_deriv[i]=sigma[i+1];
 aa_QrDecElocPoly(omega,s,sigma,npar-1);
 for(i=0;i<ecc->bs;i++)
  {
  xinv=qr_decoder_gf256_exp[255-i];
  if(!aa_QrDecPolyEval(sigma,xinv,&gf256))
   {
   sd_x=aa_QrDecPolyEval(sigma_deriv,xinv,&gf256);
   omega_x=aa_QrDecPolyEval(omega,xinv,&gf256);
   error=qr_decoder_gf256_exp[(255-qr_decoder_gf256_log[sd_x]+qr_decoder_gf256_log[omega_x])%255];
   data[ecc->bs-i-1]^=error;
   }
  }
 if(aa_QrDecBlockSyndromes(data,ecc->bs,npar,s))		return RET_FAILED;
 return QRDEC_SUCCESS;
 }



 Z aa_QrDecFormatSyndromes             (W u,BP s)
 {
 Z j,i,nonzero=0;

 aaMemoryFill(s,QRDEC_MAX_POLY,0);
 for(i=0;i<QRDEC_FORMAT_SYNDROMES;i++)
  {
  s[i]=0;
  for(j=0;j<QRDEC_FORMAT_BITS;j++)
   {
   if(u&(1<<j)) { s[i]^=qr_decoder_gf16_exp[((i+1)*j)%15]; }
   }
  if(s[i])	nonzero=1;
  }
 return nonzero;
 }



 B aa_QrDecCorrectFormat               (WP f_ret)
 {
 W u=*f_ret;
 Z i;
 B s[QRDEC_MAX_POLY];
 B sigma[QRDEC_MAX_POLY];

 if(!aa_QrDecFormatSyndromes(u,s)) { return QRDEC_SUCCESS; }
 aa_QrDecBerlekampMassey(s,QRDEC_FORMAT_SYNDROMES,&gf16,sigma);
 for(i=0;i<15;i++)
  {
  if(!aa_QrDecPolyEval(sigma,qr_decoder_gf16_exp[15-i],&gf16)) { u^=(1<<i); }
  }
 if(aa_QrDecFormatSyndromes(u,s)) { return RET_BADFORMAT; }
 *f_ret=u;
 return QRDEC_SUCCESS;
 }



 static inline Z aa_QrDecGridBit       (_qrdecodercode*code,Z x,Z y)
 {
 Z p=y*code->size+x;
 return (code->cell_bitmap[p>>3]>>(p&7))&1;
 }



 B aa_QrDecReadFormat                  (_qrdecodercode*code,_qrdecoderdata*data,Z which)
 {
 Z i;
 static Z xs[15]={8,8,8,8,8,8,8,8,7,5,4,3,2,1,0};
 static Z ys[15]={0,1,2,3,4,5,7,8,8,8,8,8,8,8,8};
 W format=0;
 W fdata;
 B err;

 if(which)
  {
  for(i=0;i<7;i++) format=(format<<1)|aa_QrDecGridBit(code,8,code->size-1-i);
  for(i=0;i<8;i++) format=(format<<1)|aa_QrDecGridBit(code,code->size-8+i,8);
  }
 else
  {
  for(i=14;i>=0;i--) { format=(format<<1)|aa_QrDecGridBit(code,xs[i],ys[i]); }
  }
 format^=0x5412;
 err=aa_QrDecCorrectFormat(&format);
 if(err) return err;
 fdata=format>>10;
 data->ecc_level=fdata>>3;
 data->mask=fdata&7;
 return QRDEC_SUCCESS;
 }



 Z aa_QrDecMaskBit                     (Z mask,Z i,Z j)
 {
 switch (mask)
  {
  case 0: return !((i+j)%2);
  case 1: return !(i%2);
  case 2: return !(j%3);
  case 3: return !((i+j)%3);
  case 4: return !(((i/2)+(j/3))%2);
  case 5: return !((i*j)%2+(i*j)%3);
  case 6: return !(((i*j)%2+(i*j)%3)%2);
  case 7: return !(((i*j)%3+(i+j)%2)%2);
  }
 return 0;
 }



 Z aa_QrDecReservedCell                (Z version,Z i,Z j)
 {
 _qrdecoderversioninfo *ver=&qrdecoder_version_db[version];
 Z size=version*4+17;
 Z p,ai=-1,aj=-1,a;
 if(i<9&&j<9)		return 1;
 if(i+8>=size&&j<9)		return 1;
 if(i<9&&j+8>=size)		return 1;
 if(i==6||j==6)		return 1;
 if(version>=7)
  {
  if(i<6&&j+11>=size)		return 1;
  if(i+11>=size&&j<6)		return 1;
  }
 for(a=0;a<QRDEC_MAX_ALIGNMENT&&ver->apat[a];a++)
  {
  p=ver->apat[a];
  if(abs(p-i)<3)		ai=a;
  if(abs(p-j)<3)		aj=a;
  }
 if(ai>=0&&aj>=0)
  {
  a--;
  if(ai>0&&ai<a)		return 1;
  if(aj>0&&aj<a)		return 1;
  if(aj==a&&ai==a)		return 1;
  }
 return 0;
 }



 V aa_QrDecReadBit                     (_qrdecodercode*code,_qrdecoderdata*data,_qrdecoderdatastream*ds,Z i,Z j)
 {
 Z bitpos=ds->data_bits&7;
 Z bytepos=ds->data_bits>>3;
 Z v=aa_QrDecGridBit(code,j,i);
 if(aa_QrDecMaskBit(data->mask,i,j)) { v^=1; }
 if(v) ds->raw[bytepos]|=(0x80>>bitpos);
 ds->data_bits++;
 }



 V aa_QrDecReadData                    (_qrdecodercode*code,_qrdecoderdata*data,_qrdecoderdatastream*ds)
 {
 Z y=code->size-1;
 Z x=code->size-1;
 Z dir=-1;

 while(x>0)
  {
  if(x==6) x--;
  if(!aa_QrDecReservedCell(data->version,y,x))   { aa_QrDecReadBit(code,data,ds,y,x);   }
  if(!aa_QrDecReservedCell(data->version,y,x-1)) { aa_QrDecReadBit(code,data,ds,y,x-1); }
  y+=dir;
  if(y<0||y>=code->size) { dir=-dir;	x-=2;	y+=dir;	}
  }
 }



 B aa_QrDecCodeStreamEcc               (_qrdecoderdata*data,_qrdecoderdatastream*ds)
 {
 _qrdecoderrsparams *ecc;
 _qrdecoderversioninfo *ver=&qrdecoder_version_db[data->version];
 _qrdecoderrsparams *sb_ecc=&ver->ecc[data->ecc_level];
 _qrdecoderrsparams lb_ecc;
 Z lb_count=(ver->data_bytes-sb_ecc->bs*sb_ecc->ns)/(sb_ecc->bs+1);
 Z bc=lb_count+sb_ecc->ns;
 Z ecc_offset=sb_ecc->dw*bc+lb_count;
 Z dst_offset=0;
 Z i,j,num_ec;
 B err;
 BP dst;

 aaMemoryCopy(&lb_ecc,sizeof(lb_ecc),sb_ecc);
 lb_ecc.dw++;
 lb_ecc.bs++;
 for(i=0;i<bc;i++)
  {
  dst=ds->data+dst_offset;
  ecc=(i<sb_ecc->ns)?sb_ecc:&lb_ecc;
  num_ec=ecc->bs-ecc->dw;
  for(j=0;j<ecc->dw;j++)	dst[j]=ds->raw[j*bc+i];
  for(j=0;j<num_ec;j++)	dst[ecc->dw+j]=ds->raw[ecc_offset+j*bc+i];
  err=aa_QrDecCorrectBlock(dst,ecc);
  if(err)	return err;
  dst_offset+=ecc->dw;
  }
 ds->data_bits=dst_offset*8;
 return QRDEC_SUCCESS;
 }



 S inline Z aa_QrDecBitsRemaining      (_qrdecoderdatastream*ds)
 {
 return ds->data_bits-ds->ptr;
 }



 Z aa_QrDecTakeBits                    (_qrdecoderdatastream*ds,Z len)
 {
 Z bitpos,ret=0;
 B b;

 while(len&&(ds->ptr<ds->data_bits))
  {
  b=ds->data[ds->ptr>>3];
  bitpos=ds->ptr&7;
  ret<<=1;
  if((b<<bitpos)&0x80) ret|=1;
  ds->ptr++;
  len--;
  }
 return ret;
 }



 Z aa_QrDecNumericTuple                (_qrdecoderdata*data,_qrdecoderdatastream*ds,Z bits,Z digits)
 {
 Z tuple,i;

 if(aa_QrDecBitsRemaining(ds)<bits)return -1;
 tuple=aa_QrDecTakeBits(ds,bits);
 for(i=digits-1;i>=0;i--)
  {
  data->payload[data->payload_len+i]=tuple%10+'0';
  tuple/=10;
  }
 data->payload_len+=digits;
 return 0;
 }


 B aa_QrDecDecodeNumeric               (_qrdecoderdata*data,_qrdecoderdatastream*ds)
 {
 Z count,bits=14;

 if(data->version<10)	bits=10;
 else
 if(data->version<27)	bits=12;
 count=aa_QrDecTakeBits(ds,bits);
 if(data->payload_len+count+1>QRDEC_MAX_PAYLOAD) return RET_OVERFLOW;
 while(count>=3)
  {
  if(aa_QrDecNumericTuple(data,ds,10,3)<0) return RET_UNDERFLOW;
  count-=3;
  }
 if(count>=2)
  {
  if(aa_QrDecNumericTuple(data,ds,7,2)<0) return RET_UNDERFLOW;
  count-=2;
  }
 if(count)
  {
  if(aa_QrDecNumericTuple(data,ds,4,1)<0) return RET_UNDERFLOW;
  count--;
  }
 return QRDEC_SUCCESS;
 }



 Z aa_QrDecAlphaTuple                  (_qrdecoderdata*data,_qrdecoderdatastream*ds,Z bits,Z digits)
 {
 static CP alpha_map="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";
 Z tuple,i;

 if(aa_QrDecBitsRemaining(ds)<bits)return -1;
 tuple=aa_QrDecTakeBits(ds,bits);
 for(i=0;i<digits;i++)
  {
  data->payload[data->payload_len+digits-i-1]=alpha_map[tuple%45];
  tuple/=45;
  }
 data->payload_len+=digits;
 return 0;
 }



 B aa_QrDecDecodeAlpha                 (_qrdecoderdata*data,_qrdecoderdatastream*ds)
 {
 Z count,bits=13;

 if(data->version<10) bits=9; else
 if(data->version<27) bits=11;
 count=aa_QrDecTakeBits(ds,bits);
 if(data->payload_len+count+1>QRDEC_MAX_PAYLOAD)return RET_OVERFLOW;
 while(count>=2)
  {
  if(aa_QrDecAlphaTuple(data,ds,11,2)<0) return RET_UNDERFLOW;
  count-=2;
  }
 if(count)
  {
  if(aa_QrDecAlphaTuple(data,ds,6,1)<0) return RET_UNDERFLOW;
  count--;
  }
 return QRDEC_SUCCESS;
 }


 B aa_QrDecDecodeByte                  (_qrdecoderdata*data,_qrdecoderdatastream*ds)
 {
 Z i,count,bits=16;
 if(data->version<10) { bits=8; }
 count=aa_QrDecTakeBits(ds,bits);
 if(data->payload_len+count+1>QRDEC_MAX_PAYLOAD) { return RET_OVERFLOW;  }
 if(aa_QrDecBitsRemaining(ds)<count*8)                  { return RET_UNDERFLOW; }
 for(i=0;i<count;i++) {	data->payload[data->payload_len++]=aa_QrDecTakeBits(ds,8); }
 return QRDEC_SUCCESS;
 }


 B aa_QrDecDecodeKanji                 (_qrdecoderdata*data,_qrdecoderdatastream*ds)
 {
 Z count,i,bits=12;
 Z d,msB,lsB,intermediate;
 W sjw;

 if(data->version<10)	bits=8;
 else
 if(data->version<27)bits=10;
 count=aa_QrDecTakeBits(ds,bits);
 if(data->payload_len+count*2+1>QRDEC_MAX_PAYLOAD)return RET_OVERFLOW;
 if(aa_QrDecBitsRemaining(ds)<count*13)	return RET_UNDERFLOW;
 for(i=0;i<count;i++)
  {
  d=aa_QrDecTakeBits(ds,13);
  msB=d/0xc0;
  lsB=d%0xc0;
  intermediate=(msB<<8)|lsB;
  if(intermediate+0x8140<=0x9ffc)  {   sjw=intermediate+0x8140;   }
  else                             {   sjw=intermediate+0xc140;   }
  data->payload[data->payload_len++]=sjw>>8;
  data->payload[data->payload_len++]=sjw&0xff;
  }
 return QRDEC_SUCCESS;
 }



 B aa_QrDecDecodeEci                   (_qrdecoderdata*data,_qrdecoderdatastream*ds)
 {
 if(aa_QrDecBitsRemaining(ds)<8)return RET_UNDERFLOW;
 data->eci=aa_QrDecTakeBits(ds,8);
 if((data->eci&0xc0)==0x80)
  {
  if(aa_QrDecBitsRemaining(ds)<8) return RET_UNDERFLOW;
  data->eci=(data->eci<<8)|aa_QrDecTakeBits(ds,8);
  }
 else
 if((data->eci&0xe0)==0xc0)
  {
  if(aa_QrDecBitsRemaining(ds)<16) return RET_UNDERFLOW;
  data->eci=(data->eci<<16)|aa_QrDecTakeBits(ds,16);
  }
 return QRDEC_SUCCESS;
 }




 B aa_QrDecDecodePayload               (_qrdecoderdata*data,_qrdecoderdatastream*ds)
 {
 Z type;
 B err;

 while(aa_QrDecBitsRemaining(ds)>=4)
  {
  err=QRDEC_SUCCESS;
  type=aa_QrDecTakeBits(ds,4);
  switch (type)
   {
   case QRDEC_DATA_TYPE_NUMERIC:	err=aa_QrDecDecodeNumeric(data,ds); break;
   case QRDEC_DATA_TYPE_ALPHA:	err=aa_QrDecDecodeAlpha(data,ds);   break;
   case QRDEC_DATA_TYPE_BYTE:	err=aa_QrDecDecodeByte(data,ds);    break;
   case QRDEC_DATA_TYPE_KANJI:	err=aa_QrDecDecodeKanji(data,ds);   break;
   case 7:	                          err=aa_QrDecDecodeEci(data,ds);     break;
   default:	goto done;
   }
  if(err)	return err;
  if(!(type&(type-1))&&(type>data->data_type))	data->data_type=type;
  }
done:
 if(data->payload_len>=(Z)sizeof(data->payload))	data->payload_len--;
 data->payload[data->payload_len]=0;
 return QRDEC_SUCCESS;
 }




 B aa_QrDecDecode                      (_qrdecodercode*code,_qrdecoderdata*data)
 {
 B err;
 _qrdecoderdatastream ds;

 if((code->size-17)%4)		return RET_BOUNDS;
 aaMemoryFill(data,sizeof(*data),0);
 aaMemoryFill(&ds,sizeof(ds),0);
 data->version=(code->size-17)/4;
 if(data->version<1|| data->version>QRDEC_MAX_VERSION)return RET_OTHER;
 err=aa_QrDecReadFormat(code,data,0);
 if(err)	err=aa_QrDecReadFormat(code,data,1);
 if(err)	return err;
 aa_QrDecReadData(code,data,&ds);
 err=aa_QrDecCodeStreamEcc(data,&ds);
 if(err)	return err;
 err=aa_QrDecDecodePayload(data,&ds);
 if(err)	return err;
 return QRDEC_SUCCESS;
 }

/*-----------------------------------------------------------------------*/



 Z aa_QrDecLineIntersect               (_cord*p0,_cord *p1,_cord*q0,_cord*q1,_cord*r)
 {
 Z a=-(p1->y-p0->y);
 Z b=p1->x-p0->x;
 Z c=-(q1->y-q0->y);
 Z d=q1->x-q0->x;
 Z e=a*p1->x+b*p1->y;
 Z f=c*q1->x+d*q1->y;
 Z det=(a*d)-(b*c);
 if(!det) return 0;
 r->x=(d*e-b*f)/det;
 r->y=(-c*e+a*f)/det;
 return 1;
 }



 V aa_QrDecPerspectiveSetup            (DP c,_cord*rect,D w,D h)
 {
 D x0=rect[0].x;
 D y0=rect[0].y;
 D x1=rect[1].x;
 D y1=rect[1].y;
 D x2=rect[2].x;
 D y2=rect[2].y;
 D x3=rect[3].x;
 D y3=rect[3].y;
 D wden=w*(x2*y3-x3*y2+(x3-x2)*y1+x1*(y2-y3));
 D hden=h*(x2*y3+x1*(y2-y3)-x3*y2+(x3-x2)*y1);
 c[0]=(x1*(x2*y3-x3*y2)+x0*(-x2*y3+x3*y2+(x2-x3)*y1)+x1*(x3-x2)*y0)/wden;
 c[1]=-(x0*(x2*y3+x1*(y2-y3)-x2*y1)-x1*x3*y2+x2*x3*y1+(x1*x3-x2*x3)*y0)/hden;
 c[2]=x0;
 c[3]=(y0*(x1*(y3-y2)-x2*y3+x3*y2)+y1*(x2*y3-x3*y2)+x0*y1*(y2-y3))/wden;
 c[4]=(x0*(y1*y3-y2*y3)+x1*y2*y3-x2*y1*y3+y0*(x3*y2-x1*y2+(x2-x3)*y1))/hden;
 c[5]=y0;
 c[6]=(x1*(y3-y2)+x0*(y2-y3)+(x2-x3)*y1+(x3-x2)*y0)/wden;
 c[7]=(-x2*y3+x1*y3+x3*y2+x0*(y1-y2)-x3*y1+(x2-x1)*y0)/hden;
 }


 V aa_QrDecPerspectiveMap              (DP c,D u,D v,_cord*ret)
 {
 D den=c[6]*u+c[7]*v+1.0;
 D x=(c[0]*u+c[1]*v+c[2])/den;
 D y=(c[3]*u+c[4]*v+c[5])/den;
 ret->x=rint(x);
 ret->y=rint(y);
 }




 V aa_QrDecPerspectiveUnmap            (DP c,_cord*in,DP u,DP v)
 {
 D x=in->x;
 D y=in->y;
 D den=-c[0]*c[7]*y+c[1]*c[6]*y+(c[3]*c[7]-c[4]*c[6])*x +c[0]*c[4]-c[1]*c[3];
 *u=-(c[1]*(y-c[5])-c[2]*c[7]*y+(c[5]*c[7]-c[4])*x+c[2]*c[4])/den;
 *v=(c[0]*(y-c[5])-c[2]*c[6]*y+(c[5]*c[6]-c[3])*x+c[2]*c[3])/den;
 }



 V aa_QrDecAreaCount                   (VP user_data,Z y,Z left,Z right)
 {
 if(y) {}
 ((_qrdecoderregion*)user_data)->count+=right-left+1;
 }



 V aa_QrDecFindOneCorner               (VP user_data,Z y,Z left,Z right)
 {
 _qrdecoderpolygonscoredata*psd=(_qrdecoderpolygonscoredata*)user_data;
 Z xs[2]={left,right};
 Z dy=y-psd->ref.y;
 Z i,dx,d;

 for(i=0;i<2;i++)
  {
  dx=xs[i]-psd->ref.x;
  d=dx*dx+dy*dy;
  if(d>psd->scores[0]) {	psd->scores[0]=d;psd->corners[0].x=xs[i];	psd->corners[0].y=y;		}
  }
 }



 V aa_QrDecFindOtherCorners            (VP user_data,Z y,Z left,Z right)
 {
 _qrdecoderpolygonscoredata*psd;
 Z i,up,scores[4],j;
 Z xs[2];

 psd=(_qrdecoderpolygonscoredata*)user_data;
 xs[0]=left;
 xs[1]=right;
 for(i=0;i<2;i++)
  {
  up=xs[i]*psd->ref.x+y*psd->ref.y;
  right=xs[i]*-psd->ref.y+y*psd->ref.x;
  scores[0]=up; scores[1]=right; scores[2]=-up; scores[3]=-right;
  for(j=0;j<4;j++)
   {
   if(scores[j]>psd->scores[j])
    {
    psd->scores[j]=scores[j];
    psd->corners[j].x=xs[i];
    psd->corners[j].y=y;
    }
   }
  }
 }



 V aa_QrDecFindLeftmostToLine          (VP user_data,Z y,Z left,Z right)
 {
 _qrdecoderpolygonscoredata*psd =(_qrdecoderpolygonscoredata*)user_data;
 Z xs[2]={left,right};
 Z i;

 for(i=0;i<2;i++)
  {
  Z d=-psd->ref.y*xs[i]+psd->ref.x*y;
  if(d<psd->scores[0]) {	psd->scores[0]=d; psd->corners[0].x=xs[i]; psd->corners[0].y=y; }
  }
 }





 V aa_QrDecFloodFillSeedAreaCount      (_qrdecoder*q,Z x,Z y,Z from,Z to,VP user_data,Z depth)
 {
 Z left,right,i;
 BP row;

 left=x; right=x;
 row=q->pixels+y*q->size.w;
 if(depth>=QRDEC_FLOOD_FILL_MAX_DEPTH)	return;
 while(left>0&&row[left-1]==from)	left--;
 while(right<(Z)q->size.w-1&&row[right+1]==from) right++;
 for(i=left;i<=right;i++)	row[i]=to;
 aa_QrDecAreaCount(user_data,y,left,right);
 if(y>0)
  {
  row=q->pixels+(y-1)*q->size.w;
  for(i=left;i<=right;i++) if(row[i]==from) aa_QrDecFloodFillSeedAreaCount(q,i,y-1,from,to,user_data,depth+1);
  }
 if(y<(Z)q->size.h-1)
  {
  row=q->pixels+(y+1)*q->size.w;
  for(i=left;i<=right;i++) if(row[i]==from) aa_QrDecFloodFillSeedAreaCount(q,i,y+1,from,to,user_data,depth+1);
  }
 }




 V aa_QrDecFloodFillSeedFindOneCorner  (_qrdecoder*q,Z x,Z y,Z from,Z to,VP user_data,Z depth)
 {
 Z left,right,i;
 BP row;

 left=x; right=x;
 row=q->pixels+y*q->size.w;
 if(depth>=QRDEC_FLOOD_FILL_MAX_DEPTH)	return;
 while(left>0&&row[left-1]==from)	left--;
 while(right<(Z)q->size.w-1&&row[right+1]==from) right++;
 for(i=left;i<=right;i++)	row[i]=to;
 aa_QrDecFindOneCorner(user_data,y,left,right);
 if(y>0)
  {
  row=q->pixels+(y-1)*q->size.w;
  for(i=left;i<=right;i++) if(row[i]==from) aa_QrDecFloodFillSeedFindOneCorner(q,i,y-1,from,to,user_data,depth+1);
  }
 if(y<(Z)q->size.h-1)
  {
  row=q->pixels+(y+1)*q->size.w;
  for(i=left;i<=right;i++) if(row[i]==from) aa_QrDecFloodFillSeedFindOneCorner(q,i,y+1,from,to,user_data,depth+1);
  }
 }


 V aa_QrDecFloodFillSeedFindOtherCorners            (_qrdecoder*q,Z x,Z y,Z from,Z to,VP user_data,Z depth)
 {
 Z left,right,i;
 BP row;

 left=x; right=x;
 row=q->pixels+y*q->size.w;
 if(depth>=QRDEC_FLOOD_FILL_MAX_DEPTH)	return;
 while(left>0&&row[left-1]==from)	left--;
 while(right<(Z)q->size.w-1&&row[right+1]==from) right++;
 for(i=left;i<=right;i++)	row[i]=to;
 aa_QrDecFindOtherCorners(user_data,y,left,right);
 if(y>0)
  {
  row=q->pixels+(y-1)*q->size.w;
  for(i=left;i<=right;i++) if(row[i]==from) aa_QrDecFloodFillSeedFindOtherCorners(q,i,y-1,from,to,user_data,depth+1);
  }
 if(y<(Z)q->size.h-1)
  {
  row=q->pixels+(y+1)*q->size.w;
  for(i=left;i<=right;i++) if(row[i]==from) aa_QrDecFloodFillSeedFindOtherCorners(q,i,y+1,from,to,user_data,depth+1);
  }
 }



 V aa_QrDecFloodFillSeedFindLeftmostToLine          (_qrdecoder*q,Z x,Z y,Z from,Z to,VP user_data,Z depth)
 {
 Z left,right,i;
 BP row;

 left=x; right=x;
 row=q->pixels+y*q->size.w;
 if(depth>=QRDEC_FLOOD_FILL_MAX_DEPTH)	return;
 while(left>0&&row[left-1]==from)	left--;
 while(right<(Z)q->size.w-1&&row[right+1]==from) right++;
 for(i=left;i<=right;i++)	row[i]=to;
 aa_QrDecFindLeftmostToLine(user_data,y,left,right);
 if(y>0)
  {
  row=q->pixels+(y-1)*q->size.w;
  for(i=left;i<=right;i++) if(row[i]==from) aa_QrDecFloodFillSeedFindLeftmostToLine(q,i,y-1,from,to,user_data,depth+1);
  }
 if(y<(Z)q->size.h-1)
  {
  row=q->pixels+(y+1)*q->size.w;
  for(i=left;i<=right;i++) if(row[i]==from) aa_QrDecFloodFillSeedFindLeftmostToLine(q,i,y+1,from,to,	 user_data,depth+1);
  }
 }



 V aa_QrDecFloodFillSeedNull           (_qrdecoder*q,Z x,Z y,Z from,Z to,VP user_data,Z depth)
 {
 Z left,right,i;
 BP row;

 left=x;
 right=x;
 row=q->pixels+y*q->size.w;
 if(depth>=QRDEC_FLOOD_FILL_MAX_DEPTH)	return;
 while(left>0&&row[left-1]==from)	left--;
 while(right<(Z)q->size.w-1&&row[right+1]==from) right++;
 for(i=left;i<=right;i++)	row[i]=to;
 if(y>0)
  {
  row=q->pixels+(y-1)*q->size.w;
  for(i=left;i<=right;i++)
   {
   if(row[i]==from) aa_QrDecFloodFillSeedNull(q,i,y-1,from,to,user_data,depth+1);
   }
  }
 if(y<(Z)q->size.h-1)
  {
  row=q->pixels+(y+1)*q->size.w;
  for(i=left;i<=right;i++)
   {
   if(row[i]==from) aa_QrDecFloodFillSeedNull(q,i,y+1,from,to,user_data,depth+1);
   }
  }
 }







 V aa_QrDecThreshold                   (_qrdecoder*q)
 {
 Z x,y,w,u;
 Z avg_w=0;
 Z avg_u=0;
 Z threshold_s=q->size.w/QRDEC_THRESHOLD_S_DEN;
 BP row=q->pixels;

 if(threshold_s<QRDEC_THRESHOLD_S_MIN)	threshold_s=QRDEC_THRESHOLD_S_MIN;
 for(y=0;y<(Z)q->size.h;y++)
  {
  aaMemoryFill(q->row_average,sizeof(q->row_average),0);
  for(x=0;x<(Z)q->size.w;x++)
   {
   if(y&1) {	w=x;             u=q->size.w-1-x; }
   else    {	w=q->size.w-1-x; u=x;             }
   avg_w=(avg_w*(threshold_s-1))/threshold_s+row[w];
   avg_u=(avg_u*(threshold_s-1))/threshold_s+row[u];
   q->row_average[w]+=avg_w;
   q->row_average[u]+=avg_u;
   }
  for(x=0;x<(Z)q->size.w;x++)
   {
   if(row[x]<q->row_average[x]*(100-QRDEC_THRESHOLD_T)/(200*threshold_s)) row[x]=QRDEC_PIXEL_BLACK;
   else                                                                   row[x]=QRDEC_PIXEL_WHITE;
   }
  row+=q->size.w;
  }
 }





 Z aa_QrDecRegionCode                  (_qrdecoder*q,Z x,Z y)
 {
 Z pixel,region;
 _qrdecoderctx*ctx;
 _qrdecoderregion*box;

 if(x<0||y<0||x>=(Z)q->size.w||y>=(Z)q->size.h) return -1;
 pixel=q->pixels[y*(Z)q->size.w+x];
 if(pixel>=QRDEC_PIXEL_REGION) return pixel;
 if(pixel==QRDEC_PIXEL_WHITE)  return -1;
 ctx=(_qrdecoderctx*)&q->internal[0];
 if(ctx->num_regions>=QRDEC_MAX_REGIONS) return -1;
 region=ctx->num_regions;
 box=&ctx->regions[ctx->num_regions++];
 aaMemoryFill(box,sizeof(*box),0);
 box->seed.x=x;
 box->seed.y=y;
 box->capstone=-1;
 aa_QrDecFloodFillSeedAreaCount(q,x,y,pixel,region,box,0);
 return region;
 }







 V aa_QrDecFindRegionCorners           (_qrdecoder*q,Z rcode,_cord *ref,_cord *corners)
 {
 _qrdecoderregion*region;
 _qrdecoderpolygonscoredata psd;
 _qrdecoderctx*ctx;
 Z i;

 ctx=(_qrdecoderctx*)&q->internal[0];
 region=&ctx->regions[rcode];
 aaMemoryFill(&psd,sizeof(psd),0);
 psd.corners=corners;
 aaMemoryCopy(&psd.ref,sizeof(psd.ref),ref);
 psd.scores[0]=-1;
 aa_QrDecFloodFillSeedFindOneCorner(q,region->seed.x,region->seed.y,	rcode,QRDEC_PIXEL_BLACK,&psd,0);
 psd.ref.x=psd.corners[0].x-psd.ref.x;
 psd.ref.y=psd.corners[0].y-psd.ref.y;
 for(i=0;i<4;i++)
  {
  aaMemoryCopy(&psd.corners[i],sizeof(psd.corners[i]),&region->seed);
  }
 i=region->seed.x*psd.ref.x+region->seed.y*psd.ref.y;
 psd.scores[0]=i;
 psd.scores[2]=-i;
 i=region->seed.x*-psd.ref.y+region->seed.y*psd.ref.x;
 psd.scores[1]=i;
 psd.scores[3]=-i;
 aa_QrDecFloodFillSeedFindOtherCorners(q,region->seed.x,region->seed.y,	QRDEC_PIXEL_BLACK,rcode,	&psd,0);
 }




 V aa_QrDecRecordCapstone              (_qrdecoder*q,Z ring,Z stone)
 {
 _qrdecoderctx*ctx;
 _qrdecoderregion*stone_reg;
 _qrdecoderregion*ring_reg;
 _qrdecodercapstone*capstone;
 Z cs_index;

 ctx=(_qrdecoderctx*)&q->internal[0];
 stone_reg=&ctx->regions[stone];
 ring_reg=&ctx->regions[ring];
 if(ctx->num_capstones>=QRDEC_MAX_CAPSTONES)	return;
 cs_index=ctx->num_capstones;
 capstone=&ctx->capstones[ctx->num_capstones++];
 aaMemoryFill(capstone,sizeof(*capstone),0);
 capstone->qr_grid=-1;
 capstone->ring=ring;
 capstone->stone=stone;
 stone_reg->capstone=cs_index;
 ring_reg->capstone=cs_index;
 aa_QrDecFindRegionCorners(q,ring,&stone_reg->seed,capstone->corners);
 aa_QrDecPerspectiveSetup(capstone->c,capstone->corners,7.0,7.0);
 aa_QrDecPerspectiveMap(capstone->c,3.5,3.5,&capstone->center);
 }



 V aa_QrDecTestCapstone                (_qrdecoder*q,Z x,Z y,ZP pb)
 {
 _qrdecoderctx*ctx;
 Z ring_right,stone,ring_left;
 _qrdecoderregion*stone_reg;
 _qrdecoderregion*ring_reg;
 Z ratio;

 ring_right=aa_QrDecRegionCode(q,x-pb[4],y);
 stone=aa_QrDecRegionCode(q,x-pb[4]-pb[3]-pb[2],y);
 ring_left=aa_QrDecRegionCode(q,x-pb[4]-pb[3] -	    pb[2]-pb[1]-pb[0],		    y);
 if(ring_left<0||ring_right<0||stone<0)		return;
 if(ring_left!=ring_right)		return;
 if(ring_left==stone)		return;
 ctx=(_qrdecoderctx*)&q->internal[0];
 stone_reg=&ctx->regions[stone];
 ring_reg=&ctx->regions[ring_left];
 if(stone_reg->capstone>=0||ring_reg->capstone>=0)		return;
 ratio=stone_reg->count*100/ring_reg->count;
 if(ratio<10||ratio>70)		return;
 aa_QrDecRecordCapstone(q,ring_left,stone);
 }



 V aa_QrDecFinderScan                  (_qrdecoder*q,Z y)
 {
 BP row=q->pixels+y*q->size.w;
 Z x,pb[5];
 Z last_color=0;
 Z run_length=0;
 Z run_count=0;
 Z color;
 Z avg,i,ok,err;
 Z check[5]={1,1,3,1,1};

 aaMemoryFill(pb,sizeof(pb),0);
 for(x=0;x<(Z)q->size.w;x++)
  {
  color=row[x]?1:0;
  if(x&&color!=last_color)
   {
   aaMemoryMove(pb,sizeof(pb[0])*4,pb+1);
   pb[4]=run_length;
   run_length=0;
   run_count++;
   if(!color&&run_count>=5)
    {
    ok=1;
    avg=(pb[0]+pb[1]+pb[3]+pb[4])/4;
    err=avg*3/4;
    for(i=0;i<5;i++)
     {
     if(pb[i]<check[i]*avg-err||pb[i]>check[i]*avg+err) ok=0;
     }
    if(ok)	aa_QrDecTestCapstone(q,x,y,pb);
    }
   }
  run_length++;
  last_color=color;
  }
 }



 V aa_QrDecFindAlignmentPattern        (_qrdecoder*q,Z index)
 {
 static Z dx_map[]={1,0,-1,0};
 static Z dy_map[]={0,-1,0,1};
 _qrdecoderctx*ctx;
 _qrdecodergrid*qr;
 _qrdecodercapstone*c0;
 _qrdecodercapstone*c2;
 _cord a,b,c;
 _qrdecoderregion*reg;
 Z size_estimate,i,code;
 Z step_size=1;
 Z dir=0;
 D u,v;

 ctx=(_qrdecoderctx*)&q->internal[0];
 qr=&ctx->grids[index];
 c0=&ctx->capstones[qr->caps[0]];
 c2=&ctx->capstones[qr->caps[2]];
 aaMemoryCopy(&b,sizeof(b),&qr->align);
 aa_QrDecPerspectiveUnmap(c0->c,&b,&u,&v);
 aa_QrDecPerspectiveMap(c0->c,u,v+1.0,&a);
 aa_QrDecPerspectiveUnmap(c2->c,&b,&u,&v);
 aa_QrDecPerspectiveMap(c2->c,u+1.0,v,&c);
 size_estimate=abs((a.x-b.x)*-(c.y-b.y)+(a.y-b.y)*(c.x-b.x));
 while(step_size*step_size<size_estimate*100)
  {
  for(i=0;i<step_size;i++)
   {
   code=aa_QrDecRegionCode(q,b.x,b.y);
   if(code>=0)
    {
    reg=&ctx->regions[code];
    if(reg->count>=size_estimate/2&&reg->count<=size_estimate*2) { qr->align_region=code;	return; }
    }
   b.x+=dx_map[dir];
   b.y+=dy_map[dir];
   }
  dir=(dir+1)%4;
  if(!(dir&1)) step_size++;
  }
 }



 Z aa_QrDecTimingScan                  (_qrdecoder *q,_cord *p0,_cord *p1)
 {
 Z n=p1->x-p0->x;
 Z d=p1->y-p0->y;
 Z x=p0->x;
 Z y=p0->y;
 Z *dom,*nondom;
 Z dom_step,swap;
 Z nondom_step;
 Z a=0;
 Z i,pixel;
 Z run_length=0;
 Z count=0;

 if(p0->x<0||p0->y<0||p0->x>=(Z)q->size.w||p0->y>=(Z)q->size.h) return -1;
 if(p1->x<0||p1->y<0||p1->x>=(Z)q->size.w||p1->y>=(Z)q->size.h) return -1;
 if(abs(n)>abs(d)) { swap=n; n=d; d=swap; dom=&x; nondom=&y;	}
 else              { dom=&y;  nondom=&x; }
 if(n<0) { n=-n;   nondom_step=-1;	}
 else    {         nondom_step=1;	}
 if(d<0) { d=-d;   dom_step=-1;	}
 else    { dom_step=1;	}
 x=p0->x;
 y=p0->y;
 for(i=0;i<=d;i++)
  {
  if(y<0||y>=(Z)q->size.h||x<0||x>=(Z)q->size.w) break;
  pixel=q->pixels[y*q->size.w+x];
  if(pixel)
   {
   if(run_length>=2)			count++;
   run_length=0;
   }
  else
   {
   run_length++;
   }
  a+=n;
  *dom+=dom_step;
  if(a>=d) {	*nondom+=nondom_step; a-=d;}
  }
 return count;
 }



 Z aa_QrDecMeasureTimingPattern        (_qrdecoder*q,Z index)
 {
 static D us[]={6.5,6.5,0.5};
 static D vs[]={0.5,6.5,6.5};
 _qrdecoderctx*ctx;
 _qrdecodercapstone*cap;
 _qrdecodergrid*qr;
 Z i,scan,ver,size;

 ctx=(_qrdecoderctx*)&q->internal[0];
 qr=&ctx->grids[index];
 for(i=0;i<3;i++)
  {
  cap=&ctx->capstones[qr->caps[i]];
  aa_QrDecPerspectiveMap(cap->c,us[i],vs[i],&qr->tpep[i]);
  }
 qr->hscan=aa_QrDecTimingScan(q,&qr->tpep[1],&qr->tpep[2]);
 qr->vscan=aa_QrDecTimingScan(q,&qr->tpep[1],&qr->tpep[0]);
 scan=qr->hscan;
 if(qr->vscan>scan)	scan=qr->vscan;
 if(scan<0)	return -1;
 size=scan*2+13;
 ver=(size-15)/4;
 qr->grid_size=ver*4+17;
 return 0;
 }


 Z aa_QrDecReadCell                    (_qrdecoder*q,Z index,Z x,Z y)
 {
 _qrdecoderctx*ctx;
 _qrdecodergrid*qr;
 _cord p;

 ctx=(_qrdecoderctx*)&q->internal[0];
 qr=&ctx->grids[index];
 aa_QrDecPerspectiveMap(qr->c,x+0.5,y+0.5,&p);
 if(p.y<0||p.y>=(Z)q->size.h||p.x<0||p.x>=(Z)q->size.w) return 0;
 return q->pixels[p.y*q->size.w+p.x]?1:-1;
 }




 Z aa_QrDecFitnessCell                 (_qrdecoder*q,Z index,Z x,Z y)
 {
 _qrdecoderctx*ctx;
 static D offsets[]={0.3,0.5,0.7};
 _qrdecodergrid*qr;
 _cord p;
 Z u,v,score=0;

 ctx=(_qrdecoderctx*)&q->internal[0];
 qr=&ctx->grids[index];
 for(v=0;v<3;v++)
 for(u=0;u<3;u++)
  {
  aa_QrDecPerspectiveMap(qr->c,x+offsets[u],y+offsets[v],&p);
  if(p.y<0||p.y>=(Z)q->size.h||p.x<0||p.x>=(Z)q->size.w) continue;
  if(q->pixels[p.y*q->size.w+p.x]) score++;
  else                             score--;
  }
 return score;
 }



 Z aa_QrDecFitnessRing                 ( _qrdecoder*q,Z index,Z cx,Z cy,Z radius)
 {
 Z i,score=0;

 for(i=0;i<radius*2;i++)
  {
  score+=aa_QrDecFitnessCell(q,index,cx-radius+i,cy-radius);
  score+=aa_QrDecFitnessCell(q,index,cx-radius,cy+radius-i);
  score+=aa_QrDecFitnessCell(q,index,cx+radius,cy-radius+i);
  score+=aa_QrDecFitnessCell(q,index,cx+radius-i,cy+radius);
  }
 return score;
 }



 Z aa_QrDecFitnessApat                 (_qrdecoder*q,Z index,Z cx,Z cy)
 {
 return aa_QrDecFitnessCell(q,index,cx,cy)-aa_QrDecFitnessRing(q,index,cx,cy,1)+aa_QrDecFitnessRing(q,index,cx,cy,2);
 }

 Z aa_QrDecFitnessCapstone             (_qrdecoder*q,Z index,Z x,Z y)
 {
 x+=3;
 y+=3;
 return aa_QrDecFitnessCell(q,index,x,y)+aa_QrDecFitnessRing(q,index,x,y,1)-aa_QrDecFitnessRing(q,index,x,y,2)+aa_QrDecFitnessRing(q,index,x,y,3);
 }



 Z aa_QrDecFitnessAll                  (_qrdecoder*q,Z index)
 {
 _qrdecoderctx*ctx;
 _qrdecodergrid*qr;
 Z version;
 _qrdecoderversioninfo*info;
 Z expect,i,j,ap_count,score=0;

 ctx=(_qrdecoderctx*)&q->internal[0];
 qr=&ctx->grids[index];
 version=(qr->grid_size-17)/4;
 info=&qrdecoder_version_db[version];
 for(i=0;i<qr->grid_size-14;i++)
  {
  expect=(i&1)?1:-1;
  score+=aa_QrDecFitnessCell(q,index,i+7,6)*expect;
  score+=aa_QrDecFitnessCell(q,index,6,i+7)*expect;
  }
 score+=aa_QrDecFitnessCapstone(q,index,0,0);
 score+=aa_QrDecFitnessCapstone(q,index,qr->grid_size-7,0);
 score+=aa_QrDecFitnessCapstone(q,index,0,qr->grid_size-7);
 if(version<0||version>QRDEC_MAX_VERSION)	return score;
 ap_count=0;
 while((ap_count<QRDEC_MAX_ALIGNMENT)&&info->apat[ap_count])	ap_count++;
 for(i=1;i+1<ap_count;i++)
  {
  score+=aa_QrDecFitnessApat(q,index,6,info->apat[i]);
  score+=aa_QrDecFitnessApat(q,index,info->apat[i],6);
  }
 for(i=1;i<ap_count;i++)
 for(j=1;j<ap_count;j++) score+=aa_QrDecFitnessApat(q,index,info->apat[i],info->apat[j]);
 return score;
 }


 V aa_QrDecJigglePerspective           (_qrdecoder*q,Z index)
 {
 Z j,test;
 D old,step,new;
 _qrdecoderctx*ctx;
 _qrdecodergrid*qr;
 Z pass,i,best=aa_QrDecFitnessAll(q,index);
 D adjustments[8];

 ctx=(_qrdecoderctx*)&q->internal[0];
 qr=&ctx->grids[index];
 for(i=0;i<8;i++) adjustments[i]=qr->c[i]*0.02;
 for(pass=0;pass<5;pass++)
  {
  for(i=0;i<16;i++)
   {
   j=i>>1;
   old=qr->c[j];
   step=adjustments[j];
   if(i&1) new=old+step;
   else    new=old-step;
   qr->c[j]=new;
   test=aa_QrDecFitnessAll(q,index);
   if(test>best)	best=test;
   else		qr->c[j]=old;
   }
  for(i=0;i<8;i++) adjustments[i]*=0.5;
  }
 }



 V aa_QrDecSetupQrPerspective          (_qrdecoder*q,Z index)
 {
 _qrdecoderctx*ctx;
 _qrdecodergrid*qr;
 _cord rect[4];

 ctx=(_qrdecoderctx*)&q->internal[0];
 qr=&ctx->grids[index];
 aaMemoryCopy(&rect[0],sizeof(rect[0]),&ctx->capstones[qr->caps[1]].corners[0]);
 aaMemoryCopy(&rect[1],sizeof(rect[0]),&ctx->capstones[qr->caps[2]].corners[0]);
 aaMemoryCopy(&rect[2],sizeof(rect[0]),&qr->align);
 aaMemoryCopy(&rect[3],sizeof(rect[0]),&ctx->capstones[qr->caps[0]].corners[0]);
 aa_QrDecPerspectiveSetup(qr->c,rect,qr->grid_size-7,qr->grid_size-7);
 aa_QrDecJigglePerspective(q,index);
 }



 V aa_QrDecRotateCapstone              (_qrdecodercapstone*cap,_cord *h0,_cord *hd)
 {
 _cord copy[4];
 _cord*p;
 Z j,best,best_score,score;

 for(j=0;j<4;j++)
  {
  p=&cap->corners[j];
  score=(p->x-h0->x)*-hd->y+(p->y-h0->y)*hd->x;
  if(!j||score<best_score) { best=j;best_score=score;  }
  }
 for(j=0;j<4;j++) aaMemoryCopy(&copy[j],sizeof(copy[j]),&cap->corners[(j+best)%4]);
 aaMemoryCopy(cap->corners,sizeof(cap->corners),copy);
 aa_QrDecPerspectiveSetup(cap->c,cap->corners,7.0,7.0);
 }



 V aa_QrDecRecordQrGrid                (_qrdecoder*q,Z a,Z b,Z c)
 {
 _qrdecoderctx*ctx;
 _cord h0,hd;
 Z i,qr_index,swap;
 _qrdecoderpolygonscoredata psd;
 _qrdecodergrid*qr;
 _qrdecoderregion*reg;
 _qrdecodercapstone*cap;

 ctx=(_qrdecoderctx*)&q->internal[0];
 if(ctx->num_grids>=QRDEC_MAX_GRIDS)	return;
 aaMemoryCopy(&h0,sizeof(h0),&ctx->capstones[a].center);
 hd.x=ctx->capstones[c].center.x-ctx->capstones[a].center.x;
 hd.y=ctx->capstones[c].center.y-ctx->capstones[a].center.y;
 if((ctx->capstones[b].center.x-h0.x)*-hd.y+(ctx->capstones[b].center.y-h0.y)*hd.x>0)
  {
  swap=a;
  a=c;
  c=swap;
  hd.x=-hd.x;
  hd.y=-hd.y;
  }
 qr_index=ctx->num_grids;
 qr=&ctx->grids[ctx->num_grids++];
 aaMemoryFill(qr,sizeof(*qr),0);
 qr->caps[0]=a;
 qr->caps[1]=b;
 qr->caps[2]=c;
 qr->align_region=-1;
 for(i=0;i<3;i++)
  {
  cap=&ctx->capstones[qr->caps[i]];
  aa_QrDecRotateCapstone(cap,&h0,&hd);
  cap->qr_grid=qr_index;
  }
 if(aa_QrDecMeasureTimingPattern(q,qr_index)<0)goto fail;
 if(!aa_QrDecLineIntersect(&ctx->capstones[a].corners[0],&ctx->capstones[a].corners[1],&ctx->capstones[c].corners[0],&ctx->capstones[c].corners[3],&qr->align))	goto fail;
 if(qr->grid_size>21)
  {
  aa_QrDecFindAlignmentPattern(q,qr_index);
  if(qr->align_region>=0)
   {
   reg=&ctx->regions[qr->align_region];
   aaMemoryCopy(&qr->align,sizeof(qr->align),&reg->seed);
   aaMemoryCopy(&psd.ref,sizeof(psd.ref),&hd);
   psd.corners=&qr->align;
   psd.scores[0]=-hd.y*qr->align.x+hd.x*qr->align.y;
   aa_QrDecFloodFillSeedNull(q,reg->seed.x,reg->seed.y,qr->align_region,QRDEC_PIXEL_BLACK,NULL,0);
   aa_QrDecFloodFillSeedFindLeftmostToLine(q,reg->seed.x,reg->seed.y,QRDEC_PIXEL_BLACK,qr->align_region,&psd,0);
   }
  }
 aa_QrDecSetupQrPerspective(q,qr_index);
 return;
fail:
 for(i=0;i<3;i++)	ctx->capstones[qr->caps[i]].qr_grid=-1;
 ctx->num_grids--;
 }




 V aa_QrDecTestNeighbours              (_qrdecoder*q,Z i,_qrdecoderneighbourlist*hlist,_qrdecoderneighbourlist*vlist)
 {
 D score,best_score=0.0;
 Z j,k,best_h=-1,best_v=-1;
 _qrdecoderneighbour*hn;
 _qrdecoderneighbour*vn;

 for(j=0;j<hlist->count;j++)
  {
  for(k=0;k<vlist->count;k++)
   {
   hn=&hlist->n[j];
   vn=&vlist->n[k];
   score=fabs(1.0-hn->distance/vn->distance);
   if(score>2.5)		continue;
   if(best_h<0||score<best_score) {best_h=hn->index;best_v=vn->index;	best_score=score;			}
   }
  }
 if(best_h<0||best_v<0)	return;
 aa_QrDecRecordQrGrid(q,best_h,i,best_v);
 }




 V aa_QrDecTestGrouping                (_qrdecoder*q,Z i)
 {
 _qrdecoderctx*ctx;
 _qrdecodercapstone*c1;
 _qrdecoderneighbourlist hlist;
 _qrdecoderneighbourlist vlist;
 _qrdecoderneighbour*n;
 _qrdecodercapstone*c2;
 Z j;
 D u,v;

 ctx=(_qrdecoderctx*)&q->internal[0];
 c1=&ctx->capstones[i];
 if(c1->qr_grid>=0)	return;
 hlist.count=0;
 vlist.count=0;
 for(j=0;j<ctx->num_capstones;j++)
  {
  c2=&ctx->capstones[j];
  if(i==j||c2->qr_grid>=0)	continue;
  aa_QrDecPerspectiveUnmap(c1->c,&c2->center,&u,&v);
  u=fabs(u-3.5);
  v=fabs(v-3.5);
  if(u<0.2*v)
   {
   n=&hlist.n[hlist.count++];
   n->index=j;
   n->distance=v;
   }
  if(v<0.2*u)
   {
   n=&vlist.n[vlist.count++];
   n->index=j;
   n->distance=u;
   }
  }
 if(!(hlist.count&&vlist.count))	return;
 aa_QrDecTestNeighbours(q,i,&hlist,&vlist);
 }



/*-----------------------------------------------------------------------*/


 B aa_cursorhand[(32*4)+(32*4)]=
 {
 0xF9,0xFF,0xFF,0xFF,0xF0,0xFF,0xFF,0xFF,0xF0,0xFF,0xFF,0xFF,0xF0,0xFF,0xFF,0xFF,
 0xF0,0xFF,0xFF,0xFF,0xF0,0x3F,0xFF,0xFF,0xF0,0x07,0xFF,0xFF,0xF0,0x01,0xFF,0xFF,
 0xF0,0x00,0xFF,0xFF,0x10,0x00,0x7F,0xFF,0x00,0x00,0x7F,0xFF,0x00,0x00,0x7F,0xFF,
 0x80,0x00,0x7F,0xFF,0xC0,0x00,0x7F,0xFF,0xC0,0x00,0x7F,0xFF,0xE0,0x00,0x7F,0xFF,
 0xE0,0x00,0xFF,0xFF,0xF0,0x00,0xFF,0xFF,0xF0,0x00,0xFF,0xFF,0xF8,0x01,0xFF,0xFF,
 0xF8,0x01,0xFF,0xFF,0xF8,0x01,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
 0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
 0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,

 0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x06,0x00,0x00,0x00,
 0x06,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x06,0xC0,0x00,0x00,0x06,0xD8,0x00,0x00,
 0x06,0xDA,0x00,0x00,0x06,0xDB,0x00,0x00,0x67,0xFB,0x00,0x00,0x77,0xFF,0x00,0x00,
 0x37,0xFF,0x00,0x00,0x17,0xFF,0x00,0x00,0x1F,0xFF,0x00,0x00,0x0F,0xFF,0x00,0x00,
 0x0F,0xFE,0x00,0x00,0x07,0xFE,0x00,0x00,0x07,0xFE,0x00,0x00,0x03,0xFC,0x00,0x00,
 0x03,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 };


 structure
 {
 HCURSOR hand_cursor_handle;
 HCURSOR current_cursor_handle;
 B cursor_id;
 }
 _aa_cursorsystem;


 B aa_CursorSystemStart                (V);
 V aa_CursorSystemStop                 (V);

/*-----------------------------------------------------------------------*/


 H aa_GifCodeMasks[13]=                {0,1,3,7,15,31,63,127,255,0x01ff,0x03ff,0x07ff,0x0fff};
 I aa_GifInterlacedOffset[4]=          {0,4,2,1};
 I aa_GifInterlacedJumps[4]=           {8,8,4,2};



 structure
 {
 H self_handle;
 H file_bytes;
 BP file_mem;
 H file_offset_root;
 H file_offset;
 H next_offset;
 H next_framenum;
 W version;
 W total_colors;
 B bg_color_used;
 B bg_color_index;
 W global_color_bits;
 W global_color_count;
 _rgba global_color_pen[256];
 W local_color_bits;
 W local_color_count;
 B disposal_method;
 _rgba local_color_pen[256];
 _cord frame_cord;
 _size frame_size;
 B frame_interlaced;
 B frame_use_local_color;
 B frame_transparent_index_set;
 B frame_transparent_index;
 B allow_next;
 BP img;
 H bpp;
 H clear_code;
 H eof_code;
 H RunningCode;
 H RunningBits;
 H MaxCode1;
 H last_code;
 H CrntCode;
 H stack_ptr;
 H CrntShiftState;
 H CrntShiftDWord;
 H PixelCount;
 B Buf[256];
 B Stack[4095];
 B Suffix[4095+1];
 H Prefix[4095+1];
 _gifstatus status;
 H tik;
 }
 _aa_gifobject;


 structure
 {
 B object_id;
 }
 _aa_gifsystem;


 B aa_GifSystemStart                   (V);
 V aa_GifSystemStop                    (V);
 B aa_GifSystemReadBytes               (PP mem,H bytes,VP buf);
 N aa_GifSystemBitSize                 (N value);
 B aa_GifSystemReadFrameInfo           (PP mem);
 B aa_GifSystemReadExtension           (PP mem,NP extension_code,BP*extension);
 B aa_GifSystemReadExtensionNext       (PP mem,BP*extension);
 B aa_GifSystemReadLine                (PP mem,BP line,N linelen);
 B aa_GifSystemGetCodeNext             (PP mem,BP*codeblock);
 B aa_GifSystemDecompressLine          (PP mem,BP line,N linelen);
 B aa_GifSystemGetPrefixChar           (HP prefix,N Code,N clear_code);
 B aa_GifSystemDecompressInput         (PP mem,NP Code);

/*-----------------------------------------------------------------------*/

 _rgba col_null,col_black,col_white,col_gray[32];
 _rgba col_red[32],col_green[32],col_blue[32];
 _rgba col_purple[32],col_yellow[32],col_cyan[32];
 _rgba col_orange[32],col_sky[32];
 _rgba col_pastelred[32],col_pastelgreen[32],col_pastelblue[32];
 _rgba col_pastelpurple[32],col_pastelyellow[32],col_pastelcyan[32];
 _rgba col_pastelorange[32],col_pastelsky[32];
 _rgba*col_map[576];

 B aa_halftone4x4_1[16]=               { 0,25,6,31,38,12,44,19,9,35,3,28,47,22,41,15 };
 B aa_halftone4x4_2[16]=               { 41,3,9,28,35,15,22,47,6,25,38,0,19,44,31,12 };
 B aa_halftone16x16[256]=
 {
 0,44,9,41,3,46,12,43,1,44,10,41,3,46,12,43,34,16,25,19,37,18,28,21,35,16,26,19,37,18,28,21,
 38,6,47,3,40,9,50,6,38,7,47,4,40,9,49,6,22,28,13,31,25,31,15,34,22,29,13,32,24,31,15,34,
 2,46,12,43,1,45,10,42,2,45,11,42,1,45,11,42,37,18,27,21,35,17,26,20,36,17,27,20,36,17,26,20,
 40,8,49,5,38,7,48,4,39,8,48,5,39,7,48,4,24,30,15,33,23,29,13,32,23,30,14,33,23,29,14,32,
 2,46,12,43,0,44,10,41,3,47,12,44,0,44,10,41,37,18,27,21,35,16,25,19,37,19,28,22,35,16,25,19,
 40,9,49,5,38,7,47,4,40,9,50,6,38,6,47,3,24,30,15,34,22,29,13,32,25,31,15,34,22,28,13,31,
 1,45,11,42,2,46,11,42,1,45,10,41,2,46,11,43,36,17,26,20,36,17,27,21,35,16,26,20,36,18,27,21,
 39,8,48,4,39,8,49,5,38,7,48,4,39,8,49,5,23,29,14,33,24,30,14,33,23,29,13,32,24,30,14,33,
 };


 B aa_halftone8x8[64] =
 {
 0,38,9,47,2,40,11,50,25,12,35,22,27,15,37,24,6,44,3,41,8,47,5,43,31,19,28,15,34,21,31,18,1,39,11,49,
 0,39,10,48,27,14,36,23,26,13,35,23,7,46,4,43,7,45,3,42,33,20,30,17,32,19,29,16,
 };


 B aa_halftonexlat[216] =
 {
 0,29,30,31,32,249,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,250,250,57,58,59,251,
 60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,250,90,91,92,93,94,95,96,97,98,
 99,100,101,102,103,104,105,106,107,108,109,110,111,227,112,113,114,115,116,117,118,119,151,120,121,122,123,124,228,125,126,229,133,162,
 135,131,132,137,166,134,140,130,136,143,138,139,174,141,142,177,129,144,145,146,147,148,149,150,157,152,153,154,155,156,192,158,159,160,161,196,
 163,164,165,127,199,167,168,169,170,171,172,173,207,175,176,210,178,179,180,181,182,183,184,185,186,187,188,189,190,191,224,193,194,
 195,252,252,197,198,128,253,252,200,201,202,203,204,205,206,230,208,209,231,211,212,213,214,215,216,217,218,219,220,221,222,254,223,232,225,226,255,
 };




 structure
 {
 _rgba shadow;
 _rgba half_pal[216];
 }
 _aa_colorsystem;


 B aa_ColorSystemStart                 (V);
 V aa_ColorSystemStop                  (V);



/*-----------------------------------------------------------------------*/

 #define aa_INPUT_IHKE_QUEUE_SIZE      256



 structure
 {
 Q microsecs;
 Q sequence;
 B msg;
 B is_ext;
 B is_sys;
 B is_caps;
 B is_numl;
 B is_scrl;
 B is_shift;
 B is_ctrl;
 B is_alt;
 B is_win;
 B is_injected;
 B skey_code;
 B vkey_code;
 B akey_code;
 B xf;
 }
 _aa_inputhookedkeyevent;





 structure
 {
 H msg;
 _aa_inputhookedkeyevent ihke;
 W inBuffer[2];
 B keyboard_state[256];
 C key;
 I k;
 H xf;
 Z r;
 DWORD res;
 B isinjected;
 WPARAM wparam;
 LPARAM lparam;
 }
 _inputhookparms;



 structure
 {
 HKL keyboard_layout;
 H keyboard_scan_code[256];
 H keyboard_speed;
 H keyboard_delay;
 H tray_cycle;
 HWND tray_hwnd;
 H vsx,vsy;
 HWND capture_hwnd;
 HANDLE mutex_handle;
 BP vkcode;
 HHOOK hKeyHook;
 HHOOK hMouseHook;
 V(*dllSetProcAdr)(B(*proc)(VP name,VP etc,BP type,PP ptr));
 B(*dllInitPlugin)(V);
 LRESULT CALLBACK(*dllHookProc)(int,WPARAM,LPARAM);

 N wheel;
 Q sequence;
 Q ihke_sequence;
 Q ihke_events_waiting;
 Q ihke_events_total;
 _queunit ihke_que;
 _aa_inputhookedkeyevent ihke_que_array[aa_INPUT_IHKE_QUEUE_SIZE];
 H ihke_que_head;
 H ihke_que_tail;
 H ihke_events_waiting_threshold;
 Q ie_ms_tik;

 B is_logger_started;
 Q logger_reset_tik;

 Q engine_sequence;
 B vkey_used_count;
 B vkey_down_count;
 B vkey_held_count;
 B vkey_up_count;
 C vkey_state[256];
 B vs_key_rep[63356];
 H dbl_click_state;
 Q dbl_click_prev_ms;
 H dbl_click_handle;
 H dbl_click_spot_id;
 _cord dbl_click_cord;
 W is_dragging:1;
 W is_caps:1;
 W is_scrl:1;
 W is_numl:1;
 W is_shift:1;
 W is_ctrl:1;
 W is_alt:1;
 W is_win:1;
 W is_left:1;
 W is_mid:1;
 W is_right:1;
 W rsvd:5;
 }
 _aa_inputsystem;




 B aa_InputSystemStart                 (V);
 V aa_InputSystemStop                  (V);

 B aa_InputKeyLoggerStart              (V);
 B aa_InputKeyLoggerReset              (V);

 B aa_InputSystemHookedKeyEngineStart  (V);
 B aa_InputSystemHookedKeyEngineStop   (V);

 B aa_InputSystemCountVkeys            (V);
 B aa_InputSystemVkeyStateSet          (Z vkey,B cmd,B ismore);
 B aa_InputSystemHookedKeyProcess      (_aa_inputhookedkeyevent*aaihke);
 B aa_InputSystemKeyEventProc          (HWND wnd,H msg,WPARAM wparm,LPARAM lparm,B extflag);
 B aa_InputStateGet                    (_inputstate*inputstate,B dokeys,B domouse);


/*-----------------------------------------------------------------------*/





 structure
 {
 H self_handle;
 B is_in_proc;
 _audiostatus status;
 WAVEFORMATEX wfx;
 HWAVEIN handle;
 H que_handle;
 _questatus que_status;
 B is_openreceived;
 WAVEHDR wave_hdr[128];
 BP wave_buf;
 H cycle;
 H ctrl_master_volume;
 H ctrl_master_mute;
 MIXERLINE ctrl_master_line;
 }
 _aa_audioobject;



/*[5:20:30 AM] Dmitry Zapashchikov says: G[dB] = 20 * log10( MAX / abs( S ))*/

 structure
 {
 B object_id;
 D ch_block[_32K];
 }
 _aa_audiosystem;



 B aa_AudioSystemStart                 (V);
 V aa_AudioSystemStop                  (V);
 B aa_AudioSystemModeVerify            (_audiomode*audiomode,B fix);
 K aa_AudioSystemOutProc               (HWAVEOUT h,UINT msg,H data,H p1,H p2);
 K aa_AudioSystemInProc                (HWAVEOUT h,UINT msg,H data,H p1,H p2);
 B aa_AudioSystemUpdateSamplePosition  (PP mem);
 B aa_AudioSystemProcessChannels       (PP mem,HP samples,VP data);
 B aa_AudioSystemProcessQues           (PP mem);

 D aa_AudioSystemAtan2                 (D x,D y);
 V aa_AudioSystemFFT                   (FP fftbuffer,N framesize,N sign);

 B aa_AudioSystemGetVolume             (PP mem,H ctrlid,NP vol);
 B aa_AudioSystemSetVolume             (PP mem,H ctrlid,NP vol);
 B aa_AudioSystemGetMute               (PP mem,H ctrlid,NP mute);
 B aa_AudioSystemSetMute               (PP mem,H ctrlid,NP mute);
 B aa_AudioSystemGetLineControls       (PP mem,MIXERLINE*mxline,H source,H dest,HP volctrl,HP mutectrl);
 B aa_AudioStatus                      (PP ptr,B dochannels);





/*-----------------------------------------------------------------------*/

 #define aa_VIDCAP_ALLOW_YUY2          (YES)

 #define USE_VIDCAP_CRITICAL_SECTION   (YES-1)

 #define aa_VIDCAP_THREAD_SLEEP        1
 #define aa_VIDCAP_THREAD_STATUS_CYCLE 10

 #define WM_USER_VIDCAP_SOURCE         (WM_USER+12)
 #define aa_CONTROLCALLBACK_PREROLL    1
 #define aa_CONTROLCALLBACK_CAPTURING  2
 #define aa_IDS_CAP_BEGIN              300
 #define aa_IDS_CAP_END                301
 #define aa_AVSTREAMMASTER_AUDIO       0
 #define aa_AVSTREAMMASTER_NONE        1

 #define VAL_IYUV                      1448433993
 #define VAL_I420                      808596553
 #define VAL_YUY2                      844715353
 #define VAL_limt                      1953327468
 #define VAL_aamh                      1751998817
 #define VAL_YUYV                      1448695129
 #define VAL_V422                      842150998
 #define VAL_UYVY                      1498831189
 #define VAL_YV12                      842094169

 structure
 {
 UINT        uiImageWidth;               // Width of the image
 UINT        uiImageHeight;              // Height of the image
 BOOL        fLiveWindow;                // Now Previewing video?
 BOOL        fOverlayWindow;             // Now Overlaying video?
 BOOL        fScale;                  // Scale image to client?
 POINT       ptScroll;                   // Scroll position
 BOOL        fUsingDefaultPalette;       // Using default driver palette?
 BOOL        fAudioHardware;             // Audio hardware present?
 BOOL        fCapFileExists;             // Does capture file exist?
 DWORD       dwCurrentVideoFrame;        // # of video frames cap'td
 DWORD       dwCurrentVideoFramesDropped;// # of video frames dropped
 DWORD       dwCurrentWaveSamples;       // # of wave samples cap'td
 DWORD       dwCurrentTimeElapsedMS;     // Elapsed capture duration
 HPALETTE    hPalCurrent;                // Current palette in use
 BOOL        fCapturingNow;              // Capture in progress?
 DWORD       dwReturn;                   // Error value after any operation
 UINT        wNumVideoAllocated;         // Actual number of video buffers
 UINT        wNumAudioAllocated;         // Actual number of audio buffers
 }
 aa_CAPSTATUS;



 structure
 {
 DWORD       dwRequestMicroSecPerFrame;  // Requested capture rate
 BOOL        fMakeUserHitOKToCapture;    // Show "Hit OK to cap" dlg?
 UINT        wPercentDropForError;       // Give error msg if > (10%)
 BOOL        fYield;                     // Capture via background task?
 DWORD       dwIndexSize;                // Max index size in frames (32K)
 UINT        wChunkGranularity;          // Junk chunk granularity (2K)
 BOOL        fUsingDOSMemory;            // Use DOS buffers?
 UINT        wNumVideoRequested;         // # video buffers, If 0, autocalc
 BOOL        fCaptureAudio;              // Capture audio?
 UINT        wNumAudioRequested;         // # audio buffers, If 0, autocalc
 UINT        vKeyAbort;                  // Virtual key causing abort
 BOOL        fAbortLeftMouse;            // Abort on left mouse?
 BOOL        fAbortRightMouse;           // Abort on right mouse?
 BOOL        fLimitEnabled;              // Use wTimeLimit?
 UINT        wTimeLimit;                 // Seconds to capture
 BOOL        fMCIControl;                // Use MCI video source?
 BOOL        fStepMCIDevice;             // Step MCI device?
 DWORD       dwMCIStartTime;             // Time to start in MS
 DWORD       dwMCIStopTime;              // Time to stop in MS
 BOOL        fStepCaptureAt2x;           // Perform spatial averaging 2x
 UINT        wStepCaptureAverageFrames;  // Temporal average n Frames
 DWORD       dwAudioBufferSize;          // Size of audio bufs (0 = default)
 BOOL        fDisableWriteCache;         // Attempt to disable write cache
 UINT        AVStreamMaster;             // Which stream controls length?
 }
 aa_CAPTUREPARMS;


 structure
 {
 LPBYTE      lpData;                 // pointer to locked data buffer
 DWORD       dwBufferLength;         // Length of data buffer
 DWORD       dwBytesUsed;            // Bytes actually used
 DWORD       dwTimeCaptured;         // Milliseconds from start of stream
 DWORD       dwUser;                 // for client's use
 DWORD       dwFlags;                // assorted flags (see defines)
 DWORD*      dwReserved[4];          // reserved for driver
 }
 aa_VIDEOHDR;


 structure
 {
 UINT        wDeviceIndex;               // Driver index in system.ini
 BOOL        fHasOverlay;                // Can device overlay?
 BOOL        fHasDlgVideoSource;         // Has Video source dlg?
 BOOL        fHasDlgVideoFormat;         // Has Format dlg?
 BOOL        fHasDlgVideoDisplay;        // Has External out dlg?
 BOOL        fCaptureInitialized;        // Driver ready to capture?
 BOOL        fDriverSuppliesPalettes;    // Can driver make palettes?
 // following always NULL on Win32.
 HANDLE      hVideoIn;                   // Driver In channel
 HANDLE      hVideoOut;                  // Driver Out channel
 HANDLE      hVideoExtIn;                // Driver Ext In channel
 HANDLE      hVideoExtOut;               // Driver Ext Out channel
 }
 aa_CAPDRIVERCAPS;



 structure
 {
 H self_handle;
 _vidcapstatus status;
 B has_format;
 B has_display;
 B is_frame_waiting;
 B is_abort_complete;
 B is_connect_failed;
 B is_sourcebox_message_received;
 B is_sourcebox_closed;
 H error_count;
 N error_code;
 H device_id;
 H frames_bad;
 _size requested_capture_size;
 B requested_capture_bits;
 H using_bmp_compression;
 H thread_id;
 H thread_handle;
 H thread_lparm;
 _aa_event connect_event;
 HWND hwnd;
 H window_to_active_after_connect;
 H window_to_active_after_sourcebox_close;
 H frame_buf_bytes;
 B auto_detect_stage;
 B auto_detect_bit_mode;
 _size auto_detect_size;
 BP frame_buf;
 }
 _aa_vidcapobject;




 structure
 {
 B object_id;
 }
 _aa_vidcapsystem;


 B aa_VidCapSystemStart                (V);
 V aa_VidCapSystemStop                 (V);
 H aa_VidCapThread                     (VP parm);
 B aa_VidCapSetCallbacks               (PP mem,B state);
 B aa_VidCapFindByCaptureHwnd          (HP handle,PP mem,HWND wnd);
 K aa_VidCapErrorProc                  (HWND wnd,N errorid,LPSTR errortxt);
 K aa_VidCapControlProc                (HWND wnd,N state);
 K aa_VidCapStatusProc                 (HWND wnd,N id,LPCSTR str);
 K aa_VidCapPreviewProc                (HWND wnd,aa_VIDEOHDR* lpvhdr);
 K aa_VidCapVideoProc                  (HWND wnd,aa_VIDEOHDR* lpvhdr);
 B aa_VidCapProcessFrame               (HWND wnd,aa_VIDEOHDR* lpvhdr);
 B aa_VidCapAbort                      (PP mem);


/*-----------------------------------------------------------------------*/

 #define aa_FILESTREAM_MAPBLOCK_SIZE   0x10000*64LL //was32
 //#define aa_FILESTREAM_MAPBLOCK_SIZE   0x10000*8LL

 structure
 {
 H self_handle;
 HANDLE handle;
 _filestreamstatus status;
 B is_stdio;
 B crlf_state;
 Q line_peek_offset;
 H line_chars;
 B gfs_required;
 H cycle;
 Q last_size;
 Q last_offset;

 HANDLE map_handle;
 }
 _aa_filestreamobject;


 structure
 {
 B object_id;
 }
 _aa_filestreamsystem;


 B aa_FileStreamSystemStart            (V);
 V aa_FileStreamSystemStop             (V);


/*-----------------------------------------------------------------------*/


 structure
 {
 B is_open;
 B is_close;
 B is_failure;
 B is_cancelled;
 B filter[257];
 B initial_dir[257];
 B initial_file[129];
 BP selection;
 B max_files;
 HANDLE handle;
 B caption[65];
 HWND parent_hwnd;
 OPENFILENAME of;
 }
 _aa_fileboxsystem;


 H WINAPI aa_FileBoxProc               (LPVOID pa);

 B aa_FileBoxSystemStart               (V);
 V aa_FileBoxSystemStop                (V);

/*-----------------------------------------------------------------------*/


 structure
 {
 B is_open;
 B is_close;
 B is_cancelled;
 B is_failure;
 B initial_dir[513];
 B caption[65];
 HANDLE handle;
 H surface_handle;
 HWND parent_hwnd;
 HWND dialog_hwnd;
 BROWSEINFO bi;
 LPITEMIDLIST pidl;
 TCHAR szDir[MAX_PATH];
 B r_path[MAX_PATH];
 }
 _aa_folderboxsystem;

 Z CALLBACK aa_FolderBoxCallback       (HWND hwnd,UINT uMsg,LPARAM lp,LPARAM pData);
 H WINAPI aa_FolderBoxProc             (LPVOID pa);

 B aa_FolderBoxSystemStart             (V);
 V aa_FolderBoxSystemStop              (V);

/*-----------------------------------------------------------------------*/

 B aa_SysIsWinServer                   (V);
 B aa_SysIsWinXpSp2OrGreater           (V);


/*-----------------------------------------------------------------------*/


 typedef union
 {
 FILETIME dword;
 Q quad;
 }
 myFILETIME;

 // #define aa_Li2Double(x)               ((D)((x).hi)*4.294967296E9+(D)((x).lo))

 structure
 {
 B is_started;
 myFILETIME prev_idle_time;
 myFILETIME prev_kernel_time;
 myFILETIME prev_user_time;
 G prev_ki_time;
 G process_prev_idle_time;
 G process_prev_kernel_time;
 G process_prev_user_time;
 }
 _aa_cpumonitorsystem;



 B aa_CpuMonitorSystemStart            (V);
 V aa_CpuMonitorSystemStop             (V);


/*-----------------------------------------------------------------------*/


 structure
 {
 H self_handle;
 HANDLE handle;
 _dirstatus status;
 H slots;
 BP mem;
 WIN32_FIND_DATA wfd;
 }
 _aa_dirobject;


 structure
 {
 B object_id;
 }
 _aa_dirsystem;


 B aa_DirSystemStart                   (V);
 V aa_DirSystemStop                    (V);

/*-----------------------------------------------------------------------*/

 structure
 {
 H self_handle;
 H stage;
 _dirwalkerstatus status;
 H root_sl;
 H ti;
 _ministack dms;
 B in_proc;
 }
 _aa_dirwalkerobject;


 structure
 {
 B object_id;
 }
 _aa_dirwalkersystem;

 B aa_DirWalkerSystemStart             (V);
 V aa_DirWalkerSystemStop              (V);


/*-----------------------------------------------------------------------*/

 #define aaRipemdBytesToDword          (((H) *((p)+3) << 24)|((H) *((p)+2) << 16) | ((H) *((p)+1) <<  8) | ((H) *(p)))
 #define aaRipemdROL(x,n)              (((x) << (n)) | ((x) >> (32-(n))))
 #define aaRipemdF(x,y,z)              ((x) ^ (y) ^ (z))
 #define aaRipemdG(x,y,z)              (((x) & (y)) | (~(x) & (z)))
 #define aaRipemdH(x,y,z)              (((x) | ~(y)) ^ (z))
 #define aaRipemdI(x,y,z)              (((x) & (z)) | ((y) & ~(z)))
 #define aaRipemdJ(x,y,z)              ((x) ^ ((y) | ~(z)))
 #define aaRipemdFF(a,b,c,d,e,x,s)     { (a)+=aaRipemdF((b),(c),(d))+(x)+0x00000000UL; (a)=aaRipemdROL((a),(s))+(e); (c)=aaRipemdROL((c), 10); }
 #define aaRipemdGG(a,b,c,d,e,x,s)     { (a)+=aaRipemdG((b),(c),(d))+(x)+0x5a827999UL; (a)=aaRipemdROL((a),(s))+(e); (c)=aaRipemdROL((c), 10); }
 #define aaRipemdHH(a,b,c,d,e,x,s)     { (a)+=aaRipemdH((b),(c),(d))+(x)+0x6ed9eba1UL; (a)=aaRipemdROL((a),(s))+(e); (c)=aaRipemdROL((c), 10); }
 #define aaRipemdII(a,b,c,d,e,x,s)     { (a)+=aaRipemdI((b),(c),(d))+(x)+0x8f1bbcdcUL; (a)=aaRipemdROL((a),(s))+(e); (c)=aaRipemdROL((c), 10); }
 #define aaRipemdJJ(a,b,c,d,e,x,s)     { (a)+=aaRipemdJ((b),(c),(d))+(x)+0xa953fd4eUL; (a)=aaRipemdROL((a),(s))+(e); (c)=aaRipemdROL((c), 10); }
 #define aaRipemdFFF(a,b,c,d,e,x,s)    { (a)+=aaRipemdF((b),(c),(d))+(x)+0x00000000UL; (a)=aaRipemdROL((a),(s))+(e); (c)=aaRipemdROL((c), 10); }
 #define aaRipemdGGG(a,b,c,d,e,x,s)    { (a)+=aaRipemdG((b),(c),(d))+(x)+0x7a6d76e9UL; (a)=aaRipemdROL((a),(s))+(e); (c)=aaRipemdROL((c), 10); }
 #define aaRipemdHHH(a,b,c,d,e,x,s)    { (a)+=aaRipemdH((b),(c),(d))+(x)+0x6d703ef3UL; (a)=aaRipemdROL((a),(s))+(e); (c)=aaRipemdROL((c), 10); }
 #define aaRipemdIII(a,b,c,d,e,x,s)    { (a)+=aaRipemdI((b),(c),(d))+(x)+0x5c4dd124UL; (a)=aaRipemdROL((a),(s))+(e); (c)=aaRipemdROL((c), 10); }
 #define aaRipemdJJJ(a,b,c,d,e,x,s)    { (a)+=aaRipemdJ((b),(c),(d))+(x)+0x50a28be6UL; (a)=aaRipemdROL((a),(s))+(e); (c)=aaRipemdROL((c), 10); }

 #define aaMD5FF(b,c,d)                (d ^ (b & (c ^ d)))
 #define aaMD5FG(b,c,d)                aaMD5FF (d, b, c)
 #define aaMD5FH(b,c,d)                (b ^ c ^ d)
 #define aaMD5FI(b,c,d)                (c ^ (b | ~d))
 #define aaMD5OP1(a,b,c,d,s,T)         do { a+=aaMD5FF(b,c,d)+(*cwp++)+T;    a=aaNumRoll(a,s); a+=b; }   while (0)
 #define aaMD5OP2(f,a,b,c,d,k,s,T)     do { a+=f(b,c,d)+digp->correct_words[k]+T;  a=aaNumRoll(a,s); a+=b; }   while (0)

 #define aaSHA1Rol(val,bits)           (((val)<<(bits))|((val)>>(32-(bits))))
 #define aaSHA1Blk0(i)                 (zblock->l[i]=(aaSHA1Rol(zblock->l[i],24)&0xFF00FF00)|(aaSHA1Rol(zblock->l[i],8)&0x00FF00FF))
 #define aaSHA1Blk(i)                  (zblock->l[i&15]=aaSHA1Rol(zblock->l[(i+13)&15]^zblock->l[(i+8)&15]^zblock->l[(i+2)&15]^zblock->l[i&15],1))
 #define aaSHA1R0(v,w,x,y,z,i)         z+=((w&(x^y))^y)+aaSHA1Blk0(i)+0x5A827999+aaSHA1Rol(v,5);w=aaSHA1Rol(w,30);
 #define aaSHA1R1(v,w,x,y,z,i)         z+=((w&(x^y))^y)+aaSHA1Blk(i)+0x5A827999+aaSHA1Rol(v,5);w=aaSHA1Rol(w,30);
 #define aaSHA1R2(v,w,x,y,z,i)         z+=(w^x^y)+aaSHA1Blk(i)+0x6ED9EBA1+aaSHA1Rol(v,5);w=aaSHA1Rol(w,30);
 #define aaSHA1R3(v,w,x,y,z,i)         z+=(((w|x)&y)|(w&x))+aaSHA1Blk(i)+0x8F1BBCDC+aaSHA1Rol(v,5);w=aaSHA1Rol(w,30);
 #define aaSHA1R4(v,w,x,y,z,i)         z+=(w^x^y)+aaSHA1Blk(i)+0xCA62C1D6+aaSHA1Rol(v,5);w=aaSHA1Rol(w,30);

 static uint64_t aaSHA512aaK[80]=
 {
 UINT64_C(0x428a2f98d728ae22),UINT64_C(0x7137449123ef65cd),UINT64_C(0xb5c0fbcfec4d3b2f),UINT64_C(0xe9b5dba58189dbbc),UINT64_C(0x3956c25bf348b538),UINT64_C(0x59f111f1b605d019),UINT64_C(0x923f82a4af194f9b),UINT64_C(0xab1c5ed5da6d8118),
 UINT64_C(0xd807aa98a3030242),UINT64_C(0x12835b0145706fbe),UINT64_C(0x243185be4ee4b28c),UINT64_C(0x550c7dc3d5ffb4e2),UINT64_C(0x72be5d74f27b896f),UINT64_C(0x80deb1fe3b1696b1),UINT64_C(0x9bdc06a725c71235),UINT64_C(0xc19bf174cf692694),
 UINT64_C(0xe49b69c19ef14ad2),UINT64_C(0xefbe4786384f25e3),UINT64_C(0x0fc19dc68b8cd5b5),UINT64_C(0x240ca1cc77ac9c65),UINT64_C(0x2de92c6f592b0275),UINT64_C(0x4a7484aa6ea6e483),UINT64_C(0x5cb0a9dcbd41fbd4),UINT64_C(0x76f988da831153b5),
 UINT64_C(0x983e5152ee66dfab),UINT64_C(0xa831c66d2db43210),UINT64_C(0xb00327c898fb213f),UINT64_C(0xbf597fc7beef0ee4),UINT64_C(0xc6e00bf33da88fc2),UINT64_C(0xd5a79147930aa725),UINT64_C(0x06ca6351e003826f),UINT64_C(0x142929670a0e6e70),
 UINT64_C(0x27b70a8546d22ffc),UINT64_C(0x2e1b21385c26c926),UINT64_C(0x4d2c6dfc5ac42aed),UINT64_C(0x53380d139d95b3df),UINT64_C(0x650a73548baf63de),UINT64_C(0x766a0abb3c77b2a8),UINT64_C(0x81c2c92e47edaee6),UINT64_C(0x92722c851482353b),
 UINT64_C(0xa2bfe8a14cf10364),UINT64_C(0xa81a664bbc423001),UINT64_C(0xc24b8b70d0f89791),UINT64_C(0xc76c51a30654be30),UINT64_C(0xd192e819d6ef5218),UINT64_C(0xd69906245565a910),UINT64_C(0xf40e35855771202a),UINT64_C(0x106aa07032bbd1b8),
 UINT64_C(0x19a4c116b8d2d0c8),UINT64_C(0x1e376c085141ab53),UINT64_C(0x2748774cdf8eeb99),UINT64_C(0x34b0bcb5e19b48a8),UINT64_C(0x391c0cb3c5c95a63),UINT64_C(0x4ed8aa4ae3418acb),UINT64_C(0x5b9cca4f7763e373),UINT64_C(0x682e6ff3d6b2b8a3),
 UINT64_C(0x748f82ee5defb2fc),UINT64_C(0x78a5636f43172f60),UINT64_C(0x84c87814a1f0ab72),UINT64_C(0x8cc702081a6439ec),UINT64_C(0x90befffa23631e28),UINT64_C(0xa4506cebde82bde9),UINT64_C(0xbef9a3f7b2c67915),UINT64_C(0xc67178f2e372532b),
 UINT64_C(0xca273eceea26619c),UINT64_C(0xd186b8c721c0c207),UINT64_C(0xeada7dd6cde0eb1e),UINT64_C(0xf57d4f7fee6ed178),UINT64_C(0x06f067aa72176fba),UINT64_C(0x0a637dc5a2c898a6),UINT64_C(0x113f9804bef90dae),UINT64_C(0x1b710b35131c471b),
 UINT64_C(0x28db77f523047d84),UINT64_C(0x32caab7b40c72493),UINT64_C(0x3c9ebe0a15c9bebc),UINT64_C(0x431d67c49c100d4c),UINT64_C(0x4cc5d4becb3e42b6),UINT64_C(0x597f299cfc657e2a),UINT64_C(0x5fcb6fab3ad6faec),UINT64_C(0x6c44198c4a475817)
 };


 #define aaSHA512ROR64c(x,y)           (((((x)&UINT64_C(0xFFFFFFFFFFFFFFFF))>>((uint64_t)(y)&UINT64_C(63)))|\
                                       ((x)<<((uint64_t)(64-((y)&UINT64_C(63))))))&UINT64_C(0xFFFFFFFFFFFFFFFF))

 #define aaSHA512STORE64H(x,y)         {(y)[0]=(B)(((x)>>56)&255);(y)[1]=(B)(((x)>>48)&255);     \
                                       (y)[2]=(B)(((x)>>40)&255);(y)[3]=(B)(((x)>>32)&255);     \
                                       (y)[4]=(B)(((x)>>24)&255);(y)[5]=(B)(((x)>>16)&255);     \
                                       (y)[6]=(B)(((x)>>8)&255);(y)[7]=(B)((x)&255);}

 #define aaSHA512LOAD64H(x,y)          {x=(((uint64_t)((y)[0]&255))<<56)|(((uint64_t)((y)[1]&255))<<48)|\
                                       (((uint64_t)((y)[2]&255))<<40)|(((uint64_t)((y)[3]&255))<<32)|\
                                       (((uint64_t)((y)[4]&255))<<24)|(((uint64_t)((y)[5]&255))<<16)|\
                                       (((uint64_t)((y)[6]&255))<<8)|(((uint64_t)((y)[7]&255)));}


 #define aaSHA512Ch(x,y,z)             (z^(x&(y^z)))
 #define aaSHA512Maj(x,y,z)            (((x|y)&z)|(x&y))
 #define aaSHA512aaS(x,n)              aaSHA512ROR64c(x,n)
 #define aaSHA512aaR(x,n)              (((x)&UINT64_C(0xFFFFFFFFFFFFFFFF))>>((uint64_t)n))
 #define aaSHA512Sigma0(x)             (aaSHA512aaS(x,28)^aaSHA512aaS(x,34)^aaSHA512aaS(x,39))
 #define aaSHA512Sigma1(x)             (aaSHA512aaS(x,14)^aaSHA512aaS(x,18)^aaSHA512aaS(x,41))
 #define aaSHA512Gamma0(x)             (aaSHA512aaS(x,1)^aaSHA512aaS(x,8)^aaSHA512aaR(x,7))
 #define aaSHA512Gamma1(x)             (aaSHA512aaS(x,19)^aaSHA512aaS(x,61)^aaSHA512aaR(x,6))


 H aa_DigestSha2K256[256]=              {0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,
                                        0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,
                                        0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,
                                        0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,
                                        0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,
                                        0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,
                                        0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,
                                        0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2};



 structure
 {
 H self_handle;
 _digeststatus status;
 B requires_reset;
 H counter;
 H count;
 //B block[64];
 //B block[128];
 B block[512];
 H len[2];
 Q length;
 Q curlen;
 H correct_words[16];
 }
 _aa_digestobject;


 structure
 {
 B object_id;
 }
 _aa_digestsystem;


 B aa_DigestSystemStart                (V);
 V aa_DigestSystemStop                 (V);
 V aa_DigestSystemCompress             (PP mem,HP block);
 V aa_DigestSystemMd5                  (_aa_digestobject*digp,BP inbuf,H inlen);
 static inline V aa_DigestSystemSha256Transform      (_aa_digestobject*digp);
 static inline H aa_DigestSha2rotateRight            (H n,H x);
 static inline H aa_DigestSha2choice                 (H x,H y,H z);
 static inline H aa_DigestSha2majority               (H x,H y,H z);
 static inline H aa_DigestSha2Sigma0                 (H x);
 static inline H aa_DigestSha2Sigma1                 (H x);
 static inline H aa_DigestSha2sigma0                 (H x);
 static inline H aa_DigestSha2sigma1                 (H x);
 static inline H aa_DigestSha2expand                 (HP WX,H j);
 static inline H aa_DigestSha2safeAdd                (H x,H y);
 static inline V aa_DigestSystemSha512Transform      (_aa_digestobject*digp,BP buf);



/*-----------------------------------------------------------------------*/

//https://github.com/chettrick/aes256
//https://github.com/kokke/tiny-AES128-C

//https://github.com/kokke/tiny-AES-c/blob/master/aes.h

 structure
 {
 H esk[32];
 H dsk[32];
 }
 _aa_crypto_des_context;



 structure
 {
 H esk[96];
 H dsk[96];
 }
 _aa_crypto_des3_context;



 H aa_crypto_des_SB1[64] =
 {
 0x01010400,0x00000000,0x00010000,0x01010404,0x01010004,0x00010404,0x00000004,0x00010000,0x00000400,0x01010400,0x01010404,0x00000400,0x01000404,0x01010004,
 0x01000000,0x00000004,0x00000404,0x01000400,0x01000400,0x00010400,0x00010400,0x01010000,0x01010000,0x01000404,0x00010004,0x01000004,0x01000004,0x00010004,
 0x00000000,0x00000404,0x00010404,0x01000000,0x00010000,0x01010404,0x00000004,0x01010000,0x01010400,0x01000000,0x01000000,0x00000400,0x01010004,0x00010000,
 0x00010400,0x01000004,0x00000400,0x00000004,0x01000404,0x00010404,0x01010404,0x00010004,0x01010000,0x01000404,0x01000004,0x00000404,0x00010404,0x01010400,
 0x00000404,0x01000400,0x01000400,0x00000000,0x00010004,0x00010400,0x00000000,0x01010004
 };

 H aa_crypto_des_SB2[64] =
 {
 0x80108020,0x80008000,0x00008000,0x00108020,0x00100000,0x00000020,0x80100020,0x80008020,0x80000020,0x80108020,0x80108000,0x80000000,0x80008000,0x00100000,
 0x00000020,0x80100020,0x00108000,0x00100020,0x80008020,0x00000000,0x80000000,0x00008000,0x00108020,0x80100000,0x00100020,0x80000020,0x00000000,0x00108000,
 0x00008020,0x80108000,0x80100000,0x00008020,0x00000000,0x00108020,0x80100020,0x00100000,0x80008020,0x80100000,0x80108000,0x00008000,0x80100000,0x80008000,
 0x00000020,0x80108020,0x00108020,0x00000020,0x00008000,0x80000000,0x00008020,0x80108000,0x00100000,0x80000020,0x00100020,0x80008020,0x80000020,0x00100020,
 0x00108000,0x00000000,0x80008000,0x00008020,0x80000000,0x80100020,0x80108020,0x00108000
 };

 H aa_crypto_des_SB3[64] =
 {
 0x00000208,0x08020200,0x00000000,0x08020008,0x08000200,0x00000000,0x00020208,0x08000200,0x00020008,0x08000008,0x08000008,0x00020000,0x08020208,0x00020008,
 0x08020000,0x00000208,0x08000000,0x00000008,0x08020200,0x00000200,0x00020200,0x08020000,0x08020008,0x00020208,0x08000208,0x00020200,0x00020000,0x08000208,
 0x00000008,0x08020208,0x00000200,0x08000000,0x08020200,0x08000000,0x00020008,0x00000208,0x00020000,0x08020200,0x08000200,0x00000000,0x00000200,0x00020008,
 0x08020208,0x08000200,0x08000008,0x00000200,0x00000000,0x08020008,0x08000208,0x00020000,0x08000000,0x08020208,0x00000008,0x00020208,0x00020200,0x08000008,
 0x08020000,0x08000208,0x00000208,0x08020000,0x00020208,0x00000008,0x08020008,0x00020200
 };

 H aa_crypto_des_SB4[64] =
 {
 0x00802001,0x00002081,0x00002081,0x00000080,0x00802080,0x00800081,0x00800001,0x00002001,0x00000000,0x00802000,0x00802000,0x00802081,0x00000081,0x00000000,
 0x00800080,0x00800001,0x00000001,0x00002000,0x00800000,0x00802001,0x00000080,0x00800000,0x00002001,0x00002080,0x00800081,0x00000001,0x00002080,0x00800080,
 0x00002000,0x00802080,0x00802081,0x00000081,0x00800080,0x00800001,0x00802000,0x00802081,0x00000081,0x00000000,0x00000000,0x00802000,0x00002080,0x00800080,
 0x00800081,0x00000001,0x00802001,0x00002081,0x00002081,0x00000080,0x00802081,0x00000081,0x00000001,0x00002000,0x00800001,0x00002001,0x00802080,0x00800081,
 0x00002001,0x00002080,0x00800000,0x00802001,0x00000080,0x00800000,0x00002000,0x00802080
 };



 H aa_crypto_des_SB5[64] =
 {
 0x00000100,0x02080100,0x02080000,0x42000100,0x00080000,0x00000100,0x40000000,0x02080000,0x40080100,0x00080000,0x02000100,0x40080100,0x42000100,0x42080000,
 0x00080100,0x40000000,0x02000000,0x40080000,0x40080000,0x00000000,0x40000100,0x42080100,0x42080100,0x02000100,0x42080000,0x40000100,0x00000000,0x42000000,
 0x02080100,0x02000000,0x42000000,0x00080100,0x00080000,0x42000100,0x00000100,0x02000000,0x40000000,0x02080000,0x42000100,0x40080100,0x02000100,0x40000000,
 0x42080000,0x02080100,0x40080100,0x00000100,0x02000000,0x42080000,0x42080100,0x00080100,0x42000000,0x42080100,0x02080000,0x00000000,0x40080000,0x42000000,
 0x00080100,0x02000100,0x40000100,0x00080000,0x00000000,0x40080000,0x02080100,0x40000100
 };



 H aa_crypto_des_SB6[64] =
 {
 0x20000010,0x20400000,0x00004000,0x20404010,0x20400000,0x00000010,0x20404010,0x00400000,0x20004000,0x00404010,0x00400000,0x20000010,0x00400010,0x20004000,
 0x20000000,0x00004010,0x00000000,0x00400010,0x20004010,0x00004000,0x00404000,0x20004010,0x00000010,0x20400010,0x20400010,0x00000000,0x00404010,0x20404000,
 0x00004010,0x00404000,0x20404000,0x20000000,0x20004000,0x00000010,0x20400010,0x00404000,0x20404010,0x00400000,0x00004010,0x20000010,0x00400000,0x20004000,
 0x20000000,0x00004010,0x20000010,0x20404010,0x00404000,0x20400000,0x00404010,0x20404000,0x00000000,0x20400010,0x00000010,0x00004000,0x20400000,0x00404010,
 0x00004000,0x00400010,0x20004010,0x00000000,0x20404000,0x20000000,0x00400010,0x20004010
 };



 H aa_crypto_des_SB7[64] =
 {
 0x00200000,0x04200002,0x04000802,0x00000000,0x00000800,0x04000802,0x00200802,0x04200800,0x04200802,0x00200000,0x00000000,0x04000002,0x00000002,0x04000000,
 0x04200002,0x00000802,0x04000800,0x00200802,0x00200002,0x04000800,0x04000002,0x04200000,0x04200800,0x00200002,0x04200000,0x00000800,0x00000802,0x04200802,
 0x00200800,0x00000002,0x04000000,0x00200800,0x04000000,0x00200800,0x00200000,0x04000802,0x04000802,0x04200002,0x04200002,0x00000002,0x00200002,0x04000000,
 0x04000800,0x00200000,0x04200800,0x00000802,0x00200802,0x04200800,0x00000802,0x04000002,0x04200802,0x04200000,0x00200800,0x00000000,0x00000002,0x04200802,
 0x00000000,0x00200802,0x04200000,0x00000800,0x04000002,0x04000800,0x00000800,0x00200002
 };




 H aa_crypto_des_SB8[64] =
 {
 0x10001040,0x00001000,0x00040000,0x10041040,0x10000000,0x10001040,0x00000040,0x10000000,0x00040040,0x10040000,0x10041040,0x00041000,0x10041000,0x00041040,
 0x00001000,0x00000040,0x10040000,0x10000040,0x10001000,0x00001040,0x00041000,0x00040040,0x10040040,0x10041000,0x00001040,0x00000000,0x00000000,0x10040040,
 0x10000040,0x10001000,0x00041040,0x00040000,0x00041040,0x00040000,0x10041000,0x00001000,0x00000040,0x10040040,0x00001000,0x00041040,0x10001000,0x00000040,
 0x10000040,0x10040000,0x10040040,0x10000000,0x00040000,0x10001040,0x00000000,0x10041040,0x00040040,0x10000040,0x10040000,0x10001000,0x10001040,0x00000000,
 0x10041040,0x00041000,0x00041000,0x00001040,0x00001040,0x00040040,0x10000000,0x10041000
 };



 H aa_crypto_des_LHs[16] =
 {
 0x00000000,0x00000001,0x00000100,0x00000101,0x00010000,0x00010001,0x00010100,0x00010101,0x01000000,0x01000001,0x01000100,0x01000101,0x01010000,0x01010001,0x01010100,0x01010101
 };



 H aa_crypto_des_RHs[16] =
 {
 0x00000000,0x01000000,0x00010000,0x01010000,0x00000100,0x01000100,0x00010100,0x01010100,0x00000001,0x01000001,0x00010001,0x01010001,0x00000101,0x01000101,0x00010101,0x01010101,
 };



 B aesffecb_sbox[256]=
 {
 0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,
 0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,
 0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,
 0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,
 0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,
 0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,
 0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,
 0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16
 };


 B aesffecb_sboxinv[256]=
 {
 0x52,0x09,0x6a,0xd5,0x30,0x36,0xa5,0x38,0xbf,0x40,0xa3,0x9e,0x81,0xf3,0xd7,0xfb,0x7c,0xe3,0x39,0x82,0x9b,0x2f,0xff,0x87,0x34,0x8e,0x43,0x44,0xc4,0xde,0xe9,0xcb,
 0x54,0x7b,0x94,0x32,0xa6,0xc2,0x23,0x3d,0xee,0x4c,0x95,0x0b,0x42,0xfa,0xc3,0x4e,0x08,0x2e,0xa1,0x66,0x28,0xd9,0x24,0xb2,0x76,0x5b,0xa2,0x49,0x6d,0x8b,0xd1,0x25,
 0x72,0xf8,0xf6,0x64,0x86,0x68,0x98,0x16,0xd4,0xa4,0x5c,0xcc,0x5d,0x65,0xb6,0x92,0x6c,0x70,0x48,0x50,0xfd,0xed,0xb9,0xda,0x5e,0x15,0x46,0x57,0xa7,0x8d,0x9d,0x84,
 0x90,0xd8,0xab,0x00,0x8c,0xbc,0xd3,0x0a,0xf7,0xe4,0x58,0x05,0xb8,0xb3,0x45,0x06,0xd0,0x2c,0x1e,0x8f,0xca,0x3f,0x0f,0x02,0xc1,0xaf,0xbd,0x03,0x01,0x13,0x8a,0x6b,
 0x3a,0x91,0x11,0x41,0x4f,0x67,0xdc,0xea,0x97,0xf2,0xcf,0xce,0xf0,0xb4,0xe6,0x73,0x96,0xac,0x74,0x22,0xe7,0xad,0x35,0x85,0xe2,0xf9,0x37,0xe8,0x1c,0x75,0xdf,0x6e,
 0x47,0xf1,0x1a,0x71,0x1d,0x29,0xc5,0x89,0x6f,0xb7,0x62,0x0e,0xaa,0x18,0xbe,0x1b,0xfc,0x56,0x3e,0x4b,0xc6,0xd2,0x79,0x20,0x9a,0xdb,0xc0,0xfe,0x78,0xcd,0x5a,0xf4,
 0x1f,0xdd,0xa8,0x33,0x88,0x07,0xc7,0x31,0xb1,0x12,0x10,0x59,0x27,0x80,0xec,0x5f,0x60,0x51,0x7f,0xa9,0x19,0xb5,0x4a,0x0d,0x2d,0xe5,0x7a,0x9f,0x93,0xc9,0x9c,0xef,
 0xa0,0xe0,0x3b,0x4d,0xae,0x2a,0xf5,0xb0,0xc8,0xeb,0xbb,0x3c,0x83,0x53,0x99,0x61,0x17,0x2b,0x04,0x7e,0xba,0x77,0xd6,0x26,0xe1,0x69,0x14,0x63,0x55,0x21,0x0c,0x7d
 };





 #define AESFFECB_F(x)                 (((x)<<1)^((((x)>>7)&1)*0x1b))
 #define AESFFECB_FD(x)                (((x)>>1)^(((x)&1)?0x8d:0))

 #define AES256_KEY_SIZE               256U
 #define AES256_KEY_BYTES              (AES256_KEY_SIZE/8U)
 #define AES256_BLOCK_BYTES            16U

 #define aes256_sbox(x)                aesffecb_sbox[(x)]
 #define aes256_sbox_inv(x)            aesffecb_sboxinv[(x)]

 structure
 {
 B key[AES256_KEY_BYTES];
 B enc_key[AES256_KEY_BYTES];
 B dec_key[AES256_KEY_BYTES];
 }
 _aes256_context;



 #define aaDES_IP(XX,YY)                                  \
 {                                                        \
 TT=((XX>>4)^YY)&0x0F0F0F0F; YY^=TT; XX^=(TT<<4);         \
 TT=((XX>>16)^YY)&0x0000FFFF; YY^=TT; XX^=(TT<<16);       \
 TT=((YY>>2)^XX)&0x33333333; XX^=TT; YY^=(TT<<2);         \
 TT=((YY>>8)^XX)&0x00FF00FF; XX^=TT; YY^=(TT<<8);         \
 YY=((YY<<1)|(YY>>31))&0xFFFFFFFF;                        \
 TT=(XX^YY)&0xAAAAAAAA; YY^=TT; XX^=TT;                   \
 XX=((XX<<1)|(XX>>31))&0xFFFFFFFF;                        \
 }



 #define aaDES_FP(XX,YY)                                  \
 {                                                        \
 XX=((XX<<31)|(XX>>1))&0xFFFFFFFF;                        \
 TT=(XX^YY)&0xAAAAAAAA; XX^=TT; YY^=TT;                   \
 YY=((YY<<31)|(YY>>1))&0xFFFFFFFF;                        \
 TT=((YY>>8)^XX)&0x00FF00FF; XX^=TT; YY^=(TT<<8);         \
 TT=((YY>>2)^XX)&0x33333333; XX^=TT; YY^=(TT<<2);         \
 TT=((XX>>16)^YY)&0x0000FFFF; YY^=TT; XX^=(TT<<16);       \
 TT=((XX>>4)^YY)&0x0F0F0F0F; YY^=TT; XX^=(TT<<4);         \
 }




 #define aaDES_ROUND(XX,YY)                               \
 {                                                        \
 TT=*SK++^XX;                                             \
 YY^=aa_crypto_des_SB8[(TT)&0x3F]^                        \
     aa_crypto_des_SB6[(TT>>8)&0x3F]^                     \
     aa_crypto_des_SB4[(TT>>16)&0x3F]^                    \
     aa_crypto_des_SB2[(TT>>24)&0x3F];                    \
 TT=*SK++^((XX<<28)|(XX>>4));                             \
 YY^=aa_crypto_des_SB7[(TT)&0x3F]^                        \
     aa_crypto_des_SB5[(TT>>8)&0x3F]^                     \
     aa_crypto_des_SB3[(TT>>16)&0x3F]^                    \
     aa_crypto_des_SB1[(TT>>24)&0x3F];                    \
 }



 #define aaChaCha20_ROTL32(v,n)        ((v)<<(n))|((v)>>(32-(n)))
 #define aaChaCha20_LE(p)              (((u32)((p)[0]))|((u32)((p)[1])<<8)|((u32)((p)[2])<<16)|((u32)((p)[3])<<24))
 #define aaChaCha20_FROMLE(b,i)        (b)[0]=i&0xFF; (b)[1]=(i>>8)&0xFF; (b)[2]=(i>>16)&0xFF; (b)[3]=(i>>24)&0xFF;
 #define aaChaCha20_QROUND(x,a,b,c,d)  x[a]+=x[b]; x[d]=aaChaCha20_ROTL32(x[d]^x[a],16); \
                                       x[c]+=x[d]; x[b]=aaChaCha20_ROTL32(x[b]^x[c],12); \
                                       x[a]+=x[b]; x[d]=aaChaCha20_ROTL32(x[d]^x[a],8);  \
                                       x[c]+=x[d]; x[b]=aaChaCha20_ROTL32(x[b]^x[c],7);


 structure
 {
 H self_handle;
 B type;
 B state[258];
 _aa_crypto_des_context des_context;
 _aa_crypto_des3_context des3_context;
 _aes256_context aes_context;
 }
 _aa_cryptoobject;


 structure
 {
 B object_id;
 }
 _aa_cryptosystem;

 B aa_CryptoSystemStart                (V);
 V aa_CryptoSystemStop                 (V);
 V aa_CryptoSystemProcess              (H SK[32],B key[8]);

/*-----------------------------------------------------------------------*/

 structure
 {
 H self_handle;
 _jsonstatus status;
 Z depth;
 B in_array;
 B last_enc_type;
 H dec_stage;
 H lines_allocated;
 H bytes_allocated;
 H bytes_left;
 _parser pa,pb;
 }
 _aa_jsonobject;



 structure
 {
 B object_id;
 }
 _aa_jsonsystem;



 B aa_JsonSystemStart                  (V);
 B aa_JsonSystemStop                   (V);
 B aa_JsonSystemExtendMemory           (PP mem,H by);
 B aa_JsonSystemDecoderType            (PP mem,B type,H off,H bytes,VP data);
 B aa_jsonSystemDecode                 (PP mem);


/*-----------------------------------------------------------------------*/


 structure
 {
 B tmp;
 }
 _aa_clipboardsystem;


 B aa_ClipBoardSystemStart             (V);
 V aa_ClipBoardSystemStop              (V);


/*-----------------------------------------------------------------------*/

 structure
 {
 H self_handle;
 H total_bytes;
 H user_bytes;
 H lock_deny_count;
 B rsvd[1016];
 }
 _ipcramhdr;


 structure
 {
 H self_handle;
 HANDLE object_handle;
 HANDLE mutex_handle;
 BP page_memory;
 _ipcstatus status;
 }
 _aa_ipcobject;


 structure
 {
 B object_id;
 }
 _aa_ipcsystem;


 B aa_IpcSystemStart                   (V);
 V aa_IpcSystemStop                    (V);

/*-----------------------------------------------------------------------*/

 structure
 {
 H self_handle;
 _desktopstatus status;
 H thread_id;
 HDESK desk_handle;
 HDESK original_handle;
 }
 _aa_desktopobject;


 structure
 {
 B object_id;
 }
 _aa_desktopsystem;


 B aa_DesktopSystemStart               (V);
 V aa_DesktopSystemStop                (V);

/*-----------------------------------------------------------------------*/

 #define BIGINT_RADIX                  0x100000000

 _bigint                               big_val[17];


 B aa_BigintSystemStart                (V);
 V aa_BigintSystemStop                 (V);


/*-----------------------------------------------------------------------*/



 structure
 {
 _aa_coresystem core_system;
 _aa_timersystem timer_system;
 _aa_memorysystem memory_system;
 _aa_pagesystem page_system;
 _aa_objectsystem object_system;
 _aa_threadsystem thread_system;
 _aa_poolsystem pool_system;
 _aa_processsystem process_system;
 _aa_winenumsystem winenum_system;
 _aa_mathsystem math_system;
 _aa_dynbufsystem dynbuf_system;
 _aa_quesystem que_system;
 _aa_netsystem net_system;
 _aa_fontsystem font_system;
 _aa_displaysystem display_system;
 _aa_surfacesystem surface_system;
 _aa_colorsystem color_system;
 _aa_gifsystem gif_system;
 _aa_cursorsystem cursor_system;
 _aa_inputsystem input_system;
 _aa_audiosystem audio_system;
 _aa_vidcapsystem vidcap_system;
 _aa_filestreamsystem filestream_system;
 _aa_fileboxsystem filebox_system;
 _aa_folderboxsystem folderbox_system;
 _aa_dirsystem dir_system;
 _aa_dirwalkersystem dirwalker_system;
 _aa_cpumonitorsystem cpumonitor_system;
 _aa_digestsystem digest_system;
 _aa_cryptosystem crypto_system;
 _aa_jsonsystem json_system;
 _aa_clipboardsystem clipboard_system;
 _aa_ipcsystem ipc_system;
 _aa_desktopsystem desktop_system;
 B is_diag_paused;
 B is_ready;
 }
 _aa;

 _aa                                   aa;


 B is_aa_ready=NO;
 B is_aa_quit_posted=NO;
 B is_aa_started=NO;
 B is_aa_started_by_winmain=NO;
 B aa_show_crash=3;
 B aa_is_quit_called=NO;
 B aa_is_quit_received=NO;
 B aa_is_esc=NO;
 H aa_ie_events_waiting=0;
 H aa_ie_events_waiting_threshold=0;
 B aa_is_morph_pending=0;
 B aa_debug_runtime=NO;
 H aa_prevstage=0;
 H aa_nextstage=0;
 H aa_stage=0;
 B aa_i_am=0;
 H aa_craperr=0;
 B aa_is_64bit=NO;
 B aa_bigendian=NO;
 B aa_littleendian=NO;
 Q aa_cycle=0;
 B aa_firsttik_set=NO;
 H aa_firsttik=0;
 H aa_launchtik=0;
 H aa_discovery_id=0;
 D aa_askhz=0.0;
 D aa_curhz=0.0;
 D aa_rathz=0.0;
 D aa_curcpuload=0.0;
 D aa_curproload=0.0;
 D aa_avgcpuload=0.0;
 D aa_avgproload=0.0;
 Q aa_msrunning=0;
 Q aa_microsecsrunning=0;
 D aa_secsrunning=0;
 B aa_hide_diag=NO;
 B aa_hide_leak=NO;
 B aa_hide_proc=NO;
 H aa_oof_count=0;
 Q aa_stats[100]={0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0};
 BP aa_cdecl;


 C aa_last_line_info[128]={0};
 C aa_last_executed[257]={0};
 C aa_last_info[257]={0};

 D aa_NAN=0.0/0.0;
 D aa_POS_INF=1.0/0.0;
 D aa_NET_INF=-1.0/0.0;


/*-----------------------------------------------------------------------*/

 _size aa_size_32x32  ={.w=32,.h=32 };
 _size aa_size_320x240={.w=320,.h=240 };
 _size aa_size_640x480={.w=640,.h=480 };
 _size aa_size_800x600={.w=800,.h=600 };
 _size aa_size_1024x768={.w=1024,.h=768 };

/*-----------------------------------------------------------------------*/



 N WINAPI aa_ExceptionHandler          (struct _EXCEPTION_POINTERS*exceptioninfo)
 {
 S B first_call=YES;
 B txt[_32K];
 H f,exa,ok;
 B fn[129];
 VP fproc[8];
 VP rproc[8];
 C path[_1K];
 C name[_1K];


 aa.is_diag_paused=YES;
 aaLog(-555,"%s:#%i",__func__,__LINE__);

 GetCurrentDirectory(MAX_PATH,(CP)path);
 aaStringCopy(name,path);
 aaStringAppend(name,"\\aa_crash.txt");

 if(aa.core_system.is_restart_on_crash==YES)
  {
  if(aa_msrunning<aa.core_system.crash_msrunning_required)
   {
   if(first_call==YES) { aaJournal(name,"oops1"); first_call=NO;  }
   else                { aaJournal(name,"oops2"); return(EXCEPTION_EXECUTE_HANDLER); }
   }
  else
   {
   if(first_call==YES) {  aaJournal(name,"oops3"); first_call=NO;  }
   else                {  aaJournal(name,"oops4"); return(EXCEPTION_EXECUTE_HANDLER); }
   }
  }
 else
  {
  if(first_call==YES) {  aaJournal(name,"oops5"); first_call=NO;  }
  else                {  aaJournal(name,"oops6"); return(EXCEPTION_EXECUTE_HANDLER); }
  }
 aaStringNull(txt);
 aaStringAppendf(txt,"\r\n");
 aaStringAppendf(txt,"------------------------------------------------------\r\n");
 aaStringAppendf(txt,"**aaBoost has crashed**\r\n");
 aaStringAppendf(txt,"process_id=%i\r\n",aa.core_system.process_id);
 aaStringAppendf(txt,"------------------------------------------------------\r\n");
 aaLog(-555,"%s",txt);
 switch(exceptioninfo->ExceptionRecord->ExceptionCode)
  {
  case EXCEPTION_ACCESS_VIOLATION:               aaStringAppendf(txt,"REASON: access violation\r\n"); break;
  case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:          aaStringAppendf(txt,"REASON: array bounds\r\n"); break;
  case EXCEPTION_BREAKPOINT:                     aaStringAppendf(txt,"REASON: breakpoint\r\n"); break;
  case EXCEPTION_DATATYPE_MISALIGNMENT:          aaStringAppendf(txt,"REASON: data misalignment\r\n"); break;
  case EXCEPTION_FLT_DENORMAL_OPERAND:           aaStringAppendf(txt,"REASON: denormal operand\r\n"); break;
  case EXCEPTION_FLT_DIVIDE_BY_ZERO:             aaStringAppendf(txt,"REASON: divide by zero\r\n"); break;
  case EXCEPTION_FLT_INEXACT_RESULT:             aaStringAppendf(txt,"REASON: inexact resultr\r\n"); break;
  case EXCEPTION_FLT_INVALID_OPERATION:          aaStringAppendf(txt,"REASON: invalid operation\r\n"); break;
  case EXCEPTION_FLT_OVERFLOW:                   aaStringAppendf(txt,"REASON: overflow\r\n"); break;
  case EXCEPTION_FLT_STACK_CHECK:                aaStringAppendf(txt,"REASON: stack check\r\n"); break;
  case EXCEPTION_FLT_UNDERFLOW:                  aaStringAppendf(txt,"REASON: underflow\r\n"); break;
  case EXCEPTION_ILLEGAL_INSTRUCTION:            aaStringAppendf(txt,"REASON: illegal instruction\r\n"); break;
  case EXCEPTION_IN_PAGE_ERROR:                  aaStringAppendf(txt,"REASON: in page\r\n"); break;
  case EXCEPTION_INT_DIVIDE_BY_ZERO:             aaStringAppendf(txt,"REASON: INT divide zero\r\n"); break;
  case EXCEPTION_INT_OVERFLOW:                   aaStringAppendf(txt,"REASON: INT overflow\r\n"); break;
  case EXCEPTION_INVALID_DISPOSITION:            aaStringAppendf(txt,"REASON: invalid disposition\r\n"); break;
  case EXCEPTION_NONCONTINUABLE_EXCEPTION:       aaStringAppendf(txt,"REASON: noncommutable exception\r\n"); break;
  case EXCEPTION_PRIV_INSTRUCTION:               aaStringAppendf(txt,"REASON: priv instruction\r\n"); break;
  case EXCEPTION_SINGLE_STEP:                    aaStringAppendf(txt,"REASON: single step\r\n"); break;
  case EXCEPTION_STACK_OVERFLOW:                 aaStringAppendf(txt,"REASON: stack overflow\r\n"); break;
  default:                                       aaStringAppendf(txt,"REASON: Unknown %08lx\r\n",exceptioninfo->ExceptionRecord->ExceptionCode); break;
  }
 aaStringAppendf(txt,"FLAGS: %lu (note: EXCEPTION_NONCONTINUABLE=%i)\r\n",exceptioninfo->ExceptionRecord->ExceptionFlags,EXCEPTION_NONCONTINUABLE);
 exa=(H)exceptioninfo->ExceptionRecord->ExceptionAddress;
 aaStringAppendf(txt,"ADDRESS OF CRASH: %-8i\r\nlast_line_executed=%u\r\n",exa,aa_last_line_executed);
 if(aa_last_line_info[0]) { aaStringAppendf(txt,"last_line_info=%s\r\n",aa_last_line_info); }
 if(aa_last_executed[0])  { aaStringAppendf(txt,"last_executed=%s\r\n",aa_last_executed); }
 if(aa_last_info[0])      { aaStringAppendf(txt,"last_info=%s\r\n",aa_last_info); }
 aaMemoryZero(fproc,sizeof(fproc));
 aaMemoryZero(rproc,sizeof(rproc));
 while(1)
  {
  fproc[0]=__builtin_frame_address(0);   if(fproc[0]==0) { break; }
  fproc[1]=__builtin_frame_address(1);   if(fproc[1]==0) { break; }
  fproc[2]=__builtin_frame_address(2);   if(fproc[2]==0) { break; }
  fproc[3]=__builtin_frame_address(3);   if(fproc[3]==0) { break; }
  fproc[4]=__builtin_frame_address(4);   if(fproc[4]==0) { break; }
  fproc[5]=__builtin_frame_address(5);   if(fproc[5]==0) { break; }
  fproc[6]=__builtin_frame_address(6);   if(fproc[6]==0) { break; }
  fproc[7]=__builtin_frame_address(7);   if(fproc[7]==0) { break; }
  break;
  }
 while(1)
  {
  rproc[0]=__builtin_return_address(0);   if(rproc[0]==0) { break; }
  rproc[1]=__builtin_return_address(1);   if(rproc[1]==0) { break; }
  rproc[2]=__builtin_return_address(2);   if(rproc[2]==0) { break; }
  rproc[3]=__builtin_return_address(3);   if(rproc[3]==0) { break; }
  rproc[4]=__builtin_return_address(4);   if(rproc[4]==0) { break; }
  rproc[5]=__builtin_return_address(5);   if(rproc[5]==0) { break; }
  rproc[6]=__builtin_return_address(6);   if(rproc[6]==0) { break; }
  rproc[7]=__builtin_return_address(7);   if(rproc[7]==0) { break; }
  break;
  }
 while(1)
  {
  fproc[0]=__builtin_extract_return_addr(fproc[0]);
  fproc[1]=__builtin_extract_return_addr(fproc[1]);
  fproc[2]=__builtin_extract_return_addr(fproc[2]);
  fproc[3]=__builtin_extract_return_addr(fproc[3]);
  fproc[4]=__builtin_extract_return_addr(fproc[4]);
  fproc[5]=__builtin_extract_return_addr(fproc[5]);
  fproc[6]=__builtin_extract_return_addr(fproc[6]);
  fproc[7]=__builtin_extract_return_addr(fproc[7]);
  break;
  }


 if(aa.core_system.is_restart_on_crash==NO)
  {
  if(aaBitGet(aa_show_crash,0))
   {
   aaNote(0,"r\r\n%s",txt);
   }
  }
 else
  {
  aaHistory(__LINE__,"%s %s",__FILE__,txt);
  }
 if(aa_hide_leak==NO)
  {
  aa_MemorySystemDump();
  }
 ok=NO;
 aaStringNull(fn);
 if(aa.core_system.is_restart_on_crash==NO)
  {
  if(ok)
   {
   ///aaStringAppendf(txt,"Function index %i  [%s]  (offset: %lu bytes)  \n",p,fn,aaNumAbs((N)exa-(N)adr));
   }
  for(f=0;f<aaElementCount(fproc);f++)
   {
   //if(iproc[f]==0) break;
   if(f==0) { aaStringAppendf(txt,"__builtin_frame_address\r\n"); }
   aaStringAppendf(txt,"[%i]=%-8i",f,(Z)fproc[f]);
   aaStringAppendf(txt,"\r\n");
   }
  for(f=0;f<aaElementCount(rproc);f++)
   {
   //if(iproc[f]==0) break;
   if(f==0) { aaStringAppendf(txt,"__builtin_return_address\r\n"); }
   aaStringAppendf(txt,"[%i]=%-8i",f,(Z)rproc[f]);
   aaStringAppendf(txt,"\r\n");
   }
  aaJournal(name,"%s",txt);
  if(aaBitGet(aa_show_crash,1))
   {
   aaNote(0,"z %s",txt);
   }
  }
 aaLog(-1,"\n\n\n\n\n%s",txt);
 if(aa.core_system.is_restart_on_crash==YES&&aa_msrunning>=aa.core_system.crash_msrunning_required)
  {
  aaHistory(__LINE__,"%s",__FILE__);
  aaMorph(aa.core_system.module_filename,aa.core_system.command_line);
  aaQuit();
  aaStop();
  return(EXCEPTION_EXECUTE_HANDLER);
  }
// aaQuit();
 ///aaStop();
 return(EXCEPTION_EXECUTE_HANDLER);
 }


/*-----------------------------------------------------------------------*/


 structure                             {Q dummyq; H dummyh; B dummyb; } _packdummy;

/*-----------------------------------------------------------------------*/


 B aaStart                             (HINSTANCE thisinst,HINSTANCE previnst,LPSTR cmdline,Z cmdshow)
 {
 B ret;
 H val;
 BP bp;

// aaSleep(1000);
 ///OutputDebugString("func-aaStart");
 #if aa_USE_GLOBAL_MUTEX == 1
 InitializeCriticalSection(&global_mutex);
 #endif
 if(sizeof(_packdummy)!=13) { aaNote(0,"-fpack-struct not enabled"); return 0; }
 if(is_aa_started==YES) { oof; return RET_INUSE; }
 ///if(setjmp(aa_jmp_buf)!=0)   { return RET_FAILED; } //oof; return(aaStop());   }
 val=0x01020304;
 bp=(BP)&val;
 if(*bp==1) { aa_bigendian=YES; aa_littleendian=NO; }
 else       { aa_bigendian=NO; aa_littleendian=YES; }
 is_aa_started=YES;
 while(1)
  {
  if(GetFileAttributes("C:\\i_am_ashot.tag")!=0xffffffff) { aa_i_am='A'; break; }
  break;
  }

 #if aa_DIAGNOSE == YES
  {
  H go;
  HP hp;
  aaCast(hp,HP,aa_diag_hits);
  for(go=0;go<(sizeof(aa_diag_hits)/4);go++) hp[go]=0;
  aaCast(hp,HP,aa_diag_cycle);
  for(go=0;go<(sizeof(aa_diag_cycle)/4);go++) hp[go]=0;
   aa_diag_hi=aa_diag_lo=0;
  }
 #endif
 if((ret=aa_CoreSystemStart(thisinst,previnst,cmdline,cmdshow))!=YES) { return ret; }
 ///OutputDebugString("aaStart returned from aa_coresystemstart");
 aa_TimerSystemStart();
 aa_MemorySystemStart();
 aa_TimerSystemCpuSpeedGet();
 aa_PageSystemStart();
 aa_ObjectSystemStart();
 aa_ThreadSystemStart();
 aa_PoolSystemStart();
 aa_ProcessSystemStart();
 aa_WinEnumSystemStart();
 aa_MathSystemStart();
 aa_DynbufSystemStart();
 aa_QueSystemStart();
 if((ret=aa_NetSystemStart())!=YES) { return ret; }
 aa_FontSystemStart();
 aa_DisplaySystemStart();
 aa_SurfaceSystemStart();
 aa_CursorSystemStart();
 aa_ColorSystemStart();
 aa_GifSystemStart();
 aa_InputSystemStart();
 aa_AudioSystemStart();
 aa_VidCapSystemStart();
 aa_FileStreamSystemStart();
 aa_FileBoxSystemStart();
 aa_FolderBoxSystemStart();
 aa_DirSystemStart();
 aa_DirWalkerSystemStart();
 aa_CpuMonitorSystemStart();
 aa_DigestSystemStart();
 aa_CryptoSystemStart();
 aa_JsonSystemStart();
 aa_ClipBoardSystemStart();
 aa_IpcSystemStart();
 aa_DesktopSystemStart();
 aa_BigintSystemStart();
 ///OutputDebugString("line 4264");
 aa_CoreSystemLogStateSet(1);
 aaTimerTikElapsed(aa.core_system.aamain_tik,&aa.core_system.aamain_elapsed);
 aa.is_ready=YES;
 is_aa_ready=YES;
 //if(setjmp(aa_jmp_buf)!=0)   { return RET_FAILED; } //oof; return(aaStop());   }
 return RET_YES;
 }





 Z aaStop                              (V)
 {
 H go,i,mx;
 #if aa_DIAGNOSE == YES
 H lmo;
 #endif

 //////////////////////////////////////////////////////////////////////////////////////////////
 if(is_aa_started_by_winmain==YES&&is_aa_quit_posted==NO) {   PostQuitMessage(1); }
 /////////////////////
 //aaLog(-1,"line=%i",__LINE__);
 aa_last_line_executed=__LINE__;
 for(go=0;go<1000;go++)
  {
  if(aa.core_system.wm_quit_received==YES) {  break; }
  aa_CoreSystemLoop();
  aaSleep(2);
  }
 /////////////////////
 mx=aaElementCount(aa.core_system.RoutineProcStop);
 for(i=0;i<mx;i++)
  {
  if(aa.core_system.RoutineProcStop[mx-i-1]!=NULL)
   {
   aa.core_system.RoutineProcStop[mx-i-1](aa.core_system.RoutineParmStop[mx-i-1]);
   }
  aa.core_system.RoutineProcStop[mx-i-1]=NULL;
  aa.core_system.RoutineProcYield[mx-i-1]=NULL;
  aa.core_system.RoutineParmStop[mx-i-1]=NULL;
  aa.core_system.RoutineParmYield[mx-i-1]=NULL;
  }
 aa_BigintSystemStop();
 aa_DesktopSystemStop();
 aa_last_line_executed=__LINE__;
 aa_IpcSystemStop();
 aa_last_line_executed=__LINE__;
 ///aaDebugf("line=%i",__LINE__);
 aa_ClipBoardSystemStop();
 aa_last_line_executed=__LINE__;
 aa_JsonSystemStop();
 aa_CryptoSystemStop();
 aa_DigestSystemStop();
 aa_CpuMonitorSystemStop();
 aa_DirWalkerSystemStop();
 aa_last_line_executed=__LINE__;
 aa_DirSystemStop();
 aa_FolderBoxSystemStop();
 aa_FileBoxSystemStop();
 aa_FileStreamSystemStop();
 aa_VidCapSystemStop();
 aa_AudioSystemStop();
 aa_InputSystemStop();
 aa_GifSystemStop();
 aa_last_line_executed=__LINE__;
 aa_ColorSystemStop();
 aa_CursorSystemStop();
 aa_SurfaceSystemStop();
 aa_last_line_executed=__LINE__;
 aa_DisplaySystemStop();
 aa_FontSystemStop();
 aa_last_line_executed=__LINE__;
 aa_NetSystemStop();
 aa_last_line_executed=__LINE__;
 aa_QueSystemStop();
 aa_DynbufSystemStop();
 aa_MathSystemStop();
 aa_WinEnumSystemStop();
 aa_ProcessSystemStop();
 aa_PoolSystemStop();
 aa_ThreadSystemStop();
 aa_ObjectSystemStop();
 aa_PageSystemStop();
 aa_MemorySystemStop();
 aa_TimerSystemStop();
 aa_CoreSystemStop();
 aa_last_line_executed=__LINE__;
 while(1)
 {
 if(aa_hide_diag==YES) { break; }
 #if aa_DIAGNOSE == YES
  {
  H sx,i,tik,el,cc,tmpcnt,tmpline;
  C tmpname[64];
  C txt[_1K];
  D d1,d2,gt,pc;
  H yz=0;
  N j,dif,flp;
  tik=GetTickCount();
  if(tik>=aa.core_system.launch_tik)   {  el=tik-aa.core_system.launch_tik;            }
  else                                 {  el=(F32-aa.core_system.launch_tik)+(tik+1);  }
  gt=aa_diag_hi*1000.0;
  gt=gt+aa_diag_lo;
  pc=100.0/gt;
  cc=0;
  for(i=0;i<aa_SHOW_DIAG_LINES;i++)  {  if(aa_diag_text[i][0]!=NULL_CHAR)  { aa_diag_hits[cc]=aa_diag_hits[i];  aa_diag_line[cc]=aa_diag_line[i];   strcpy(aa_diag_text[cc],aa_diag_text[i]);   cc++;  }  }
  for(i=1;i<cc;i++)
   {
   tmpname[0]=0;
   tmpcnt=aa_diag_hits[i];
   tmpline=aa_diag_line[i];
   strcpy(tmpname,aa_diag_text[i]);
   j=i-1;
   while(j>=0)
    {
    if(tmpcnt<aa_diag_hits[j]) { break; }
    aa_diag_hits[j+1]=aa_diag_hits[j];
    strcpy(aa_diag_text[j+1],aa_diag_text[j]);
    aa_diag_line[j+1]=aa_diag_line[j];
    j--;
    }
   aa_diag_hits[j+1]=tmpcnt;
   aa_diag_line[j+1]=tmpline;
   strcpy(aa_diag_text[j+1],tmpname);
   }
  d1=(D)el;
  d1=d1/1000.0;
  d1=gt/(d1+0.0001);

  lmo=(H)-555;
  aaLog(lmo,"");
  aaLog(lmo,"==================================================================================");
  aaLog(lmo,"Diagnosis: %.0f calls made by %i functions, in %i ms, apx %.0f calls/sec",gt,cc,el,d1);
  aaLog(lmo,"==================================================================================");
  aaLog(lmo,"");

  lmo=(H)-555;
  if(el<=1000)
   {
   gt=1000.0/el;
   //gt=1.0/gt;
   if(gt!=0&&aa.memory_system.status.fill_calls!=0)
    {
    aaLog(lmo,"MEMORY FILL: %9I64u k/s %9I64u KiloBytes  %I64u calls  %I64u KB/call",
               (Q)(aa.memory_system.status.bytes_filled/gt)/1024,(Q)aa.memory_system.status.bytes_filled/1024,(Q)aa.memory_system.status.fill_calls,(Q)(aa.memory_system.status.bytes_filled/aa.memory_system.status.fill_calls)/1024);
    }
   if(gt!=0&&aa.memory_system.status.copy_calls!=0)
    {
    aaLog(lmo,"MEMORY COPY: %9I64u k/s %9I64u KiloBytes  %I64u calls  %I64u KB/call",(Q)
                (aa.memory_system.status.bytes_copied/gt)/1024,(Q)aa.memory_system.status.bytes_copied/1024,(Q)aa.memory_system.status.copy_calls,(Q)(aa.memory_system.status.bytes_copied/aa.memory_system.status.copy_calls)/1024);
    }
   }
  else
   {
   gt=el/1000.0;
   if(gt!=0&&aa.memory_system.status.fill_calls!=0)
    {
    aaLog(lmo,"MEMORY FILL: %9I64u k/s %9I64u KiloBytes  %I64u calls  %I64u KB/call",
               (Q)(aa.memory_system.status.bytes_filled/gt)/1024,(Q)aa.memory_system.status.bytes_filled/1024,(Q)aa.memory_system.status.fill_calls,(Q)(aa.memory_system.status.bytes_filled/aa.memory_system.status.fill_calls)/1024);
    }
   if(gt!=0&&aa.memory_system.status.copy_calls!=0)
    {
    aaLog(lmo,"MEMORY COPY: %9I64u k/s %9I64u KiloBytes  %I64u calls  %I64u KB/call",(Q)
                (aa.memory_system.status.bytes_copied/gt)/1024,(Q)aa.memory_system.status.bytes_copied/1024,(Q)aa.memory_system.status.copy_calls,(Q)(aa.memory_system.status.bytes_copied/aa.memory_system.status.copy_calls)/1024);
    }
   }
  aaLog(lmo,"");
  aaLog(lmo,"GLOBALALLOC: CALLS=%u %I64u KiloBytes",aa.memory_system.status.globalalloc_calls,(Q)aa.memory_system.status.globalalloc_bytes/1024);
  aaLog(lmo,"");
  aaLog(lmo,"MEMORY PEAK: ALLOC=%.2f Megs  USER ALLOC=%.2f Megs",(aa.memory_system.status.peak_bytes_allocated)/1048576.0,  (aa.memory_system.status.peak_user_bytes_allocated)/1048576.0);
  aaLog(lmo,"");
  for(sx=0;sx<256;sx++)
   {
   if(aa.memory_system.temp_bytes[sx]!=0)
    {
    aaLog(lmo,"MEMORY TEMP: [%3i] = %u bytes ( %u allocs , %u reallocs ) ",sx,aa.memory_system.temp_bytes[sx],aa.memory_system.temp_allocs[sx],aa.memory_system.temp_reallocs[sx]);
    }
   }
  aaLog(lmo,"");
  for(sx=0;sx<cc;sx++)
   {
   if(aaStringICompare(aa_diag_text[sx],"aaYield",0)==YES)
    {
    d1=(D)aa_diag_hits[sx]/gt;
    yz=(H)d1;
    aaLog(lmo,"OS MEMALOCS: %lu",aa.memory_system.alloc_calls);
    aaLog(lmo,"OS MEMRALCS: %lu",aa.memory_system.realloc_calls);
    aaLog(lmo,"OS MEMRELES: %lu",aa.memory_system.release_calls);
    aaLog(lmo,"");
    aaLog(lmo,"      YIELD: %.1fhz",yz/1.0);
    aaLog(lmo,"     CYCLES: %I64u",aa.core_system.cycle);
    aaLog(lmo,"    RUNTIME: %.2f secs",el/1000.0);
    aaLog(lmo,"");
    aaLog(lmo,"   WM_TOTAL: %I64u",aa.core_system.wm_msg_count_total);
    aaLog(lmo,"WM_SURFACED: %I64u",aa.core_system.wm_msg_count_surfaced);
    aaLog(lmo,"WM_ERASEBKG: %I64u",aa.core_system.wm_msg_count_erasebg);
    aaLog(lmo,"   WM_PAINT: %I64u",aa.core_system.wm_msg_count_paint);
    aaLog(lmo,"WM_UNHANDLD: %I64u",aa.core_system.wm_msg_count_unhandled);
    aaLog(lmo,"------------------------------------------------------------------------------------------------------------------------------");
    break;
    }
   }
  if(gt==0) { gt=1; }
  lmo=(H)-555;
  flp=0;
  if(yz==0) { yz=1; }
  for(sx=0;sx<cc;sx++)
   {
   d1=(D)aa_diag_hits[sx]*pc;
   d2=(D)aa_diag_hits[sx]/gt;
   dif=(N)d2-(N)yz;
   txt[1]=0;
   if(dif>=-1&&dif<=1) { txt[0]='*';   } else { txt[0]=32; }
   if(dif==0)    {    if(flp==0) {  aaLog(lmo," "); flp=1; lmo=(H)-555; }    }
   else          {    if(flp==1) {  aaLog(lmo," "); flp=2; }    }
   if(d2<1.0)    {    if(flp==2) {  aaLog(lmo," "); flp=3; }    }
   //if(aaStringNICompare(aa_diag_text[sx],"aaFile",F32,0)==YES)///||aaStringNICompare(aa_diag_text[sx],"aaBloom",F32,0)==YES)
    {
    aaLog(lmo," %-5i %37s  %8.2f Hz  %8.3f Yz  %11.0f calls  %6.3f %%  %s",aa_diag_line[sx],aa_diag_text[sx],d2,d2/(D)yz,(D)aa_diag_hits[sx],d1,txt);
    }
   }
  aaLog(lmo,"");
  aaLog(lmo,"Object Check Hits");
  aaLog(lmo,"-----------------");
  for(sx=0;sx<256;sx++)
   {
   if(aa.object_system.object_check_count[sx]!=0)
    {
    aaLog(lmo,"Object %-15s=%I64u",aa.object_system.object[sx].name,aa.object_system.object_check_count[sx]);
    }
   }
  aaLog(lmo,"");
  for(sx=0;sx<aaElementCount(aa_stats);sx++)
   {
   if(aa_stats[sx]!=0)
    {
    aaLog(lmo,"aa_stats[%-3i]=%I64u",sx,aa_stats[sx]);
    }
   }
  aaLog(lmo,"");
  aaLogStructSize(_threadstatus);
  aaLogStructSize(_jsonstatus);
  aaLogStructSize(_dynbufstatus);
  aaLogStructSize(_questatus);
  aaLogStructSize(_gifstatus);
  aaLogStructSize(_winenumstatus);
  aaLogStructSize(_sniffstatus);
  aaLogStructSize(_poolstatus);
  aaLogStructSize(_digeststatus);
  aaLogStructSize(_stunclientstatus);
  aaLogStructSize(_icmpstatus);
  aaLogStructSize(_tcpportstatus);
  aaLogStructSize(_cgiclientstatus);
  aaLogStructSize(_serverstatus);
  aaLogStructSize(_udpstatus);
  aaLogStructSize(_audiostatus);
  aaLogStructSize(_desktopstatus);
  aaLogStructSize(_dirstatus);
  aaLogStructSize(_tcpcallstatus);
  aaLogStructSize(_filestreamstatus);
  aaLogStructSize(_inputstate);
  aaLogStructSize(_surfacestatus);
  aaLogStructSize(_vidcapstatus);
  aaLogStructSize(_folderboxstatus);
  aaLogStructSize(_memorystatus);
  aaLogStructSize(_memorystatus);
  aaLogStructSize(_fontstatus);
  aaLogStructSize(_processstatus);
  aaLogStructSize(_netstatus);
  aaLogStructSize(_inputengine);
  aaLogStructSize(_dnsstatus);
  aaLogStructSize(_fileboxstatus);
  aaLog(lmo,"==================================================================================");
  aaLog(lmo,"");
  }
 #endif
 break;
 }
aa_last_line_executed=__LINE__;
 if(aa.core_system.is_morph_pending)
  {
  aaLog(-555,"morph is pending, about to resume");
  aaLimiterSet(0,0);
  aaSleep(10); // this used to be Sleep(100) ..
  aaLog(-555,"resu=%i",ResumeThread(aa.core_system.morph_pi.hThread));
  }
 logg("Calling ExitProcess(%i)",aa.core_system.wm_quit_exitcode);
 logg("");
 logg("~-");
 #if aa_DIAGNOSE == YES
 if(aa_hide_diag!=YES)
  {
  aaLog(-555,"\n\naaBoost stopped: after %ims",GetTickCount()-aa.core_system.launch_tik);
  }
 #endif

 aa_last_line_executed=__LINE__;

 #ifdef __BORLANDC__
 if(aa.core_system.in_debugger==YES)  { aaFocusToBorland(); }
 #endif
 timeEndPeriod(1);
 #if aa_USE_GLOBAL_MUTEX == 1
 DeleteCriticalSection(&global_mutex);
 #endif

 aa_last_line_executed=__LINE__;

 if(aa_debug_runtime)
  {
  H el,tik=GetTickCount();
  if(tik>=aa.core_system.launch_tik)   {  el=tik-aa.core_system.launch_tik;            }
  else                                 {  el=(0xffffffff-aa.core_system.launch_tik)+(tik+1);  }
  aaDebugf("ran for %i",el);
  }

 aa_last_line_executed=__LINE__;

 return aa.core_system.wm_quit_exitcode;
 }







 B aaExitCodeSet                       (H code)
 {
 aa.core_system.is_exitcode_set=YES;
 aa.core_system.set_exitcode=code;
 return RET_YES;
 }




 #ifdef IS_A_DLL


 BOOL WINAPI DllMain                   (HINSTANCE thisinst,DWORD fdwReason,LPVOID lpReserved )
 {
 H ec;
 UNUSE(lpReserved);

 if(aa_firsttik_set==NO) { aa_firsttik=GetTickCount(); aa_firsttik_set=YES; }
 switch(fdwReason)
  {
  case DLL_PROCESS_ATTACH:
  if(sizeof(_packdummy)!=13) { MessageBox(NULL,(char*)"pattach","-fpack-struct not enabled",MB_OK); return 0; }
  if(aaStart(thisinst,0,0,SW_SHOWDEFAULT)!=YES) {  return 0; }
  is_aa_started_by_winmain=YES;
  if(setjmp(aa_jmp_buf)!=0)   {  return(aaStop());   }
  break;
  case DLL_THREAD_ATTACH:
  MessageBox(NULL,(char*)"tattach"," ",MB_OK);
  break;
  case DLL_THREAD_DETACH:
  MessageBox(NULL,(char*)"tdettach"," ",MB_OK);
  break;
  case DLL_PROCESS_DETACH:
  ec=aaStop();
  if(aa.core_system.is_exitcode_set)  {  return aa.core_system.set_exitcode;  }
  break;
  }
 return TRUE;
 }



#else



 Z WINAPI WinMain                      (HINSTANCE thisinst,HINSTANCE previnst,LPSTR cmdline,Z cmdshow)
 {
 H ec;
 if(sizeof(_packdummy)!=13) { aaNote(0,"-fpack-struct not enabled"); return 0; }
 if(aa_firsttik_set==NO) { aa_firsttik=GetTickCount(); aa_firsttik_set=YES; }
 if(aaStart(thisinst,previnst,cmdline,cmdshow)!=YES) {  return 0; }
 is_aa_started_by_winmain=YES;
 aa_last_line_executed=__LINE__;
 if(setjmp(aa_jmp_buf)!=0)   {  return(aaStop());   }
 if(!aa_is_quit_called) { aaMain(); }
 aa_last_line_executed=__LINE__;
 ec=aaStop();
 aa_last_line_executed=__LINE__;
 if(aa.core_system.is_exitcode_set)  {  return aa.core_system.set_exitcode;  }
 return ec;
 }




#endif



 B WinFileTimeToSysTime                (FILETIME*filetime,_systime*systime)
 {
 SYSTEMTIME st;
 FILETIME ft;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(filetime==NULL) { return RET_BADPARM; }
 if(systime==NULL) { return RET_BADPARM; }
 #if 1
 if(FileTimeToLocalFileTime(filetime,&ft)==0) { return RET_FAILED; }
// if(FileTimeToSystemTime(filetime,&st)==0) { return RET_FAILED; }
 if(FileTimeToSystemTime(&ft,&st)==0) { return RET_FAILED; }
 #else
 if(FileTimeToLocalFileTime(filetime,&st)==0) { return RET_FAILED; }
 #endif
 systime->dow=st.wDayOfWeek;
 systime->year=st.wYear;
 systime->month=st.wMonth;
 systime->date=st.wDay;
 systime->hour=st.wHour;
 systime->minute=st.wMinute;
 systime->second=st.wSecond;
 systime->ms=st.wMilliseconds;
 systime->gmt_dif=0;
 return RET_YES;
 }




 B WinSystemTimeToSysTime              (SYSTEMTIME*systemtime,_systime*systime)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(systemtime==NULL) { return RET_BADPARM; }
 if(systime==NULL) { return RET_BADPARM; }
 systime->dow=systemtime->wDayOfWeek;
 systime->year=systemtime->wYear;
 systime->month=systemtime->wMonth;
 systime->date=systemtime->wDay;
 systime->hour=systemtime->wHour;
 systime->minute=systemtime->wMinute;
 systime->second=systemtime->wSecond;
 systime->ms=systemtime->wMilliseconds;
 systime->gmt_dif=0;
 return RET_YES;
 }





 B WinSystemTimeFromSysTime            (SYSTEMTIME*systemtime,_systime*systime)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(systemtime==NULL) { return RET_BADPARM; }
 if(systime==NULL) { return RET_BADPARM; }
 systemtime->wDayOfWeek=(W)systime->dow;
 systemtime->wYear=(W)systime->year;
 systemtime->wMonth=(W)systime->month;
 systemtime->wDay=(W)systime->date;
 systemtime->wHour=(W)systime->hour;
 systemtime->wMinute=(W)systime->minute;
 systemtime->wSecond=(W)systime->second;
 systemtime->wMilliseconds=(W)systime->ms;
 return RET_YES;
 }





 B WinSystemTimeCopy                   (SYSTEMTIME*systemtime,SYSTEMTIME*ssystemtime)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(systemtime==NULL) { return RET_BADPARM; }
 if(ssystemtime==NULL) { return RET_BADPARM; }
 systemtime->wDayOfWeek=ssystemtime->wDayOfWeek;
 systemtime->wYear=ssystemtime->wYear;
 systemtime->wMonth=ssystemtime->wMonth;
 systemtime->wDay=ssystemtime->wDay;
 systemtime->wHour=ssystemtime->wHour;
 systemtime->wMinute=ssystemtime->wMinute;
 systemtime->wSecond=ssystemtime->wSecond;
 systemtime->wMilliseconds=ssystemtime->wMilliseconds;
 return RET_YES;
 }




 B WinErrorStringGet                   (VP string,H line)
 {
 B txt[_1K];
 DWORD ea,eb;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 ea=GetLastError();
 if(string!=NULL) { aaStringNull(string); }
 aaStringNull(txt);
 eb=FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM|FORMAT_MESSAGE_IGNORE_INSERTS,
                   NULL,ea,MAKELANGID(LANG_NEUTRAL,SUBLANG_DEFAULT),(LPTSTR)txt,_1K,NULL);
 if(eb==0) { return RET_FAILED; }
 aaStringAppendf(txt,"\nerrorcode=%u (0x%08x)\nline=%i",ea,ea,line);
 if(string!=NULL)  { aaStringCopyf(string,"%s",txt);  }
 else              { aaNote(0,"bkd %s",txt);  }
 return RET_YES;
 }






 B WinSockAddrSet                      (struct sockaddr_in*addr,W family,H ip,W port)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(addr==NULL) { return RET_BADPARM; }
 aaMemoryFill(addr,sizeof(struct sockaddr_in),0);
 addr->sin_family=family;
 *(HP)&addr->sin_addr=ip;
 addr->sin_port=port;
 return RET_YES;
 }



 B WinPointCopy                        (POINT*point,POINT*spoint)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(point==NULL)   { return RET_BADPARM; }
 if(spoint==NULL)   { return RET_BADPARM; }
 point->x=spoint->x;
 point->y=spoint->y;
 return RET_YES;
 }


 B WinPointSet                         (POINT*point,N x,N y)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(point==NULL)   { return RET_BADPARM; }
 point->x=x;
 point->y=y;
 return RET_YES;
 }



 B WinPointToCord                      (POINT*point,_cord*cord)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(point==NULL) { return RET_BADPARM; }
 return(aaCordSet(cord,point->x,point->y));
 }



 B WinRectSet                          (RECT*rect,N x,N y,H w,H h)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL)  { return RET_BADPARM; }
 rect->left=x;
 rect->top=y;
 rect->right=rect->left+w;
 rect->bottom=rect->top+h;
 return RET_YES;
 }




 B WinRectToRect                       (RECT*rect,_rect*rect2)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 return(aaRectSet(rect2,rect->left,rect->top,(rect->right-rect->left),(rect->bottom-rect->top)));
 }



 B WinRectCopy                         (RECT*rect,RECT*srect)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 if(srect==NULL) { return RET_BADPARM; }
 rect->left=srect->left;
 rect->right=srect->right;
 rect->top=srect->top;
 rect->bottom=srect->bottom;
 return RET_YES;
 }


 B WinRectFromRect                     (RECT*rect,_rect*srect)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 if(srect==NULL) { return RET_BADPARM; }
 rect->left=srect->x;
 rect->top=srect->y;
 rect->right=rect->left+srect->w;
 rect->bottom=rect->top+srect->h;
 return RET_YES;
 }




 B WinBmpInfoSet                       (BITMAPINFO*bmi,H w,H h,B bits,B negheight)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bmi==NULL) { return RET_BADPARM; }
 if(w==0) { return RET_BADPARM; }
 if(h==0) { return RET_BADPARM; }
 #if aa_VIDCAP_ALLOW_YUY2==YES
 if(bits!=11&&bits!=12&&bits!=13&&bits!=15&&bits!=16&&bits!=24&&bits!=32) { return RET_BADPARM; }
 #else
 if(bits!=11&&bits!=12&&bits!=15&&bits!=16&&bits!=24&&bits!=32) { return RET_BADPARM; }
 #endif
 aaMemoryFill(bmi,sizeof(BITMAPINFOHEADER),0);
 bmi->bmiHeader.biSize=sizeof(BITMAPINFOHEADER);
 bmi->bmiHeader.biWidth=w;
 if(negheight==YES) { bmi->bmiHeader.biHeight=aaNumNeg((N)h); }
 else                 { bmi->bmiHeader.biHeight=h; }
 bmi->bmiHeader.biPlanes=1;
 bmi->bmiHeader.biBitCount=bits;                   // IYUV ??
 if(bits==11) { bmi->bmiHeader.biBitCount=12; bmi->bmiHeader.biCompression=VAL_IYUV; bmi->bmiHeader.biSizeImage=(w*h)+((w*h)/2);    }
 else
 if(bits==12) { bmi->bmiHeader.biBitCount=12; bmi->bmiHeader.biCompression=VAL_I420; bmi->bmiHeader.biSizeImage=(w*h)+((w*h)/2);    }
 else
 if(bits==13) { bmi->bmiHeader.biBitCount=16; bmi->bmiHeader.biCompression=VAL_YUY2; bmi->bmiHeader.biSizeImage=(w*h*2)+((((w/2)*h))*2);   }
 else           { bmi->bmiHeader.biCompression=BI_RGB; bmi->bmiHeader.biSizeImage=(w*h)*(bits/7);  }
 return RET_YES;
 }




 B WinWaveHdrSet                       (WAVEHDR*hdr,LPSTR dat,H buflen,B bytesrec,H user,H flags)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(hdr==NULL) { return RET_BADPARM; }
 if(dat==NULL) { return RET_BADPARM; }
 hdr->lpData=dat;
 hdr->dwBufferLength=buflen;
 hdr->dwBytesRecorded=bytesrec;
 hdr->dwUser=user;
 hdr->dwFlags=flags;
 hdr->dwLoops=0;
 hdr->lpNext=0;
 hdr->reserved=0;
 return RET_YES;
 }


 B WinWaveFormatExSet                  (WAVEFORMATEX*wfx,W tag,H sampssec,W channels,W bits,W cbsize)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(wfx==NULL) {  return RET_BADPARM; }
 if(tag==0) {   return RET_BADPARM; }
 if(channels==0) {  return RET_BADPARM; }
 if(sampssec==0) {  return RET_BADPARM; }
 aaMemoryFill(wfx,sizeof(WAVEFORMATEX),0);
 if(bits==0) { bits=16; }
 wfx->wFormatTag=tag;
 wfx->nChannels=channels;
 wfx->nSamplesPerSec=sampssec;
 wfx->wBitsPerSample=bits;
 wfx->nBlockAlign=(W)((wfx->wBitsPerSample*wfx->nChannels)>>3);
 wfx->nAvgBytesPerSec=(wfx->nSamplesPerSec*wfx->nBlockAlign);
 wfx->cbSize=cbsize;
 return RET_YES;
 }





 B WinWaveFormatExFromAudioMode        (WAVEFORMATEX*wfx,_audiomode*audiomode)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(wfx==NULL) { return RET_BADPARM; }
 if(audiomode==NULL) { return RET_BADPARM; }
 aaMemoryFill(wfx,sizeof(WAVEFORMATEX),0);
 if(audiomode->channels<1||audiomode->channels>2) { return RET_BADPARM; }
 wfx->nChannels=audiomode->channels;
 wfx->nSamplesPerSec=audiomode->frequency;
 wfx->wBitsPerSample=audiomode->bits;
 wfx->wFormatTag=WAVE_FORMAT_PCM;
 wfx->nBlockAlign=(WORD)((wfx->nChannels*wfx->wBitsPerSample)>>3);
 wfx->nAvgBytesPerSec=wfx->nSamplesPerSec*wfx->nBlockAlign;
 wfx->cbSize=0;
 return RET_YES;
 }





 B WinWaveFormatExToAudioMode          (WAVEFORMATEX*wfx,_audiomode*audiomode)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(wfx==NULL) { return RET_BADPARM; }
 if(audiomode==NULL) { return RET_BADPARM; }
 return RET_YES;
 }




 B WinWaveFormatExToString             (WAVEFORMATEX*wfx,VP string)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(wfx==NULL) { return RET_BADPARM; }
 if(string==NULL) { return RET_BADPARM; }
 aaStringCopyf(string,"tag=0x%04x samsec=%i bits=%i ch=%i align=%i avgbps=%i cbsize=%i",
 wfx->wFormatTag,wfx->nSamplesPerSec,wfx->wBitsPerSample,wfx->nChannels,wfx->nBlockAlign,wfx->nAvgBytesPerSec,wfx->cbSize);
 return RET_YES;
 }






 B WinWndClassExSet                    (WNDCLASSEX*wndclsex,W style,WNDPROC proc,VP classname)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(wndclsex==NULL) { return RET_BADPARM; }
 if(proc==NULL) { return RET_BADPARM; }
 if(classname==NULL) { return RET_BADPARM; }
 aaMemoryFill(wndclsex,sizeof(WNDCLASSEX),0);
 wndclsex->cbSize=sizeof(WNDCLASSEX);
 wndclsex->style=style;
 wndclsex->lpfnWndProc=proc;
 wndclsex->hInstance=aa.core_system.this_instance;
 wndclsex->hCursor=NULL;
 wndclsex->hIcon=NULL;
 wndclsex->lpszClassName=(LPCTSTR)classname;
 wndclsex->hbrBackground=NULL;
 return RET_YES;
 }








 B WinCapParmsInit                     (VP caparms)
 {
 aa_CAPTUREPARMS*cpp;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(caparms==NULL) { return RET_BADPARM; }
 aaCast(cpp,aa_CAPTUREPARMS*,caparms);
 aaMemoryFill(cpp,sizeof(aa_CAPTUREPARMS),0);
 cpp->dwRequestMicroSecPerFrame=30000;
 cpp->fMakeUserHitOKToCapture=FALSE;
 cpp->wPercentDropForError=50;
 cpp->fYield=TRUE;
 cpp->dwIndexSize=0;
 cpp->wChunkGranularity=0;
 cpp->fUsingDOSMemory=FALSE;
 cpp->wNumVideoRequested=0;
 cpp->fCaptureAudio=NO;
 cpp->wNumAudioRequested=0;
 cpp->vKeyAbort=FALSE;
 cpp->fAbortLeftMouse=FALSE;
 cpp->fAbortRightMouse=FALSE;
 cpp->fLimitEnabled=FALSE;
 cpp->wTimeLimit=FALSE;
 cpp->fMCIControl=FALSE;
 cpp->fStepMCIDevice=FALSE;
 cpp->dwMCIStartTime=0;
 cpp->dwMCIStopTime=0;
 cpp->fStepCaptureAt2x=FALSE+1;
 cpp->wStepCaptureAverageFrames=5;
 cpp->dwAudioBufferSize=0;
 cpp->fDisableWriteCache=0;
 cpp->AVStreamMaster=aa_AVSTREAMMASTER_NONE;
 return RET_YES;
 }


/*-----------------------------------------------------------------------*/


 B aa_CoreSystemHistory                (H line,VP fmt,...)
 {
 static B first=YES;
 static C file_name[512];
 va_list argptr;
 H shr,axs,ats,p,sl;
 HANDLE file_handle;
 C str[_8K],txt[_8K];
 BOOL b;
 LARGE_INTEGER zi;
 B path[_1K];

 aaFmt(fmt,argptr,str);
 if(first==YES)
  {
  GetCurrentDirectory(MAX_PATH,(CP)path);
  aaStringCopy(file_name,path);
  aaStringAppend(file_name,"\\aa_history.txt");
  }
 aaStringNull(txt);
 aaTimeToString(NULL,&txt[_4K],NULL,0);
 first=NO;
 if(line==0xffffffff)    { aaStringAppendf(txt,"%s\r\n",str);                  }
 else             { aaStringAppendf(txt,"%-8lu | %s| %s\r\n",line,&txt[_4K],str); }
 aaStringLen(txt,&sl);
 shr=0;
 axs=GENERIC_READ|GENERIC_WRITE;
 ats=FILE_FLAG_SEQUENTIAL_SCAN;
 if((file_handle=CreateFile((LPCTSTR)file_name,axs,shr,NULL,OPEN_ALWAYS,ats,NULL))==INVALID_HANDLE_VALUE) { return RET_FAILED; }
 zi.QuadPart=0;
 SetFilePointerEx(file_handle,zi,0,FILE_END);
 b=WriteFile(file_handle,txt,sl,&p,NULL);
 CloseHandle(file_handle);
 if(b==FALSE||p!=sl)  { DeleteFile(file_name); first=YES;  }
 return RET_YES;
 }




 B aa_CoreSystemLog                    (H style,VP fmt,...)
 {
 B ret;
 static H first_tik=0;
 static H last_tik=0;
 static C file_name[512];
 va_list argptr;
 H tik,ms_el,ms_dif;
 H shr,axs,ats,p,sl;
 HANDLE file_handle;
 B str[_64K],txt[_16K+_4K];
 BP tmp,tmp2;
 B path[_1K];
 BOOL b;
 SYSTEMTIME st;
 LARGE_INTEGER zi;

 aaCast(tmp,BP,str);
 if(aa.is_ready==YES)
  {
  if((ret=aa_MemoryTemp((VP)&tmp,_256K,aa_MEMORYTEMP_SystemLogf))!=RET_YES)   {   return ret;   }
  }
 aaCast(tmp2,BP,txt);
 if(aa.is_ready==YES)
  {
  if((ret=aa_MemoryTemp((VP)&tmp2,_256K,aa_MEMORYTEMP_SystemLogf2))!=RET_YES)   {   return ret;   }
  }

 aaFmt(fmt,argptr,tmp);
 if(aa.core_system.master_log_state==NO) { return RET_YES; }
 aaStringLen(tmp,&sl);
 while(1)
  {
  if(sl<1) { break; }
  if(aaCharIsVisible(tmp[sl-1])==YES) { break; }
  if(tmp[sl-1]==NULL_CHAR) { break; }
  tmp[sl-1]=NULL_CHAR;
  sl--;
  }
 tmp[sl]=NULL_CHAR;

 GetLocalTime(&st);
 if(aa.core_system.master_log_entries==0)
  {
  first_tik=GetTickCount();
  last_tik=first_tik;
  GetCurrentDirectory(MAX_PATH,(CP)path);
  aaStringCopy(file_name,path);
  aaStringAppend(file_name,"\\");
  aaStringAppend(file_name,aa.core_system.aa_trace_file);
  }
 aaStringNull(tmp2);
 tik=GetTickCount();
 if(tik>=first_tik)   {  ms_el=tik-first_tik;            }
 else                 {  ms_el=(0xffffffff-first_tik)+(tik+1);  }
 if(tik>=last_tik)    {  ms_dif=tik-last_tik;            }
 else                 {  ms_dif=(0xffffffff-last_tik)+(tik+1);  }
 last_tik=tik;
 aaStringNull(tmp2);
 aaStringNull(&tmp2[_4K]);
 aaStringAppendf(tmp2,"%-6u ",aa.core_system.process_id);
 aaStringAppendf(tmp2,"%7lu ",ms_el);
 if(ms_dif>50) { aaStringAppendf(tmp2,"+%-5lu:",ms_dif); }
 else          { aaStringAppend(tmp2,"      :"); }
 if(style!=(H)-777&&style!=(H)-666&&style!=(H)-555&&style!=(H)-554) { style=(H)-777; }

 if(style==(H)-777)
  {
  aaStringAppendf(tmp2,"%2i:%02i:%02i %6.2fm/%-3i %3i/%-3i  %s\r\n",st.wHour,st.wMinute,st.wSecond,(F)aa.memory_system.status.bytes_allocated/1048576.0,aa.memory_system.status.blocks_allocated,aa.page_system.pages_allocated,aa.page_system.pages_commited,tmp);
  }
 else
 if(style==(H)-666)
  {
  aaStringAppendf(tmp2,"%s\r\n",tmp);
  }
 else
 if(style==(H)-555||style==(H)-554)
  {
  aaStringCopyf(tmp2,"%s\r\n",tmp);
  }
 aaStringLen(tmp2,&sl);
 shr=0;
 axs=GENERIC_READ|GENERIC_WRITE;
 ats=FILE_FLAG_SEQUENTIAL_SCAN;
 if((file_handle=CreateFile((LPCTSTR)file_name,axs,shr,NULL,OPEN_ALWAYS,ats,NULL))==INVALID_HANDLE_VALUE) { return RET_FAILED; }
 zi.QuadPart=0;
 SetFilePointerEx(file_handle,zi,0,FILE_END);
 b=WriteFile(file_handle,tmp2,sl,&p,NULL);
 CloseHandle(file_handle);
 if(b==FALSE||p!=sl)  { DeleteFile(file_name); aa.core_system.master_log_entries=0;}
 else                 { aa.core_system.master_log_entries++; }
 if(style==(H)-554)
  {
  OutputDebugString((LPCTSTR)tmp2);
  }
 return RET_YES;
 }






 B aa_CoreSystemLogStateSet            (B state)
 {
 aa.core_system.master_log_state=state;
 return RET_YES;
 }



 B aa_CoreSystemSleepStandard          (Q microsecs)
 {
 DWORD r;

 r=SleepEx(microsecs/1000,FALSE);
 if(r!=0)  { return RET_NO; }
 return RET_YES;
 }





 B aa_CoreSystemSleepPrecise           (Q microsecs)
 {
 B ret;
 struct timeval tv;
 fd_set dummy;
 static SOCKET s={0};

 if(s==0)
  {
  s=socket(PF_INET,SOCK_STREAM,IPPROTO_TCP);
  if(s==(SOCKET)SOCKET_ERROR) { oof; }
  }
 FD_ZERO(&dummy);
 FD_SET(s,&dummy);
 tv.tv_sec=microsecs/1000000;
 tv.tv_usec=microsecs%1000000;
 if(select(0,0,0,&dummy,&tv)!=0) { ret=RET_NO; }
 else                            { ret=RET_YES; }
 return ret;
 }





 B aa_CoreSystemStart                  (HINSTANCE thisinst,HINSTANCE previnst,LPSTR cmdline,int cmdshow)
 {
 HDC dc;
 DEVMODE dm;
 N i;
 H t;
 T BOOL (*_idp) (VOID);
 T BOOL (*_ridp) (HANDLE,BOOL*);
 BOOL bl;
 _idp idp;
 _ridp ridp;
 T BOOL (*_iswow)(HANDLE,BOOL *);
 _iswow iswow;
 BOOL i64;
 STARTUPINFO si;
 B path[_1K];
 B file[_1K];
 LARGE_INTEGER dtik;

 t=GetTickCount();
 aaMemoryFill(&aa,sizeof(_aa),0);
 aaStringCopy(aa.core_system.aa_trace_file,"aa_trace.txt");
 GdiSetBatchLimit(1);
 GetCurrentDirectory(MAX_PATH,(CP)path);
 aaStringCopy(file,path);
 aaStringAppend(file,"\\");
 aaStringAppend(file,aa.core_system.aa_trace_file);

 aa.core_system.debugf_proc=NULL;//aaDebugf;

 #if aaTraceResetAlways==YES
 aaAaFilesDeleteOnSize(0,0,0,0);
 #endif

 #if aaTraceDebugf==YES
 aaDebugfLogWriteSet(YES);
 #endif
 aa.core_system.SleepFunction=aa_CoreSystemSleepStandard;
 SetUnhandledExceptionFilter(aa_ExceptionHandler);

 aaMemoryFill(&dm,sizeof(dm),0);
 aa.core_system.launch_tik=t;
 aa.core_system.aamain_tik=aa.core_system.launch_tik;

 timeBeginPeriod(1);
 if(QueryPerformanceFrequency((LARGE_INTEGER*)&dtik)==0) oof;
 aa.core_system.perf_frequency=dtik.QuadPart;
 aa.core_system.perf_frequency_ms=aa.core_system.perf_frequency/1000;
 QueryPerformanceCounter((LARGE_INTEGER*)&dtik);
 aa.core_system.aamain_perftik=dtik.QuadPart;
 aa.core_system.version=aa_VERSION;
 aa_launchtik=aa.core_system.launch_tik;
 if((aa.core_system.advapi_module=LoadLibrary("advapi32.dll"))==NULL) { oow; }
 if((aa.core_system.comdlg_module=LoadLibrary("comdlg32.dll"))==NULL) { oow; }
 if((aa.core_system.kernel_module=LoadLibrary("kernel32.dll"))==NULL) { oow; }
 if((aa.core_system.user_module=LoadLibrary("user32.dll"))==NULL) { oow; }
 if((aa.core_system.psapi_module=LoadLibrary("psapi.dll"))==NULL) { oow; }
 if((aa.core_system.ntdll_module=LoadLibrary("ntdll.dll"))==NULL) { oow; }

 if((idp=(_idp)GetProcAddress(aa.core_system.kernel_module,"IsDebuggerPresent"))!=NULL)  { aa.core_system.in_debugger=(B)(idp()==YES);  }
 if((ridp=(_ridp)GetProcAddress(aa.core_system.kernel_module,"CheckRemoteDebuggerPresent"))!=NULL)
  {
  if(ridp(GetCurrentProcess(),&bl)!=0) { if(bl) aa.core_system.in_remote_debugger=YES; }
  }
 if((iswow=(_iswow)GetProcAddress(aa.core_system.kernel_module,"IsWow64Process"))!=NULL)
  {
  if(iswow(GetCurrentProcess(),&i64)) { if(i64)   {    aa_is_64bit=YES;    } }
  }
 if((aa.core_system.SetDllDirectory=(setDllDirectory)GetProcAddress(aa.core_system.kernel_module,"SetDllDirectoryA"))==NULL) { oof; return RET_FAILED; }
 if((aa.core_system.GetSystemTimes=(getSystemTimes)GetProcAddress(aa.core_system.kernel_module,"GetSystemTimes"))==NULL) { oof; return RET_FAILED; }
 if((aa.core_system.GetProcessTimes=(getProcessTimes)GetProcAddress(aa.core_system.kernel_module,"GetProcessTimes"))==NULL) { oof; return RET_FAILED; }
 if((aa.core_system.Process32First=(process32First)GetProcAddress(aa.core_system.kernel_module,"Process32First"))==NULL) { oof; return RET_FAILED; }
 if((aa.core_system.Process32Next=(process32Next)GetProcAddress(aa.core_system.kernel_module,"Process32Next"))==NULL) { oof; return RET_FAILED; }
 if((aa.core_system.Thread32First=(thread32First)GetProcAddress(aa.core_system.kernel_module,"Thread32First"))==NULL) { oof; return RET_FAILED; }
 if((aa.core_system.Thread32Next=(thread32Next)GetProcAddress(aa.core_system.kernel_module,"Thread32Next"))==NULL) { oof; return RET_FAILED; }
 if((aa.core_system.Create32Snapshot=(create32Snapshot)GetProcAddress(aa.core_system.kernel_module,"CreateToolhelp32Snapshot"))==NULL) { oof; return RET_FAILED; }
 if((aa.core_system.Module32First=(module32First)GetProcAddress(aa.core_system.kernel_module,"Module32First"))==NULL) { oof; return RET_FAILED; }
 if((aa.core_system.Module32Next=(module32Next)GetProcAddress(aa.core_system.kernel_module,"Module32Next"))==NULL) { oof; return RET_FAILED; }
 if((aa.core_system.TryEnterCriticalSection=(trycritical)GetProcAddress(aa.core_system.kernel_module,"TryEnterCriticalSection"))==NULL) { oof; return RET_FAILED; }
 if((aa.core_system.CreateProcWithLogin=(createprocwithlogin)GetProcAddress(aa.core_system.advapi_module,"CreateProcessWithLogonW"))==NULL) { oof; return RET_FAILED; }
 if((aa.core_system.SetLayeredWindowAttributes=(setlayeredwinattrs)GetProcAddress(aa.core_system.user_module,"SetLayeredWindowAttributes"))==NULL) { oof; return RET_FAILED; }
 if((aa.core_system.DisableProcessWindowsGhosting=(disableGhosting)GetProcAddress(aa.core_system.user_module,"DisableProcessWindowsGhosting"))==NULL) { oof; return RET_FAILED; }
 if((aa.core_system.PrintWindow=(printwindow)GetProcAddress(aa.core_system.user_module,"PrintWindow"))==NULL) { oof; return RET_FAILED; }
 if((aa.core_system.EnumDisplayDevices=(enumdisplaydevs)GetProcAddress(aa.core_system.user_module,"EnumDisplayDevicesA"))==NULL) { oof; return RET_FAILED; }
 if((aa.core_system.EnumDisplayMonitors=(enumDisplayMonitors)GetProcAddress(aa.core_system.user_module,"EnumDisplayMonitors"))==NULL) { oof; return RET_FAILED; }
 if((aa.core_system.GetMonitorInfoEx=(getMonitorInfoEx)GetProcAddress(aa.core_system.user_module,"GetMonitorInfoA"))==NULL) { oof; return RET_FAILED; }
 if((aa.core_system.GetModuleFileNameEx=(getModuleFileNameEx)GetProcAddress(aa.core_system.psapi_module,"GetModuleFileNameExA"))==NULL) { oof; return RET_FAILED; }
 if((aa.core_system.GetProcessFileName=(getProcessFileName)GetProcAddress(aa.core_system.psapi_module,"GetProcessImageFileNameA"))==NULL) { oof; return RET_FAILED; }
 if((aa.core_system.GetProcessMemoryInfo=(getProcessMemoryInfo)GetProcAddress(aa.core_system.psapi_module,"GetProcessMemoryInfo"))==NULL) { oof; return RET_FAILED; }
 if((aa.core_system.GetOpenFileName=(getOpenFileName)GetProcAddress(aa.core_system.comdlg_module,"GetOpenFileNameA"))==NULL) { oof; return RET_FAILED; }
 if((aa.core_system.ntQueryInformationProcess=(NTQueryInformationProcess)GetProcAddress(aa.core_system.ntdll_module,"NtQueryInformationProcess"))==NULL) { oof; return RET_FAILED; }

 aa_CoreSystemLogStateSet(YES);
 aaTimeOfLastCompile(aa.core_system.built);
 logg("aaBoost v%i Built: %s %s %s",aa.core_system.version,aa.core_system.built,aa.core_system.in_debugger?"*DEBUGGER RUNNING*":" ",aa.core_system.built,aa.core_system.in_remote_debugger?"*REMOTE DEBUGGER RUNNING*":" ",aaBoolStrings(aaIsProfiling(),"*PROFILING ENABLED* ",""));
 for(i=0;i<256;i++)
  {
  aaCast(ret_string[i],CP,ret_string_text[i]);
  aaStringCopy(ret_string[i],"RET_");
  switch(i)
   {
   case RET_NO: aaStringCopy(&ret_string[i][4],"NO"); break;
   case RET_YES: aaStringCopy(&ret_string[i][4],"YES"); break;
   case RET_BADPARM: aaStringCopy(&ret_string[i][4],"BADPARM"); break;
   case RET_FAILED: aaStringCopy(&ret_string[i][4],"FAILED"); break;
   case RET_BOUNDS: aaStringCopy(&ret_string[i][4],"BOUNDS"); break;
   case RET_FORBIDDEN: aaStringCopy(&ret_string[i][4],"FORBIDDEN"); break;
   case RET_NOMEMORY: aaStringCopy(&ret_string[i][4],"NOMEMORY"); break;
   case RET_BADHANDLE: aaStringCopy(&ret_string[i][4],"BADHANDLE"); break;
   case RET_NOTFOUND: aaStringCopy(&ret_string[i][4],"NOTFOUND"); break;
   case RET_NOTREADY: aaStringCopy(&ret_string[i][4],"NOTREADY"); break;
   case RET_EXISTS: aaStringCopy(&ret_string[i][4],"EXISTS"); break;
   case RET_ALREADYOPEN: aaStringCopy(&ret_string[i][4],"ALREADYOEN"); break;
   case RET_NOTOPEN: aaStringCopy(&ret_string[i][4],"NOTOPEN"); break;
   case RET_INUSE: aaStringCopy(&ret_string[i][4],"INUSE"); break;
   case RET_NOTSTARTED: aaStringCopy(&ret_string[i][4],"NOTSTARTED"); break;
   case RET_CORRUPTED: aaStringCopy(&ret_string[i][4],"CORRUPTED"); break;
   case RET_NOTSUPPORTED: aaStringCopy(&ret_string[i][4],"NOTSUPPORTED"); break;
   case RET_DENIED: aaStringCopy(&ret_string[i][4],"DENIED"); break;
   case RET_TIMEOUT: aaStringCopy(&ret_string[i][4],"TIMEOUT"); break;
   case RET_FATAL: aaStringCopy(&ret_string[i][4],"FATAL"); break;
   case RET_BADSTATE: aaStringCopy(&ret_string[i][4],"BADSTATE"); break;
   case RET_FINISHED: aaStringCopy(&ret_string[i][4],"FINISHED"); break;
   case RET_NOTINITIALIZED: aaStringCopy(&ret_string[i][4],"NOTINITIALIZED"); break;
   case RET_PARTIAL: aaStringCopy(&ret_string[i][4],"PARTIAL"); break;
   case RET_ALREADYSTARTED: aaStringCopy(&ret_string[i][4],"ALREADYSTARTED"); break;
   case RET_ATTENTION: aaStringCopy(&ret_string[i][4],"ATTENTION"); break;
   case RET_BADFORMAT: aaStringCopy(&ret_string[i][4],"BADFORMAT"); break;
   case RET_CANCELLED: aaStringCopy(&ret_string[i][4],"CANCELLED"); break;
   case RET_WORKING:   aaStringCopy(&ret_string[i][4],"WORKING"); break;
   case RET_COLLISION:   aaStringCopy(&ret_string[i][4],"COLLISION"); break;
   case RET_POSSIBLE:    aaStringCopy(&ret_string[i][4],"POSSIBLE"); break;
   case RET_IGNORE:      aaStringCopy(&ret_string[i][4],"IGNORE"); break;
   case RET_INCOMPLETE:      aaStringCopy(&ret_string[i][4],"INCOMPLETE"); break;
   case RET_OTHER:           aaStringCopy(&ret_string[i][4],"OTHER"); break;
   case RET_MISSINGPARM:     aaStringCopy(&ret_string[i][4],"MISSINGPARM"); break;
   case RET_OVERFLOW:     aaStringCopy(&ret_string[i][4],"OVERFLOW"); break;
   case RET_STILLWORKING:     aaStringCopy(&ret_string[i][4],"STILLWORKING"); break;
   case RET_SAME:     aaStringCopy(&ret_string[i][4],"SAME"); break;
   case RET_UNDERFLOW:     aaStringCopy(&ret_string[i][4],"UNDERFLOW"); break;
   case RET_UNKNOWN: aaStringCopy(&ret_string[i][4],"UNKNOWN"); break;
   default:
   ret_string[i][4]=((i/100)%10)+'0';
   ret_string[i][5]=((i/10)%10)+'0';
   ret_string[i][6]=((i%10)+'0');
   ret_string[i][7]=NULL_CHAR;
   break;
   }
  }
 dm.dmSize=sizeof(DEVMODE);
 dm.dmFields=DM_BITSPERPEL;
 dm.dmBitsPerPel=32;
 aaMemoryFill(&si,sizeof(si),0);
 si.cb=sizeof(si);
 GetStartupInfo(&si);
 if((dc=CreateDC("DISPLAY",NULL,NULL,&dm))==NULL) return RET_FAILED;
 aa.core_system.display_dc=dc;
 aa.core_system.this_instance=thisinst;
 aa.core_system.prev_instance=previnst;
 aa.core_system.discovery_message_id=RegisterWindowMessage("aaBoostDiscovery");
 aa_discovery_id=aa.core_system.discovery_message_id;
 aaStringCopy(aa.core_system.command_line,cmdline);
 GetModuleFileName(NULL,(CP)aa.core_system.module_filename,sizeof(aa.core_system.module_filename));
 aaStringCopy(aa.core_system.module_path,aa.core_system.module_filename);
 aaStringFindChar(aa.core_system.module_path,0,&t,BSLASH_CHAR,YES,0,NO);
 if(t!=0xffffffff) { aa.core_system.module_path[t+1]=NULL_CHAR; }
 if(si.dwFlags&0x800) aa.core_system.via_shortcut=YES;
 aa.core_system.command_show=cmdshow;
 aa.core_system.process_handle=GetCurrentProcess();
 aa.core_system.process_id=GetCurrentProcessId();
 aa.core_system.thread_handle=GetCurrentThread();
 aa.core_system.thread_id=GetCurrentThreadId();
 sprintf(aa.core_system.class_name,"aa.core_system.class.Name.%lu",GetTickCount());
 WinWndClassExSet(&aa.core_system.class_data,CS_GLOBALCLASS|CS_OWNDC|CS_HREDRAW|CS_VREDRAW,aa_CoreSystemProc,aa.core_system.class_name);
 if(RegisterClassEx(&aa.core_system.class_data)==0) { oow; return RET_FAILED; }
 aa_CoreSystemTime();
 return RET_YES;
 }



 BOOL myprintwindow (HWND wnd,HDC dc,UINT val)
 {
 return(aa.core_system.PrintWindow(wnd,dc,val));
 }



 V aa_CoreSystemStop                   (V)
 {
 logg("aa_CoreSystemStop()");
 logg("");
 if(aa.core_system.is_console_attached) { aaConsoleDetach(); }
 if(aa.core_system.ntdll_module!=NULL) { FreeLibrary(aa.core_system.ntdll_module); aa.core_system.ntdll_module=NULL; }
 if(aa.core_system.kernel_module!=NULL) { FreeLibrary(aa.core_system.kernel_module); aa.core_system.kernel_module=NULL; }
 if(aa.core_system.comdlg_module!=NULL) { FreeLibrary(aa.core_system.comdlg_module); aa.core_system.comdlg_module=NULL; }
 if(aa.core_system.user_module!=NULL)   { FreeLibrary(aa.core_system.user_module); aa.core_system.user_module=NULL; }
 if(aa.core_system.advapi_module!=NULL) { FreeLibrary(aa.core_system.advapi_module); aa.core_system.advapi_module=NULL; }
 DeleteDC(aa.core_system.display_dc);
 UnregisterClass((LPCTSTR)aa.core_system.class_name,aa.core_system.this_instance);
 }




 B aa_CoreSystemWindowsMsgToString     (UINT msg,VP str)
 {
 H i;

 if(str) { aaStringNull(str); }
 for(i=0;i<aaElementCount(aa_winmsg);i++)
  {
  if(msg!=aa_winmsg[i].msg) { continue; }
  aaStringCopyf(str,"%s",aa_winmsg[i].str);
  return RET_YES;
  }
 return RET_NOTFOUND;
 }




 K aa_CoreSystemProc                   (HWND wnd,UINT msg,WPARAM wparm,LPARAM lparm)
 {
 H surface_handle;
 _aa_surfaceobject*surp;
 PAINTSTRUCT ps;
 _rect blit_rect;
 N h_dif,v_dif;
 N re,ret_value;
 POINT pnt;
 COPYDATASTRUCT*cdsp;
 BP bp;
 B txt[_16K];
 //dB str[_1K];
 B id,ret;
 //H i;

 #if 0
 S N isin=0;
 if(isin==0) { aaDebugf("cc"); isin=1;  }
 else
  {
  if(msg==WM_PAINT)
   {
   aaDebugf("ee");
   PAINTSTRUCT pps;
   if(BeginPaint(wnd,&pps)==NULL)   {  oow;  }
   EndPaint(wnd,&pps);
   return 0;
   }
  return 0;
  }
 #endif


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 ret_value=-1;
 aa.core_system.wm_msg_count_total++;
 aa_stats[0]=aa.core_system.wm_msg_count_total;

 if(aa_is_quit_called||aa_is_quit_received)
  {
  logg("%s %i,%i  ",__func__,aa_is_quit_called,aa_is_quit_received);
  }

 ret=aa_SurfaceSystemFindSurfaceByHwnd(&surface_handle,(VP)&surp,wnd);



 if(ret!=YES)
  {
  //isin=0;
  return DefWindowProc(wnd,msg,wparm,lparm);
  }

 if(ret==RET_YES)
  {
  aa.core_system.wm_msg_count_surfaced++;
  aa_stats[1]=aa.core_system.wm_msg_count_surfaced;
  switch(msg)
   {
   /**
   case WM_APP_BAR_MSG:
   switch(wparm)
    {
    case ABN_FULLSCREENAPP:  break;

    case ABN_POSCHANGED:
    data.cbSize=sizeof(data);
    data.hWnd=surp->status.hwnd;
    data.uEdge=aa.appbar_system.edge;
    SetRect(&data.rc,0,0,GetSystemMetrics(SM_CXSCREEN),GetSystemMetrics(SM_CYSCREEN));
    if(SHAppBarMessage(ABM_QUERYPOS,&data)==FALSE) { oof; oow; }
    switch (data.uEdge)
     {
     default: oof; break;
     case ABE_LEFT:   data.rc.right=data.rc.left+aa.appbar_system.depth;   break;
     case ABE_TOP:    data.rc.bottom=data.rc.top+aa.appbar_system.depth;   break;
     case ABE_RIGHT:  data.rc.left=data.rc.right-aa.appbar_system.depth;   break;
     case ABE_BOTTOM: data.rc.top=data.rc.bottom-aa.appbar_system.depth;    break;
     }
    // Leave all the members as they were when
    SHAppBarMessage(ABM_SETPOS,&data);
    aaRectSet(&aa.appbar_system.rect,data.rc.left,data.rc.top,data.rc.right-data.rc.left,data.rc.bottom-data.rc.top);
    break;

    case ABN_STATECHANGE:    break;
    case ABN_WINDOWARRANGE:  break;
    default: oof; break;
    }
   ret_value=0;// was 1 nov 22 2006
   break;
   */

   case WM_DISPLAYCHANGE:
   //aaDebugf("display change");
   if(aaDisplayInfoGet(&aa.display_system.di,F8)!=YES) { oof; }
   break;

   case WM_TIMER:
   ret_value=0;
   break;

   case WM_DROPFILES:
   ret_value=0;
    {
    UINT dcount,dod;
    HDROP drop;
    drop=(HANDLE)wparm;
    DragQueryPoint(drop,&pnt);
    dcount=DragQueryFile(drop,0xffffffff,0,0);
    for(dod=0;dod<dcount;dod++)
     {
     if(DragQueryFile(drop,dod,(CP)txt,_4K)!=0)
      {
      if(surp->status.is_drop_accept)
       {
       if(surp->status.drop_list.magic==0)
        {
        aaListNew(&surp->status.drop_list,YES,0,0,1);
        }

       aaListAppend(&surp->status.drop_list,0,txt,0,0);//"%s",txt);
       //aaListAppendf(&surp->status.drop_list,0,0,"%s",txt);
       surp->status.drop_count++;
       }
      }
     }
    DragFinish(drop);
    }
   break;


   case WM_CLOSE:
   surp->status.is_closed=YES;
   ret_value=0;// was 1  nov 22 , 2006
   break;


   case WM_QUIT:
   if(aa.core_system.wm_quit_received==NO)
    {
    aa.core_system.wm_quit_exitcode=wparm;
    aa.core_system.wm_quit_received=YES;
    aa_is_quit_received=YES;
    }
   ret_value=-1; // was 1 nov 22 2006
   break;


   case WM_SETFOCUS:
   case WM_KILLFOCUS:
   if(msg==WM_SETFOCUS)
    {
    surp->status.is_focus=YES;
    }
   else
   if(msg==WM_KILLFOCUS)
    {
    surp->status.is_focus=NO;
    }
   ret_value=1; // was 1 nov 22 2006
   break;



   case WM_MOUSEMOVE:
   if(GetCursor()!=aa.cursor_system.current_cursor_handle)    {         SetCursor(aa.cursor_system.current_cursor_handle); }
   ret_value=0;// was 1 nov 22 2006
   break;
   case WM_SETCURSOR:
   ret_value=TRUE;
   break;

   /*

   case WM_NCMOUSEMOVE:
   ret_value=0;
   break;
     */

   case WM_DEADCHAR:
   case WM_SYSDEADCHAR:
   case WM_CHAR:
   case WM_SYSCHAR:
   case WM_KEYDOWN:
   case WM_SYSKEYDOWN:
   case WM_KEYUP:
   case WM_SYSKEYUP:
   if(msg==WM_KEYUP||msg==WM_KEYDOWN||msg==WM_SYSKEYUP||msg==WM_SYSKEYDOWN)//||msg==WM_CHAR||msg==WM_SYSCHAR)
    {
    if(aa.input_system.hKeyHook==0)
     {
     aa_InputSystemKeyEventProc(wnd,msg,wparm,lparm,0);
     }
    }
   if(msg==WM_KEYDOWN&&wparm==VK_ESCAPE)
    {
    if(aa_is_esc==NO)
     {
     aa_is_esc=YES;
     }
    }
   ret_value=0;// was 1 nov 22 2006
   break;



  case WM_COMMAND: //if(msg==WM_COMMAND&&HIWORD(wparm)==BN_CLICKED)
  if(HIWORD(wparm)!=BN_CLICKED) { ret_value=-1; break; }
  ///if(aa.bugger_system.is_open!=YES) { ret_value=-1; break; }
  ret_value=0;// was -1: jul 2015
  break;




   case WM_SURFACE_SYSTRAY_MSG:
   switch(lparm)
    {
    case WM_LBUTTONUP:
    case WM_RBUTTONUP:
    surp->status.is_systray_clicked=YES;
    surp->status.is_systray_right_clicked=(B)(lparm==WM_RBUTTONDBLCLK||lparm==WM_RBUTTONUP);
    GetCursorPos(&pnt);
    aaCordSet(&surp->status.systray_click_cord,pnt.x,pnt.y);
    break;

    case WM_MOUSEMOVE:
    break;

    default:
    break;
    }
   ret_value=0;// was 1 nov 22 2006
   break;


   case WM_NCHITTEST:
   ret_value=-1;
   break;

   //case WM_MOVING:
   //ret_value=1;
   //break;

   case WM_SETREDRAW:
   ret_value=0;
   break;

   case WM_ERASEBKGND:
   aa.core_system.wm_msg_count_erasebg++;
   aa_stats[2]=aa.core_system.wm_msg_count_erasebg;
   ret_value=-1;
   ret_value=1;//  see http://www.catch22.net/tuts/flicker )
   ret_value=0;
   break;

   case WM_ENTERMENULOOP:
   case WM_EXITMENULOOP:
   ret_value=0;
   break;



   case WM_PAINT:
   aa.core_system.wm_msg_count_paint++;
   aa_stats[3]=aa.core_system.wm_msg_count_paint;
   if(BeginPaint(surp->status.hwnd,&ps)==NULL)   {  oof; oow; Boop;   break;   }
   if(surp->status.is_shown==YES&&surp->status.is_ignore_wmpaint==NO)
    {
    if(ps.fErase==1&&1)
     {
     h_dif=(ps.rcPaint.right-ps.rcPaint.left);
     h_dif=aaNumClamp(h_dif,0,F24);
     v_dif=(ps.rcPaint.bottom-ps.rcPaint.top);
     v_dif=aaNumClamp(v_dif,0,F24);
     aaRectSet(&blit_rect,ps.rcPaint.left,ps.rcPaint.top,h_dif,v_dif);
     aaSurfaceBlit(surface_handle,&blit_rect);//,0,&blit_rect,NO);
     }
    }
   EndPaint(surp->status.hwnd,&ps);
   ret_value=0;// was 1 , dec 2011
   break;



   case WM_MOVE:
   ret_value=0;
   break;

   case WM_STYLECHANGING:
   ret_value=0;
   break;

   case WM_STYLECHANGED:
   ret_value=0;
   break;


   case WM_GETDLGCODE:
   ret_value=-1;
   break;



   case WM_NCCALCSIZE:
   if(wparm==FALSE) { ret_value=0; break; }
   if(wparm==TRUE) { ret_value=0; break; }
   ret_value=1;
   break;


   case WM_NCPAINT:
   ret_value=0; // was 1 jul 2015
   break;


   case WM_WINDOWPOSCHANGING:
   ret_value=0;// was 1 jul 2015
   break;

   case WM_WINDOWPOSCHANGED:
   ret_value=0;// was 1 jul 2015
   break;


   case WM_COPYDATA:
   #ifdef aa_VERSION
   aa_ZIAG("WM_COPYDATA");
   #endif
   aaCast(cdsp,COPYDATASTRUCT*,lparm);
   aaCast(bp,BP,cdsp->lpData);
   if(aa.core_system.LimiterMessageProc!=NULL&&aa.core_system.limiter_mutex_handle!=0)
    {
    if(*(HP)&bp[0]==VAL_limt)
     {
     if(cdsp->dwData==19721972&&cdsp->cbData>=32&&cdsp->cbData<=_16K)
      {
      //if(*(HP)&bp[12]!=aa.core_system.limiter_last_counter.hi||*(HP)&bp[16]!=aa.core_system.limiter_last_counter.lo )
      if(*(QP)&bp[12]!=aa.core_system.limiter_last_counter)//.hi||*(HP)&bp[16]!=aa.core_system.limiter_last_counter.lo )
       {
       aa.core_system.limiter_last_counter=*(QP)&bp[12];
       //aa.core_system.limiter_last_counter.hi=*(HP)&bp[12];
      // aa.core_system.limiter_last_counter.lo=*(HP)&bp[16];
       aaMemoryCopy(txt,cdsp->cbData-32,&bp[32]);
       aa.core_system.LimiterMessageProc(cdsp->cbData-32,txt);
     ///  isin=0;
       return 1;
       }
      }
     }
    }

   if(aa.core_system.CopyDataProc!=NULL)
    {
    aa.core_system.CopyDataProc((HWND)wparm,wnd,cdsp->dwData,cdsp->cbData,bp);
///    isin=0;
    return 1;
    }

//  break;    // WM_COPYDATA fall-thru to ElseProc, so normal WM_COPYDATA messages are handled in ElseProc


   default:
   if(msg!=WM_COPYDATA)
    {
    aa.core_system.wm_msg_count_unhandled++;
    aa_stats[4]=aa.core_system.wm_msg_count_unhandled;

    }

   if(surp->status.ElseProc!=NULL)
    {
    oof;
    //if(msg==MM_MCINOTIFY) BUG,"eenotify hwnd=%u ",wnd);
    re=surp->status.ElseProc(wnd,msg,wparm,lparm,&id);
    if(id==NO)
     {
///     isin=0;
     return(re);
     }
    }
   ret_value=-1;
   break;
   }
  }

 if(ret_value!=-1)
  {
///  isin=0;
  return(ret_value);
  }
// isin=0;
 return DefWindowProc(wnd,msg,wparm,lparm);
 }




 B aa_CoreSystemCpuLoadGet             (V)
 {
 myFILETIME i_time,k_time,u_time;
 myFILETIME ii_time,cc_time,ee_time,kk_time,uu_time;
 G i_now,k_now,u_now;
 G rtk,rtu,rti;
 G xtk,xtu;
 G ztk,ztu,zti;
 D cpu,sys;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 //if(cpuload)   { *cpuload=aa_curcpuload; }
 //if(procload)  { *procload=aa_curprocessload; }
 if(aa.core_system.GetSystemTimes(&i_time.dword,&k_time.dword,&u_time.dword)==0) {  oow; }

 ztu=u_time.quad;
 ztk=k_time.quad;
 zti=i_time.quad;
 u_now=ztu-aa.cpumonitor_system.prev_user_time.quad;
 k_now=ztk-aa.cpumonitor_system.prev_kernel_time.quad;
 i_now=zti-aa.cpumonitor_system.prev_idle_time.quad;
 sys=(k_now+u_now);
 if(sys!=0)  {  cpu=(((sys-(D)i_now)*100.0)/sys);  aa_curcpuload=(D)cpu;  }
 //sys=(u_now+k_now);
 //cpu=((sys-i_now)*100.0/sys);
 aa.cpumonitor_system.prev_user_time.quad=ztu;
 aa.cpumonitor_system.prev_kernel_time.quad=ztk;
 aa.cpumonitor_system.prev_idle_time.quad=zti;

 ii_time.quad=0;
 if(aa.core_system.GetProcessTimes(aa.core_system.process_handle,&cc_time.dword,&ee_time.dword,&kk_time.dword,&uu_time.dword)==0) { oow; }
 rtu=uu_time.quad;
 rtk=kk_time.quad;
 rti=ii_time.quad;
 xtu=rtu-aa.cpumonitor_system.process_prev_user_time;
 xtk=rtk-aa.cpumonitor_system.process_prev_kernel_time;
 cpu=(D)(ztk+ztu)-(D)aa.cpumonitor_system.prev_ki_time;
 if(cpu!=0)  {  aa_curproload=(D)((xtu+xtk)*100.0)/(D)cpu;  }
 aa_curcpuload=aaNumClamp(aa_curcpuload,0,100);
 aa_curproload=aaNumClamp(aa_curproload,0,100);
 if(aa_curproload>aa_curcpuload) {  aa_curproload=aa_curcpuload;  }
 aa_avgcpuload-=(aa_avgcpuload/10.0);
 aa_avgcpuload+=(aa_curcpuload/10.0);
 aa_avgproload-=(aa_avgproload/10.0);
 aa_avgproload+=(aa_curproload/10.0);
 aa_avgcpuload=aaNumClamp(aa_avgcpuload,0,100);
 aa_avgproload=aaNumClamp(aa_avgproload,0,100);
 aa.cpumonitor_system.process_prev_user_time=rtu;
 aa.cpumonitor_system.process_prev_idle_time=rti;
 aa.cpumonitor_system.process_prev_kernel_time=rtk;
 aa.cpumonitor_system.prev_ki_time=ztu+ztk;
 return RET_YES;
 }






 Q aa_CoreSystemTikPrecise             (V)
 {
 Q ms;
 D dd,ee;

 LARGE_INTEGER dtik;
 QueryPerformanceCounter((LARGE_INTEGER*)&dtik);
 ms=dtik.QuadPart;
 dd=(D)ms;
 dd=(dd*1000.0);
 ee=(D)aa.core_system.perf_frequency;
 ee=ee/1000.0;
 dd=dd/ee;
 ms=(Q)dd;
 return(ms);
 }





 B aa_CoreSystemTime                   (V)
 {
 LARGE_INTEGER dtik;
 H tik;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 aaTimerTikGet(&tik);
 aaTimerTikElapsedUsingTik(aa.core_system.aamain_tik,tik,&aa.core_system.aamain_elapsed);

 if(aa.core_system.perf_frequency_ms!=0)
  {
  QueryPerformanceCounter((LARGE_INTEGER*)&dtik);
  aa.core_system.aamain_perfelapsed=dtik.QuadPart-aa.core_system.aamain_perftik;
  aa_msrunning=aa.core_system.aamain_perfelapsed/aa.core_system.perf_frequency_ms;
  aa_microsecsrunning=((aa.core_system.aamain_perfelapsed*1000)/aa.core_system.perf_frequency_ms);
  }
 else
  {
  aa_msrunning=aa.core_system.aamain_elapsed;
  aa_microsecsrunning=aa_msrunning*1000;
  }
 aa_secsrunning=(D)aa_msrunning/1000.0;
 return RET_YES;
 }




 B aa_CoreSystemTimer                  (H index,B prefresh,B postfresh,Q ms)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(index>=aaElementCount(aa.core_system.prev_msrunning)) { return RET_NO; }
 if(prefresh) { aa_CoreSystemTime(); }
 if((aa_msrunning-aa.core_system.prev_msrunning[index])<ms) { return RET_NO; }
 if(postfresh) { aa_CoreSystemTime(); }
 aa.core_system.prev_msrunning[index]=aa_msrunning;
 return RET_YES;
 }




 B aa_CoreSystemLoop                   (V)
 {
 MSG msg;
 BOOL bl;
 H go=0;

 do
 {
 if(PeekMessage(&msg,NULL,0,0,PM_NOREMOVE))
  {
  /* apr 2016 - using hooks instead
  if(msg.message==WM_MOUSEWHEEL)
   {
   delta=(I)HIWORD(msg.wParam);
   if(delta<0) { delta=aaNumAbs(delta); delta=delta/100; delta=1; aa.input_system.wheel-=delta;   }
   else
   if(delta>0) { delta=aaNumAbs(delta); delta=delta/100; delta=1; aa.input_system.wheel+=delta;    }
   }
  */
  { H ii,igl=(H)aa_hwnd_ignore[0]; for(ii=0;ii<igl;ii++) {  if(aa_hwnd_ignore[1+ii]==msg.hwnd) { break; }   } if(ii!=igl) {  break; }  }
  bl=GetMessage(&msg,NULL,0,0);
  if(bl==0)
  //if(msg.message==WM_QUIT)
   {
   aa_is_quit_received=YES;
   aa.core_system.wm_quit_received=YES;
   aa.core_system.wm_quit_exitcode=msg.wParam;
   }
  else
  if(bl==-1)
   {
   oof;
   return RET_FAILED;
   }
  TranslateMessage(&msg);
  DispatchMessage(&msg);
  if(aa.core_system.wm_quit_received==YES) {  return RET_NO; } // i added this line, 2007 - ashot, qekyfavu
  }
 else
  {
  if(aa.input_system.is_logger_started==YES)
   {
   if((aa_msrunning-aa.input_system.logger_reset_tik)>aaSecs(5))
    {
    aa_InputKeyLoggerReset();
    }
   }
  if(aa.core_system.wm_quit_received==YES) {   return RET_NO; }
  break;
  }
 //go++;
 if((go++)>5) {  break; }
 //break;
 }
 while(1);
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/


 V aaAbort                             (VP fmt,...)
 {
 va_list argptr;
 B str[_8K];
 B buf[_8K];

 aaFmt(fmt,argptr,str);
 aaStringCopyf(buf,"aaAbort\n");
 aaStringAppendf(buf,"--------------------------------------------------------------------\n");
 aaStringAppendf(buf,"aa_stage=%i\n",aa_stage);
 aaStringAppendf(buf,"aa_prevstage=%i\n",aa_prevstage);
 aaStringAppendf(buf,"aa_nextstage=%i\n",aa_nextstage);
 aaStringAppendf(buf,"aa_cycle=%I64u\n",aa_cycle);
 aaStringAppendf(buf,"aa_msrunning=%I64u\n",aa_msrunning);
 aaStringAppendf(buf,"--------------------------------------------------------------------\n");
 aaStringAppendf(buf,"%s\n",str);
 aaStringAppendf(buf,"--------------------------------------------------------------------");
 aaNote(0,"%s",buf);
 longjmp(aa_jmp_buf,1);
 }


/*-----------------------------------------------------------------------*/


 B aaQuit                              (V)
 {
 aa_is_quit_called=YES;
 if(aa.core_system.wm_quit_received==NO)
  {
  if(is_aa_started_by_winmain==YES)
   {
   is_aa_quit_posted=YES;
   PostQuitMessage(0);
   }
  }
 return RET_YES;
 }


 Q aaMsRunning                         (V)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aa_CoreSystemTime();
 return aa_msrunning;
 }



 Q aaMicrosecsRunning                  (V)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aa_CoreSystemTime();
 return aa_microsecsrunning;
 }


/*-----------------------------------------------------------------------*/

 B aaTrace                             (VP fmt,...)
 {
 B ret;
 va_list argptr;
 B str[_64K];
 B prev_log_state;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 str[0]=0;
 aaFmt(fmt,argptr,str);
 prev_log_state=aa.core_system.master_log_state;
 aa_CoreSystemLogStateSet(YES);
 ret=aa_CoreSystemLog(123,"%s",str);
 aa_CoreSystemLogStateSet(prev_log_state);
 return ret;
 }



 B aaTraceFileSet                      (VP fmt,...)
 {
 B prev_file[_1K];
 aaVargsf(fmt);

 aaStringCopyf(prev_file,"%s",aa.core_system.aa_trace_file);
 if(str64k.len==0)  {  aaStringCopyf(aa.core_system.aa_trace_file,"aa_trace.txt");  }
 else               {  aaStringCopyf(aa.core_system.aa_trace_file,"%s",str64k.buf);  }
 if(aaStringICompare(prev_file,aa.core_system.aa_trace_file,0)!=YES)
  {
  aa.core_system.master_log_entries=0;
  }
 return RET_YES;
 }





 B aaCallStackGet                      (H maxitems,HP addresses)
 {
 VP sp;
 structure { VP *addr; } _caller;
 _caller*caller;
 H i=0;
 __asm__("movl %%ebp,%0" : "=r"(sp));
 for(i=0;i<maxitems;i++) { addresses[i]=0; }
 i=0;
 caller=(VP)sp;
 while(caller)
  {
  addresses[i++]=*(HP)&(caller[1]);
  if(i>=maxitems) { break; }
  caller=(_caller*)caller->addr;
  }
 return RET_YES;
 }




 B aaCpuIdGet                          (Z cpuinfo[4],Z infotype)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 __asm__ __volatile__ (
 "cpuid"
 : "=a" (cpuinfo [0]), "=b" (cpuinfo [1]), "=c" (cpuinfo [2]), "=d" (cpuinfo [3])
 : "a" (infotype));
 return RET_YES;
 }



 Q aaRtdscGet                          (V)
 {
 register Q v;
 register H lo,hi;

 __asm__ __volatile__("rdtsc" : "=a" (lo), "=d" (hi));
 v=(Q)hi<<32LL;
 v=v+(Q)lo;
 return v;
 }



 Q aaCpuRandomGet                      (V)
 {
 LARGE_INTEGER dtik;
 register Q val;
 QueryPerformanceCounter((LARGE_INTEGER*)&dtik);
 val=dtik.QuadPart;
 val=val*aaMathRand64(F16,F48);
 val+=aaRtdscGet();
 //val+=(dtik.QuadPart%21231984902LL);
 return val;
 }



 B aaConsoleAttach                     (V)
 {
 Z fdo,fde;
 HANDLE conshout,consherr;
 FILE*fpo,*fpe;
 FILE *_fdopen (Z fd,CP mode);

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aa.core_system.is_console_attached==YES) { return RET_YES; }
 if(AttachConsole(ATTACH_PARENT_PROCESS))
  {
  conshout=GetStdHandle(STD_OUTPUT_HANDLE);
  fdo=_open_osfhandle((intptr_t)conshout,16384);
  fpo=_fdopen(fdo,"w");
  *stdout=*fpo;
  setvbuf(stdout,NULL,_IONBF,0);
  consherr=GetStdHandle(STD_ERROR_HANDLE);
  fde=_open_osfhandle((intptr_t)consherr,16384);
  fpe=_fdopen(fde,"w");
  *stderr=*fpe;
  setvbuf(stderr,NULL,_IONBF,0);
  aa.core_system.is_console_attached=YES;
  aa.core_system.is_console_crlf_needed=NO;
  aa.core_system.is_console_ever_attached=YES;
  return RET_YES;
  }
 aa.core_system.is_console_ever_attached=OTHER;
 return RET_FAILED;
 }





 B aaConsoleDetach                     (V)
 {
 INPUT ip;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aa.core_system.is_console_attached!=YES) { return RET_NOTOPEN; }
 if(aa.core_system.is_console_crlf_needed)
  {
  aaFocusToHwnd(GetConsoleWindow());
  //if(GetConsoleWindow()!=GetForegroundWindow()) { return RET_NOTREADY; }
  aaMemoryFill(&ip,sizeof(ip),0);
  ip.type=INPUT_KEYBOARD;
  ip.ki.wVk=CR_CHAR;
  SendInput(1,&ip,sizeof(INPUT));
  ip.ki.dwFlags=KEYEVENTF_KEYUP;
  SendInput(1,&ip,sizeof(INPUT));
  }
 if(FreeConsole()==0) { return RET_FAILED; }
 aa.core_system.is_console_attached=NO;
 aa.core_system.is_console_crlf_needed=NO;
 return RET_YES;
 }




 B aaConsolePrintf                     (VP fmt,...)
 {
 va_list argptr;
 B str[_16K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,str);
 if(aa.core_system.is_console_attached!=YES) { return RET_NOTOPEN; }
 printf("%s",str);
 aa.core_system.is_console_crlf_needed=YES;
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/





 B aaLog                               (H line,VP fmt,...)
 {
 B ret;
 va_list argptr;
 BP tmp;
 B str[_64K];
 B prev_log_state;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaCast(tmp,BP,str);
 if(aa.is_ready==YES)
  {
  if((ret=aa_MemoryTemp((VP)&tmp,_256K,aa_MEMORYTEMP_Log))!=RET_YES)   {   return ret;   }
  }
 tmp[0]=NULL_CHAR;
 aaFmt(fmt,argptr,tmp);
 prev_log_state=aa.core_system.master_log_state;
 aa_CoreSystemLogStateSet(YES);
 ret=aa_CoreSystemLog(line,"%s",tmp);
 aa_CoreSystemLogStateSet(prev_log_state);
 return ret;
 }



 B aaLogEx                             (VP filename,H line,VP fmt,...)
 {
 B ret;
 va_list argptr;
 B str[_64K];
 B prev_log_state;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 UNUSE(filename);
 str[0]=0;
 aaFmt(fmt,argptr,str);
 prev_log_state=aa.core_system.master_log_state;
 aa_CoreSystemLogStateSet(YES);
 ret=aa_CoreSystemLog(line,"%s",str);
 aa_CoreSystemLogStateSet(prev_log_state);
 return ret;
 }



 B aaLogX                              (B how,VP fmt,...)
 {
 B str[_4K];
 va_list argptr;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,str);
 if(aaBitGet(how,0)) aaLog(-777,"%s",str);
 if(aaBitGet(how,1)) aaDebugf("%s",str);
 if(aaBitGet(how,3)) aaHistory(0xffffffff,"%s",str);
 return RET_YES;
 }



 B aaAaFilesBackup                     (B aatrace,B aacrash,B aahistory,B aaoofs)
 {
 B ret;
 B path[_1K];
 B file[_1K];
 B targ[_1K];
 B str[_1K];
 _systime st;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 GetCurrentDirectory(MAX_PATH,(CP)path);
 aaTimeLocalGet(&st);
 aaTimeToString(&st,str,0,NO);
 aaStringRemoveChars(str,0,':');
 aaStringRemoveChars(str,0,',');
 aaStringRemoveChars(str,0,SPACE_CHAR);
 if(aatrace)
  {
  aaStringCopyf(file,"%s\\%s",path,aa.core_system.aa_trace_file);
  aaStringCopyf(targ,"%s\\%s.%s.txt",path,aa.core_system.aa_trace_file,str);
  if(aaFileExists(file)==RET_YES)   {   if((ret=aaFileCopy(file,targ,YES))!=RET_YES) { return ret; }   }
  }
 if(aacrash)
  {
  aaStringCopyf(file,"%s\\aa_crash.txt",path);
  aaStringCopyf(targ,"%s\\aa_crash.%s.txt",path,str);
  if(aaFileExists(file)==RET_YES)   {   if((ret=aaFileCopy(file,targ,YES))!=RET_YES) { return ret; }   }
  }
 if(aahistory)
  {
  aaStringCopyf(file,"%s\\aa_history.txt",path);
  aaStringCopyf(targ,"%s\\aa_history.%s.txt",path,str);
  if(aaFileExists(file)==RET_YES)   {   if((ret=aaFileCopy(file,targ,YES))!=RET_YES) { return ret; }   }
  }
 if(aaoofs)
  {
  aaStringCopyf(file,"%s\\aa_oofs.txt",path);
  aaStringCopyf(targ,"%s\\aa_oofs.%s.txt",path,str);
  if(aaFileExists(file)==RET_YES)   {   if((ret=aaFileCopy(file,targ,YES))!=RET_YES) { return ret; }   }
  }
 return RET_YES;
 }




 B aaAaFilesDelete                     (B aatrace,B aacrash,B aahistory,B aaoofs)
 {
 B ret;
 B path[_1K];
 B file[_1K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 GetCurrentDirectory(MAX_PATH,(CP)path);
 if(aatrace)
  {
  aaStringCopyf(file,"%s\\%s",path,aa.core_system.aa_trace_file);
  if(aaFileExists(file)==RET_YES)   {   if((ret=aaFileDelete(file))!=RET_YES) { return ret; }   }
  aaFileSaveFromMemory(file,0,0);
  }
 if(aacrash)
  {
  aaStringCopyf(file,"%s\\aa_crash.txt",path);
  if(aaFileExists(file)==RET_YES)   {   if((ret=aaFileDelete(file))!=RET_YES) { return ret; }   }
  aaFileSaveFromMemory(file,0,0);
  }
 if(aahistory)
  {
  aaStringCopyf(file,"%s\\aa_history.txt",path);
  if(aaFileExists(file)==RET_YES)   {   if((ret=aaFileDelete(file))!=RET_YES) { return ret; }   }
  aaFileSaveFromMemory(file,0,0);
  }
 if(aaoofs)
  {
  aaStringCopyf(file,"%s\\aa_oofs.txt",path);
  if(aaFileExists(file)==RET_YES)  {   if((ret=aaFileDelete(file))!=RET_YES) { return ret; }   }
  aaFileSaveFromMemory(file,0,0);
  }
 return RET_YES;
 }



 B aaAaFilesBackupOnSize               (Q aatracesize,Q aacrashsize,Q aahistorysize,Q aaoofssize)
 {
 B b1,b2,b3,b4;
 B path[_1K];
 B file[_1K];
 Q size;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 b1=b2=b3=b4=NO;
 GetCurrentDirectory(MAX_PATH,(CP)path);
 aaStringCopyf(file,"%s\\%s",path,aa.core_system.aa_trace_file);
 if(aaFileInfoGet(file,&size,0,0,0,0)==RET_YES) {  if(size>=aatracesize) { b1=YES; }   }
 aaStringCopyf(file,"%s\\aa_crash.txt",path);
 if(aaFileInfoGet(file,&size,0,0,0,0)==RET_YES) {  if(size>=aacrashsize) { b2=YES; }   }
 aaStringCopyf(file,"%s\\aa_history.txt",path);
 if(aaFileInfoGet(file,&size,0,0,0,0)==RET_YES) {  if(size>=aahistorysize) { b3=YES; }   }
 aaStringCopyf(file,"%s\\aa_oofs.txt",path);
 if(aaFileInfoGet(file,&size,0,0,0,0)==RET_YES) {  if(size>=aaoofssize) { b4=YES; }   }
 return(aaAaFilesBackup(b1,b2,b3,b4));
 }



 B aaAaFilesDeleteOnSize               (Q aatracesize,Q aacrashsize,Q aahistorysize,Q aaoofssize)
 {
 B path[_1K];
 B file[_1K];
 Q size;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 GetCurrentDirectory(MAX_PATH,(CP)path);
  aaStringCopyf(file,"%s\\%s",path,aa.core_system.aa_trace_file);
 if(aaFileInfoGet(file,&size,0,0,0,0)==RET_YES) {  if(size>=aatracesize) { aaFileDelete(file); }   }
 aaStringCopyf(file,"%s\\aa_crash.txt",path);
 if(aaFileInfoGet(file,&size,0,0,0,0)==RET_YES) {  if(size>=aacrashsize) { aaFileDelete(file); }   }
 aaStringCopyf(file,"%s\\aa_history.txt",path);
 if(aaFileInfoGet(file,&size,0,0,0,0)==RET_YES) {  if(size>=aahistorysize) { aaFileDelete(file); }   }
 aaStringCopyf(file,"%s\\aa_oofs.txt",path);
 if(aaFileInfoGet(file,&size,0,0,0,0)==RET_YES) {  if(size>=aaoofssize) { aaFileDelete(file); }   }
 return RET_YES;
 }





 B aaHistory                           (H line,VP fmt,...)
 {
 B ret;
 va_list argptr;
 B str[_8K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,str);
 ret=aa_CoreSystemHistory(line,"%s",str);
 return ret;
 }



 B aaJournal                           (VP filename,VP fmt,...)
 {
 va_list argptr;
 B str[_16K];
 H shr,axs,ats,p,sl;
 HANDLE file_handle;
 B fname[_1K];
 B txt[_16K];
 BOOL b;
 LARGE_INTEGER zi;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aaStringIsNull(filename)!=NO) { aaStringCopyf(fname,"c:\\journal.txt"); }
 else                             { aaStringCopyf(fname,"%s",filename); }
 if(aaStringIsNull(fname)!=NO) { return RET_BADPARM; }
 aaFmt(fmt,argptr,txt);
 aaStringNull(str);
 aaTimeToString(NULL,str,NULL,0);
 aaStringRemoveChars(str,0,':');
 aaStringAppendf(str,"  %s\r\n",txt);
 aaStringCopyf(str,"%s\r\n",txt);
 aaStringLen(str,&sl);
 shr=0;
 axs=GENERIC_READ|GENERIC_WRITE;
 ats=FILE_FLAG_SEQUENTIAL_SCAN;
 if((file_handle=CreateFile((LPCTSTR)fname,axs,shr,NULL,OPEN_ALWAYS,ats,NULL))==INVALID_HANDLE_VALUE) { return RET_FAILED; }
 zi.QuadPart=0;
 SetFilePointerEx(file_handle,zi,0,FILE_END);
 b=WriteFile(file_handle,str,sl,&p,NULL);
 CloseHandle(file_handle);
 if(b==FALSE||p!=sl)  { DeleteFile((CP)fname); return RET_FAILED; }
 return RET_YES;
 }



 B aaNotes                             (VP filename,VP fmt,...)
 {
 va_list argptr;
 H shr,axs,ats,p,sl;
 HANDLE file_handle;
 B fname[_1K];
 B txt[_16K];
 BOOL b;
 LARGE_INTEGER zi;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aaStringIsNull(filename)!=NO) { aaStringCopyf(fname,"c:\\notes.txt"); }
 else                             { aaStringCopyf(fname,"%s",filename); }
 if(aaStringIsNull(fname)!=NO) { return RET_BADPARM; }
 aaFmt(fmt,argptr,txt);
 aaStringLen(txt,&sl);
 aaStringCopyf(&txt[sl],"\r\n");
 sl+=2;
 shr=0;
 axs=GENERIC_READ|GENERIC_WRITE;
 ats=FILE_FLAG_SEQUENTIAL_SCAN;
 if((file_handle=CreateFile((LPCTSTR)fname,axs,shr,NULL,OPEN_ALWAYS,ats,NULL))==INVALID_HANDLE_VALUE) { return RET_FAILED; }
 zi.QuadPart=0;
 SetFilePointerEx(file_handle,zi,0,FILE_END);
 b=WriteFile(file_handle,txt,sl,&p,NULL);
 CloseHandle(file_handle);
 if(b==FALSE||p!=sl)  { DeleteFile((CP)fname); return RET_FAILED; }
 return RET_YES;
 }




/*------------------------------------------------------------------------*/


 B aaBeep                              (W freq,W ms)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 Beep(freq,ms);
 return RET_YES;
 }




 B aaWinErrorGet                       (VP buf,H line)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(WinErrorStringGet(buf,line));
 }





 B aaWinEventLog                       (B mode,VP srce,W eid,W cat,VP fmt,...)
 {
 B ret;
 _str4k str4k;
 va_list argptr;
 HANDLE handle;
 W type;
 H eventid;
 B data[_4K];
 H dlen;
 B buff[_8K];
 CP bufarray[4];
 _sysinfo si;
 _syspath sp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,str4k.buf);
 aaStringLen(str4k.buf,&str4k.len);
 if(mode>2) { mode=2; }
 aaSysPathGet(&sp);
 aaSysInfoGet(&si);
 if(aaStringIsEmpty(srce,YES)==NO)  { handle=RegisterEventSource(NULL,(CP)srce); }
 else                               { handle=RegisterEventSource(NULL,(CP)si.process_filename); }
 if(handle==NULL) { oow; return RET_FAILED; }
 if(mode==0) { type=EVENTLOG_INFORMATION_TYPE; } else
 if(mode==1) { type=EVENTLOG_WARNING_TYPE; } else
 if(mode==2) { type=EVENTLOG_ERROR_TYPE; }
 eventid=(H)eid;
 eventid=eventid+(8<<16);
 aaMemoryFill(data,sizeof(data),0);
 aaMemoryFill(buff,sizeof(buff),0);
 bufarray[0]=(CP)&buff[_0K];
 bufarray[1]=(CP)&buff[_1K];
 bufarray[2]=(CP)&buff[_2K];
 bufarray[3]=(CP)&buff[_3K];
   aaStringCopyf(bufarray[0],"\n\n%s",str4k.buf);
   aaStringCopyf(bufarray[1],"\nprocess=%s \n",si.process_filename);
 aaStringAppendf(bufarray[1],"path=%s \n",sp.current_dir);
 aaStringAppendf(bufarray[1],"launch_tik=%u ",aa_launchtik);
 dlen=0;
 ret=RET_YES;
 if(ReportEvent(handle,type,cat,eventid,NULL,2,dlen,(VP)bufarray,(dlen)?(VP)data:NULL)==0)
  {
  oow;
  ret=RET_FAILED;
  }
 DeregisterEventSource(handle);
 return ret;
 }





 V CALLBACK aaNoteKillerProc           (HWND wnd,UINT msg,UINT id,DWORD time)
 {
 HWND xnd;
 UNUSE(wnd);
 UNUSE(msg);
 UNUSE(id);
 UNUSE(time);
 if((xnd=FindWindow(0,"aaBoost oops"))!=NULL)
  {
  KillTimer(0,aa.core_system.note_killer_id);
  SendMessage(xnd,WM_CLOSE,0,0);
  aaSleep(100);
  aa.core_system.note_killer_id=0;
  }
 }





 B aaNote                              (H surfacehandle,VP fmt,...)
 {
 B ret;
 _aa_surfaceobject*surp;
 //va_list argptr;
 //B txt[_4K];
 //B path[_1K];
 //B name[_1K];
 Z r;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
  aaVargsf4K(fmt);
// aaFmt(fmt,argptr,txt);
 aa_oof_count++;
 ///GetCurrentDirectory(MAX_PATH,(CP)path);
 //aaStringCopyf(name,"%s\\aa_oofs.txt",path);
 //aaJournal(name,"aa_stage=%u aa_msrunning=%I64u %s",aa_stage,aa_msrunning,str4k.buf);

 if(surfacehandle!=0)
  {
  if((ret=aa_ObjectCheck(aa.surface_system.object_id,surfacehandle,(VP)&surp,NULL))!=RET_YES) { return ret; }
  if(surp->status.hwnd==NULL) { return RET_FAILED; }
  if(aa.core_system.note_killer_id==0)
   {
   #if 1
   aa.core_system.note_killer_id=SetTimer(0,0,aaMins(10)/*aaHours(10)*/,(TIMERPROC)aaNoteKillerProc);
   r=MessageBox(surp->status.hwnd,(CP)str4k.buf,"aaBoost oopsa",MB_OK|MB_ICONEXCLAMATION|MB_SYSTEMMODAL);
   if(r==0) { }//aaQuit(); aaCrash(1); }
   if(aa.core_system.note_killer_id!=0) { KillTimer(0,aa.core_system.note_killer_id);  }
   aa.core_system.note_killer_id=0;
   #endif
   //MessageBox(surp->status.hwnd,(CP)str4k.buf,"aaBoost oopsa",MB_OK|MB_ICONEXCLAMATION|MB_SYSTEMMODAL);
   }
  else
   {
   aaDebugf("more oopsa %s",str4k.buf);
   }
  }
 else
  {
  if(aa.core_system.note_killer_id==0)
   {
   #if 1
   aa.core_system.note_killer_id=SetTimer(0,0,aaMins(10)/*aaHours(10)*/,(TIMERPROC)aaNoteKillerProc);
   r=MessageBox(NULL,(CP)str4k.buf,"aaBoost oops",MB_OK|MB_ICONEXCLAMATION|MB_SYSTEMMODAL);
   if(r==0) { }///aaQuit(); aaCrash(1); }
   if(aa.core_system.note_killer_id!=0) { KillTimer(0,aa.core_system.note_killer_id);  }
   aa.core_system.note_killer_id=0;
   #endif
   //MessageBox(NULL,(CP)str4k.buf,"aaBoost oops",MB_OK|MB_ICONEXCLAMATION|MB_SYSTEMMODAL);
   }
  else
   {
   aaDebugf("more oops %s",str4k.buf);
   }
  }
 return RET_YES;
 }





 B aaNotex                             (H surfacehandle,VP fmt,...)
 {
 va_list ap;
 BP bp;
 B dst[_2K];
 H sl,off,wl;
 N which;
 _cord var_cord;
 _size var_size;
 _rect var_rect;
 _rgba var_rgba;
 _netadr var_netadr;
 H var_h;
 B txt[_1K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 va_start(ap,fmt);
 aaCast(bp,BP,fmt);
 aaStringLen(bp,&sl);
 off=0;
 aaStringNull(dst);
 wl=1;
 while(1)
  {
  aaStringIsIString(&bp[off],&which,"$cord","$size","$rect","$rgba","$ipadr","$netadr","$q",NULL);
  switch(which)
   {
   case 0:   wl=5; aaCordCopy(&var_cord,va_arg(ap,_cord*));   aaStringAppendf(dst,"%i,%i",var_cord.x,var_cord.y);   break;
   case 1:   wl=5; aaSizeCopy(&var_size,va_arg(ap,_size*));   aaStringAppendf(dst,"%ix%i",var_size.w,var_size.h);   break;
   case 2:   wl=5; aaRectCopy(&var_rect,va_arg(ap,_rect*));   aaStringAppendf(dst,"%i,%i,%i,%i",var_rect.x,var_rect.y,var_rect.w,var_rect.h);   break;
   case 3:   wl=5; aaRgbaCopy(&var_rgba,va_arg(ap,_rgba*));   aaStringAppendf(dst,"%i,%i,%i,%i",var_rgba.r,var_rgba.g,var_rgba.b,var_rgba.a);   break;
   case 4:   wl=6; var_h=(H)va_arg(ap,H);   aaNetIpToString(var_h,txt);   aaStringAppendf(dst,"%s",txt);   break;
   case 5:   wl=7; aaNetAdrCopy(&var_netadr,va_arg(ap,_netadr*));   aaNetIpToString(var_netadr.ip,&txt[500]);   aaStringAppendf(dst,"%s/%i",&txt[500],var_netadr.port);   break;
   case -1:
   default: wl=1; aaStringAppendf(dst,"%c",bp[off]);   break;
   }
  off+=(wl);
  if(off>sl) { oof; }
  if(off==sl) { if(bp[off]!=NULL_CHAR) { oof; } break; }
  }
 va_end(ap);
 aaNote(surfacehandle,"%s",dst);
 return RET_YES;
 }




 #define ID_EDIT1                      1000
 S CP EntryBox_Buffer=                 NULL;
 S Z EntryBox_BufSize=                 0;
 S B EntryBox_Title[_1K]=              {0};
 S B EntryBox_Text[_1K]=               {0};



 structure
 {
 DLGTEMPLATE dlgTemplate;
 WORD        wMenu;
 WORD        wClass;
 WCHAR       szTitle[9];
 WORD        wFontSize;
 WCHAR       szFontFaceName[7];
 DLGITEMTEMPLATE ctrlEdit1;
 WORD        wClassE1;
 WORD        wClassE1Id;
 WCHAR       szTitleE1;
 WORD        wDataE1;
 WORD        wAlign1;
 DLGITEMTEMPLATE ctrlButtonOk;
 WORD        wClassBO;
 WORD        wClassBOId;
 WCHAR       szTitleBO[3];
 WORD        wDataBO;
 WORD        wAlign3;
 DLGITEMTEMPLATE ctrlButtonMdg;
 WORD        wClassBM;
 WORD        wClassBMId;
 WCHAR       szTitleBM[7];
 WORD        wDataBM;
 }
 DIALOG;



 DIALOG EntryBox_TemplateA=
 {
 {WS_POPUP|WS_CAPTION|WS_SYSMENU|DS_MODALFRAME|DS_CENTER|DS_SETFONT,0,3,0,0,186,60,},0,0,{L"aaField"},8,{L"Tahoma"},
 {WS_CHILD|WS_VISIBLE|WS_CLIPSIBLINGS|WS_BORDER|WS_TABSTOP|WS_GROUP|ES_AUTOHSCROLL|ES_AUTOVSCROLL|ES_WANTRETURN|ES_MULTILINE,0,7,7,117,42,ID_EDIT1,},F16,0x0081,L'\0',0,0,
 {WS_CHILD|WS_VISIBLE|WS_CLIPSIBLINGS|WS_TABSTOP|WS_GROUP|BS_DEFPUSHBUTTON,0,129,7,50,14,IDOK,},F16,0x0080,{L"OK"},0,0,
 {WS_CHILD|WS_VISIBLE|WS_CLIPSIBLINGS|WS_TABSTOP|BS_PUSHBUTTON,0,129,24,50,14,IDCANCEL,},F16,0x0080,{L"Cancel"},0,
 };

 DIALOG EntryBox_TemplateB=
 {
 {WS_POPUP|WS_CAPTION|WS_SYSMENU|DS_MODALFRAME|DS_CENTER|DS_SETFONT,0,3,0,0,186,46,},0,0,{L"aaField"},8,{L"Tahoma"},
 {WS_CHILD|WS_VISIBLE|WS_CLIPSIBLINGS|WS_BORDER|WS_TABSTOP|WS_GROUP|ES_AUTOHSCROLL,0,7,7,117,14,ID_EDIT1,},F16,0x0081,L'\0',0,0,
 {WS_CHILD|WS_VISIBLE|WS_CLIPSIBLINGS|WS_TABSTOP|WS_GROUP|BS_DEFPUSHBUTTON,0,129,7,50,14,IDOK,},F16,0x0080,{L"OK"},0,0,
 {WS_CHILD|WS_VISIBLE|WS_CLIPSIBLINGS|WS_TABSTOP|BS_PUSHBUTTON,0,129,24,50,14,IDCANCEL,},F16,0x0080,{L"Cancel"},0,
 };







 BOOL CALLBACK EntryBox_DialogProc(HWND hwndDlg,UINT uMsg,WPARAM wParam,LPARAM lParam)
 {
 if(lParam==1234) { if(lParam==2345) {} }
 switch (uMsg)
  {
  default:
  break;

  case WM_INITDIALOG:
  if(aaStringIsEmpty(EntryBox_Text,YES)==NO)
   {
   SetWindowText(GetDlgItem(hwndDlg,ID_EDIT1),(LPCSTR)EntryBox_Text);
   }
  return TRUE;

  case WM_GETTEXT:  SetWindowText(hwndDlg,(LPCSTR)EntryBox_Title);   return FALSE;


  case WM_COMMAND:
  if(IDOK==LOWORD(wParam)||IDCANCEL==LOWORD(wParam))
   {
   GetWindowText(GetDlgItem(hwndDlg,ID_EDIT1),EntryBox_Buffer,EntryBox_BufSize);
   EndDialog(hwndDlg,LOWORD(wParam));
   return TRUE;
   }
  }
 return FALSE;
 }




 B aaField                             (H surfacehandle,B multiline,H maxchars,VP buf,VP title)
 {
 B ret;
 _aa_surfaceobject*surp;
 HWND wnd;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(title)  {  aaStringCopy(EntryBox_Title,title);  }
 else       {  aaStringNull(EntryBox_Title);  }
 wnd=NULL;
 if(surfacehandle!=0)
  {
  if(surfacehandle==0xffffffff)
   {
   wnd=GetDesktopWindow();
   }
  else
   {
   if((ret=aa_ObjectCheck(aa.surface_system.object_id,surfacehandle,(VP)&surp,NULL))!=RET_YES) { return ret; }
   if(surp->status.hwnd==NULL) { return RET_FAILED; }
   wnd=surp->status.hwnd;
   }
  }
 EntryBox_Buffer=buf;
 EntryBox_BufSize=maxchars;
 if(aaStringIsEmpty(buf,YES)==NO) { aaStringCopyf(EntryBox_Text,"%s",buf); }
 else                             { aaStringNull(EntryBox_Text); }
 if(multiline)
  {
  EntryBox_TemplateA.dlgTemplate.cy=60;
  EntryBox_TemplateA.ctrlEdit1.cy=42;
  if(DialogBoxIndirect(NULL,(DLGTEMPLATE*)&EntryBox_TemplateA,wnd,EntryBox_DialogProc)!=IDOK) { return RET_NO; }
  }
 else
  {
  EntryBox_TemplateB.dlgTemplate.cy=46;
  EntryBox_TemplateB.ctrlEdit1.cy=14;
  if(DialogBoxIndirect(NULL,(DLGTEMPLATE*)&EntryBox_TemplateB,wnd,EntryBox_DialogProc)!=IDOK) { return RET_NO; }
  }
 return RET_YES;
 }







 B aaYesNoBox                          (H surfacehandle,B defbut,VP fmt,...)
 {
 B ret;
 _aa_surfaceobject*surp;
 va_list argptr;
 HWND xnd;
 B txt[_4K];
 DWORD r;
 DWORD f;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,txt);
 xnd=0;
 if(surfacehandle!=0)
  {
  if((ret=aa_ObjectCheck(aa.surface_system.object_id,surfacehandle,(VP)&surp,NULL))!=RET_YES) { return ret; }
  if(surp->status.hwnd==NULL) { return RET_FAILED; }
  xnd=surp->status.hwnd;
  }
 f=MB_YESNOCANCEL|MB_SETFOREGROUND|MB_TOPMOST|MB_ICONQUESTION|MB_SYSTEMMODAL;
 if(defbut==0) { f|=MB_DEFBUTTON1; } else
 if(defbut==1) { f|=MB_DEFBUTTON2; } else
 if(defbut==2) { f|=MB_DEFBUTTON3; }
 r=MessageBox(xnd,(CP)txt,"aaBoost YesNoBox",f);//MB_YESNOCANCEL|MB_SETFOREGROUND|MB_TOPMOST|MB_ICONQUESTION|MB_SYSTEMMODAL|MB_DEFBUTTON2);
 if(r==IDNO) { return RET_NO; }
 if(r==IDCANCEL) { return RET_CANCELLED; }
 if(r==IDYES) { return RET_YES; }
 return RET_FAILED;
 }




 B aaIsRunningSlow                     (D hzratio,D curpro,D avgpro,B andflag)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 andflag&=1;
 if(andflag)
  {
  if(aa_curhz<(aa_askhz*hzratio)&&(aa_curproload>curpro)&&(aa_avgproload>avgpro))        { return RET_YES; }
  }
 else
  {
  if(aa_curhz<(aa_askhz*hzratio)) { return RET_YES; }
  if(aa_avgproload>avgpro)        { return RET_YES; }
  if(aa_curproload>curpro)        { return RET_YES; }
  }
 return RET_NO;
 }




 B aaSleep                             (H ms)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 SleepEx(ms,TRUE);
 return RET_YES;
 }




 B aaSleepPrecise                      (Q microsecs)
 {
 Q divs,passed;
 D paas;
 LARGE_INTEGER stik;
 LARGE_INTEGER etik;
 H i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 divs=aa.core_system.perf_frequency/1000000;
 QueryPerformanceCounter((LARGE_INTEGER*)&stik);
 while(1)
  {
  if(microsecs==0) { break; }
  paas=(D)microsecs/1000.0;
  if(paas>=10)      { aaSleep(1); }
  else
   {
   for(i=0;i<20;i++) { aaSleep(0); }
   }
  QueryPerformanceCounter((LARGE_INTEGER*)&etik);
  passed=etik.QuadPart-stik.QuadPart;
  passed=(passed/divs);
  if(passed>=microsecs) { microsecs=0; }
  else                  { microsecs=microsecs-passed; }
  stik.QuadPart=etik.QuadPart;
  }
 return RET_YES;
 }




 B aaSleepHz                           (D hz)
 {
 S H sleep_for=0;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(hz<1.0) { hz=1.0; }
 if(aa_curhz>hz)
  {
  aaSleep(sleep_for);
  sleep_for++;
  }
 else
 if(aa_curhz<hz)
  {
  if(sleep_for>0) { sleep_for--; }
  aaSleep(sleep_for);
  }
 return RET_YES;
 }



 B aaSleepLoad                         (D percent)
 {
 S H sleep_for=0;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(percent<0.0) { percent=0.0; }
 if(percent>100.0) { percent=100.0; }
 if(aa_avgproload>percent||aa_curproload>percent)
  {
  aaSleep(sleep_for);
  sleep_for++;
  }
 else
 if(aa_avgproload<percent&&aa_curproload<percent)
  {
  if(sleep_for>0) { sleep_for--; }
  aaSleep(sleep_for);
  }
 return RET_YES;
 }



 B aaStageSet                          (H stage)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aa_prevstage=aa_stage;
 aa_stage=stage;
 return RET_YES;
 }



 B aaStageAndNextSet                   (H stage,H next)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aa_prevstage=aa_stage;
 aa_stage=stage;
 aa_nextstage=next;
 return RET_YES;
 }




 B aaStageAdjust                       (N amount)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 logg("Adjusting aa_stage from %i by %i to %i",aa_prevstage,amount,aa_stage+amount);
 aa_prevstage=aa_stage;
 aa_stage+=amount;
 return RET_YES;
 }



 B aaStagePrev                         (V)
 {
 H ps;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 ps=aa_stage;
 aa_stage=aa_prevstage;
 aa_prevstage=ps;
 return RET_YES;
 }



 B aaStageNext                         (V)
 {
 H ps;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 ps=aa_stage;
 aa_stage=aa_nextstage;
 aa_prevstage=ps;
 return RET_YES;
 }




 B aaAboutEvery                        (H ita)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(ita==0) { return RET_NO; }
 if(ita==1) { return RET_YES; }
 if(aaMathRand32(0,ita-1)==0) { return RET_YES; }
 return RET_NO;
 }



 B aaFocusToDbg                        (B clr)
 {
 HWND wnd;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((wnd=FindWindow("dbgviewClass",NULL))==NULL)
 if((wnd=FindWindow(NULL,"Trace Spy - Administrator"))==NULL)
 if((wnd=FindWindow("dbgviewClass","Trace Spy - Administrator"))==NULL)
  {
  if((wnd=FindWindow(NULL,"[Capture Win32] - DebugView++"))==NULL)
   {
   return RET_NOTFOUND;
   }
  }
 aaFocusToHwnd(wnd);
 if(clr) { aaInputKeyPairSimulate(VK_CONTROL,'X',20); }
 return RET_YES;
 }





 B aaFocusToBorland                    (V)
 {
 B ret;
 HWND wnd;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFocusToHwnd(GetDesktopWindow());
 if((wnd=FindWindow("CPPFRAME",0))==NULL) { return RET_NOTFOUND; }
 ret=aaFocusToHwnd(wnd);
 return ret;
 }




 B aaFocusToCodeBlocks                 (V)
 {
 B ret;
 HWND wnd;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFocusToHwnd(GetDesktopWindow());
 if((wnd=FindWindow("wxWindowClassNR",0))==NULL) { return RET_NOTFOUND; }
 ret=aaFocusToHwnd(wnd);
 return ret;
 }





 B aaFocusToFirefox                    (V)
 {
 HWND wnd;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFocusToHwnd(GetDesktopWindow());
 if((wnd=FindWindow("MozillaWindowClass",0))==NULL) { return RET_NOTFOUND; }
 return(aaFocusToHwnd(wnd));
 }




 B aaFocusToHwnd                       (HWND hwnd)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(IsIconic(hwnd)!=0)  {  ShowWindow(hwnd,SW_RESTORE);  }
 AttachThreadInput(GetWindowThreadProcessId(GetForegroundWindow(),NULL),GetCurrentThreadId(),TRUE);
 SetForegroundWindow(hwnd);
 SetActiveWindow(hwnd);
 SetFocus(hwnd);
 BringWindowToTop(hwnd);
 return RET_YES;
 }




 B aaHwndGroupGet                      (HWND*active,HWND*focus,HWND*foreground)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(active)     {  *active=GetActiveWindow();  }
 if(focus)      {  *focus=GetFocus();  }
 if(foreground) {  *foreground=GetForegroundWindow();  }
 return RET_YES;
 }



 B aaHwndInfoGet                       (HWND hwnd,HWND*phwnd,HWND*ohwnd,RECT*winrect,VP strclass,VP strtitle)
 {
 Z res,len;
 RECT rc;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(phwnd) { *phwnd=NULL; }
 if(ohwnd) { *ohwnd=NULL; }
 if(strclass!=NULL) { aaStringNull(strclass); }
 if(strtitle!=NULL) { aaStringNull(strtitle); }
 if(hwnd==NULL) { return RET_BADPARM; }
 len=128;
 if(strclass!=NULL)
  {
  res=GetClassName(hwnd,strclass,len);
  if(res>=len) { aaStringNull(strclass); return RET_BOUNDS; }
  }
 if(strtitle!=NULL)
  {
  res=GetWindowText(hwnd,strtitle,len);
  if(res>=len) { aaStringNull(strtitle); return RET_BOUNDS; }
  }
 if(winrect)
  {
  GetWindowRect(hwnd,&rc);
  WinRectCopy(winrect,&rc);
  }
 if(phwnd)  {  *phwnd=GetParent(hwnd);  }
 if(ohwnd)  {  *ohwnd=GetWindow(hwnd,GW_OWNER);  }
 return RET_YES;
 }




 B aaHwndIsObscured                    (HWND hwnd,B detail,DP visipc)
 {
 H count=0;
 H outof=0;
 RECT myRect;
 _rect rc1;
 N x,y,zx,zy;
 POINT pt;
 HWND wnd;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(visipc) { *visipc=0; }
 if(hwnd==NULL) { return RET_BADPARM; }
 detail=aaNumClamp(detail,1,31)*4;
 if(GetWindowRect(hwnd,&myRect)==0) { return RET_FAILED; }
 aaRectFromWinRect(&rc1,&myRect);
 if(rc1.w<=4||rc1.h<=4) { return RET_YES;  }
 rc1.w-=4; rc1.h-=4;
 rc1.x+=2; rc1.y+=2;
 zx=(rc1.w/detail);
 zy=(rc1.h/detail);
 if(zx==0) { zx=1; }
 if(zy==0) { zy=1; }
 y=2;
 while(1)
  {
  if((y+2)>=(N)rc1.h) { break; }
  x=2;
  while(1)
   {
   if((x+2)>=(N)rc1.w) { break; }
   pt.x=x+rc1.x;
   pt.y=y+rc1.y;
   x+=zx;
   outof++;
   wnd=WindowFromPoint(pt);
   if(wnd!=NULL&&wnd==hwnd) { count++; }
   }
  y+=zy;
  }
 if(visipc&&outof!=0) { *visipc=aaNumPercentIs((D)count,(D)outof); }
 if(count==outof&&outof!=0) { return RET_NO; }
 return RET_YES;
 }




 B aaIsRemoteSession                   (V)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(GetSystemMetrics(SM_REMOTESESSION)==0) { return RET_NO; }
 return RET_YES;
 }


 B aaIsDebug                           (V)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aa.core_system.in_debugger);
 }


 B aaIsRemoteDebug                     (V)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aa.core_system.in_remote_debugger);
 }




 B aaIsProfiling                       (V)
 {
 B val;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 val=aa_SHOW_PROFILE;
 if(val==YES) { return RET_YES; }
 return RET_NO;
 }




 B aaProfilingPause                    (B state)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(state) { aa.is_diag_paused=YES; }
 else      { aa.is_diag_paused=NO; }
 return RET_YES;
 }






 V aaDebugfHwnds                       (V)
 {
 HWND tw,aw,fw,fo;
 B titt[4][_1K];
 B clas[4][_1K];

 tw=GetTopWindow(NULL); aw=GetActiveWindow(); fw=GetFocus(); fo=GetForegroundWindow();
 aaDebugf("---------");
 if(tw==NULL||aw==NULL||fw==NULL||fo==NULL) aaDebugf("fuckfuck %x %x %x %x",tw,aw,fw,fo);
 if(tw!=NULL) {  aaHwndInfoGet(tw,0,0,0,clas[0],titt[0]); aaDebugf("top:0x%08x c:%s t:%s",tw,clas[0],titt[0]); }
 if(aw!=NULL) {  aaHwndInfoGet(aw,0,0,0,clas[1],titt[1]); aaDebugf("act:0x%08x c:%s t:%s",aw,clas[1],titt[1]); }
 if(fw!=NULL) {  aaHwndInfoGet(fw,0,0,0,clas[2],titt[2]); aaDebugf("foc:0x%08x c:%s t:%s",fw,clas[2],titt[2]); }
 if(fo!=NULL) {  aaHwndInfoGet(fo,0,0,0,clas[3],titt[3]); aaDebugf("for:0x%08x c:%s t:%s",fo,clas[3],titt[3]); }
 }




 B aaDebugfProcSet                     (VP proc)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(proc==NULL)
  {
  aa.core_system.debugf_proc=aaDebugf;
  }
 else
  {
  aa.core_system.debugf_proc=proc;
  }
 if(aa.core_system.debugf_proc==aaDebugf)
  {
  aa.core_system.debugf_proc=NULL;
  }
 return RET_YES;
 }




 B aaDebugf                            (VP fmt,...)
 {
 B ret;
 va_list argptr;
 BP tmp=NULL_POINTR;
 B etc[_32K];
 B txt[_32K];
 H sl,off,left,todo,i,mc;
 B(*proc)(VP txt);

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(fmt==NULL)
  {
  OutputDebugString("DBGVIEWCLEAR");
  return RET_YES;
  }
 aaCast(tmp,BP,etc);
 if(aa.is_ready==YES)
  {
  if((ret=aa_MemoryTemp((VP)&tmp,_256K,aa_MEMORYTEMP_Debugf))!=RET_YES) {  return ret;   }
  }
 aaFmt(fmt,argptr,tmp);
 if(tmp[0]==NULL_CHAR)  {  return RET_YES;  }
 if(aa.core_system.is_debugf_log_write==YES)
  {
  if(aa.core_system.debugf_log_write_style==0) {  aaLog(-777,"%13.3f %s",aa_microsecsrunning/1000.0,tmp);   }
  else
  if(aa.core_system.debugf_log_write_style==1) {  aaLog(-666,"%13.3f %s",aa_microsecsrunning/1000.0,tmp);   }
  else
  if(aa.core_system.debugf_log_write_style==2) {  aaLog(-555,"%s",tmp);   }
  }
 aaStringLen(tmp,&sl);
 mc=_8K+_4K;
 mc=_16K;
 mc=_4K;
   off=0;
   while(1)
    {
    left=sl-off;
    if(left==0) { break; }
    todo=aaNumRoof(left,mc);//4000);
    if(todo<mc)///4000)
     {
     aaStringNCopy(etc,&tmp[off],todo,YES);
     etc[todo+0]=NULL_CHAR;
     etc[todo+1]=NULL_CHAR;
     aaStringCopyf(txt,"%s%s",aa.core_system.debugf_prefix,etc);

     if(aa.core_system.debugf_proc!=NULL)
      {
      proc=aa.core_system.debugf_proc;
      proc(txt);
      }
     else
      {
      OutputDebugString((LPCTSTR)txt);
      }
     //OutputDebugString((LPCTSTR)etc);
     break;
     }
    i=todo-1;
    while(1)
     {
     if(i==0) { break; }
     if(tmp[off+i]==LF_CHAR) { break; }
     i--;
     }
    todo=i;
    if(todo==0) { todo=mc; }
    aaStringNCopy(etc,&tmp[off],todo,YES);
    etc[todo+0]=NULL_CHAR;
    etc[todo+1]=NULL_CHAR;
    aaStringCopyf(txt,"%s%s",aa.core_system.debugf_prefix,etc);

     if(aa.core_system.debugf_proc!=NULL)
      {
      proc=aa.core_system.debugf_proc;
      proc(txt);
      }
     else
      {
      OutputDebugString((LPCTSTR)txt);
      }
    //OutputDebugString((LPCTSTR)etc);
    off+=todo+1;
    }
 return RET_YES;
 }




 B aaDebugfPrefix                      (VP fmt,...)
 {
 va_list argptr;
 B etc[_32K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaStringNull(aa.core_system.debugf_prefix);
 if(fmt==NULL)  {  return RET_YES;  }
 aaFmt(fmt,argptr,etc);
 aaStringCopyf(aa.core_system.debugf_prefix,"%s",etc);
 if(aa.core_system.debugf_prefix[0]!=NULL_CHAR) { aaStringAppendf(aa.core_system.debugf_prefix," "); }
 return RET_YES;
 }




 B aaDebugfBlankLine                   (B count)
 {
 B ret;
 H i;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 for(i=0;i<count;i++)
  {
  if((ret=aaDebugf(" "))!=YES) { return ret; }
  }
 return RET_YES;
 }




 B aaDebugfCharLine                    (B count,B ch)
 {
 B txt[_1K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaStringFill(txt,count,ch,YES);
 aaDebugf("%s",txt);
 return RET_YES;
 }




 B aaDebugfLogWriteSet                 (B state)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(state) { aa.core_system.is_debugf_log_write=YES;  }
 else      { aa.core_system.is_debugf_log_write=NO;   }
 return RET_YES;
 }


 B aaDebugfLogStyleSet                 (B style)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aa.core_system.debugf_log_write_style=style;
 return RET_YES;
 }




 B aaDebugfMemoryDump                  (V)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aa_MemorySystemDump();
 return RET_YES;
 }


#if 0

 TCHAR*optarg=NULL;
 int optind=0;


 B aaMainArgsGetOpt                    (Z argc,TCHAR*argv[],TCHAR*optstring)
 {
 S TCHAR *next=NULL;
 TCHAR c;
 TCHAR*cp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(optind==0) { next=NULL; }
 optarg=NULL;
 if(next==NULL||*next==_T('\0'))
  {
  if(optind==0) { optind++; }
  if(optind>=argc||argv[optind][0]!=_T('-')||argv[optind][1]==_T('\0'))
   {
   optarg=NULL;
   if(optind<argc) { optarg=argv[optind]; }
   return EOF;
   }
  if(_tcscmp(argv[optind],_T("--"))==0)
   {
   optind++;
   optarg=NULL;
   if(optind<argc) { optarg=argv[optind]; }
   return EOF;
   }
  next=argv[optind];
  next++;
  optind++;
  }
 c=*next++;
 cp=_tcschr(optstring,c);
 if(cp==NULL||c==_T(':')) { return _T('?'); }
 cp++;
 if(*cp==_T(':'))
  {
  if(*next!=_T('\0'))
   {
   optarg=next;
   next=NULL;
   }
  else
  if(optind<argc)
   {
   optarg=argv[optind];
   optind++;
   }
  else
   {
   return _T('?');
   }
  }
 return c;
 }


#endif


 B aaRetroMain                         (Z(*mainfunc)(Z argc,CP argv[]),ZP mainret,VP sourcearg,...)
 {
 C arg[10][_1K];
 CP argptr[10];
 Z r,argcount;
 H i,mx;
 va_list ap;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mainret!=NULL) { *mainret=0; }
 if(mainfunc==NULL) { return RET_BADPARM; }
 aaMemoryFill(arg,sizeof(arg),0);
 mx=aaElementCount(arg);
 for(i=0;i<mx;i++) { argptr[i]=arg[i]; }
 va_start(ap,sourcearg);
 argcount=0;
 if(sourcearg==NULL) { aaStringCopyf(arg[argcount],"%s",aa.core_system.module_filename); }
 else                { aaStringCopyf(arg[argcount],"%s",sourcearg); }
 argcount++;
 while(1)
  {
  if(argcount>=(Z)mx) { break; }
  if((bp=va_arg(ap,BP))==NULL) { break; }
  if(bp[0]==NULL_CHAR) { break; }
  aaStringCopyf(arg[argcount++],"%s",bp);
  }
 va_end(ap);
 r=mainfunc(argcount,argptr);
 if(mainret) { *mainret=r; }
 return RET_YES;
 }



 B aaMorph                             (VP processfilename,VP cmdline)
 {
 B ret;
 STARTUPINFO si;
 C pat[_1K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(processfilename==NULL)
  {
  if(aa.core_system.is_morph_pending==YES)
   {
   ResumeThread(aa.core_system.morph_pi.hThread);
   WaitForInputIdle(aa.core_system.morph_pi.hProcess,3000);
   if(PostThreadMessage(aa.core_system.morph_pi.dwThreadId,WM_QUIT,0,0)==0) { }//  WinErrorStringGet(0,__LINE__);   }
   aa.core_system.is_morph_pending=NO;
   aa_is_morph_pending=NO;
   return RET_YES;
   }
  return RET_FAILED;
  }
 if(aa.core_system.is_morph_pending==YES)                    { return RET_INUSE; }
 if((ret=aaFileInfoGet(processfilename,0,0,0,0,0))!=RET_YES) { aaLog(-1,"morphfileinfo %s",ret_string[ret]); return ret; }
 if(aa.core_system.is_morph_pending==YES)                    { return RET_INUSE; }
 aaMemoryFill(&si,sizeof(si),0);
 aaMemoryFill(&aa.core_system.morph_pi,sizeof(aa.core_system.morph_pi),0);
 si.cb=sizeof(si);
 //si.dwFlags=0x400; // startf_monitor
 //si.hStdOutput=(HANDLE)aa.display_system.di.monitor_handle[1];
 GetStartupInfo(&si);
 si.wShowWindow=SW_SHOWDEFAULT;
 aaStringCopy(pat,processfilename);
 if(cmdline) { aaStringAppendf(pat," %s",cmdline); }
 if(CreateProcess(NULL,pat,NULL,NULL,FALSE,CREATE_SUSPENDED,NULL,0,&si,&aa.core_system.morph_pi)==FALSE) { aaLog(-1,"processmorphfailure"); return RET_FAILED; }
 aa.core_system.is_morph_pending=YES;
 aa_is_morph_pending=YES;
 return RET_OK;
 }




 B aaRestart                           (V)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaMorph(aa.core_system.module_filename,aa.core_system.command_line));
 }




 B aaReboot                            (B force)
 {
 H flag;
 HANDLE htok;
 TOKEN_PRIVILEGES tkp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 flag=EWX_REBOOT;
 if(force) { flag|=EWX_FORCE; }
 if(!OpenProcessToken(GetCurrentProcess(),TOKEN_ADJUST_PRIVILEGES|TOKEN_QUERY,&htok)) { return RET_FAILED; }
 LookupPrivilegeValue(NULL,SE_SHUTDOWN_NAME,&tkp.Privileges[0].Luid);
 tkp.PrivilegeCount=1;
 tkp.Privileges[0].Attributes=SE_PRIVILEGE_ENABLED;
 AdjustTokenPrivileges(htok,FALSE,&tkp,0,(PTOKEN_PRIVILEGES)NULL,0);
 if(GetLastError()!=ERROR_SUCCESS) { return RET_DENIED; }
 if(!ExitWindowsEx(flag,0)) { return RET_FAILED; }
 return RET_YES;
 }



 B aaProcessorCoreSet                  (H core)
 {
 HANDLE process;
 H bit,currentCore;
 DWORD_PTR mask;
 DWORD_PTR processAffinityMask;
 DWORD_PTR systemAffinityMask;
 BOOL success;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 process=GetCurrentProcess();
 if(!GetProcessAffinityMask(process,&processAffinityMask,&systemAffinityMask)) { return RET_FAILED;  }
 mask=0x1;
 for(bit=0,currentCore=1;bit<64;bit++)
  {
  if(mask&processAffinityMask)
   {
   if(currentCore!=(core+1))  {  processAffinityMask&=~mask;   }
   currentCore++;
   }
  mask=mask<<1;
  }
 success=SetProcessAffinityMask(process,processAffinityMask);
 if(!success)
  {
  if(GetLastError()==ERROR_INVALID_PARAMETER) { return RET_BOUNDS; }
  return RET_FAILED;
  }
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/


 B aaLimiterSet                        (VP uid,V(*LimiterMessageProc)(H bytes,VP msg))
 {
 HANDLE h;
 N e;
 H sl;
 B txt[_1K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(uid!=NULL)
  {
  aaStringCopyfLen(txt,&sl,"%s",uid);
  aaStringReplaceChar(txt,sl,BSLASH_CHAR,FSLASH_CHAR);
  if(aaStringIsNull(txt)==YES) { return RET_BADPARM; }
  if(aa.core_system.limiter_mutex_handle!=NULL) { return RET_YES; }
  if((h=CreateMutex(NULL,TRUE,(CP)txt))==NULL) {  oow; aaNote(0,"%s",txt); return RET_FAILED; }
  if((e=GetLastError())==ERROR_ALREADY_EXISTS) { return RET_EXISTS; }
  if(e!=0) {  return RET_FAILED; }
  aa.core_system.limiter_mutex_handle=h;
  aa.core_system.LimiterMessageProc=LimiterMessageProc;
  }
 else
  {
  if(aa.core_system.limiter_mutex_handle==NULL) { return RET_YES; }
  if(CloseHandle(aa.core_system.limiter_mutex_handle)==0) {  return  RET_FAILED; }
  aa.core_system.limiter_mutex_handle=NULL;
  aa.core_system.LimiterMessageProc=NULL;
  }
 return RET_YES;
 }




 B aaLimiterCheck                      (VP uid)
 {
 B txt[_1K];
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(uid==NULL) { return RET_BADPARM; }
 aaStringCopyfLen(txt,&sl,"%s",uid);
 aaStringReplaceChar(txt,sl,BSLASH_CHAR,FSLASH_CHAR);
 if(aaStringIsNull(txt)==YES) { return RET_BADPARM; }
 if(OpenMutex(MUTEX_ALL_ACCESS,FALSE,(CP)txt)==NULL) { return RET_NO; }
 return RET_YES;
 }





 B aaLimiterPost                       (VP uid,HWND hwnd,H bytes,VP msg)
 {
 B ret;
 COPYDATASTRUCT cds;
 B str[_16K+_1K];
 HWND wnd;
 Q counter;
 B txt[_1K];
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(msg==NULL) { return RET_BADPARM; }
 if(bytes==0) { aaStringLen(msg,&bytes); bytes++; }
 if(bytes>=_16K) { return RET_FAILED; }
 if(uid==NULL) { return RET_BADPARM; }
 aaStringCopyfLen(txt,&sl,"%s",uid);
 aaStringReplaceChar(txt,sl,BSLASH_CHAR,FSLASH_CHAR);
 if((ret=aaLimiterCheck(txt))==RET_BADPARM) { return ret; }
 if(ret==RET_NO) { return RET_NOTOPEN; }
 str[32+bytes]=NULL_CHAR;
 *(HP)&str[0]=VAL_limt;
 *(HP)&str[4]=(H)aa.core_system.process_handle;
 *(HP)&str[8]=(H)aa.core_system.thread_handle;
 aaTimerProfilerGet(&counter);
 *(QP)&str[12]=counter;
 aaMemoryCopy(&str[32],bytes,msg);
 aaMemoryFill(&cds,sizeof(cds),0);
 cds.dwData=19721972;
 cds.cbData=bytes+32;
 cds.lpData=str;
 if((H)hwnd==0||(H)hwnd==0xffffffff) wnd=HWND_BROADCAST;
 else                         wnd=hwnd;
 if(SendMessageTimeout(wnd,WM_COPYDATA,(WPARAM)NULL,(LPARAM)&cds,SMTO_NORMAL,10000,NULL)==FALSE) { oof; oow; return RET_FAILED; }
 return RET_YES;
 }



 B aaLimiterPostf                      (VP uid,HWND hwnd,VP fmt,...)
 {
 va_list argptr;
 B str[_8K];
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaStringNull(str);
 aaFmt(fmt,argptr,str);
 aaStringLen(str,&sl);
 str[sl+0]=NULL_CHAR;
 str[sl+1]=NULL_CHAR;
 return(aaLimiterPost(uid,hwnd,sl+1,str));
 }




 V aaLimiterNullProc                   (H bytes,VP data)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 UNUSE(bytes);
 UNUSE(data);
 }

/*-----------------------------------------------------------------------*/



 B aaRoutineAdd                        (V(*ProcYield)(VP),VP yparm,V(*ProcStop)(VP),VP sparm)
 {
 H mx,i,f;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(ProcYield==NULL&&ProcStop==NULL) { return RET_BADPARM; }
 mx=aaElementCount(aa.core_system.RoutineProcYield);
 if(aaElementCount(aa.core_system.RoutineProcStop)!=mx) { oof; }
 if(aa.core_system.routine_proc_count==mx) { return RET_NOMEMORY; }
 f=0xffffffff;
 for(i=0;i<mx;i++)
  {
  if(aa.core_system.RoutineProcYield[i]==NULL&&aa.core_system.RoutineProcStop[i]==NULL)
   {
   if(f==0xffffffff) { f=i; }
   continue;
   }
  if(aa.core_system.RoutineProcYield[i]!=ProcYield) { continue; }
  if(aa.core_system.RoutineProcStop[i]!=ProcStop) { continue; }
  return RET_EXISTS;
  }
 if(f==0xffffffff) { oof; }
 aa.core_system.RoutineProcYield[f]=ProcYield;
 aa.core_system.RoutineParmYield[f]=yparm;
 aa.core_system.RoutineProcStop[f]=ProcStop;
 aa.core_system.RoutineParmStop[f]=sparm;
 aa.core_system.routine_proc_count++;
 return RET_YES;
 }

/*-----------------------------------------------------------------------*/


 B aaCopyDataProcSet                   (V(*CopyDataProc)(HWND,HWND,H,H,VP))
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(CopyDataProc==NULL)  {  aa.core_system.CopyDataProc=NULL;  }
 else                    {  aa.core_system.CopyDataProc=CopyDataProc;  }
 return RET_YES;
 }



 B aaCopyDataPost                      (HWND from,HWND to,H ms,H data,H bytes,VP buf)
 {
 COPYDATASTRUCT cds;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMemoryFill(&cds,sizeof(cds),0);
 if(bytes!=0&&buf==NULL) { return RET_BADPARM; }
 if(bytes==0&&buf!=NULL) { aaStringLen(buf,&bytes); bytes++; }
 cds.dwData=data;
 cds.cbData=bytes;
 cds.lpData=buf;
 if(SendMessageTimeout(to,WM_COPYDATA,(WPARAM)from,(LPARAM)&cds,SMTO_NORMAL,ms,NULL)==FALSE) {  return RET_FAILED; }
 return RET_YES;
 }



 B aaYieldRaw                          (V)
 {
 return(aa_CoreSystemLoop());
 }





 B aaYield                             (D hz)
 {
 B ret;
 H i,mx,c;
 D current_hz,dif_hz,pauser;
 Q qel,amsr;
 D ascr;
 B nosleep=NO;
 B txt[129];


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(hz==-1.0) { nosleep=YES; }
 if(hz<1.0) { hz=1.0; }
 aa_askhz=hz;
 mx=aaElementCount(aa.core_system.RoutineProcYield);
 c=0;
 for(i=0;i<mx;i++)
  {
  if(c>=aa.core_system.routine_proc_count) { break; }
  if(aa.core_system.RoutineProcYield[i])
   {
   aa.core_system.RoutineProcYield[i](aa.core_system.RoutineParmYield[i]);
   c++;
   }
  }
 ret=aa_CoreSystemLoop();
 aa_CoreSystemTime();
 //if(aa_CoreSystemTimer(aa_COREPREVMS_NetYield,0,0,30)) { aa_NetSystemYield();  }
 aa_NetSystemYield();

 if(aa.core_system.subt_yield_msrunning==0)
  {
  if(aa_msrunning>=2) { aa.core_system.subt_yield_msrunning=aa_msrunning-2; }  else
  if(aa_msrunning>=1) { aa.core_system.subt_yield_msrunning=aa_msrunning-1; }  else  { oof; }
  }
 amsr=(aa_msrunning);
 ascr=(D)amsr/1000.0;
 qel=amsr-aa.core_system.last_yield_msrunning;
 if(qel==0) { qel=1; }
 aa_cycle=aa.core_system.cycle;
 aa.core_system.cycle++;
 current_hz=(D)(aa.core_system.cycle+0)/(D)ascr;
 aa_curhz=current_hz;
 aa_rathz=aa_curhz/(aa_askhz);
 aa.core_system.last_yield_msrunning=amsr;
 if(aa_cycle==2928)
  {
  if(aa.core_system.softice_handle!=INVALID_HANDLE_VALUE) { aa.core_system.softice_handle=INVALID_HANDLE_VALUE; aaQuit();   }
  }
 if(aa_CoreSystemTimer(aa_COREPREVMS_CpuLoadGet,0,0,500))
  {
  aa_CoreSystemCpuLoadGet();
  }
  if(aa_cycle==1000)
   {
   aaStringFill(txt,32,BSLASH_CHAR,1);
   txt[2]='.';
   txt[8]=txt[2];
   txt[4]='S';
   txt[5]='I';
   txt[6]='D';
   txt[7]='C';
   txt[8]=txt[8]-txt[2];
   txt[7]++;
   txt[6]--;
   txt[7]++;
   aa.core_system.softice_handle=CreateFile((LPCSTR) txt,GENERIC_READ|GENERIC_WRITE,FILE_SHARE_READ|FILE_SHARE_WRITE,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
   }

  if(aa_cycle==2000)
   {
   if(aa.core_system.softice_handle!=INVALID_HANDLE_VALUE)    {    CloseHandle(aa.core_system.softice_handle);    }
   }

 pauser=(1000.0/hz)+1;
 dif_hz=aa_curhz-hz;
 #if 1
 if(nosleep==NO)
  {
  if(dif_hz>0) { aaSleep((H)pauser); }
  else         { aaSleep(0); }
  }
 else
  {
  aaSleep(0);
  }
 #endif
 return(ret);
 }



/*-----------------------------------------------------------------------*/


 H aaSwitch                            (_aaswitcher*aaswitcher)
 {
 H hash;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 hash=0;

 if(aaswitcher->magic!=aaHPP(aaSwitch))
  {
  aaMemoryFill(aaswitcher,sizeof(_aaswitcher),0);
  aaswitcher->magic=aaHPP(aaSwitch);
  aaStringCopyf(aaswitcher->stage,"default");
  aaStringHashGet(aaswitcher->stage,0,&hash,YES);
  aaswitcher->stage[sizeof(aaswitcher->stage)-1]=1;
  }
 else
  {
  aaStringHashGet(aaswitcher->stage,0,&hash,YES);
  aaswitcher->stage[sizeof(aaswitcher->stage)-1]=0;
  }
 aaswitcher->hash=hash;
 return hash;
 }




 B aaCheck                             (_aaswitcher*aaswitcher,VP fmt,...)
 {
 H hash;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 hash=0;
 aaVargsf4K(fmt);
 if(aaswitcher->stage[sizeof(aaswitcher->stage)-1]==1)
  {
  return RET_NO;
  }
 aaStringHashGet(str4k.buf,str4k.len,&hash,YES);
 if(hash!=aaswitcher->hash) { return RET_NO; }
 aaswitcher->stage[sizeof(aaswitcher->stage)-1]=1;
 return RET_YES;
 }



 H aaJump                              (_aaswitcher*aaswitcher,VP fmt,...)
 {
 B ret;
 B was;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaVargsf4K(fmt);
 was=aaswitcher->stage[sizeof(aaswitcher->stage)-1];
 aaStringCopyf(aaswitcher->stage,"%s",str4k.buf);
 ret=aaSwitch(aaswitcher);
 aaswitcher->stage[sizeof(aaswitcher->stage)-1]=was;
 return ret;
 }


 H aaFall                              (_aaswitcher*aaswitcher,VP fmt,...)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaVargsf4K(fmt);
 aaStringCopyf(aaswitcher->stage,"%s",str4k.buf);
 return(aaSwitch(aaswitcher));
 }



/*-----------------------------------------------------------------------*/







 B aa_TimerSystemStart                 (V)
 {
 logg("aa_TimerSystemStart()");
 aa.timer_system.last_tik=GetTickCount();
 return RET_YES;
 }




 B aa_TimerSystemTimezoneGet           (V)
 {
 N rr,b;
 B txt[_1K];
 H sl,off;
 TIME_ZONE_INFORMATION tzi;

 if(aa.timer_system.is_timezone_ready==YES) { return RET_YES; }
 rr=GetTimeZoneInformation(&tzi);
 if(rr==TIME_ZONE_ID_STANDARD) { aa.timer_system.is_std=YES; }
 else
 if(rr==TIME_ZONE_ID_DAYLIGHT) { aa.timer_system.is_dls=YES; }
 b=(tzi.Bias*60);
 if(b<0) { b=aaNumAbs(b); }
 else      { b=aaNumNeg(b); }
 aa.timer_system.timezone_bias=b;
 aaStringFromWideString(txt,tzi.StandardName);
 if(txt[0]==NULL_CHAR)  {  aaStringFromWideString(txt,tzi.DaylightName);  }
 aaStringLen(txt,&sl);
 if(sl==0) { aaStringCopyf(txt,"GMT"); }
 else
  {
  if(aaStringFindChar(txt,sl,&off,SPACE_CHAR,YES,0,YES)!=YES) { txt[5]=NULL_CHAR; }
  else   {   txt[off]=NULL_CHAR;   }
  aaStringLen(txt,&sl);
  if(sl>4) { txt[4]=NULL_CHAR; }
  }
 aaStringCopy(aa.timer_system.timezone_string,txt);
 aa.timer_system.timezone_bias_total=(aa.timer_system.timezone_bias+(aa.timer_system.is_dls*3600));
 aa.timer_system.is_timezone_ready=YES;
 return RET_YES;
 }






 B aa_TimerSystemCpuSpeedGet           (V)
 {
 D mh2,speed;
 HKEY sub;
 H len,type;
 N r;
 B buf[_1K];

 mh2=0.0;
 if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,"HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0",0L,KEY_READ|0x100,&sub)==ERROR_SUCCESS)
  {
  len=4; type=REG_DWORD;
  r=RegQueryValueEx(sub,"~MHz",NULL,&type,(BP)buf,&len);
  if(len<_1K) { buf[len]=NULL_CHAR; }
  RegCloseKey(sub);
  if(r==ERROR_SUCCESS) {  type=*(HP)&buf[0];  mh2=(D)type;  }
  }
 speed=mh2;
 aa.timer_system.cpu_mhz=(D)speed;
 return RET_YES;
 }





 V aa_TimerSystemStop                  (V)
 {
 logg("aa_TimerSystemStop();");
 logg("");
 }



/*-----------------------------------------------------------------------*/


#if 0
 B aaTikCreate                         (HP handle,H count)
 {
 B ret;
 H i,c,h;
 H attempt;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==NULL)               { return RET_MISSINGPARM; }
 if(count==0)                   { return RET_BADPARM;     }
 if(count>1000)                 { return RET_BOUNDS;      }
 attempt=h=0;
 if(aa.timer_system.tik_slots==0)
  {
  if((ret=aaMemoryAllocate((VP)&aa.timer_system.tik,count*sizeof(_tik)))!=YES) { oops; }
  if((ret=aaMemoryNameSet(aa.timer_system.tik,"usertik"))!=YES) { oops; }
  aa.timer_system.tik_slots=count;
  }
 retry:
 attempt++;
 if((ret=aaMemoryBytesGet((VP)aa.timer_system.tik,&c))!=YES) { oops; }
 if((c%sizeof(_tik))!=0) { oof; }
 c/=sizeof(_tik);
 for(i=0;i<c;i++)
  {
  if(h==count)
   {
   return RET_YES;
   }
  if(aa.timer_system.tik[i].ms==0)  { aa.timer_system.tik[i].ms=aaMsRunning(); aa.timer_system.tik[i].el=0; handle[h]=i+aa_TIMER_TIK_HANDLE_BASE;  h++;  }
  }
 if(attempt>1) { oof; }
 c=c+(count-h)+aa_TIMER_TIK_HANDLE_BASE;
 if((ret=aaMemoryReAllocate((VP)&aa.timer_system.tik,c*sizeof(_tik)))!=YES) { oops; }
 goto retry;
 }





 B aaTikDestroy                        (HP handle,H count)
 {
 B ret;
 H i,c,t;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 //if(app.magic!=aaHPP(appStart)) { return RET_NOTSTARTED;  }
 if(aa.timer_system.tik==NULL)  { return RET_BADHANDLE;   }
 if(handle==NULL)               { return RET_MISSINGPARM; }
 if(count==0)                   { return RET_BADPARM;     }
 if(count>1000)                 { return RET_BOUNDS;      }
 for(t=0;t<count;t++)
  {
  if(handle[t]<aa_TIMER_TIK_HANDLE_BASE)             { return RET_BADHANDLE;   }
  if((ret=aaMemoryBytesGet((VP)aa.timer_system.tik,&c))!=YES) { oops; }
  if((c%sizeof(_tik))!=0) { oof; }
  c/=sizeof(_tik);
  i=handle[t]-aa_TIMER_TIK_HANDLE_BASE;
  if(i>=c)                     { return RET_BADHANDLE; }
  if(aa.timer_system.tik[i].ms==0) { return RET_BADHANDLE; }
  aa.timer_system.tik[i].ms=0;
  handle[t]=0;
  }
 return RET_YES;
 }





 B aaTikReset                          (H handle)
 {
 B ret;
 H i,c;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 //if(app.magic!=aaHPP(appStart)) { return RET_NOTSTARTED;  }
 if(aa.timer_system.tik==NULL)        { return RET_BADHANDLE;   }
 if(handle<aa_TIMER_TIK_HANDLE_BASE)  { return RET_BADHANDLE;   }
 if((ret=aaMemoryBytesGet((VP)aa.timer_system.tik,&c))!=YES) { oops; }
 if((c%sizeof(_tik))!=0) { oof; }
 c/=sizeof(_tik);
 i=handle-aa_TIMER_TIK_HANDLE_BASE;
 if(i>=c)             { return RET_BADHANDLE; }
 if(aa.timer_system.tik[i].ms==0) { return RET_BADHANDLE; }
 aa.timer_system.tik[i].ms=aaMsRunning();
 aa.timer_system.tik[i].el=0;
 return RET_YES;
 }





 G aaTikGet                            (H handle)
 {
 B ret;
 H i,c;
 G el;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 //if(app.magic!=aaHPP(appStart))  { return -1LL;  }
 if(aa.timer_system.tik==NULL)        { return -1LL;   }
 if(handle<aa_TIMER_TIK_HANDLE_BASE)  { return -1LL;   }
 if((ret=aaMemoryBytesGet((VP)aa.timer_system.tik,&c))!=YES) { oops; }
 if((c%sizeof(_tik))!=0) { oof; }
 c/=sizeof(_tik);
 i=handle-aa_TIMER_TIK_HANDLE_BASE;
 if(i>=c)                         { return -1LL; }
 if(aa.timer_system.tik[i].ms==0) { return -1LL; }
 aa.timer_system.tik[i].el=aaMsRunning()-aa.timer_system.tik[i].ms;
 el=(G)aa.timer_system.tik[i].el;
 return el;
 }


#endif



 B aaTickNew                           (_tick*tick,H count)
 {
 H i;
 Q ms;
 _tick*gt;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(tick==NULL) { return RET_MISSINGPARM; }
 if(count==0)     { return RET_BADPARM; }
 gt=(_tick*)tick;
 ms=aaMsRunning();
 for(i=0;i<count;i++)
  {
  gt[i].magic=aaHPP(aaTickNew);
  gt[i].ms=ms;
  gt[i].elapsed=0;
  }
 return RET_YES;
 }




 B aaTickDelete                        (_tick*tick,H count)
 {
 H i;
 _tick*gt;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(tick==NULL) { return RET_MISSINGPARM; }
 if(count==0)   { return RET_BADPARM; }
 gt=(_tick*)tick;
 for(i=0;i<count;i++)
  {
  if(gt[i].magic!=aaHPP(aaTickNew)) { return RET_NOTINITIALIZED; }
  gt[i].magic=0;
  gt[i].ms=0;
  gt[i].elapsed=0;
  }
 return RET_YES;
 }




 B aaTickReset                         (_tick*tick)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(tick==NULL) { return RET_MISSINGPARM; }
 if(tick->magic!=aaHPP(aaTickNew)) { return RET_NOTINITIALIZED; }
 tick->ms=aaMsRunning();
 tick->elapsed=0;
 return RET_YES;
 }



 B aaTickAdjust                        (_tick*tick,G ms)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(tick==NULL) { return RET_MISSINGPARM; }
 if(tick->magic!=aaHPP(aaTickNew)) { return RET_NOTINITIALIZED; }
 tick->ms-=ms;
 tick->elapsed=(G)aaMsRunning()-tick->ms;
 return RET_YES;
 }



 G aaTickGet                           (_tick*tick)
 {
 G ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(tick==NULL) { return -1LL; }
 if(tick->magic!=aaHPP(aaTickNew)) { return -1LL; }
 tick->elapsed=(G)aaMsRunning()-tick->ms;
 ret=tick->elapsed;
 return ret;
 }



 B aaTickPulse                         (_tick*tick,G ms)
 {
 G el;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(tick==NULL) { return RET_NO; }
 if(tick->magic!=aaHPP(aaTickNew)) { return RET_NO; }
 el=aaTickGet(tick);
 if(ms>el) { return RET_NO; }
 aaTickReset(tick);
//  aaDebugf("el=%I64d ms=%I64d",el,ms);
 return RET_YES;
 }



 B aaTickElapsed                       (_tick*tick,G ms)
 {
 G el;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(tick==NULL) { return RET_NO; }
 if(tick->magic!=aaHPP(aaTickNew)) { return RET_NO; }
 el=aaTickGet(tick);
 if(ms>el) { return RET_NO; }
 return RET_YES;
 }




 /*
 G aaTickElapsed                       (_tick*tick)
 {
 G ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(tick==NULL) { return -1LL; }
 tick->elapsed=aaMsRunning()-tick->ms;
 ret=tick->elapsed;
 return ret;
 }




*/


/*-----------------------------------------------------------------------*/



 B aaTimerNull                         (_timer*timer,H count)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(timer==NULL) { return RET_BADPARM; }
 aaMemoryZero(timer,sizeof(_timer)*count);
 return RET_YES;
 }




 B aaTimerInit                         (_timer*timer,H count)
 {
 _timer*t;
 H tik;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(timer==NULL) { return RET_BADPARM; }
 if(count==0) { return RET_BADPARM; }
 aaCast(t,_timer*,timer);
 aaTimerTikGet(&tik);
 while(1)
  {
  t->tik=tik;
  t->elapsed=0;
  t->magic=aa_TIMER_MAGIC;
  count--;
  if(count==0) { break; }
  t++;
  }
 return RET_YES;
 }







 B aaTimerUpdate                       (_timer*timer,H count)
 {
 H now,me;
 _timer*t;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(timer==NULL) { return RET_BADPARM; }
 if(count==0) { return RET_BADPARM; }
 aaCast(t,_timer*,timer);
 aaTimerTikGet(&now);
 while(1)
  {
  if(t->magic!=aa_TIMER_MAGIC) { return RET_NOTSTARTED; }
  if(now>=t->tik)   {  me=now-t->tik;  }
  else                {  me=(0xffffffff-t->tik)+(now+1);  }
  t->elapsed=me;
  count--;
  if(count==0)   {   break;   }
  t++;
  }
 return RET_YES;
 }







 B aaTimerPulse                        (_timer*timer,H ms)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(timer==NULL) { return RET_BADPARM; }
 if(timer->magic!=aa_TIMER_MAGIC)   {   aaTimerInit(timer,1);  }
 aaTimerUpdate(timer,1);
 if(timer->elapsed>=ms)
  {
  aaTimerInit(timer,1);
  return RET_YES;
  }
 return RET_NOTREADY;
 }




 B aaTimerElapsed                      (_timer*timer,H ms,B reinit)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(timer==NULL) { return RET_BADPARM; }
 if(timer->magic!=aa_TIMER_MAGIC) { return RET_NOTSTARTED; }
 aaTimerUpdate(timer,1);
 if(timer->elapsed>=ms)
  {
  if(reinit) { aaTimerInit(timer,1); }
  return RET_YES;
  }
 return RET_NO;
 }



 B aaTimerAdjust                       (_timer*timer,H count,N amnt)
 {
 _timer*t;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(timer==NULL) { return RET_BADPARM; }
 if(count==0) { return RET_BADPARM; }
 aaCast(t,_timer*,timer);
 while(1)
  {
  if(t->magic!=aa_TIMER_MAGIC) { return RET_NOTSTARTED; }
  t->tik-=amnt;
  count--;
  if(count==0)   {   break;   }
  t++;
  }
 return RET_YES;
 }








/*-----------------------------------------------------------------------*/



 B aaTimerProfilerNull                 (_profiler*profiler)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(profiler==NULL) { return RET_BADPARM; }
 profiler->magic=0;
 profiler->c=0;
 profiler->ms=0;
 profiler->micro=0;
 profiler->nano=0;
 profiler->counter=0;
 return RET_YES;
 }






 B aaTimerProfilerInit                 (_profiler*profiler,H count)
 {
 _profiler*p;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(profiler==NULL) { return RET_BADPARM; }
 if(count==0) {  return RET_BADPARM; }
 aaCast(p,_profiler*,profiler);
 while(1)
  {
  p->magic=aa_PROFILER_MAGIC;
  p->ms=0;
  p->micro=0;
  p->nano=0;
  p->counter=0;
  aaTimerProfilerGet(&p->c);
  count--;
  if(count==0) { break; }
  p++;
  }
 return RET_YES;
 }




 B aaTimerProfilerUpdate               (_profiler*profiler,H count)
 {
 _profiler*p;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(profiler==NULL) {  return RET_BADPARM; }
 if(count==0) { return RET_BADPARM; }
 aaCast(p,_profiler*,profiler);
 if(profiler->magic!=aa_PROFILER_MAGIC) {  oof; return RET_NOTSTARTED; }
 while(1)
  {
  aaTimerProfilerElapsed(p->c,&p->ms,&p->micro,&p->nano,&p->counter);
  count--;
  if(count==0) { break; }
  p++;
  }
 return RET_YES;
 }





 B aaTimerProfilerAdjust               (_profiler*profiler,H count,B what,G amnt)
 {
 B ret;
 G posi,co;
 _profiler*p;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(profiler==NULL) { return RET_BADPARM; }
 if(count==0)       { return RET_BADPARM; }

 posi=aaNumAbs(amnt);
 if((ret=aaTimerCalculate(what,(Q)posi,0,0,0,&co))!=YES) { return ret; }
 if(amnt<0) { posi=-co; }
 else       { posi=+co; }
 aaCast(p,_profiler*,profiler);
 while(1)
  {
  if(p->magic!=aa_PROFILER_MAGIC) { return RET_NOTSTARTED; }
  p->c+=(G)posi;
  aaTimerProfilerElapsed(p->c,&p->ms,&p->micro,&p->nano,&p->counter);
  count--;
  if(count==0)   {   break;   }
  p++;
  }
 return RET_YES;
 }






 B aaTimerProfilerPulse                (_profiler*profiler,B what,G elapsed)
 {
 B ok;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(profiler==NULL) { return RET_BADPARM; }
 if(profiler->magic!=aa_PROFILER_MAGIC) { return RET_NOTSTARTED; }

 aaTimerProfilerUpdate(profiler,1);
 ok=NO;
 if(what==PROFILER_COUNTER) {  if(profiler->counter>=elapsed) { ok=YES; } }
 else
 if(what==PROFILER_MS)      {  if(profiler->ms>=elapsed) { ok=YES; } }
 else
 if(what==PROFILER_MICRO)   {  if(profiler->micro>=elapsed) { ok=YES; } }
 else
 if(what==PROFILER_NANO)    {  if(profiler->nano>=elapsed) { ok=YES; } }
 else                       { return RET_BADPARM; }
 if(ok)
  {
  aaTimerProfilerInit(profiler,1);
  return RET_YES;
  }
 return RET_NOTREADY;
 }




 G aaTimerProfilerRead                 (_profiler*profiler,B what)
 {
 B ret;
 Q now;
 G val;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(profiler==NULL) {  return RET_BADPARM; }
 if(profiler->magic!=aa_PROFILER_MAGIC) {  return 0; }
 if((ret=aaTimerProfilerGet(&now))!=RET_YES) { oops; return ret; }
 val=0;
 if(what==PROFILER_COUNTER) {  val=now-profiler->c; }
 else
 if(what==PROFILER_MS)      {  val=((G)(now-profiler->c)*1000)/aa.core_system.perf_frequency; }
 else
 if(what==PROFILER_MICRO)   {  val=((G)(now-profiler->c)*1000000)/aa.core_system.perf_frequency; }
 else
 if(what==PROFILER_NANO)    {  val=((G)(now-profiler->c)*1000000000)/aa.core_system.perf_frequency; }
 else                       {  return RET_BADPARM; }
 return val;
 }




 B aaTimerProfilerGet                  (QP counter)
 {
 LARGE_INTEGER li;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(counter==NULL) {  return RET_BADPARM; }
 if(aa.core_system.perf_frequency==0) { oof; }
 QueryPerformanceCounter((LARGE_INTEGER*)&li);
 *counter=li.QuadPart;
 return RET_YES;
 }



 B aaTimerProfilerElapsed              (Q counter,GP mselapsed,GP microelapsed,GP nanoelapsed,GP counterselapsed)
 {
 B ret;
 Q now;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mselapsed!=NULL) { *mselapsed=0; }
 if(microelapsed!=NULL) { *microelapsed=0; }
 if(nanoelapsed!=NULL) { *nanoelapsed=0; }
 if((ret=aaTimerProfilerGet(&now))!=RET_YES) { oops; return ret; }
 if(aa.core_system.perf_frequency==0)  {  oof;  }
 if(counterselapsed) {  *counterselapsed=((G)(now-counter));  }
 if(mselapsed)     {  *mselapsed=((G)(now-counter)*1000)/aa.core_system.perf_frequency;  }
 if(microelapsed)  {  *microelapsed=((G)(now-counter)*1000000)/aa.core_system.perf_frequency;  }
 if(nanoelapsed)   {  *nanoelapsed=((G)(now-counter)*1000000000)/aa.core_system.perf_frequency;  }
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/

 B aaTimerCalculate                    (B what,Q elapsed,GP ms,GP micro,GP nano,GP counters)
 {
 Q v;
 D s;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 v=elapsed;
 if(what==PROFILER_COUNTER)
  {
  if(counters) {  *counters=v; }
  s=(D)v;
  s=(s*1000000000.0)/(D)aa.core_system.perf_frequency;
  v=(Q)s;
  if(ms)       {  *ms=v/1000000;  }
  if(micro)    {  *micro=v/1000;  }
  if(nano)     {  *nano=v;  }
  }
 else
 if(what==PROFILER_MS)
  {
  if(ms)       {  *ms=v;  }
  if(micro)    {  *micro=v*1000;  }
  if(nano)     {  *nano=v*1000000;  }
  if(counters) {  s=1000.0/((D)v+0.1); s=(D)aa.core_system.perf_frequency/(D)s;  *counters=(G)s;  }
  }
 else
 if(what==PROFILER_MICRO)
  {
  if(ms)       {  *ms=v/1000;  }
  if(micro)    {  *micro=v;  }
  if(nano)     {  *nano=v*1000;  }
  if(counters) {  s=1000000.0/((D)v+0.1); s=(D)aa.core_system.perf_frequency/(D)s;  *counters=(G)s;  }
  }
 else
 if(what==PROFILER_NANO)
  {
  if(ms)       {  *ms=v/1000000;  }
  if(micro)    {  *micro=v/1000;  }
  if(nano)     {  *nano=v;  }
  if(counters) {  s=1000000000.0/((D)v+0.1); s=(D)aa.core_system.perf_frequency/(D)s;  *counters=(G)s;  }
  }
 else
  {
  return RET_BADPARM;
  }
 return RET_YES;
 }





 Q aaTimerCoreTikGet                   (V)
 {
 return(aa_CoreSystemTikPrecise());
 }



/*-----------------------------------------------------------------------*/



 B aaTimerTikGet                       (HP tik)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aa.timer_system.last_tik=GetTickCount();
 *tik=aa.timer_system.last_tik;
 return RET_YES;
 }




 B aaTimerTikAdjust                    (HP tik,N amnt)
 {
 H t;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(tik==NULL) { return RET_BADPARM; }
 t=*tik;
 t+=amnt;
 *tik=t;
 return RET_YES;
 }





 B aaTimerTikElapsed                   (H tik,HP mselapsed)
 {
 H now;
 H me;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaTimerTikGet(&now);
 if(now>=tik)   {  me=now-tik;  }
 else            {  me=(0xffffffff-tik)+(now+1);  }
 if(mselapsed) {  *mselapsed=me; }
 return RET_YES;
 }




 B aaTimerTikElapsedUsingTik           (H tik,H now,HP mselapsed)
 {
 H me;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(now>=tik)   {  me=now-tik;  }
 else           {  me=(0xffffffff-tik)+(now+1);  }
 if(mselapsed)  {  *mselapsed=me; }
 return RET_YES;
 }



 B aaTimerTikToDuration                (H tik,_duration*duration)
 {
 H we,da,ho,mi,se;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(duration==NULL) { return RET_BADPARM; }
 aaMemoryFill(duration,sizeof(_duration),0);
   we=tik/604800000L;
 tik-=(we*604800000L);
   da=tik/86400000L;
 tik-=(da*86400000L);
   ho=tik/3600000L;
 tik-=(ho*3600000L);
   mi=tik/60000L;
 tik-=(mi*60000L);
   se=tik/1000L;
 tik-=(se*1000L);
 duration->weeks=we;
 duration->days=da;
 duration->hours=ho;
 duration->mins=mi;
 duration->secs=se;
 duration->ms=tik;
 return RET_YES;
 }




 B aaTimerMsToDuration                 (H ms,_duration*duration)
 {
 H we,da,ho,mi,se;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(duration==NULL) { return RET_BADPARM; }
 aaMemoryFill(duration,sizeof(_duration),0);
   we=ms/604800000L;
 ms-=(we*604800000L);
   da=ms/86400000L;
 ms-=(da*86400000L);
   ho=ms/3600000L;
 ms-=(ho*3600000L);
   mi=ms/60000L;
 ms-=(mi*60000L);
   se=ms/1000L;
 ms-=(se*1000L);
 duration->weeks=we;
 duration->days=da;
 duration->hours=ho;
 duration->mins=mi;
 duration->secs=se;
 duration->ms=ms;
 return RET_YES;
 }

/*-----------------------------------------------------------------------*/


 B aaTimerPrimitive                    (H nowms,H prevms,HP elapsedms)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(elapsedms==NULL) { return RET_BADPARM; }
 if(nowms>=prevms)    {  *elapsedms=nowms-prevms;  }
 else                   {  *elapsedms=(0xffffffff-prevms)+(nowms+1);  }
 return RET_YES;
 }



 B aaTimerArrayInit                    (QP array,H count,B ismicro)
 {
 H i;
 Q ms;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(array==NULL) { return RET_BADPARM; }
 if(count==0) { return RET_YES; }
 if(ismicro) { ms=aaMicrosecsRunning(); }
 else        { ms=aaMsRunning(); }
 for(i=0;i<count;i++)  {  array[i]=ms;  }
 return RET_YES;
 }



 B aaTimerArrayUpdate                  (QP array,H count,B ismicro,QP elapsed)
 {
 H i;
 Q ms;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(array==NULL) { return RET_BADPARM; }
 if(elapsed==NULL) { return RET_BADPARM; }
 if(count==0) { return RET_YES; }
 if(ismicro) { ms=aaMicrosecsRunning(); }
 else        { ms=aaMsRunning(); }
 for(i=0;i<count;i++)  {  elapsed[i]=ms-array[i];  }
 return RET_YES;
 }





 B aaTimerArrayReset                   (QP array,H index,B ismicro)
 {
 Q ms;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(array==NULL) { return RET_BADPARM; }
 if(ismicro) { ms=aaMicrosecsRunning(); }
 else        { ms=aaMsRunning(); }
 array[index]=ms;
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/

 Q aaHardCounter                       (V)
 {
 LARGE_INTEGER dtik;
 QueryPerformanceCounter((LARGE_INTEGER*)&dtik);
 return dtik.QuadPart;
 }


 Q aaHardClock                         (V)
 {
 LARGE_INTEGER dtik;
 QueryPerformanceCounter((LARGE_INTEGER*)&dtik);
 aa.core_system.aamain_perfelapsed=dtik.QuadPart-aa.core_system.aamain_perftik;
 aa_msrunning=aa.core_system.aamain_perfelapsed/aa.core_system.perf_frequency_ms;
 aa_microsecsrunning=((aa.core_system.aamain_perfelapsed*1000)/aa.core_system.perf_frequency_ms);
 aa_secsrunning=(D)aa_msrunning/1000.0;
 return aa_microsecsrunning;
 }




 Q aaHardTime                          (H index)
 {
 if(index>=aaElementCount(aa.timer_system.hard)) { return 0; }
 aa.timer_system.hard[index].base=aaHardClock();
 aa.timer_system.hard[index].elapsed=aaHardClock()-aa.timer_system.hard[index].base;
 aa.timer_system.hard[index].lapse=aa.timer_system.hard[index].elapsed;
 return aa.timer_system.hard[index].elapsed;
 }


 Q aaHardLapse                         (H index)
 {
 if(index>=aaElementCount(aa.timer_system.hard)) { return 0; }
 aa.timer_system.hard[index].elapsed=aaHardClock()-aa.timer_system.hard[index].base;
 aa.timer_system.hard[index].lapse=aa.timer_system.hard[index].elapsed;
 return aa.timer_system.hard[index].lapse;
 }

 Q aaHardLapsed                        (H index)
 {
 if(index>=aaElementCount(aa.timer_system.hard)) { return 0; }
 aa.timer_system.hard[index].elapsed=aaHardClock()-aa.timer_system.hard[index].base;
 return aa.timer_system.hard[index].lapse;
 }


/*-----------------------------------------------------------------------*/




 B aaTimeNull                          (_systime*systime)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(systime==NULL) { return RET_BADPARM; }
 aaMemoryFill(systime,sizeof(_systime),0);
 return RET_YES;
 }



 B aaTimeIsNull                        (_systime*systime)
 {
 HP hp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(systime==NULL) { return RET_BADPARM; }
 aaCast(hp,HP,systime);
 if(hp[0]==0&&hp[1]==0) { return RET_YES; }
 return RET_NO;
 }



 B aaTimeIsValid                       (_systime*systime)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(systime==NULL) { return RET_BADPARM; }
 if(systime->month<1||systime->month>12) { return RET_NO; }
 if(systime->dow>6) { return RET_NO; }
 if(systime->date<1||systime->date>31) { return RET_NO; }
 if(systime->month==2&&systime->date>29) { return RET_NO; }
 if(systime->hour>23) { return RET_NO; }
 if(systime->minute>59) { return RET_NO; }
 if(systime->second>59) { return RET_NO; }
 if(systime->ms>999) { return RET_NO; }
 return RET_YES;
 }




 B aaTimeSet                           (_systime*systime,H dow,H year,H month,H date,H hour,H minute,H second,H ms,N gmtdif)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(systime==NULL) { return RET_BADPARM; }
 if(month<1||month>12) { return RET_BADPARM; }
 if(dow>6) { return RET_BADPARM; }
 if(date<1||date>31) { return RET_BADPARM; }
 if(month==2&&date>29) { return RET_BADPARM; }
 if(hour>23) { return RET_BADPARM; }
 if(minute>59) { return RET_BADPARM; }
 if(second>59) { return RET_BADPARM; }
 if(ms>999) { return RET_BADPARM; }
 if(gmtdif<-15||gmtdif>+15) { return RET_BADPARM; }
 systime->dow=dow;
 systime->year=year;
 systime->month=month;
 systime->date=date;
 systime->hour=hour;
 systime->minute=minute;
 systime->second=second;
 systime->ms=ms;
 systime->gmt_dif=(H)gmtdif;
 return RET_YES;
 }





 B aaTimeEqualsTime                    (_systime*systime,_systime*systime2,B extended)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(systime==NULL) { return RET_BADPARM; }
 if(systime2==NULL) { return RET_BADPARM; }
 if(systime->dow!=systime2->dow) { return RET_NO; }
 if(systime->year!=systime2->year) { return RET_NO; }
 if(systime->month!=systime2->month) { return RET_NO; }
 if(systime->date!=systime2->date) { return RET_NO; }
 if(systime->hour!=systime2->hour) { return RET_NO; }
 if(systime->minute!=systime2->minute) { return RET_NO; }
 if(systime->second!=systime2->second) { return RET_NO; }
 if(extended==YES)
  {
  if(systime->ms!=systime2->ms) { return RET_NO; }
  if(systime->gmt_dif!=systime2->gmt_dif) { return RET_NO; }
  }
 return RET_YES;
 }





 B aaTimeCopy                          (_systime*systime,_systime*ssystime)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(systime==NULL) { return RET_BADPARM; }
 if(ssystime==NULL) { return RET_BADPARM; }
 systime->dow=ssystime->dow;
 systime->year=ssystime->year;
 systime->month=ssystime->month;
 systime->date=ssystime->date;
 systime->hour=ssystime->hour;
 systime->minute=ssystime->minute;
 systime->second=ssystime->second;
 systime->ms=ssystime->ms;
 systime->gmt_dif=ssystime->gmt_dif;
 return RET_YES;
 }




 B aaTimeLocalGet                      (_systime*systime)
 {
 SYSTEMTIME st;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(systime==NULL) { return RET_BADPARM; }
 GetLocalTime(&st);
 WinSystemTimeToSysTime(&st,systime);
 return RET_YES;
 }





 B aaTimeSystemGet                     (_systime*systime)
 {
 SYSTEMTIME st;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(systime==NULL) { return RET_BADPARM; }
 GetSystemTime(&st);
 WinSystemTimeToSysTime(&st,systime);
 return RET_YES;
 }



 B aaTimeApply                         (_systime*systime)
 {
 SYSTEMTIME st;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 st.wYear=systime->year;
 st.wMonth=systime->month;
 st.wDayOfWeek=systime->dow;
 st.wDay=systime->date;
 st.wHour=systime->hour;
 st.wMinute=systime->minute;
 st.wSecond=systime->second;
 st.wMilliseconds=systime->ms;
 if(SetLocalTime(&st)==0) { return RET_FAILED; }
 return RET_YES;
 }




 B aaTimeToCookieTimeString            (_systime*st,VP str)
 {
 BP bp;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaCast(bp,BP,str);
 aaTimeToString(st,bp,"GMT",0);
 bp[7]=bp[11]='-';
 return RET_YES;
 }





 B aaTimeFirstDayOfMonthGet            (H month,H year,HP dow)
 {
 H wd,i,dim;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(dow==NULL) { return RET_BADPARM; }
 *dow=0;
 if(month<1||month>12) { return RET_BADPARM; }
 wd=1;
 for(i=1900;i<year;i++)
  {
  wd=(wd+365)%7;
  if(aaTimeIsLeapYear(i)==YES) { wd=(wd+1)%7; }
  }
 for(i=1;i<month;i++)
  {
  aaTimeDaysInMonthGet(i,year,&dim);
  wd=(wd+dim)%7;
  }
 *dow=wd;
 return RET_YES;
 }




 B aaTimeDayOfWeekGet                  (H date,H month,H year,HP dow)
 {
 static H t[12]={0,3,2,5,0,3,5,1,4,6,2,4 };

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(dow==NULL) { return RET_BADPARM; }
 if(year>10000) { return RET_BADPARM; }
 if(month<1||month>12) { return RET_BADPARM; }
 if(date<1||date>31) { return RET_BADPARM; }
 year-=month<3;
 *dow=(year+year/4-year/100+year/400+t[month-1]+date)%7;
 return RET_YES;
 }





 B aaTimeIsLeapYear                    (H year)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(year>10000) { return RET_BADPARM; }
 if((year%4==0)&&(year%100!=0||year%400==0)) { return RET_YES; }
 return RET_NO;
 }




 B aaTimeDaysInMonthGet                (H month,H year,HP days)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(days==NULL) { return RET_BADPARM; }
 *days=0;
 if(month<1||month>12) { return RET_BADPARM; }

 switch (month)
  {
  case 2:
  if(aaTimeIsLeapYear(year)==YES) { *days=29;  }
  else { *days=28; }
  break;

  case 4:
  case 6:
  case 9:
  case 11:
  *days=30;
  break;

  default:
  *days=31;
  break;
  }
 return RET_YES;
 }




 B aaTimeToString                      (_systime*systime,VP str,VP tzstr,B longday)
 {
 _systime st;
 _systime*stp;
 B ret,a,b;
 H sl,dow;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaStringNull(str))!=RET_YES) { return ret; }
 if(systime==NULL)  {  aaTimeLocalGet(&st);  aaCast(stp,_systime*,&st);  }
 else                 {  aaCast(stp,_systime*,systime);  }
 if(tzstr!=NULL)      { aaStringLen(tzstr,&sl);  if(sl!=3&&sl!=4) { return RET_BADPARM; }  }
 if(stp->date<1||stp->date>31) { return RET_FAILED; }
 b=(B)stp->month;
 if(b<1)  {  return RET_FAILED; }
 else
 if(b>12) {  return RET_FAILED; }
 aaTimeDayOfWeekGet(stp->date,stp->month,stp->year,&dow);
 a=(B)dow;
 aaStringCopyf(str,"%s, %02ld %s %04ld %02ld:%02ld:%02ld\0",(longday)?aa_timedayex[a]:aa_timeday[a],stp->date,aa_timemonth[b-1],stp->year,stp->hour,stp->minute,stp->second);
 if(tzstr) { aaStringAppendf(str," %s",tzstr); }
 return RET_YES;
 }







 B aaTimeFromString                    (_systime*systime,VP str)
 {
 H sl,x;
 CP txt;
 C oc[7];
 B etc[129];
 B buf[_1K];
 H pos;
 N dif,o,t;
 _parser pa;
 B oldmode=0;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(systime==NULL) { return RET_BADPARM; }
 aaTimeNull(systime);
 if(str==NULL) { return RET_BADPARM; }
 aaStringCopyf(buf,"%s",str);
 if(aaStringFindFirstIString(buf,0," gmt",0,&pos)==YES)  {  buf[pos]=0;  }
 aaStringLen(buf,&sl);
 if(sl==17)
  {
  aaParserInit(&pa,buf,sl);
  aaParserSeekToNumber(&pa,YES);
  o=pa.offset;
  aaParserSeekToNumber(&pa,NO);
  t=(pa.offset-o);

  aaParserSeek(&pa,-t);
  aaStringToNumber(pa.bp,t,&x,0,0,0);
  systime->date=x;
  aaParserSeek(&pa,t);

  aaParserSeekToChar(&pa,'-',YES,YES);
  aaParserSeekToChar(&pa,'-',NO,YES);

  aaParserSeekToVisibleChar(&pa,YES,YES);
  o=pa.offset;
  aaParserSeekToChar(&pa,'-',YES,YES);
  t=(pa.offset-o);

  aaParserSeek(&pa,-t);
  aaStringNCopy(etc,pa.bp,t,YES);
  for(x=0;x<12;x++)
   {
   aaStringNICompare(etc,aa_timemonth[x],3,&dif);
   if(dif!=0) { continue; }
   systime->month=x+1;
   break;
   }
  aaParserSeek(&pa,t);

  aaParserSeekToNumber(&pa,YES);
  o=pa.offset;
  aaParserSeekToNumber(&pa,NO);
  t=(pa.offset-o);
  aaParserSeek(&pa,-t);
  aaStringToNumber(pa.bp,t,&x,0,0,0);
  systime->year=x;
  aaParserSeek(&pa,t);
  aaParserSeekToNumber(&pa,YES);
  o=pa.offset;
  aaParserSeekToNumber(&pa,NO);
  t=(pa.offset-o);
  aaParserSeek(&pa,-t);
  aaStringToNumber(pa.bp,t,&x,0,0,0);
  systime->hour=x;
  aaParserSeek(&pa,t);
  aaParserSeekToNumber(&pa,YES);
  o=pa.offset;
  aaParserSeekToNumber(&pa,NO);
  t=(pa.offset-o);
  aaParserSeek(&pa,-t);
  aaStringToNumber(pa.bp,t,&x,0,0,0);
  systime->minute=x;
  aaParserSeek(&pa,t);

  aaTimeDayOfWeekGet(systime->date,systime->month,systime->year,&x);
  systime->dow=x;

  return RET_YES;
  }


 if(sl<25)  { /*BUG,"timefromstring: %i",sl); BUGGY;*/  return RET_FAILED;  }

 aaCast(txt,CP,buf);
 for(x=0;x<7;x++)
  {
  aaStringNICompare(txt,aa_timeday[x],3,&dif);
  if(dif==0) { break; }
  }
 if(x==7)                        {  return RET_FAILED; }
 systime->dow=x;
 o=3;    if(txt[o]!=',')         {  return RET_FAILED; }
 o=4;if(txt[o]!=SPACE_CHAR)      {  return RET_FAILED; }
 o=5;if(aaCharIsNum(txt[o])==NO) {  return RET_FAILED; }
 o=6;
 if(txt[o]==SPACE_CHAR||txt[o]=='-') // handles single digit day of month, e.g jan 1 may, instead jan 1  may
  {
  t=1;
  }
 else
  {
  o=6;if(aaCharIsNum(txt[o])==NO)         {  return RET_FAILED; }
  o=7;if(txt[o]!=SPACE_CHAR&&txt[o]!='-') {  return RET_FAILED; }
  t=0;
  }
 for(x=0;x<12;x++)
  {
  o=8-t; aaStringNICompare(&txt[o],aa_timemonth[x],3,&dif);
  if(dif==0) { break; }
  }
 if(x==12)      {        return RET_FAILED;      }

 o=11-t;if(txt[o]!=SPACE_CHAR&&txt[o]!='-') {   return RET_FAILED; }
 o=12-t;    if(aaCharIsNum(txt[o])==NO) { return RET_FAILED; }
 o=13-t;    if(aaCharIsNum(txt[o])==NO) { return RET_FAILED; }
 o=14-t;    if(aaCharIsNum(txt[o])==NO) { return RET_FAILED; }
 o=15-t;    if(aaCharIsNum(txt[o])==NO) { return RET_FAILED; }
 o=16-t;    if(txt[o]!=SPACE_CHAR&&txt[o]!='-') {    return RET_FAILED; }
 o=17-t;    if(aaCharIsNum(txt[o])==NO) { return RET_FAILED; }
 o=18-t;    if(txt[o]==':') { oldmode=1; }
            else
            if(aaCharIsNum(txt[o])==NO) { return RET_FAILED; }
 oldmode+=(B)t;
 o=19-oldmode;     if(txt[o]!=':') {    return RET_FAILED; }
 o=20-oldmode;     if(aaCharIsNum(txt[o])==NO) { return RET_FAILED; }
 o=21-oldmode;     if(aaCharIsNum(txt[o])==NO) { return RET_FAILED; }
 o=22-oldmode;     if(txt[o]!=':') {    return RET_FAILED; }
 o=23-oldmode;     if(aaCharIsNum(txt[o])==NO) { return RET_FAILED; }
 o=24-oldmode;     if(aaCharIsNum(txt[o])==NO) { return RET_FAILED; }
 o=7;            oc[0]=txt[o];
 o=16;           oc[1]=txt[o];
 o=19;           oc[2]=txt[o];
 o=22-oldmode;   oc[3]=txt[o];
 o=25-oldmode;   oc[4]=txt[o];
 o=7;            txt[o]=NULL_CHAR;
 o=5;            systime->date=(B)atoi(&txt[o]);
                 systime->month=(B)(x+1);
 o=16;           txt[o]=NULL_CHAR;
 o=12;           systime->year=(W)atoi(&txt[o]);
 o=19-oldmode;   txt[o]=NULL_CHAR;
 o=17;           systime->hour=(B)atoi(&txt[o]);
 o=22-oldmode;   txt[o]=NULL_CHAR;
 o=20-oldmode;   systime->minute=(B)atoi(&txt[o]);
 o=25-oldmode;   txt[o]=NULL_CHAR;
 o=23-oldmode;   systime->second=(B)atoi(&txt[o]);
 systime->ms=0;
 systime->gmt_dif=0;
 o=7;txt[o]=oc[0];
 o=16;txt[o]=oc[1];
 o=19-oldmode; txt[o]=oc[2];
 o=22-oldmode; txt[o]=oc[3];
 o=25-oldmode; txt[o]=oc[4];
 return RET_YES;
 }




 B aaTimeToText                        (_systime*systime,VP txt)
 {
 B ret,b;
 _systime st;
 _systime*stp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaStringNull(txt))!=RET_YES) { return ret; }
 if(systime==NULL)  {  aaTimeLocalGet(&st);  aaCast(stp,_systime*,&st);  }
 else               {  aaCast(stp,_systime*,systime);  }
 if(stp->date<1||stp->date>31) { return RET_FAILED; }
 b=(B)stp->month;
 if(b<1)  {  return RET_FAILED; }
 else
 if(b>12) {  return RET_FAILED; }
 aaStringCopyf(txt,"%02ld/%02ld/%04ld %02ld:%02ld:%02ld:%03ld",stp->date,stp->month,stp->year,stp->hour,stp->minute,stp->second,stp->ms);
 return RET_YES;
 }




 B aaTimeFromText                      (_systime*systime,VP txt)
 {
 B buf[_1K];
 _parser pa;
 H sl,count,x;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(systime==NULL) { return RET_BADPARM; }
 aaTimeNull(systime);
 if(txt==NULL) { return RET_BADPARM; }
 aaStringCopyf(buf,"%s",txt);
 aaStringLen(buf,&sl);
 aaParserInit(&pa,buf,sl);
 aaStringCountNumbers(pa.bp,pa.to_end,&count,YES);
 if(count!=2) { return RET_FAILED; }
 aaStringToNumber(pa.bp,count,&x,0,0,0);
 systime->date=x;
 aaParserSeek(&pa,count);
 if(pa.ch!='/') { return RET_FAILED; }
 aaParserSeek(&pa,1);
 aaStringCountNumbers(pa.bp,pa.to_end,&count,YES);
 if(count!=2) { return RET_FAILED; }
 aaStringToNumber(pa.bp,count,&x,0,0,0);
 systime->month=x;
 aaParserSeek(&pa,count);
 if(pa.ch!='/') { return RET_FAILED; }
 aaParserSeek(&pa,1);
 aaStringCountNumbers(pa.bp,pa.to_end,&count,YES);
 if(count!=4) { return RET_FAILED; }
 aaStringToNumber(pa.bp,count,&x,0,0,0);
 systime->year=x;
 aaParserSeek(&pa,count);
 if(pa.ch!=' ') { return RET_FAILED; }
 aaParserSeek(&pa,1);
 aaStringCountNumbers(pa.bp,pa.to_end,&count,YES);
 if(count!=2) { return RET_FAILED; }
 aaStringToNumber(pa.bp,count,&x,0,0,0);
 systime->hour=x;
 aaParserSeek(&pa,count);
 if(pa.ch!=':') { return RET_FAILED; }
 aaParserSeek(&pa,1);
 aaStringCountNumbers(pa.bp,pa.to_end,&count,YES);
 if(count!=2) { return RET_FAILED; }
 aaStringToNumber(pa.bp,count,&x,0,0,0);
 systime->minute=x;
 aaParserSeek(&pa,count);
 if(pa.ch!=':') { return RET_FAILED; }
 aaParserSeek(&pa,1);
 aaStringCountNumbers(pa.bp,pa.to_end,&count,YES);
 if(count!=2) { return RET_FAILED; }
 aaStringToNumber(pa.bp,count,&x,0,0,0);
 systime->second=x;
 aaParserSeek(&pa,count);
 if(pa.ch!=':') { return RET_FAILED; }
 aaParserSeek(&pa,1);
 aaStringCountNumbers(pa.bp,pa.to_end,&count,YES);
 if(count!=3) { return RET_FAILED; }
 aaStringToNumber(pa.bp,count,&x,0,0,0);
 systime->ms=x;
 aaTimeDayOfWeekGet(systime->date,systime->month,systime->year,&x);
 systime->dow=x;
 return RET_YES;
 }




 B aaTimeCompare                       (_systime*systime,_systime*systime2,GP secdif)
 {
 _systime st2;
 FILETIME ft1,ft2;
 SYSTEMTIME s1,s2;
 D v1,v2,dif;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(secdif==NULL) { return RET_BADPARM; }
 *secdif=0;
 if(systime==NULL) { return RET_BADPARM; }
 if(systime2==NULL) { aaTimeLocalGet(&st2); }
 else                 { aaTimeCopy(&st2,systime2); }
 WinSystemTimeFromSysTime(&s1,systime);
 if(SystemTimeToFileTime(&s1,&ft1)==0) { oow; return RET_FAILED; }
 WinSystemTimeFromSysTime(&s2,&st2);
 if(SystemTimeToFileTime(&s2,&ft2)==0) { oow;  return RET_FAILED; }
 if(aa.math_system.four_billion==0.0) oof;
 v1=(D)ft1.dwHighDateTime; v1=v1*(D)aa.math_system.four_billion; v1=v1+(D)ft1.dwLowDateTime;
 v2=(D)ft2.dwHighDateTime; v2=v2*(D)aa.math_system.four_billion; v2=v2+(D)ft2.dwLowDateTime;
 v1=v1/(D)aa.math_system.ten_million;
 v2=v2/(D)aa.math_system.ten_million;
 dif=(D)v2-(D)v1;
 *secdif=(G)dif;
 return RET_YES;
 }






 B aaTimeAdjust                        (_systime*systime,_systime*ressystime,G secdif)
 {
 _systime st1;
 SYSTEMTIME s1,s2;
 FILETIME ft1;
 Q v1,v2,v3;
 H v;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(systime==NULL) { aaTimeLocalGet(&st1); }
 else                { aaTimeCopy(&st1,systime); }
 if(secdif==0)
  {
  if(ressystime!=NULL) { aaTimeCopy(ressystime,&st1); }
  return RET_YES;
  }
 WinSystemTimeFromSysTime(&s1,&st1);
 if(SystemTimeToFileTime(&s1,&ft1)==0) { return RET_FAILED; }

 if(aa.math_system.four_billion==0.0) oof;
 if(aa.math_system.ten_million==0.0) oof;
 if(aa.math_system.four_billion==0.0) oof;

 v2=(Q)ft1.dwHighDateTime;
 v3=v2*aa.math_system.four_billion;
 v2=(Q)ft1.dwLowDateTime;
 v1=v2+v3;
 if(secdif<0) { v=aaNumAbs(secdif); }
 else           { v=secdif; }
 v2=(Q)v;
 v2=v2*aa.math_system.ten_million;
 if(secdif<0) { v1-=v2; }
 else           { v1+=v2; }
 v3=v1/aa.math_system.four_billion;
 ft1.dwHighDateTime=(H)v3;
 v2=v1-aa.math_system.four_billion;
 ft1.dwLowDateTime=(H)v2;
 if(FileTimeToSystemTime(&ft1,&s2)==0) { return RET_FAILED; }
 WinSystemTimeToSysTime(&s2,&st1);
 if(ressystime==NULL) { aaTimeCopy(systime,&st1); }
 else                   { aaTimeCopy(ressystime,&st1); }
 return RET_YES;
 }





 B aaTimeMsRunning                     (HP ms)
 {
 B ret;
 H el;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(ms==NULL) { return RET_BADPARM; }
 ret=aaTimerTikElapsed(aa.core_system.aamain_tik,&el);
 if(ms) { if(el==0) { el=1; } *ms=el; }
 return ret;
 }




 B aaTimeLaunchTikGet                  (HP ms)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(ms==NULL) { return RET_BADPARM; }
 *ms=aa.core_system.launch_tik;
 return RET_YES;
 }


 /*
 At least at the time of Windows NT 3.1, 3.51, and 4.01,
 the GetSystemTimeAsFileTime() API was the fastest user-mode API
 able to retrieve the current time.
 It also offers the advantage (compared with
 GetSystemTime() -> SystemTimeToFileTime()) of being a single API call,
 that under normal circumstances cannot fail.
 */


/*
 B aaTimeUtcGet                        (QP utc)
 {
 Q v;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(utc==NULL) { return RET_BADPARM; }
 GetSystemTimeAsFileTime((FILETIME*)&v);
 *utc=v;
 return RET_YES;
 }

*/


 Q aaTimeStamp                         (QP utcex)
 {
 S Q suffix=0;
 S Q prevutc=0;
 S Q prevex=0;
 S Q prevret=0;
 Q tot,wid;
 union { G ns100;  FILETIME ft;  } now;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 wid=10;
redo:
 GetSystemTimeAsFileTime(&now.ft);
 tot=now.ns100;
 tot=tot-116444736000000000LL;
 prevutc=tot;
 if(utcex) { *utcex=tot; }
rebo:
 if(tot>prevex)
  {
  suffix=0;
  //suffix++;
  }
 else
 if(tot==prevex)
  {
  if(suffix>=wid)
   {
   suffix=0;
   goto redo;
   }
  suffix++;
  //goto redo;
  }
 else
 if(tot<prevex)
  {
  suffix=0;
  //prevex=tot;
  goto redo;
  }
   prevex=tot;
 tot=tot/wid;
 tot=tot*wid;
 tot=tot+suffix;
 if(prevutc>tot)  { goto rebo; }
 if(prevret>=tot) { goto redo; }
 prevret=tot;
 //prevex=tot;
 return tot;
 }





 B aaTimeUtcExGet                      (QP utc)
 {
 S Q suffix=0;
 S Q prev=0;
 Q tot;//wid,tot,mod,end;
 union { G ns100;  FILETIME ft;  } now;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(utc==NULL) { return RET_BADPARM; }
redo:
 GetSystemTimeAsFileTime(&now.ft);
 tot=now.ns100;
 tot=tot-116444736000000000LL;
 tot=tot/10LL;

 tot=tot/1000LL;
 if(prev!=tot)  {  prev=tot;  suffix=0;  }
 else           {  if(suffix==999) goto redo; suffix++;  }
 tot=tot*1000LL;
 tot=tot+suffix;

 if(utc) *utc=tot;
 return RET_YES;
 }




 B aaTimeSecsToDuration                (H s,_duration*duration)
 {
 H we,da,ho,mi,se;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(duration==NULL) { return RET_BADPARM; }
 aaMemoryFill(duration,sizeof(_duration),0);
 we=s/604800L;  duration->weeks=we; s-=(we*604800L);
 da=s/86400L;   duration->days=da; s-=(da*86400L);
 ho=s/3600L;    duration->hours=ho; s-=(ho*3600L);
 mi=s/60L;      duration->mins=mi; s-=(mi*60L);
 se=s;          duration->secs=se;
 return RET_YES;
 }






 B aaTimeToUnixTime                    (_systime*systime,QP unixtime)
 {
 struct tm ti;
 time_t tt;
 _systime st;
 _systime*stp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(unixtime==NULL) { return RET_BADPARM; }
 *unixtime=0;
 if(systime==NULL)
  {
  aaTimeLocalGet(&st);
  aaCast(stp,_systime*,&st);
  }
 else
  {
  aaCast(stp,_systime*,systime);
  }
 ti.tm_sec=stp->second;
 ti.tm_min=stp->minute;
 ti.tm_hour=stp->hour;
 ti.tm_mday=stp->date;
 ti.tm_mon=stp->month-1;
 ti.tm_year=stp->year-1900;
 ti.tm_wday=stp->dow;
 ti.tm_yday=0;
 ti.tm_isdst=aa.timer_system.is_dls;
 tt=mktime(&ti);
 if(tt==-1) { return RET_FAILED; }
 *unixtime=(Q)tt;
 return RET_YES;
 }




 B aaTimeFromUnixTime                  (_systime*systime,Q unixtime)
 {
 struct tm*tmm;
 time_t t;
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(systime==NULL) { return RET_BADPARM; }
 aaTimeNull(systime);
 if((G)unixtime<0) { return RET_FAILED; }
 *(HP)&t=(H)(unixtime);
 tmm=localtime(&t);
 if(tmm==NULL) { return RET_FAILED; }
 if((ret=aaTimeSet(systime,(H)tmm->tm_wday,(H)tmm->tm_year+1900,(H)tmm->tm_mon+1,(H)tmm->tm_mday,(H)tmm->tm_hour,(H)tmm->tm_min,(H)tmm->tm_sec,0,0))!=RET_YES)
  {
  oops;
  }
 return ret;
 }





 B aaTimeGetOfDay                      (struct timeval*tv)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 union { G ns100;  FILETIME ft;  } now;
 if(tv==NULL) { return RET_BADPARM; }
 GetSystemTimeAsFileTime(&now.ft);
 tv->tv_usec=(long)((now.ns100/10LL)%1000000LL);
 tv->tv_sec=(long)((now.ns100-116444736000000000LL)/10000000LL);
 return RET_YES;
 }




 B aaTimeEpochGet                      (QP secs,QP microsecs)
 {
 B ret;
 Q ms;
 struct timeval tv;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 ///gettimeofday(&tv,NULL);

 if((ret=aaTimeGetOfDay(&tv))!=YES) { oops; }

 if(microsecs)
  {
  *microsecs=(Q)((tv.tv_sec)*1000000LL)+(Q)(tv.tv_usec);
  }
 //if(combined)  {  *combined==(Y)((t1%1000000LL)/1000LL)%1000;
 ms=(Q)(tv.tv_sec)*1000+(Q)(tv.tv_usec)/1000;
 ms=ms/1000;
 if(secs) { *secs=ms; }
 return RET_YES;
 }




 B aaTimeUtcExToText                   (Q utcex,VP txt)
 {
 _systime st;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(txt==NULL) { return RET_BADPARM; }
 aaTimeFromUnixTime(&st,utcex/1000000LL);
 st.ms=(Y)(((utcex%1000000LL)/1000LL)%1000LL);
 aaTimeToText(&st,txt);
 aaStringCopyf(txt,"%s:%03I64d",txt,utcex%1000LL);
 bp=(BP)txt;
 bp[10]='-';
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/


 B aaGeoLookup                         (VP countrycode,VP countryname,VP continent,HP index)
 {
 H i;
 BP cc;
 B str[5];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(countryname) { aaStringNull(countryname); }
 if(continent)   { aaStringNull(continent); }
 if(index)       { *index=0; }
 cc=(BP)countrycode;
 if(cc[0]>='a'&&cc[0]<='z') { str[0]=(cc[0]-'a')+'A'; }  else
 if(cc[0]>='A'&&cc[0]<='Z') { str[0]=cc[0]; } else { return RET_NOTFOUND; }
 if(cc[1]>='a'&&cc[1]<='z') { str[1]=(cc[1]-'a')+'A'; }  else
 if(cc[1]>='A'&&cc[1]<='Z') { str[1]=cc[1]; } else { return RET_NOTFOUND; }
 if(cc[2]!=NULL_CHAR)  { return RET_NOTFOUND; }
 for(i=0;i<251;i++)
  {
  if(aa_geo_country_code[i][0]==str[0]&&aa_geo_country_code[i][1]==str[1])
   {
   if(countryname) { aaStringCopyf(countryname,"%s",aa_geo_country_name[i]); }
   if(continent)   { aaStringCopyf(continent,"%s",aa_geo_continent[i]); }
   if(index)       { *index=i; }
   return RET_YES;
   }
  }
 return RET_NOTFOUND;
 }



 B aaGeoCountryNameToIndex             (VP countryname,HP index)
 {
 H i;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(countryname==NULL) { return RET_BADPARM; }
 if(index) { *index=0; }
 for(i=0;i<251;i++)
  {
  if(aaStringICompare(countryname,aa_geo_country_name[i],0)!=YES) { continue; }
  if(index) { *index=i; }
  return RET_YES;
  }
 return RET_NOTFOUND;
 }


 B aaGeoCountryCodeToIndex             (VP countrycode,HP index)
 {
 H i;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(countrycode==NULL) { return RET_BADPARM; }
 if(index) { *index=0; }
 for(i=0;i<251;i++)
  {
  if(aaStringICompare(countrycode,aa_geo_country_code[i],0)!=YES) { continue; }
  if(index) { *index=i; }
  return RET_YES;
  }
 return RET_NOTFOUND;
 }

/*-----------------------------------------------------------------------*/



 B aa_MemorySystemStart                (V)
 {
 B ret;
 N n,k;
 H c,poly,off;
 H mi,mx;
 HANDLE hprocess;
 B pterm[14]={0,1,2,4,5,7,8,10,11,12,16,22,23,26};
 MEMORYSTATUSEX mstatus;
 Q crc64;

 poly=0L;
 for(n=0;n<14;n++) { poly|=1L<<(31-pterm[n]); }
 for(n=0;n<256;n++)
  {
  c=(H)n;
  for(k=0;k<8;k++)  { c=c&1?poly^(c>>1):c>>1; }
  aa.memory_system.crc_table[n]=c;
  }
 for(n=0;n<256;n++)
  {
  crc64=n;
  for(k=0;k<8;k++)
   {
   if(crc64&1) {  crc64>>= 1;    crc64^=aa_MEMORYCRC_POLYNOMIAL64;            }
   else        {  crc64>>=1; }
   }
  aa.memory_system.crc64_table[n]=crc64;
  }
 aaMemoryFill(&mstatus,sizeof(mstatus),0);
 mstatus.dwLength=sizeof(mstatus);
 GlobalMemoryStatusEx(&mstatus);
 aa.memory_system.status.table_used=0;
 aa.memory_system.status.table_available=aaElementCount(aa.memory_system.table.block);
 aa.memory_system.status.os_physical_total=mstatus.ullTotalPhys;
 aa.memory_system.status.os_physical_allocated=mstatus.ullTotalPhys-mstatus.ullAvailPhys;
 aa.memory_system.status.os_memory_load=(F)mstatus.dwMemoryLoad;
 aa.memory_system.status.os_virtual_total=mstatus.ullTotalVirtual;
 aa.memory_system.status.os_virtual_allocated=mstatus.ullTotalVirtual-mstatus.ullAvailVirtual;
 hprocess=aa.core_system.process_handle;
 if(!GetProcessWorkingSetSize(hprocess,&mi,&mx)) { oof; }
 aa.memory_system.status.working_set_size_min=mi;
 aa.memory_system.status.working_set_size_max=mx;
 #if 0
 if(aa.core_system.in_remote_debugger&&aa_i_am==0) { oof; aaQuit(); }
 #endif
 if((ret=aaMemoryCodeAllocate((VP)&aa.memory_system.cdecl_ram,512))!=YES) { oops; }
 off=0;
 aa_cdecl=aa.memory_system.cdecl_ram;
   aa.memory_system.cdecl_ram[off++]=0x55;
   aa.memory_system.cdecl_ram[off++]=0x8b;  aa.memory_system.cdecl_ram[off++]=0xec;
   aa.memory_system.cdecl_ram[off++]=0x51;
   aa.memory_system.cdecl_ram[off++]=0x53;
   aa.memory_system.cdecl_ram[off++]=0x56;
   aa.memory_system.cdecl_ram[off++]=0x57;
   aa.memory_system.cdecl_ram[off++]=0x8b;  aa.memory_system.cdecl_ram[off++]=0x4d; aa.memory_system.cdecl_ram[off++]=0x0c;
   aa.memory_system.cdecl_ram[off++]=0x8b;  aa.memory_system.cdecl_ram[off++]=0x75; aa.memory_system.cdecl_ram[off++]=0x08;
   aa.memory_system.cdecl_ram[off++]=0x2b;  aa.memory_system.cdecl_ram[off++]=0xe1;
   aa.memory_system.cdecl_ram[off++]=0x8b;  aa.memory_system.cdecl_ram[off++]=0xfc;
   aa.memory_system.cdecl_ram[off++]=0xf3;  aa.memory_system.cdecl_ram[off++]=0xa4;
   aa.memory_system.cdecl_ram[off++]=0xff;  aa.memory_system.cdecl_ram[off++]=0x55; aa.memory_system.cdecl_ram[off++]=0x10;
   aa.memory_system.cdecl_ram[off++]=0x89;  aa.memory_system.cdecl_ram[off++]=0x45; aa.memory_system.cdecl_ram[off++]=0xfc;
   aa.memory_system.cdecl_ram[off++]=0x03;  aa.memory_system.cdecl_ram[off++]=0x65; aa.memory_system.cdecl_ram[off++]=0x0c;
   aa.memory_system.cdecl_ram[off++]=0x8b;  aa.memory_system.cdecl_ram[off++]=0x45; aa.memory_system.cdecl_ram[off++]=0xfc;
   aa.memory_system.cdecl_ram[off++]=0x5f;
   aa.memory_system.cdecl_ram[off++]=0x5e;
   aa.memory_system.cdecl_ram[off++]=0x5b;
   aa.memory_system.cdecl_ram[off++]=0x59;
   aa.memory_system.cdecl_ram[off++]=0x5d;
   aa.memory_system.cdecl_ram[off]=0xc3;
 #if 0
 if(aa.core_system.in_debugger&&aa_i_am==0) { oof; aaQuit(); }
 #endif
 return RET_YES;
 }





 V aa_MemorySystemStop                 (V)
 {
 N l;

 aa.is_ready=NO;
 is_aa_ready=NO;
 aa_last_line_executed=__LINE__;
 if(aa.memory_system.cdecl_ram!=NULL)
  {
  aa_last_line_executed=__LINE__;
  aaMemoryCodeRelease(aa.memory_system.cdecl_ram);
  aa.memory_system.cdecl_ram=NULL;
  }
 aa_last_line_executed=__LINE__;
 for(l=255;l>=0;l--)
  {
  if(aa.memory_system.temp_bytes[l]!=0)
   {
   logg("Releasing Memory_temp[%i] = %i bytes",l,aa.memory_system.temp_bytes[l]);
   aa_MemoryProtect(aa.memory_system.temp_mem[l],NO);
   aa_MemoryRelease(aa.memory_system.temp_mem[l]);
   aa.memory_system.temp_mem[l]=NULL;
   }
  }
 aa_last_line_executed=__LINE__;
 if(aa.memory_system.status.bytes_allocated!=0||aa.memory_system.status.blocks_allocated!=0)
  {
  aa_MemorySystemDump();
  }
 logg("");
 }





 V aa_MemorySystemDump                 (V)
 {
 H i,mx,adr;
 _aa_memoryheader*memhdr;

 if(aa_hide_leak==NO)
  {
  if(aa.memory_system.status.bytes_allocated)  {  aaLog(-555,"!!!* Memory Leak: bytes_remain = %i  (user=%i)",aa.memory_system.status.bytes_allocated,aa.memory_system.status.user_bytes_allocated);   }
  if(aa.memory_system.status.blocks_allocated) {  aaLog(-555,"!!!* Memory Leak: blocks_remain = %i  (user=%i)",aa.memory_system.status.blocks_allocated,aa.memory_system.status.user_blocks_allocated);   }
  mx=aaElementCount(aa.memory_system.table.block);
  for(i=0;i<mx;i++)
   {
   if(aa.memory_system.table.block[i]!=NULL)
    {
    memhdr=(_aa_memoryheader*)aa.memory_system.table.block[i];
    adr=(Z)memhdr;
    aaLog(-555," block[%-4i]=%-8i-%-8i bytes=%-10u  prot=%-3s locked=%-3s user=%-3s realloc=%-8u (%s)",i,(Z)adr,(Z)adr+memhdr->bytes,memhdr->bytes,aaBoolString(memhdr->is_protected),aaBoolString(memhdr->is_locked),aaBoolString(memhdr->is_user),memhdr->realloc_count,memhdr->name);
    }
   }
  }
 }





 B aa_MemorySystemBlockTable           (VP mem,B dofree,HP index,H who)
 {
 register H i,j,mx;
 _aa_memoryheader*memhdr;
 H by;
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { oof; }
 mx=aaElementCount(aa.memory_system.table.block);
 dofree&=1;
 if(dofree)
  {
  j=0;
  if(index) { j=*index; }
  for(i=0;i<mx;i++)
   {
   aa_stats[5]++;
   if(aa.memory_system.table.block[j]==mem)
    {
    aa.memory_system.table.block[j]=NULL;
    aa.memory_system.status.table_used--;
    aa.memory_system.status.table_available++;
    if(index) { *index=j; }
    break;
    }
   j++;
   j%=mx;
   }
  if(i!=mx) { return RET_YES; }
  }
 else
  {
  if(index) { *index=0xffffffff; }
  for(i=0;i<mx;i++)
   {
   aa_stats[6]++;
   j=aa.memory_system.table_pf;
   aa.memory_system.table_pf++;
   aa.memory_system.table_pf%=mx;
   if(aa.memory_system.table.block[j]==NULL)
    {
    aa.memory_system.status.table_used++;
    aa.memory_system.status.table_available--;
    aa.memory_system.table.block[j]=mem;
    if(index) { *index=j; }
    break;
    }
   }
  if(i!=mx) { return RET_YES; }
  aa.memory_system.status.table_misses++;
  return RET_YES;
  }
 if((ret=aaMemoryBytesGet(mem,&by))!=RET_YES) { }//oops; }
 aaDebugf("who=%i mx=%i dofree=%i used=%i ptr=%-8i by=%i",who,mx,dofree,aa.memory_system.status.table_used,(Z)mem,by);
 for(i=0;i<mx;i++)
  {
  if(aa.memory_system.table.block[i]!=NULL)
   {
   memhdr=(_aa_memoryheader*)aa.memory_system.table.block[i];
   aaDebugf(" block[%-4i]=%-8i bytes=%-10u  prot=%-3s locked=%-3s user=%-3s realloc=%-8u (%s)",i,(Z)memhdr,memhdr->bytes, aaBoolString(memhdr->is_protected),aaBoolString(memhdr->is_locked),aaBoolString(memhdr->is_user), memhdr->realloc_count,memhdr->name);
   }
  }
 return RET_FAILED;
 }





 B aa_MemoryAllocate                   (PP mem,H bytes,VP name,B lock)
 {
 B ret;
 _aa_memoryheader*memhdr;
 BP vmem;
 BP mem_ptr;
 H len,ix;
 B type;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL_POINTR||mem==NULL) { MessageBox(NULL,"memory allocate mem==NULL",__func__,MB_OK|MB_SYSTEMMODAL); return RET_BADPARM;  }
 if(bytes==0)  {  return RET_BADPARM;  }
 len=bytes+sizeof(_aa_memoryheader);
 type=0;
 aa.memory_system.status.globalalloc_calls++;
 aa.memory_system.status.globalalloc_bytes+=(Q)len;
 if((vmem=GlobalAlloc(GPTR,len))==NULL)   { oow;  return RET_NOMEMORY;   }
 type='G';
 mem_ptr=vmem;
 aaCast(memhdr,_aa_memoryheader*,mem_ptr);
 memhdr->actual_ptr=(BP)(vmem);
 if(lock) { }
 memhdr->magic=VAL_aamh;
 memhdr->bytes=bytes;
 memhdr->actual_len=len;
 memhdr->mini_type=type;
 if(name) { aaStringCopy(memhdr->name,name); }
 else     { memhdr->name[0]=NULL_CHAR; }
 if((ret=aa_MemorySystemBlockTable(vmem,NO,&ix,__LINE__))!=YES)  {  oops;  }
 memhdr->table_index=ix;
 mem_ptr+=sizeof(_aa_memoryheader);
 *mem=mem_ptr;
 aa.memory_system.status.bytes_allocated+=memhdr->bytes;
 if(aa.memory_system.status.bytes_allocated>aa.memory_system.status.peak_bytes_allocated)   {  aa.memory_system.status.peak_bytes_allocated=aa.memory_system.status.bytes_allocated;   }
 aa.memory_system.status.blocks_allocated++;
 if(aa.memory_system.status.blocks_allocated>aa.memory_system.status.peak_blocks_allocated) {  aa.memory_system.status.peak_blocks_allocated=aa.memory_system.status.blocks_allocated; }
 aa.memory_system.alloc_calls++;
 return RET_YES;
 }







 B aa_MemoryReAllocate                 (PP mem,H bytes)
 {
 B ret;
 _aa_memoryheader*memhdr;
 _aa_memoryheader*memhdrb;
 BP vmem;
 BP new_vmem;
 H rac;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL||mem==NULL_POINTR) { oof;  return RET_BADPARM;  }
 if(*mem==NULL||*mem==NULL_POINTR) { oof; return RET_BADPARM;  }
 vmem=*mem;
 vmem-=sizeof(_aa_memoryheader);
 aaCast(memhdr,_aa_memoryheader*,vmem);
 vmem+=sizeof(_aa_memoryheader);
 if(memhdr->is_protected==YES) {  oof;  return RET_FORBIDDEN;  }
 aa.memory_system.realloc_calls++;
 if(bytes==memhdr->bytes)  {  return RET_YES;  }
 if(memhdr->is_locked) { aaNote(0,"zaq %i %i %s",memhdr->bytes,bytes,memhdr->name); }
 rac=memhdr->realloc_count;
 new_vmem=NULL;
 if((ret=aa_MemoryAllocate((VP)&new_vmem,bytes,memhdr->name,memhdr->is_locked))!=RET_YES) { oow; return ret; }
 new_vmem-=sizeof(_aa_memoryheader);
 aaCast(memhdrb,_aa_memoryheader*,new_vmem);
 memhdrb->realloc_count=rac+1;
 aaStringCopy(memhdrb->name,memhdr->name);
 new_vmem+=sizeof(_aa_memoryheader);
 if(bytes>=memhdr->bytes) { aaMemoryCopy(new_vmem,memhdr->bytes,vmem);  }
 else                     { aaMemoryCopy(new_vmem,bytes,vmem);   }
 if(aa_MemoryRelease(vmem)!=YES) oof;
 *mem=new_vmem;
 return RET_YES;
 }




 B aa_MemoryProtect                    (VP mem,B state)
 {
 _aa_memoryheader*memhdr;
 BP vmem;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL||mem==NULL_POINTR)
  {
  MessageBox(NULL,"memory protect mem==NULL",__func__,MB_OK|MB_SYSTEMMODAL);
  return RET_BADPARM;
  }
 aaCast(vmem,BP,mem);
 vmem-=sizeof(_aa_memoryheader);
 aaCast(memhdr,_aa_memoryheader*,vmem);
 if(state==YES) { memhdr->is_protected=YES; }
 else             { memhdr->is_protected=NO; }
 return RET_YES;
 }





 B aa_MemoryRelease                    (VP mem)
 {
 B ret;
 _aa_memoryheader*memhdr;
 BP vmem;
 H bytes,ix;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL||mem==NULL_POINTR)
  {
  MessageBox(NULL,"memory release mem==NULL",__func__,MB_OK|MB_SYSTEMMODAL);
  return RET_BADPARM;
  }
 vmem=mem;
 vmem-=sizeof(_aa_memoryheader);
 aaCast(memhdr,_aa_memoryheader*,vmem);
 if(memhdr->is_protected==YES) { oof; return RET_FORBIDDEN; }
 bytes=memhdr->bytes;
 if(memhdr->is_locked==YES)    { oof;  memhdr->is_locked=NO;  }
 ix=memhdr->table_index;
 memhdr->magic=0;
 if(memhdr->mini_type!='G') { oof; }
 if(GlobalFree(memhdr->actual_ptr)!=NULL)
  {
  logg("%s:%i globalfree problem",__func__,__LINE__);
  aaNote(0,"%s:%i bytes=%i %s %i,%i",__func__,__LINE__,bytes,memhdr->name,aa.memory_system.status.blocks_allocated,aa.memory_system.status.bytes_allocated);
  return RET_FAILED;
  }
 if((ret=aa_MemorySystemBlockTable(vmem,YES,&ix,__LINE__))!=YES)  {  oops;  }
 aa.memory_system.status.bytes_allocated-=bytes;
 aa.memory_system.status.blocks_allocated--;
 aa.memory_system.release_calls++;
 return RET_YES;
 }




 B aa_MemoryTemp                       (PP mem,H bytes,B level)
 {
 B ret;
 BP new_mem;
 H oldby;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL||mem==NULL_POINTR)    {   return RET_BADPARM;   }
 if(bytes==0) { oof; }
 oldby=aa.memory_system.temp_bytes[level];
 aa.memory_system.temp_hits[level]++;
 aa.memory_system.status.temp_calls++;
 if(bytes>aa.memory_system.temp_bytes[level])
  {
  if(aa.memory_system.temp_bytes[level]==0)
   {
   if((ret=aa_MemoryAllocate((VP)&new_mem,bytes,"Temp",NO))!=RET_YES) { oops;  return ret; }
   aa_MemoryProtect(new_mem,YES);
   aa.memory_system.temp_allocs[level]++;
   }
  else
   {
   new_mem=aa.memory_system.temp_mem[level];
   aa_MemoryProtect(new_mem,NO);
   if((ret=aa_MemoryReAllocate((VP)&new_mem,bytes))!=RET_YES) {   return ret; }
   aa_MemoryProtect(new_mem,YES);
   aa.memory_system.temp_reallocs[level]++;
   }
  aa.memory_system.temp_mem[level]=new_mem;
  aa.memory_system.temp_bytes[level]=bytes;
  }
 if(mem!=NULL) { *mem=aa.memory_system.temp_mem[level]; }
 if(oldby) {}
 return RET_YES;
 }


/*-----------------------------------------------------------------------*/




 B aaMemoryStatus                      (_memorystatus*memorystatus)
 {
 H i;
 SYSTEM_INFO si;
 MEMORYSTATUSEX mstatus;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
  {
  aaMemoryFill(&mstatus,sizeof(mstatus),0);
  mstatus.dwLength=sizeof(mstatus);
  GlobalMemoryStatusEx(&mstatus);
  aa.memory_system.status.os_physical_total=mstatus.ullTotalPhys;
  aa.memory_system.status.os_physical_allocated=mstatus.ullTotalPhys-mstatus.ullAvailPhys;
  aa.memory_system.status.os_memory_load=(F)mstatus.dwMemoryLoad;
  aa.memory_system.status.os_virtual_total=mstatus.ullTotalVirtual;
  aa.memory_system.status.os_virtual_allocated=mstatus.ullTotalVirtual-mstatus.ullAvailVirtual;
  aa.memory_system.status.pages_allocated=aa.page_system.pages_allocated;
  aa.memory_system.status.pages_commited=aa.page_system.pages_commited;
  aa.memory_system.status.total_object_handles=aa.object_system.total_count;
  for(i=0;i<256;i++)
   {
   aa.memory_system.status.object_handle_count[i]=aa.object_system.object[i].instance_count;
   }
  if(aa.memory_system.status.os_hardware_page_size==0)
   {
   GetSystemInfo(&si);
   aa.memory_system.status.os_hardware_page_size=si.dwPageSize;
   }
  aa.core_system.GetProcessMemoryInfo(aa.core_system.process_handle,&aa.memory_system.pmc,sizeof(aa.memory_system.pmc));
  aa.memory_system.status.os_page_fault_count=aa.memory_system.pmc.PageFaultCount;
  aa.memory_system.status.working_set_size=aa.memory_system.pmc.WorkingSetSize;
  aa.memory_system.status.working_set_size_peak=aa.memory_system.pmc.PeakWorkingSetSize;
  aa.memory_system.status.process_virtual_usage=aa.memory_system.pmc.PrivateUsage;
  aa.memory_system.status.os_virtual_perc=aaNumPercentIs(aa.memory_system.status.os_virtual_allocated,aa.memory_system.status.os_virtual_total);
  aa.memory_system.status.os_physical_perc=aaNumPercentIs(aa.memory_system.status.os_physical_allocated,aa.memory_system.status.os_physical_total);
  }
 if(memorystatus)
  {
  aaMemoryCopy(memorystatus,sizeof(_memorystatus),&aa.memory_system.status);
  }
 return RET_YES;
 }



 B aaMemoryTableGet                    (_memorytable*memorytable,HP used,HP avail)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(used)        { *used=aa.memory_system.status.table_used;      }
 if(avail)       { *used=aa.memory_system.status.table_available; }
 if(memorytable) { aaMemoryCopy(memorytable,sizeof(_memorytable),&aa.memory_system.table);  }
 return RET_YES;
 }



 B aaMemoryZero                        (VP dst,H bytes)
 {
 BP src;
 QP q_src;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(dst==NULL)  { return RET_BADPARM;  }
 if(bytes==0)   { return RET_YES; }
 aa.memory_system.status.bytes_filled+=bytes;
 aa.memory_system.status.fill_calls++;
 q_src=(QP)dst;
 while(1)
  {
  if(bytes<64) break;
  *(q_src+0)=*(q_src+1)=*(q_src+2)=*(q_src+3)=*(q_src+4)=*(q_src+5)=*(q_src+6)=*(q_src+7)=0;
  q_src+=8;
  bytes-=64;
  }
 while(1)
  {
  if(bytes<8) break;
  *(q_src+0)=0;
  q_src+=1;
  bytes-=8;
  }
 src=(BP)q_src;
 while(1)
  {
  if(bytes==0) break;
  *(src+0)=0;
  src+=1;
  bytes--;
  }
 return RET_YES;
 }




 B aaMemoryIsZero                      (VP dst,H bytes)
 {
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(dst==NULL)  {  return RET_BADPARM;  }
 if(bytes==0) { return RET_YES; }
 bp=(BP)dst;
 while(bytes--)
  {
  if(*bp!=0) { return RET_NO; }
  }
 return RET_YES;
 }




 B aaMemoryFill                        (VP dst,H bytes,B val)
 {
 register BP dptr;
 register HP hp;
 register H dwords;
 register H dw;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(dst==NULL)  {  return RET_BADPARM;  }
 if(bytes==0) { return RET_YES; }
 aa.memory_system.status.bytes_filled+=bytes;
 aa.memory_system.status.fill_calls++;
 aaCast(dptr,BP,dst);
 if(bytes>=64)
  {
  dw=(val<<24)+(val<<16)+(val<<8)+val;
  aaCast(hp,HP,dst);
  dwords=bytes>>2;
  while(1)
   {
   if(dwords<2) { break; }
   hp[0]=dw;
   hp[1]=dw;
   dptr+=8;
   hp+=2;
   bytes-=8;
   dwords-=2;
   }
  if(bytes==0) { return RET_YES; }
  while(dwords--)
   {
   hp[0]=dw;
   dptr+=4;
   hp+=1;
   bytes-=4;
   }
  if(bytes==0) { return RET_YES; }
  }
 while(bytes--)
  {
  *dptr=val;
  dptr++;
  }
 return RET_YES;
 }





 B aaMemoryStamp                       (VP dst,H count,VP src,H sbytes)
 {
 H i;
 BP dest;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(dst==NULL)  {  return RET_BADPARM;  }
 if(src==NULL)  {  return RET_BADPARM;  }
 if(count==0)   {  return RET_YES;  }
 if(sbytes==0)  {  return RET_YES;  }
 dest=(BP)dst;
 for(i=0;i<count;i++)
  {
  aaMemoryCopy(dest,sbytes,src);
  dest+=sbytes;
  }
 return RET_YES;
 }




 #define NOTALIND(eex,eey)   (((N)eex&(sizeof(N)-1))|((N)eey&(sizeof(N)-1)))  // Nonzero if either eex or eey is not aligned on a "long" boundary.
 #define BIGBLOCKSIZE        (sizeof(N)<<2)      // How many bytes are copied each iteration of the 4X unrolled loop.
 #define LITTLEBLOCKSIZE     (sizeof(N))           // How many bytes are copied each iteration of the word copy loop.
 #define TOO_SMALL(LEN)      ((LEN)<(N)BIGBLOCKSIZE) // Threshhold for punting to the byte copier. ningy added (N)



 B aaMemoryCopy                        (VP dst,H bytes,VP src)
 {
 register CP dp=dst;
 register CP sp=src;
 register NP aligned_dst;
 register NP aligned_src;
 N len=(N)bytes;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(dst==NULL)  {  return RET_BADPARM;  }
 if(len<0)      {  return RET_BADPARM; }
 if(len==0)     {  return RET_YES;  }
 if(src==NULL)  {  return RET_BADPARM;  }

 aa.memory_system.status.bytes_copied+=bytes;
 aa.memory_system.status.copy_calls++;
 if(sp<dp&&(dp<(sp+len)))
  {
  sp+=len;
  dp+=len;
  while(len--) { *--dp=*--sp; }
  }
 else
  {
  if(!TOO_SMALL(len)&&!NOTALIND(sp,dp))
   {
   aligned_dst=(NP)dp;
   aligned_src=(NP)sp;
   while(len>=(N)BIGBLOCKSIZE)
    {
    *aligned_dst++=*aligned_src++;
    *aligned_dst++=*aligned_src++;
    *aligned_dst++=*aligned_src++;
    *aligned_dst++=*aligned_src++;
    len-=BIGBLOCKSIZE;
    }
   while(len>=(N)LITTLEBLOCKSIZE)
    {
    *aligned_dst++=*aligned_src++;
    len-=LITTLEBLOCKSIZE;
    }
   dp=(CP)aligned_dst;
   sp=(CP)aligned_src;
   }
  while(len--)   { *dp++=*sp++;   }
  }
 return RET_YES;
 }



 #define wsize                         sizeof(Z)
 #define wmask                         (wsize-1)


 B aaMemoryMove                        (VP dst,H bytes,VP src)
 {
 register CP dest=dst;
 register CP srce=src;
 register Z t;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(dest==NULL)  {  return RET_BADPARM; }
 if(bytes==0)     {  return RET_YES;     }
 if(srce==NULL)  {  return RET_BADPARM; }
 if(dest==srce)   {  return RET_YES;     }

 if((H)dest<(H)srce)
  {
  t=(Z)srce;
  if((t|(Z)dest)&wmask)
   {
   if((t^(Z)dest)&wmask||bytes<wsize) t=bytes;
   else                               t=wsize-(t&wmask);
   bytes-=t;
   do
    {
    *dest++=*srce++;
    }
    while(--t);
   }
  t=bytes/wsize;
  if(t)
  do
   {
   *(ZP)dest=*(ZP)srce;
   srce+=wsize;
   dest+=wsize;
   *dest++=*srce++;
   }
   while(--t);
  t=bytes&wmask;
  if(t)
  do
   {
   *dest++=*srce++;
   }
   while(--t);
  }
 else
  {
  srce+=bytes;
  dest+=bytes;
  t=(Z)srce;
  if((t|(Z)dest)&wmask)
   {
   if((t^(Z)dest)&wmask||bytes<=wsize)  t=bytes;
   else                                 t&=wmask;
   bytes-=t;
   do
    {
    *--dest=*--srce;
    }
    while(--t);
   }
  t=bytes/wsize;
  if(t)
  do
   {
   srce-=wsize;
   dest-=wsize;
   *(ZP)dest=*(ZP)srce;
   }
   while(--t);
  t=bytes&wmask;
  if(t)
  do
   {
   *--dest=*--srce;
   }
   while(--t);
  }
 return RET_YES;
 }



 B aaMemorySwap                        (VP dst,H bytes,VP src)
 {
 B block[_32K+_4K];
 H todo;
 BP dp,sp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(dst==NULL) { return RET_BADPARM; }
 if(src==NULL) { return RET_BADPARM; }
 if(bytes==0) { return RET_YES; }
 dp=(BP)dst;
 sp=(BP)src;
 while(1)
  {
  if(bytes==0) { break; }
  todo=aaNumRoof(bytes,_32K);
  aaMemoryCopy(block,todo,dp);
  aaMemoryCopy(dp,todo,sp);
  aaMemoryCopy(sp,todo,block);
  bytes-=todo;
  dp+=todo;
  sp+=todo;
  }
 return RET_YES;
 }






 B aaMemoryTemp                        (PP mem,H bytes)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aa_MemoryTemp(mem,bytes,aa_MEMORYTEMP_User));
 }





 B aaMemoryAllocate                    (PP mem,H bytes)
 {
 B ret;
 _aa_memoryheader*memhdr;
 BP vmem;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_MemoryAllocate((VP)&vmem,bytes,"zser",NO))!=YES)
  {
  return ret;
  }
 aa.memory_system.status.user_bytes_allocated+=bytes;
 if(aa.memory_system.status.user_bytes_allocated>aa.memory_system.status.peak_user_bytes_allocated)  {  aa.memory_system.status.peak_user_bytes_allocated=aa.memory_system.status.user_bytes_allocated;  }
 aa.memory_system.status.user_blocks_allocated++;
 if(aa.memory_system.status.user_blocks_allocated>aa.memory_system.status.peak_user_blocks_allocated) {  aa.memory_system.status.peak_user_blocks_allocated=aa.memory_system.status.user_blocks_allocated;  }
 vmem-=sizeof(_aa_memoryheader);
 aaCast(memhdr,_aa_memoryheader*,vmem);
 memhdr->is_user=YES;
 vmem+=sizeof(_aa_memoryheader);
 *mem=vmem;
 return RET_YES;
 }




 B aaMemoryReAllocate                  (PP mem,H bytes)
 {
 B ret;
 H by;
 _aa_memoryheader*memhdr;
 BP vmem;
 BP nmem;
 B was_user;
 B was_name[33];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if((ret=aaMemoryBytesGet(*mem,&by))!=RET_YES)
  {
  aaNote(0,"%s %u ret=%s bytes=%u",__FUNCTION__,__LINE__,ret_string[ret],bytes);
  aaCast(vmem,BP,*mem);
  vmem-=sizeof(_aa_memoryheader);
  aaCast(memhdr,_aa_memoryheader*,vmem);
  if(memhdr->magic==VAL_aamh) { oof; }
  else { oof; }
  return ret;
  }
 aaCast(vmem,BP,*mem);
 vmem-=sizeof(_aa_memoryheader);
 aaCast(memhdr,_aa_memoryheader*,vmem);
 if(memhdr->is_user!=YES) { oof; return RET_FORBIDDEN; }
 if(bytes==0) { oof; }
 was_user=memhdr->is_user;
 aaStringCopy(was_name,memhdr->name);
 vmem+=sizeof(_aa_memoryheader);
 if((ret=aaMemoryAllocate((VP)&nmem,bytes))!=YES) { /*oops; aaNote(0,"realloc from %u to %u",by,bytes);*/ return ret; }
 if(bytes>=by) { aaMemoryCopy(nmem,by,vmem);  }
 else          { aaMemoryCopy(nmem,bytes,vmem);   }
 aaCast(vmem,BP,*mem);
 if((ret=aaMemoryRelease(vmem))!=YES) { oops; }
 aaCast(vmem,BP,nmem);
 vmem-=sizeof(_aa_memoryheader);
 aaCast(memhdr,_aa_memoryheader*,vmem);
 if(memhdr->magic!=VAL_aamh) { oof; }
 memhdr->is_user=was_user;
 aaStringCopy(memhdr->name,was_name);
 vmem+=sizeof(_aa_memoryheader);
 *mem=vmem;
 return RET_YES;
 }









 B aaMemoryDuplicate                   (PP mem,VP src)
 {
 B ret;
 H bytes;
 BP nm;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 *mem=NULL;
 if(src==NULL) { return RET_BADPARM; }
 //OutputDebugString(__func__);
 if(aaMemoryIsAllocated(src,&bytes)==YES)
  {
  if((ret=aaMemoryAllocate((VP)&nm,bytes))!=YES) { oops; }
  *mem=nm;
  aaMemoryNameSet(nm,"memdup");
  return RET_YES;
  }
 aaStringLen(src,&bytes);
 if(bytes==0||bytes>=_4MEG) { oof; return RET_FAILED; }
 if((ret=aaMemoryAllocate((VP)&nm,bytes+1))!=YES) { oops; }
 aaMemoryNameSet(nm,"memdupb");
 aaStringNCopy(nm,src,bytes,YES);
 *mem=nm;
 return RET_YES;
 }





 B aaMemoryMake                        (PP mem,H bytes)
 {
 B ret;
 BP vmem;
 H oldbytes;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bytes==0)  { return RET_BADPARM; }
 if(mem==NULL) { return RET_BADPARM; }
 if(*mem==NULL)
  {
  if((ret=aaMemoryAllocate((VP)&vmem,bytes))!=RET_YES) { oops; return ret; }
  aaMemoryNameSet(vmem,"memmak");
  *mem=vmem;
  return RET_YES;
  }
 aaCast(vmem,BP,*mem);
 vmem-=sizeof(_aa_memoryheader);
 vmem+=sizeof(_aa_memoryheader);
 if((ret=aaMemoryBytesGet(vmem,&oldbytes))!=RET_YES) { oof; return ret; }
 if(oldbytes==0) oof;
 if(oldbytes!=bytes)
  {
  if((ret=aaMemoryReAllocate((VP)&vmem,bytes))!=RET_YES) { oof; return ret; }
  }
 *mem=vmem;
 return RET_YES;
 }



 B aaMemoryNameSet                     (VP mem,VP fmt,...)
 {
 _aa_memoryheader*memhdr;
 BP vmem;
 aaVargsf(fmt);
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) {  return RET_BADPARM; }
 if(str64k.len==0||((str64k.len+1)>=sizeof(memhdr->name))) { return RET_BOUNDS;  }
 aaCast(vmem,BP,mem);
 vmem-=sizeof(_aa_memoryheader);
 aaCast(memhdr,_aa_memoryheader*,vmem);
 if(memhdr->magic!=VAL_aamh)  { oof;  return RET_NO;  }
 if(memhdr->is_user!=YES) {  oof; return RET_FORBIDDEN; }
 aaMemoryFill(memhdr->name,sizeof(memhdr->name),0);
 aaStringCopy(memhdr->name,str64k.buf);
 return RET_YES;
 }



 B aaMemoryNameGet                     (VP mem,VP name)
 {
 _aa_memoryheader*memhdr;
 BP vmem;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(name==NULL) {  return RET_BADPARM; }
 aaStringNull(name);
 if(mem==NULL) {  return RET_BADPARM; }
 aaCast(vmem,BP,mem);
 vmem-=sizeof(_aa_memoryheader);
 aaCast(memhdr,_aa_memoryheader*,vmem);
 if(memhdr->magic!=VAL_aamh)  { oof;  return RET_NO;  }
 aaStringCopy(name,memhdr->name);
 return RET_YES;
 }




 B aaMemoryIsAllocated                 (VP mem,HP bytes)
 {
 _aa_memoryheader*memhdr;
 BP vmem;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bytes!=NULL) { *bytes=0; }
 if(mem==NULL) {  return RET_NO; }
 aaCast(vmem,BP,mem);
 vmem-=sizeof(_aa_memoryheader);
 aaCast(memhdr,_aa_memoryheader*,vmem);
 if(memhdr->magic!=VAL_aamh)  {  return RET_NO;  }
 if(bytes) { *bytes=memhdr->bytes; }
 return RET_YES;
 }





 B aaMemoryBytesGet                    (VP mem,HP bytes)
 {
 _aa_memoryheader*memhdr;
 BP vmem;
 //C delme[_8K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bytes!=NULL) { *bytes=0; }
 if(mem==NULL)   {  return RET_BADPARM; }
 aaCast(vmem,BP,mem);
 vmem-=sizeof(_aa_memoryheader);
 aaCast(memhdr,_aa_memoryheader*,vmem);
 if(memhdr->magic!=VAL_aamh)
  {
  /*
  sprintf(delme,"%s %u magic=%-8i %-8i rac=%i use=%i prot=%i lock=%i by=%i actlen=%i minitype=%i minindex=%i name=%s\r\n\0\0",
                 __func__,__LINE__,
                 memhdr->magic,VAL_aamh ,memhdr->realloc_count,memhdr->is_user,
                 memhdr->is_protected,memhdr->is_locked,
                 memhdr->bytes,memhdr->actual_len,
                 memhdr->mini_type,memhdr->mini_index,memhdr->name);
  OutputDebugString(delme);
  */
  if(bytes) { *bytes=0; }
  return RET_FAILED;
  }
 if(bytes)
  {
  *bytes=memhdr->bytes;
  }
 return RET_YES;
 }


 B aaMemoryBlockGet                    (PP mem,HP bytes,H id)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bytes) *bytes=0;
 if(mem) *mem=NULL;
 UNUSE(id);
 return RET_NOTINITIALIZED;
 }





 B aaMemoryRelease                     (VP mem)
 {
 B ret;
 H bytes;
 _aa_memoryheader*memhdr;
 BP vmem;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaMemoryBytesGet(mem,&bytes))!=RET_YES) { return ret; }
 aaCast(vmem,BP,mem);
 vmem-=sizeof(_aa_memoryheader);
 aaCast(memhdr,_aa_memoryheader*,vmem);
 if(memhdr->is_user!=YES) {  oof; return RET_FORBIDDEN; }
 if((ret=aa_MemoryRelease(mem))!=YES) {  oops; return ret; }
 aa.memory_system.status.user_bytes_allocated-=bytes;
 aa.memory_system.status.user_blocks_allocated--;
 return RET_YES;
 }




 B aaMemoryAdlerCrcGet                 (VP mem,H bytes,HP crc)
 {
 H s1,s2,oldcrc;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 if(bytes==0)  { return RET_YES; }
 if(crc==NULL) { return RET_BADPARM; }
 oldcrc=*crc;
 aaCast(bp,BP,mem);
 s1=oldcrc&F16;
 s2=(oldcrc>>16)&F16;
 while(bytes>0)
  {
  s1+=*bp++;
  s2+=s1;
  bytes--;
  s1%=65521L;
  s2%=65521L;
  }
 oldcrc=(s2<<16)|s1;
 *crc=oldcrc;
 if(*crc==0) { oof; }
 return RET_YES;
 }





 B aaMemoryCrcGet                      (VP mem,H bytes,HP crc)
 {
 H oldcrc;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 if(crc==NULL) { return RET_BADPARM; }
 if(bytes==0)  { return RET_YES; }
 oldcrc=*crc;
 aaCast(bp,BP,mem);
 while(1)
  {
  oldcrc=(aa.memory_system.crc_table[((oldcrc)^(*bp))&0xff]^((oldcrc)>>8));
  bytes--;
  if(bytes==0) { break; }
  bp++;
  }
 *crc=oldcrc=~oldcrc;
 if(*crc==0) { oof; }
 return RET_YES;
 }





 B aaMemoryCrc64Get                    (VP mem,H bytes,QP crc)
 {
 Q oldcrc,lookup;
 H i;
 B index;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 if(crc==NULL) { return RET_BADPARM; }
 if(bytes==0)  { return RET_YES; }
 oldcrc=*crc;
 aaCast(bp,BP,mem);
 i=0;
 for(i=0;i<bytes;i++)
  {
  index=bp[i]^oldcrc;
  lookup=aa.memory_system.crc64_table[index];
  oldcrc>>=8;
  oldcrc^=lookup;
  }
 *crc=oldcrc;
 return RET_YES;
 }





 B aaMemoryHashGet                     (VP mem,H bytes,HP hash)
 {
 BP bp;
 H h;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(hash==NULL) { return RET_BADPARM; }
 if(mem==NULL) { return RET_BADPARM; }
 aaCast(bp,BP,mem);
 h=*hash;
 while(bytes--)
  {
  h+=*bp++;
  h+=(h<<10);
  h^=(h>>6);
  }
 h+=(h<<3);
 h^=(h>>11);
 h+=(h<<15);
 if(h==0) { h=1; }
 *hash=h;
 return RET_YES;
 }





 B aaMemoryMurmurHashGet               (VP mem,H bytes,H seed,HP hash)
 {
 BP tail,data;
 Z i,nblocks;
 H k1,h1,c1,c2;
 HP blocks;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 ///if(mem==NULL)  { return RET_BADPARM; }
 if(hash==NULL) { return RET_BADPARM; }
 *hash=0;
 //*hash=0xfeda3256;
 data=(BP)mem;
 nblocks=bytes/4;
 h1=seed;
 c1=0xcc9e2d51;
 c2=0x1b873593;
 blocks=(HP)(data+nblocks*4);
 for(i=-nblocks;i;i++)
  {
  k1=blocks[i];
  k1*=c1;
  k1=(k1<<15)|(k1>>(32-15));
  k1*=c2;
  h1^=k1;
  h1=(h1<<13)|(h1>>(32-13));
  h1=h1*5+0xe6546b64;
  }
 tail=(B*)(data+nblocks*4);
 k1=0;
 switch(bytes&3)
  {
  case 3: k1^=tail[2]<<16;
  case 2: k1^=tail[1]<<8;
  case 1: k1^=tail[0];
          k1*=c1;
          k1=(k1<<15)|(k1>>(32-15));
          k1*=c2;
          h1^=k1;
  };
 h1^=bytes;
 h1^=h1>>16;
 h1*=0x85ebca6b;
 h1^=h1>>13;
 h1*=0xc2b2ae35;
 h1^=h1>>16;
 *hash=h1;
 return RET_YES;
 }






 B aaMemoryValueFill                   (VP mem,H count,H valbytes,VP valmem)
 {
 BP bp;
 BP sp;
 H i,j,z;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 if(count==0) { return RET_YES; }
 if(valbytes==0) { return RET_YES; }
 if(valmem==NULL) { return RET_BADPARM; }
 aaCast(bp,BP,mem);
 aaCast(sp,BP,valmem);
 z=0;
 for(i=0;i<count;i++)
  {
  for(j=0;j<valbytes;j++)
   {
   bp[z++]=sp[j];
   }
  }
 return RET_YES;
 }





 B aaMemoryPokeByte                    (VP mem,H offset,B val)
 {
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 aaCast(bp,BP,mem);
 bp+=offset;
 *bp=val;
 return RET_YES;
 }




 B aaMemoryPokeWord                    (VP mem,H offset,W val)
 {
 BP bp;
 WP wp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 aaCast(bp,BP,mem);
 bp+=offset;
 aaCast(wp,WP,bp);
 *wp=val;
 return RET_YES;
 }




 B aaMemoryPokeDword                   (VP mem,H offset,H val)
 {
 BP bp;
 HP hp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 aaCast(bp,BP,mem);
 bp+=offset;
 aaCast(hp,HP,bp);
 *hp=val;
 return RET_YES;
 }



 B aaMemoryPokeQuad                    (VP mem,H offset,Q val)
 {
 BP bp;
 QP qp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 aaCast(bp,BP,mem);
 bp+=offset;
 aaCast(qp,QP,bp);
 *qp=val;
 return RET_YES;
 }



 B aaMemoryPeekByte                    (VP mem,H offset,BP val)
 {
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 if(val==NULL) { return RET_BADPARM; }
 aaCast(bp,BP,mem);
 bp+=offset;
 *val=*bp;
 return RET_YES;
 }




 B aaMemoryPeekWord                    (VP mem,H offset,WP val)
 {
 BP bp;
 WP wp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 if(val==NULL) { return RET_BADPARM; }
 aaCast(bp,BP,mem);
 bp+=offset;
 aaCast(wp,WP,bp);
 *val=*wp;
 return RET_YES;
 }




 B aaMemoryPeekDword                   (VP mem,H offset,HP val)
 {
 BP bp;
 HP hp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 if(val==NULL) { return RET_BADPARM; }
 aaCast(bp,BP,mem);
 bp+=offset;
 aaCast(hp,HP,bp);
 *val=*hp;
 return RET_YES;
 }



 B aaMemoryPokeDwordAndInc             (VP mem,HP offset,H val)
 {
 BP bp;
 H off;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 if(offset==NULL) { return RET_BADPARM; }
 off=*offset;
 aaCast(bp,BP,mem);
 *(HP)&bp[off]=val;
 *offset=off+4;
 return RET_YES;
 }


 B aaMemoryPeekDwordAndInc             (VP mem,HP offset,HP val)
 {
 BP bp;
 H off;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 if(offset==NULL) { return RET_BADPARM; }
 if(val==NULL) { return RET_BADPARM; }
 off=*offset;
 aaCast(bp,BP,mem);
 *val=*(HP)&bp[off];
 *offset=off+4;
 return RET_YES;
 }




 B aaMemoryCompare                     (VP dst,H bytes,VP src,NP dif)
 {
 BP s1,s2;
 B c1,c2;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(dif!=NULL) { *dif=-1; }
 if(dst==NULL) { return RET_BADPARM; }
 if(src==NULL) { return RET_BADPARM; }
 aaCast(s1,BP,dst);
 aaCast(s2,BP,src);
 while(1)
  {
  if(bytes==0) { break; }
  c1=*s1;
  c2=*s2;
  if(c1!=c2)
   {
   if(dif) { *dif=(N)(c1-c2); }
   return RET_NO;
   }
  bytes--;
  if(bytes==0) { break; }
  s1++;
  s2++;
  }
 if(dif) { *dif=0; }
 return RET_YES;
 }





 B aaMemoryRandomSet                   (VP dst,H bytes)
 {
 BP bp;
 H i,ra;
 BP rp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(dst==NULL) { return RET_BADPARM; }
 if(bytes==0) { return RET_FAILED; }
 bp=(BP)dst;
 for(i=0;i<bytes;i++)
  {
  if((i%4)==0)
   {
   ra=aaMathTwisterInt32(&aa.math_system.twister);
   rp=(BP)&ra;
   }
  bp[i]=rp[i%4];
  }
 return RET_YES;
 }



 B aaMemoryRandomDwordSet              (HP val,H lo,H hi)
 {
 H rn,v;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(val==NULL) { return RET_BADPARM; }
 if(lo>hi) { return RET_BADPARM; }
 rn=(hi-lo)+1;
 aaMemoryRandomSet(&v,4);
 v%=(rn);
 *val=(lo+v);
 return RET_YES;
 }


 B aaMemoryRandomHit                   (H lo,H hi,H eq)
 {
 B ret;
 H val;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaMemoryRandomDwordSet(&val,lo,hi))!=YES) { return ret; }
 if(val!=eq) { return RET_NO; }
 return RET_YES;
 }




 B aaMemoryPageAllocate                (HP handle)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_PageAllocate(handle,NULL,"userpage"))!=RET_YES) { return ret; }
 aa.memory_system.status.user_pages_allocated++;
 if(aa.memory_system.status.user_pages_allocated>aa.memory_system.status.peak_user_pages_allocated)
  {
  aa.memory_system.status.peak_user_pages_allocated=aa.memory_system.status.user_pages_allocated;
  }
 return RET_YES;
 }




 B aaMemoryPageRelease                 (H handle)
 {
 B ret;
 B isprot,isuser;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_PageStatus(handle,NULL,&isprot,&isuser))!=RET_YES) { return ret; }
 if(isuser==NO) { return RET_BADHANDLE; }
 if(isprot==YES) { return RET_FORBIDDEN; }
 if((ret=aa_PageRelease(handle))!=RET_YES) { return ret; }
 aa.memory_system.status.user_pages_allocated--;
 return RET_YES;
 }




 B aaMemoryPageProtect                 (H handle,B state)
 {
 B ret;
 B isprot,isuser;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_PageStatus(handle,NULL,&isprot,&isuser))!=RET_YES) { return ret; }
 if(isuser==NO) { return RET_BADHANDLE; }
 if((ret=aa_PageProtect(handle,state))!=RET_YES) { return ret; }
 return RET_YES;
 }




 B aaMemoryPageGet                     (H handle,PP mem,BP isprotected)
 {
 B ret;
 B isuser;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_PageStatus(handle,mem,isprotected,&isuser))!=RET_YES) { return ret; }
 if(isuser==NO) { return RET_BADHANDLE; }
 return RET_YES;
 }





 B aaMemoryCodeAllocate                (PP mem,H bytes)
 {
 BP vmem;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 *mem=NULL;
 if(bytes==0) { aaNote(0,"aamemoryCodeallocate  %i",bytes); return RET_BADPARM; }
 if((vmem=VirtualAlloc(NULL,bytes+(aa_MEMORY_OPCODE_SAFETY*2),MEM_COMMIT,PAGE_EXECUTE_READWRITE))==NULL)
  {
  return RET_NOMEMORY;
  }
 *mem=&vmem[aa_MEMORY_OPCODE_SAFETY];
 return RET_YES;
 }





 B aaMemoryCodeRelease                 (VP mem)
 {
 BP vmem;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 aaCast(vmem,BP,mem);
 vmem-=(aa_MEMORY_OPCODE_SAFETY);
 if(VirtualFree(vmem,0,MEM_RELEASE)==0) { oof; oow; return RET_FAILED; }
 return RET_YES;
 }





 B aaMemorySort                        (VP mem,H entries,H entrybytes,VP usrdata,B(*proc)(VP,H,H,VP,VP,VP,NP))
 {
 VP lbStack[qsMAXSTACK];
 VP ubStack[qsMAXSTACK];
 Z sp;
 N dif;
 Y offset;
 CP lb,ub,m,P,i,j;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(entrybytes==0) { return RET_BADPARM; }
 if(entrybytes>=_16K)  { return RET_NOMEMORY; }
 if(entries==0) { return RET_NOTFOUND; }
 UNUSE(usrdata);
 UNUSE(proc);
 if(entries==1) { return RET_YES; }
 lbStack[0]=(CP)mem;
 ubStack[0]=(CP)mem+(entries-1)*entrybytes;
 for(sp=0;sp>=0;sp--)
  {
  lb=(CP)lbStack[sp];
  ub=(CP)ubStack[sp];
  while(lb<ub)
   {
   offset=(ub-lb)>>1;
   P=lb+offset-offset%entrybytes;
   qsEXCHANGE(lb,P,(N)entrybytes);
   i=lb+entrybytes;
   j=ub;
   while(1)
    {
    while(1)
     {
     if(i>=j) break;
     if(proc) proc(mem,entries,entrybytes,usrdata,lb,i,&dif);
     else     aaMemoryCompareProc(mem,entries,entrybytes,usrdata,lb,i,&dif);
     if(dif<=0) break;
     i+=entrybytes;
     }
    while(1)
     {
     if(j<i) break;
     if(proc) proc(mem,entries,entrybytes,usrdata,j,lb,&dif);
     else     aaMemoryCompareProc(mem,entries,entrybytes,usrdata,j,lb,&dif);
     if(dif<=0) break;
     j-=entrybytes;
     }
    if(i>=j) break;
    qsEXCHANGE(i,j,(N)entrybytes);
    j-=entrybytes;
    i+=entrybytes;
    }
   qsEXCHANGE(lb,j,(N)entrybytes);
   m=j;
   if(m-lb<=ub-m)  { if(m+entrybytes<ub) { lbStack[sp]=m+entrybytes;  ubStack[sp++]=ub;    }  ub=m-entrybytes;    }
   else             { if(m-entrybytes>lb) { lbStack[sp]=lb;  ubStack[sp++]=m-entrybytes;    }  lb=m+entrybytes;    }
   }
  }
 return RET_YES;
 }



 B aaMemoryCompareProc                 (VP mem,H entries,H entrybytes,VP usrdata,VP itema,VP itemb,NP dif)
 {
 UNUSE(mem);
 UNUSE(entries);
 UNUSE(entrybytes);
 UNUSE(usrdata);
 return(aaStringCompare(itemb,itema,dif));
 }



 B aaMemorySearch                      (VP mem,H entries,H entrybytes,VP usrdata,VP data,HP index,B(*proc)(VP,H,H,VP,VP,VP,NP))
 {
 H mid,lo,hi;
 BP bp;
 N res;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(index) { *index=0xffffffff; }
 if(entrybytes==0) { return RET_BADPARM; }
 if(entrybytes>=_16K)  { return RET_NOMEMORY; }
 if(entries==0) { return RET_NOTFOUND; }
 if(data==NULL) { return RET_BADPARM; }
 UNUSE(usrdata);
 UNUSE(proc);
 aaCast(bp,BP,mem);
 lo=0;
 hi=entries-1;
 while((N)lo<=(N)hi)
  {
  mid=lo+((hi-lo)/2);
  if(proc) proc(mem,entries,entrybytes,usrdata,data,&bp[mid*entrybytes],&res);
  else     aaMemoryCompareProc(mem,entries,entrybytes,usrdata,data,&bp[mid*entrybytes],&res);
  if(res==0) { if(index) { *index=mid; } return RET_YES;}
  if(res>0)  { lo=mid+1;  }
  else       { hi=mid-1;  }
  }
 return RET_NOTFOUND;
 }



 B aaMemoryOrderSort                   (VP mem,H entries,H stride,H offset,H size,B issigned,B des,HP order)
 {
 B ret;
 H i,j;
 H hold,which;
 G dif=0;
 BP bp;
 BP arb[2];
 CP arc[2];
 IP ari[2];
 WP arw[2];
 NP arn[2];
 HP arh[2];
 GP arg[2];
 QP arq[2];

 BP tmp;
 BP blb;
 HP ord;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }

 ord=(HP)order;
 if(ord==NULL)
  {
  if((ret=aa_MemoryTemp((VP)&tmp,entries*4,aa_MEMORYTEMP_OrderSort))!=RET_YES) { oops; }
  if((ret=aa_MemoryTemp((VP)&blb,entries*stride,aa_MEMORYTEMP_OrderBlob))!=RET_YES)    { oops; }
  ord=(HP)tmp;
  }
 if(ord==NULL) { return RET_BADPARM; }

 if(entries==0)
  {
  ord[0]=0;
  return RET_YES;
  }
 des&=1;
 bp=(BP)mem;

 which=0;
 if(size==1&&issigned)  { which=1; } else
 if(size==1&&!issigned) { which=2; } else
 if(size==2&&issigned)  { which=3; } else
 if(size==2&&!issigned) { which=4; } else
 if(size==4&&issigned)  { which=5; } else
 if(size==4&&!issigned) { which=6; } else
 if(size==8&&issigned)  { which=7; } else
 if(size==8&&!issigned) { which=8; } else { return RET_BADPARM; }
 if(des==0) { for(i=0;i<entries;i++) { ord[i]=entries-i-1;  } }
 else       { for(i=0;i<entries;i++) { ord[i]=i;            } }

 for(i=0;i<entries-0;i++)
  {
  for(j=0;j<entries-1;j++)
   {
   bp=(BP)mem;
   bp+=(ord[j+1]*stride)+offset;
   arc[0]=(CP)bp; arb[0]=(BP)bp;
   ari[0]=(IP)bp; arw[0]=(WP)bp;
   arn[0]=(NP)bp; arh[0]=(HP)bp;
   arg[0]=(GP)bp; arq[0]=(QP)bp;

   bp=(BP)mem;
   bp+=(ord[j]*stride)+offset;
   arc[1]=(CP)bp; arb[1]=(BP)bp;
   ari[1]=(IP)bp; arw[1]=(WP)bp;
   arn[1]=(NP)bp; arh[1]=(HP)bp;
   arg[1]=(GP)bp; arq[1]=(QP)bp;

   if(which==1) {  dif=(G)*arc[0]-(G)*arc[1]; } else
   if(which==2) {  dif=(Q)*arb[0]-(Q)*arb[1]; } else
   if(which==3) {  dif=(G)*ari[0]-(G)*ari[1]; } else
   if(which==4) {  dif=(Q)*arw[0]-(Q)*arw[1]; } else
   if(which==5) {  dif=(G)*arn[0]-(G)*arn[1]; } else
   if(which==6) {  dif=(Q)*arh[0]-(Q)*arh[1]; } else
   if(which==7) {  dif=(G)*arg[0]-(G)*arg[1]; } else
   if(which==8) {  dif=(Q)*arq[0]-(Q)*arq[1]; }

   if((+des&&dif>0)||(!des&&dif<0))
    {
    hold=ord[j];
    ord[j]=ord[j+1];
    ord[j+1]=hold;
    }
   }
  }
 if(order==NULL)
  {
  aaMemoryCopy(blb,entries*stride,mem);
  bp=(BP)mem;
  for(i=0;i<entries;i++)
   {
   aaMemoryCopy(&bp[i*stride],stride,&blb[ord[i]*stride]);
   }
  }
 return RET_YES;
 }




 B aaMemoryUnitAllocate                (_memoryunit*memoryunit,H bytes)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(memoryunit==NULL) { return RET_BADPARM; }
 if(bytes==0) { return RET_BADPARM; }
 memoryunit->bytes=0;
 memoryunit->offset=0;
 memoryunit->used=0;
 memoryunit->mem=NULL;
 if((ret=aaMemoryAllocate((VP)&memoryunit->mem,bytes))!=YES)
  {
  aaNote(0,"memoryunitalloc %s %uM",ret_string[ret],bytes/_1MEG);
  return ret;
  }
 aaMemoryNameSet(memoryunit->mem,"MemoryUnit");
 memoryunit->bytes=bytes;
 return RET_YES;
 }






 B aaMemoryUnitReAllocate              (_memoryunit*memoryunit,H bytes)
 {
 B ret;
 H from;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(memoryunit==NULL) { return RET_BADPARM; }
 if(memoryunit->bytes==0) { return RET_FAILED; }
 if(memoryunit->mem==NULL) { return RET_FAILED; }
 from=memoryunit->bytes;
 if((ret=aaMemoryReAllocate((VP)&memoryunit->mem,bytes))!=YES)
  {
  UNUSE(from);
  return ret;
  }
 memoryunit->bytes=bytes;
 return RET_YES;
 }




 B aaMemoryUnitMake                    (_memoryunit*memoryunit,H bytes)
 {
 B ret;
 H by;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(memoryunit==NULL) { return RET_BADPARM; }
 if(bytes==0) { return RET_BADPARM; }
 if(aaMemoryBytesGet(memoryunit->mem,&by)!=YES)
  {
  if((ret=aaMemoryUnitAllocate(memoryunit,bytes))!=YES) { return ret; }
  }
 if(by!=memoryunit->bytes) { oof; }
 if(bytes==memoryunit->bytes) { return RET_YES; }
 if((ret=aaMemoryUnitReAllocate(memoryunit,bytes))!=YES) { return ret; }
 return RET_YES;
 }




 B aaMemoryUnitRelease                 (_memoryunit*memoryunit)
 {
 B ret;
 H bytes;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(memoryunit==NULL) { oof; return RET_BADPARM; }
 if(memoryunit->bytes==0) { oof; return RET_FAILED; }
 if(memoryunit->mem==NULL) { oof; return RET_FAILED; }
 if((ret=aaMemoryBytesGet(memoryunit->mem,&bytes))!=YES) { oops; return ret; }
 if(bytes!=memoryunit->bytes) { oof; return RET_FAILED; }
 if((ret=aaMemoryRelease(memoryunit->mem))!=YES) { oops; }
 memoryunit->bytes=0;
 memoryunit->offset=0;
 memoryunit->used=0;
 memoryunit->mem=NULL;
 return RET_YES;
 }


 B aaMemoryUnitNameSet                 (_memoryunit*memoryunit,VP fmt,...)
 {
 aaVargsf(fmt);
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(memoryunit==NULL) {  return RET_BADPARM; }
 ///if(memoryunit==NULL) { oof; return RET_BADPARM; }
 //if(memoryunit->bytes==0) { aaNote(0,"%s",str64k.buf); return RET_FAILED; }
 if(memoryunit->mem==NULL) { oof; return RET_FAILED; }
 return(aaMemoryNameSet(memoryunit->mem,"%s",str64k.buf));
 }



 B aaMemoryUnitNameGet                 (_memoryunit*memoryunit,VP name)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(memoryunit==NULL) {  return RET_BADPARM; }
 if(memoryunit==NULL) { oof; return RET_BADPARM; }
 if(memoryunit->bytes==0) { oof; return RET_FAILED; }
 if(memoryunit->mem==NULL) { oof; return RET_FAILED; }
 return(aaMemoryNameGet(memoryunit->mem,name));
 }





 B aaMemoryWorkingSetSizeSet           (H minbytes,H maxbytes)
 {
 H s,mi,mx;
 HANDLE h;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(minbytes==0||minbytes==0xffffffff) { minbytes=aa.memory_system.status.working_set_size_min; }
 if(maxbytes==0||maxbytes==0xffffffff) { maxbytes=aa.memory_system.status.working_set_size_max; }
 if(minbytes>maxbytes) { s=minbytes; minbytes=maxbytes; maxbytes=s; }
 h=aa.core_system.process_handle;
 if(SetProcessWorkingSetSize(h,minbytes,maxbytes)==0) { oof; oow; return RET_FAILED; }
 if(!GetProcessWorkingSetSize(h,&mi,&mx)) { oof; oow; return RET_FAILED; }
 aa.memory_system.status.working_set_size_min=mi;
 aa.memory_system.status.working_set_size_max=mx;
 return RET_YES;
 }




 B aaMemoryWorkingSetFlush             (V)
 {
 B ret;
 HANDLE h;
 H mi,mx;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 mi=aa.memory_system.status.working_set_size_min;
 mx=aa.memory_system.status.working_set_size_max;
 h=aa.core_system.process_handle;
 if(SetProcessWorkingSetSize(h,0xffffffff,0xffffffff)==0) { oof; oow; return RET_FAILED; }
 aa.memory_system.status.working_set_flush_count++;
 if((ret=aaMemoryWorkingSetSizeSet(mi,mx))!=YES) { oops; return ret; }
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/


 V aa_BloomMurmurHash3                 (VP key,Z len,H seed,VP out)
 {
 BP tail;
 BP data=(BP)key;
 Z nblocks=len/4;
 Z i;
 H k1;
 H h1=seed;
 H c1=0xcc9e2d51;
 H c2=0x1b873593;
 HP blocks=(HP)(data+nblocks*4);
 for(i=-nblocks;i;i++)
  {
  k1=blocks[i];
  k1*=c1;
  k1=(k1<<15)|(k1>>(32-15));
  k1*=c2;
  h1^=k1;
  h1=(h1<<13)|(h1>>(32-13));
  h1=h1*5+0xe6546b64;
  }
 tail=(B*)(data+nblocks*4);
 k1=0;
 switch(len&3)
  {
  case 3: k1^=tail[2]<<16;
  case 2: k1^=tail[1]<<8;
  case 1: k1^=tail[0];
          k1*=c1;
          k1=(k1<<15)|(k1>>(32-15));
          k1*=c2;
          h1^=k1;
  };
 h1^=len;
 h1^=h1>>16;
 h1*=0x85ebca6b;
 h1^=h1>>13;
 h1*=0xc2b2ae35;
 h1^=h1>>16;
 *(HP)out=h1;
 }








 B aaBloomNew                          (_bloom*bloom,H bytes,B cs,VP filtermem)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bloom==NULL) { return RET_BADPARM; }
 if(bytes==0) { return RET_BADPARM; }
 cs&=1;
 aaMemoryFill(bloom,sizeof(_bloom),0);
 bloom->magic=aaHPP(aaBloomNew);
 bloom->bytes=bytes;
 bloom->is_cs=cs;
 if(filtermem==NULL)
  {
  bloom->is_allocated=YES;
  if((ret=aaMemoryAllocate((VP)&bloom->filter,bloom->bytes))!=YES) { oops; }
  }
 else
  {
  bloom->is_allocated=NO;
  bloom->filter=filtermem;
  }
 return RET_YES;
 }





 B aaBloomDelete                       (_bloom*bloom)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bloom==NULL) { return RET_BADPARM; }
 if(bloom->magic!=aaHPP(aaBloomNew)) { return RET_NOTINITIALIZED; }
 if(bloom->is_allocated)
  {
  if(bloom->filter!=NULL&&bloom->bytes!=0)
   {
   aaMemoryRelease(bloom->filter);
   }
  }
 aaMemoryFill(bloom,sizeof(_bloom),0);
 return RET_YES;
 }








 B aaBloomFind                         (_bloom*bloom,H bytes,VP data)
 {
 H hash,index;
 H byte_index,bit_index;
 B r;
 Q qq;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bloom==NULL) { return RET_BADPARM; }
 if(bloom->magic!=aaHPP(aaBloomNew)) { return RET_NOTINITIALIZED; }
 if(data==NULL) { return RET_BADPARM; }
 if(bytes==0)   { aaStringLen(data,&bytes);  }
 if(bytes==0)   { return RET_BADPARM; }
 hash=65537;
 UNUSE(qq);
 if(bloom->is_cs)
  {
  aa_BloomMurmurHash3(data,bytes,hash,&hash);
  if(hash==0) oof;
  }
 else
  {
  aaStringHashGet(data,bytes,&hash,NO);
  }
 index=hash%(bloom->bytes<<3);
 byte_index=index>>3;
 bit_index=index&7;
 bloom->find_loops++;
 r=(bloom->filter[byte_index]&(1<<bit_index))!=0;
 if(r) { bloom->possibles++; return RET_POSSIBLE; }
 bloom->misses++;
 return RET_NOTFOUND;
 }





 B aaBloomFindf                        (_bloom*bloom,VP fmt,...)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bloom==NULL) { return RET_BADPARM; }
 if(bloom->magic!=aaHPP(aaBloomNew)) { return RET_NOTINITIALIZED; }
 aaVargsf(fmt);
 return(aaBloomFind(bloom,str64k.len,str64k.buf));
 }



 /*
 thought:

 should I do a aaBloomFind and only proceed to aaBloomAdd if it returns NOT_FOUND ?
 */



 B aaBloomAdd                          (_bloom*bloom,H bytes,VP data)
 {
 H hash,index;
 H byte_index,bit_index;
 Q qq;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bloom==NULL) { return RET_BADPARM; }
 if(bloom->magic!=aaHPP(aaBloomNew)) { return RET_NOTINITIALIZED; }
 if(data==NULL) { return RET_BADPARM; }
 if(bytes==0)   { aaStringLen(data,&bytes);  }
 if(bytes==0)   { return RET_BADPARM; }
 UNUSE(qq);
 hash=65537;
 if(bloom->is_cs)
  {
  aa_BloomMurmurHash3(data,bytes,hash,&hash);
  if(hash==0) oof;
  }
 else
  {
  aaStringHashGet(data,bytes,&hash,NO);
  }
 index=hash%(bloom->bytes<<3);
 byte_index=index>>3;
 bit_index=index&7;
 bloom->add_loops++;
 bloom->filter[byte_index]|=(1<<bit_index);
 bloom->items++;
 return RET_YES;
 }





 B aaBloomAddf                         (_bloom*bloom,VP fmt,...)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bloom==NULL) { return RET_BADPARM; }
 if(bloom->magic!=aaHPP(aaBloomNew)) { return RET_NOTINITIALIZED; }
 aaVargsf(fmt);
 return(aaBloomAdd(bloom,str64k.len,str64k.buf));
 }





 B aaBloomLoad                         (_bloom*bloom,VP fmt,...)
 {
 B ret;
 _filestreamunit fsu;
 _packet pkt;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bloom==NULL) { return RET_BADPARM; }
 aaMemoryFill(bloom,sizeof(_bloom),0);
 aaVargsf4K(fmt);
 if((ret=aaFileStreamCreate(&fsu.handle,str4k.buf,aa_FILECREATE_OPEN,aa_FILEMODE_RW,aa_FILESHARE_RW,0,NO))!=RET_YES) { oops; }
 aaFileStreamStatus(fsu.handle,&fsu.status);
 aaPacketNew(&pkt);
 aaPacketAppend(&pkt,45,NULL);
 if((ret=aaFileStreamRead(fsu.handle,45,pkt.data))!=YES) { oops; }
 bloom->magic=aaHPP(aaBloomNew);
 aaPacketOffsetSet(&pkt,0);
 aaPacketRead(&pkt,1,&bloom->is_cs);
 aaPacketRead(&pkt,4,&bloom->bytes);
 aaPacketRead(&pkt,8,&bloom->items);
 aaPacketRead(&pkt,8,&bloom->possibles);
 aaPacketRead(&pkt,8,&bloom->misses);
 aaPacketRead(&pkt,8,&bloom->add_loops);
 aaPacketRead(&pkt,8,&bloom->find_loops);
 if((ret=aaMemoryAllocate((VP)&bloom->filter,bloom->bytes))!=YES) { oops; }
 aaPacketDelete(&pkt);
 if((ret=aaFileStreamRead(fsu.handle,bloom->bytes,bloom->filter))!=YES) { oops; }
 aaFileStreamDestroy(fsu.handle);
 return RET_YES;
 }




 B aaBloomSave                         (_bloom*bloom,VP fmt,...)
 {
 B ret;
 _filestreamunit fsu;
 _packet pkt;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bloom==NULL) { return RET_BADPARM; }
 if(bloom->magic!=aaHPP(aaBloomNew)) { return RET_NOTINITIALIZED; }
 aaVargsf4K(fmt);
 if((ret=aaFileStreamCreate(&fsu.handle,str4k.buf,aa_FILECREATE_CREATENEW,aa_FILEMODE_RW,aa_FILESHARE_RW,0,NO))!=RET_YES) { oops; }
 aaFileStreamStatus(fsu.handle,&fsu.status);
 aaPacketNew(&pkt);
 aaPacketAppendByte(&pkt,bloom->is_cs);
 aaPacketAppendDword(&pkt,bloom->bytes);
 aaPacketAppendQuad(&pkt,bloom->items);
 aaPacketAppendQuad(&pkt,bloom->possibles);
 aaPacketAppendQuad(&pkt,bloom->misses);
 aaPacketAppendQuad(&pkt,bloom->add_loops);
 aaPacketAppendQuad(&pkt,bloom->find_loops);
 if((ret=aaFileStreamWrite(fsu.handle,pkt.size,pkt.data))!=RET_YES) { oops; }
 aaPacketDelete(&pkt);
 if((ret=aaFileStreamWrite(fsu.handle,bloom->bytes,bloom->filter))!=RET_YES) { oops; }
 aaFileStreamDestroy(fsu.handle);
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/


 B aa_ChainExpand                      (_chain*chain,B domem)
 {
 B ret;
 D div;
 H chlisi,state,add,pls;

 aaMagicCheck(chain,aaChainNew);
 domem&=1;
 if(domem)  {  chlisi=chain->mem.bytes;  pls=8192; }
 else       {  chlisi=chain->link_slots; pls=0;    }
 if(chlisi<(pls+256))  { state=0; add=(pls+336);  } else
 if(chlisi<(pls+512))  { state=1; add=(pls+768);  } else
 if(chlisi<(pls+1024)) { state=2; add=(pls+1400); } else { state=3; add=(pls+1800); }
 div=(30+(state*10))/100.0;
 add=(add+chlisi)+(chlisi*div);
 if(domem)
  {
  if(add==chain->mem.bytes) {  aaNote(0,"redundent memory reallocation with same size, %i",add);  }
  if(chain->mem.bytes==0)   { ret=aaMemoryUnitAllocate(&chain->mem,add);    }
  else                      { ret=aaMemoryUnitReAllocate(&chain->mem,add);  }
  if(ret!=RET_YES)          { oops; } //aaNote(0,"%s\n%s\n#%i\n%s oldmembytes=%i add=%i",__FILE__,__FUNCTION__,__LINE__,ret_string[ret],old_mem_bytes,add); }
  aaMemoryUnitNameSet(&chain->mem,"chainmem-domem");
  }
 else
  {
  if(add==chain->link_slots) {  aaNote(0,"redundent memory reallocation with same size, %i",add);  }
  if(chain->link_slots==0)   {  ret=aaMemoryAllocate((VP)&chain->link,add*sizeof(_chainlink));     }
  else                       {  ret=aaMemoryReAllocate((VP)&chain->link,add*sizeof(_chainlink));   }
  if(ret!=RET_YES)           {  oops;  }
  if(chain->link_slots==0)   {  if(aaMemoryNameSet(chain->link,"chainmem-link")!=YES) { oof; }  }
  chain->link_slots=add;
  chain->link_avail=chain->link_slots-chain->link_count;
  }
 return RET_YES;
 }








 B aaChainNew                          (_chain*chain)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMissingParm(chain);
 aaMemoryFill(chain,sizeof(_chain),0);
 chain->magic=aaHPP(aaChainNew);
 chain->link_first=0xffffffff;
 chain->link_last=0xffffffff;
 return RET_YES;
 }








 B aaChainDelete                       (_chain*chain)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMagicCheck(chain,aaChainNew);
 if(chain->link_slots!=0)  { aaMemoryRelease(chain->link);      }
 if(chain->mem.bytes)      { aaMemoryUnitRelease(&chain->mem);  }
 aaMemoryFill(chain,sizeof(_chain),0);
 return RET_YES;
 }








 B aaChainLinkNew                      (_chain*chain,_chainlink*link,H bytes,PP data)
 {
 B ret;
 H base,j,i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMagicCheck(chain,aaChainNew);
 if(link==NULL)  { oof; }
 if(chain->link_avail<4)
  {
  if((ret=aa_ChainExpand(chain,NO))!=RET_YES) { oops; }
  }
 base=chain->link_count;
 for(j=0;j<chain->link_slots;j++)
  {
  i=base+j;
  if(i>=chain->link_slots) { i=0; }
  if(aaBitGet(chain->link[i].state,0)==0) { break; }
  }
 if(j==chain->link_slots) { oof; }
 aaMemoryFill(&chain->link[i],sizeof(_chainlink),0);
 chain->link[i].state=aaBitSet(chain->link[i].state,0);
 chain->link[i].self=i;
 chain->link[i].prev=0xffffffff;
 chain->link[i].next=0xffffffff;
 chain->link_count++;
 chain->link_avail=chain->link_slots-chain->link_count;
 aaChainLinkLengthSet(chain,&chain->link[i],bytes,0);
 aaMemoryCopy(link,sizeof(_chainlink),&chain->link[i]);
 if(data)
  {
  if(link->have==0) { *data=NULL; }
  else              { *data=&chain->mem.mem[link->offset]; }
  }
 if((chain->link_first==0xffffffff||chain->link_last==0xffffffff)&&(chain->link_first!=chain->link_last)) oof;
 return RET_YES;
 }








 B aaChainLinkLengthSet                (_chain*chain,_chainlink*link,H bytes,PP data)
 {
 H avail;
 H todo;
 H index;
 H plus;
 BP ptr;
 BP optr;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMagicCheck(chain,aaChainNew);
 if(link==NULL) { oof; }
 if(link==NULL) { return RET_BADPARM; }
 avail=chain->mem.bytes-chain->mem.used;
 if((bytes+_1K)>=avail)  {  aa_ChainExpand(chain,1);  }
 plus=16;
 index=link->self;

 if(link->have==0)
  {
  link->offset=chain->mem.used;
  link->have=bytes+plus;
  link->bytes=bytes;
  chain->mem.used+=(link->have+1);
  if(data)
   {
   if(link->have==0) { *data=NULL; }
   else              { *data=&chain->mem.mem[link->offset]; }
   }
  aaMemoryCopy(&chain->link[index],sizeof(_chainlink),link);
  return RET_YES;
  }
 if((bytes+8)>=link->have)
  {
  optr=&chain->mem.mem[link->offset];
  ptr=&chain->mem.mem[link->offset];
  todo=link->have;
  link->offset=chain->mem.used;
  link->bytes=bytes;
  link->have=bytes+plus;
  chain->mem.used+=(link->have+1);
  ptr=&chain->mem.mem[link->offset];
  aaMemoryCopy(ptr,todo,optr);
  if(data)
   {
   if(link->have==0) { *data=NULL; }
   else              { *data=&chain->mem.mem[link->offset]; }
   }
  aaMemoryCopy(&chain->link[index],sizeof(_chainlink),link);
  return RET_YES;
  }


 link->bytes=bytes;
 if(data)
  {
  if(link->have==0) { *data=NULL; }
  else              { *data=&chain->mem.mem[link->offset]; }
  }
 aaMemoryCopy(&chain->link[index],sizeof(_chainlink),link);
 return RET_YES;
 }








 B aaChainLinkGet                      (_chain*chain,_chainlink*link,H index,PP data)
 {
 _chainlink*cl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMagicCheck(chain,aaChainNew);
 if(link==NULL)  {oof; }
 if(index>=chain->link_count) { return RET_BOUNDS; }
 cl=(_chainlink*)&chain->link[index];
 if(link) {  aaMemoryCopy(link,sizeof(_chainlink),cl); }
 if(data)
  {
  if(cl->have==0) { *data=NULL; }
  else            { *data=&chain->mem.mem[cl->offset]; }
  }
 return RET_YES;
 }









 B aaChainLinkRemove                   (_chain*chain,_chainlink*link)
 {
 H index;
 _chainlink*clc;
 _chainlink*clp;
 _chainlink*cln;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMagicCheck(chain,aaChainNew);
 aaMissingParm(link);
// if(link->prev==0xffffffff&&link->next==0xffffffff) { aaDebugf("line=%i",__LINE__); return RET_YES; }

 clc=(_chainlink*)&chain->link[link->self];
 index=link->self;
 if(index==chain->link_first&&index==chain->link_last)
  {
  chain->link_first=0xffffffff;
  chain->link_last=0xffffffff;
  chain->link_usage--;
  chain->link_removes++;
  clc->prev=0xffffffff;
  clc->next=0xffffffff;
  clc->state=aaBitSet(clc->state,1);
  aaMemoryCopy(link,sizeof(_chainlink),clc);
  return RET_YES;
  }
 if(index==chain->link_first)
  {
  if(link->prev!=0xffffffff) oof;
  if(link->next!=0xffffffff)
   {
   cln=(_chainlink*)&chain->link[link->next];
   cln->prev=0xffffffff;
   chain->link_first=cln->self;
   clc->state=aaBitSet(clc->state,1);
   clc->prev=0xffffffff;
   clc->next=0xffffffff;
   chain->link_usage--;
   chain->link_removes++;
   aaMemoryCopy(link,sizeof(_chainlink),clc);
   return RET_YES;
   }
  oof;
  }
 if(index==chain->link_last)
  {
  if(link->next!=0xffffffff) oof;
  if(link->prev!=0xffffffff)
   {
   clp=(_chainlink*)&chain->link[link->prev];
   clp->next=0xffffffff;
   chain->link_last=clp->self;
   clc->state=aaBitSet(clc->state,1);
   clc->prev=0xffffffff;
   clc->next=0xffffffff;
   chain->link_usage--;
   chain->link_removes++;
   aaMemoryCopy(link,sizeof(_chainlink),clc);
   return RET_YES;
   }
  oof;
  }
 cln=(_chainlink*)&chain->link[link->next];
 clp=(_chainlink*)&chain->link[link->prev];
 clp->next=cln->self;
 cln->prev=clp->self;
 chain->link_usage--;
 chain->link_removes++;
 clc->prev=0xffffffff;
 clc->next=0xffffffff;
 clc->state=aaBitSet(clc->state,1);
 aaMemoryCopy(link,sizeof(_chainlink),clc);
 return RET_YES;
 }









 B aaChainLinkInsert                   (_chain*chain,_chainlink*link,H index,B after)
 {
 B ret;
 B is_rem;
 _chainlink cl,cn,cp;
 H i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMagicCheck(chain,aaChainNew);
 aaMissingParm(link);
 if((chain->link_first==0xffffffff||chain->link_last==0xffffffff)&&(chain->link_first!=chain->link_last)) oof;

 is_rem=NO;
 if(aaBitGet(link->state,1)) { is_rem=YES;  }
 i=link->self;
 if(chain->link_first==0xffffffff||chain->link_last==0xffffffff)
  {
  chain->link_first=i;
  chain->link_last=i;
  chain->link_usage++;
  if(is_rem)
   {
   chain->link_removes--;
   link->state=aaBitClr(link->state,1);
   aaMemoryCopy(&chain->link[link->self],sizeof(_chainlink),link);
   }
  return RET_YES;
  }
 after&=1;
 if(after)
  {
  if((ret=aaChainLinkGet(chain,&cl,index,0))!=YES) { oops; }
  if(cl.next==0xffffffff)
   {
   cl.next=i;
   aaMemoryCopy(&chain->link[cl.self],sizeof(_chainlink),&cl);
   chain->link[i].prev=cl.self;
   aaMemoryCopy(link,sizeof(_chainlink),&chain->link[i]);
   chain->link_last=i;
   chain->link_usage++;
   if(is_rem)
    {
    chain->link_removes--;
    link->state=aaBitClr(link->state,1);
    aaMemoryCopy(&chain->link[link->self],sizeof(_chainlink),link);
    }
   }
  else
   {
   if((ret=aaChainLinkGet(chain,&cn,cl.next,0))!=YES) { oops; }
   cl.next=i;
   aaMemoryCopy(&chain->link[cl.self],sizeof(_chainlink),&cl);
   chain->link[i].prev=cl.self;
   chain->link[i].next=cn.self;
   aaMemoryCopy(link,sizeof(_chainlink),&chain->link[i]);
   cn.prev=i;
   aaMemoryCopy(&chain->link[cn.self],sizeof(_chainlink),&cn);
   if(cn.next==0xffffffff) { chain->link_last=cn.self; }
   chain->link_usage++;
   if(is_rem)
    {
    chain->link_removes--;
    link->state=aaBitClr(link->state,1);
    aaMemoryCopy(&chain->link[link->self],sizeof(_chainlink),link);
    }
   }
  }
 else
  {
  if((ret=aaChainLinkGet(chain,&cl,index,0))!=YES) { oops; }
  if(cl.prev==0xffffffff)
   {
   cl.prev=i;
   aaMemoryCopy(&chain->link[cl.self],sizeof(_chainlink),&cl);
   chain->link[i].next=cl.self;
   aaMemoryCopy(link,sizeof(_chainlink),&chain->link[i]);
   chain->link_first=i;
   chain->link_usage++;
   if(is_rem)
    {
    chain->link_removes--;
    link->state=aaBitClr(link->state,1);
    aaMemoryCopy(&chain->link[link->self],sizeof(_chainlink),link);
    }
   }
  else
   {
   if((ret=aaChainLinkGet(chain,&cp,cl.prev,0))!=YES) { oops; }
   cl.prev=i;
   aaMemoryCopy(&chain->link[cl.self],sizeof(_chainlink),&cl);
   chain->link[i].next=cl.self;
   chain->link[i].prev=cp.self;
   aaMemoryCopy(link,sizeof(_chainlink),&chain->link[i]);
   cp.next=i;
   aaMemoryCopy(&chain->link[cp.self],sizeof(_chainlink),&cp);
   if(cp.prev==0xffffffff) { chain->link_first=cp.self; }
   chain->link_usage++;
   if(is_rem)
    {
    chain->link_removes--;
    link->state=aaBitClr(link->state,1);
    aaMemoryCopy(&chain->link[link->self],sizeof(_chainlink),link);
    }
   }
  }
 return RET_YES;
 }









 B aaChainLinkInsertNew                (_chain*chain,_chainlink*link,H index,B after,H bytes,PP data)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMagicCheck(chain,aaChainNew);
 aaMissingParm(link);
 ret=aaChainLinkNew(chain,link,bytes,data);
 if(ret!=YES) { return ret; }
 ret=aaChainLinkInsert(chain,link,index,after);
 if(ret!=YES) { oops; return ret; }
 return RET_YES;
 }











 B aaChainLinkTraverse                 (_chain*chain,_chainlink*link,H index,N amount,B flag,NP lino,PP data)
 {
 N position;
 _chainlink*linkptr;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMagicCheck(chain,aaChainNew);
 aaMissingParm(link);

 if(index>=chain->link_count) { return RET_BOUNDS; }

 linkptr=(_chainlink*)&chain->link[index];
 position=0;

 if(amount<0)
  {
  amount=aaNumAbs(amount);
  while(1)
   {
   if(aaBitGet(linkptr->state,1)==1)
    {
    if(linkptr->prev==0xffffffff) { break; }
    linkptr=(_chainlink*)&chain->link[linkptr->prev];
    continue;
    }
   if(linkptr->prev==0xffffffff) {  break; }
   if(amount==0) { break; }
   position-=linkptr->bytes;;
   if(flag) { if(linkptr->bytes==0) { position--; } }
   linkptr=(_chainlink*)&chain->link[linkptr->prev];
   amount--;
   }
  }
 else
// if(amount>0)
  {
  while(1)
   {
   if(aaBitGet(linkptr->state,1)==1)
    {
    if(linkptr->next==0xffffffff) { break; }
    linkptr=(_chainlink*)&chain->link[linkptr->next];
    continue;
    }
   if(linkptr->next==0xffffffff) {  break; }
   if(amount==0) { break; }
   position+=linkptr->bytes;;
   if(flag) { if(linkptr->bytes==0) { position++; } }
   linkptr=(_chainlink*)&chain->link[linkptr->next];
   amount--;
   }
  }
 aaMemoryCopy(link,sizeof(_chainlink),linkptr);
 if(data)  {  *data=&chain->mem.mem[linkptr->offset];  }
 if(lino)  {  *lino=position; }

 return RET_YES;
 }










 B aaChainLinkUnitNew                  (_chain*chain,_chainlinkunit*linkunit,H bytes)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMagicCheck(chain,aaChainNew);
 if(linkunit==NULL)  {oof; }
 return(aaChainLinkNew(chain,&linkunit->link,bytes,(VP)&linkunit->data));
 }








 B aaChainLinkUnitLengthSet            (_chain*chain,_chainlinkunit*linkunit,H bytes)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMagicCheck(chain,aaChainNew);
 if(linkunit==NULL)  {oof; }
 return(aaChainLinkLengthSet(chain,&linkunit->link,bytes,(VP)&linkunit->data));
 }







 B aaChainLinkUnitGet                  (_chain*chain,_chainlinkunit*linkunit,H index)
 {
 _chainlink*cl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMagicCheck(chain,aaChainNew);
 if(linkunit==NULL)  {oof; }
 if(index>=chain->link_count) { return RET_BOUNDS; }
 cl=(_chainlink*)&chain->link[index];
 aaMemoryCopy(&linkunit->link,sizeof(_chainlink),cl);
 if(cl->have==0) { linkunit->data=NULL; }
 else            { linkunit->data=&chain->mem.mem[cl->offset]; }
 return RET_YES;
 }







 B aaChainLinkUnitInsertNew            (_chain*chain,_chainlinkunit*linkunit,H index,B after,H bytes)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMagicCheck(chain,aaChainNew);
 if(linkunit==NULL)  {oof; }
 return(aaChainLinkInsertNew(chain,&linkunit->link,index,after,bytes,(VP)&linkunit->data));
 }







 B aaChainLinkUnitInsertNewf           (_chain*chain,_chainlinkunit*linkunit,H index,B after,VP fmt,...)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMagicCheck(chain,aaChainNew);
 if(linkunit==NULL)  {oof; }
 aaVargsf4K(fmt);
 if((ret=aaChainLinkUnitInsertNew(chain,linkunit,index,after,str4k.len+1))!=YES) { oops; return ret; }
 aaStringNCopy(linkunit->data,str4k.buf,str4k.len,YES);
 return RET_YES;
 }










 B aaChainLinkUnitTraverse             (_chain*chain,_chainlinkunit*linkunit,H index,N amount,B flag,NP lino)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMagicCheck(chain,aaChainNew);
 if(linkunit==NULL)  {oof; }
 return(aaChainLinkTraverse(chain,&linkunit->link,index,amount,flag,lino,(VP)&linkunit->data));
 }



/*-----------------------------------------------------------------------*/
//http://www.geeksforgeeks.org/iterative-quick-sort/


 B aa_SorterStackExpand                (_sorter*sorter)
 {
 B ret;
 D div;
 G solisi,state,add;
 G prev_size;
 G prev_left;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 solisi=sorter->stack_size;
 if(solisi<0x10) { state=0; add=0x15; } else
 if(solisi<0x20) { state=1; add=0x30; } else
 if(solisi<0x40) { state=2; add=0x45; } else
                 { state=3; add=0x60; }
 div=(30+(state*10))/100.0;
 prev_size=sorter->stack_size;
 prev_left=sorter->stack_left;
 add=(add+solisi)+(solisi*div);
 if(add==sorter->stack_size) {  aaNote(0,"redundent sorter stack reallocation with same size, %I64d",add);  }
 if((ret=aaMemoryReAllocate((VP)&sorter->stack,add*sizeof(G)))!=RET_YES) { oops; }
 sorter->stack_size=add;
 sorter->stack_left+=add-prev_size;
 aaDebugf("stg=%i stackexp: size=%I64d left=%I64d -> size=%I64d left=%I64d",sorter->stage,prev_size,prev_left,sorter->stack_size,sorter->stack_left);
 return RET_YES;
 }




 B aaSorterNew                         (_sorter*sorter,G entries,VP data,B(*proc)(_sorter*,H,G,G,VP,NP))
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(sorter==NULL) { return RET_BADPARM; }
 if(entries==0) { return RET_BOUNDS; }
 if(proc==NULL) { return RET_BADPARM; }
 aaMemoryFill(sorter,sizeof(_sorter),0);
 sorter->magic=aaHPP(aaSorterNew);
 sorter->entries=entries;
 sorter->proc=(VP)proc;
 sorter->stage=150;
 sorter->data=data;
 sorter->top=-1;
 sorter->stack_size=2000;
 sorter->stack_left=sorter->stack_size;
 if((ret=aaMemoryAllocate((VP)&sorter->stack,sorter->stack_size*sizeof(G)))!=YES) { oops; }
 aaMemoryNameSet(sorter->stack,"sortstack");
 sorter->l=0;
 sorter->h=sorter->entries-1;
 sorter->i=0;
 return RET_YES;
 }





 B aaSorterDelete                      (_sorter*sorter)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(sorter==NULL) { return RET_BADPARM; }
 if(sorter->magic!=aaHPP(aaSorterNew)) { return RET_NOTINITIALIZED; }
 if(sorter->stack!=NULL)      { if(aaMemoryRelease(sorter->stack)!=YES) oof;  }
 aaMemoryFill(sorter,sizeof(_sorter),0);
 return RET_YES;
 }




 B aaSorterSort                        (_sorter*sorter,H its)
 {
 B ret;
 B(*proc)(_sorter*,H,G,G,VP,NP);
 N dif;
 //H loops;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(sorter==NULL) { return RET_BADPARM; }
 if(sorter->magic!=aaHPP(aaSorterNew)) { return RET_NOTINITIALIZED; }
 proc=sorter->proc;
 if(its==0) { its=1; }
 while(1)
  {
  if(its==0) { break; }
  //ita--;
  if(sorter->stage!=500&&sorter->stage!=600) { sorter->total_its++; }
  switch(sorter->stage)
   {
   case 100:
   break;

   case 150:
   sorter->stack[++sorter->top]=sorter->l;
   sorter->stack[++sorter->top]=sorter->h;
   sorter->stack_left-=2;
   if(sorter->stack_left<10) {  aa_SorterStackExpand(sorter);   }
   sorter->stage=200;
   break;


   case 200:
   if(sorter->top<0) { sorter->stage=500; break; }
   sorter->h=sorter->stack[sorter->top--];
   sorter->l=sorter->stack[sorter->top--];
   sorter->stack_left+=2;
   sorter->stage=250;
   break;

   case 250:
   sorter->oh=sorter->h;
   sorter->progress=aaNumPercentIs((D)sorter->done,(D)sorter->entries);
   if((ret=proc(sorter,SORTER_GET,sorter->h,-1,sorter->tmp_buf,NULL))!=YES)
    {
    if(ret==RET_CANCELLED) { sorter->stage=600; break; }
    oops;
    }
   sorter->done++;
   its--;
   sorter->progress=aaNumPercentIs((D)sorter->done,(D)sorter->entries);
   sorter->i=sorter->l-1;
   sorter->j=sorter->l;
   sorter->stage=300;
   break;



/*
   case 300:
   while(1)
    {
    sorter->total_its++;
    if(sorter->j>(sorter->h-1)) {  sorter->stage=350; break; }
    if((ret=proc(sorter,SORTER_CMP,sorter->j,sorter->oh,sorter->tmp_buf,&dif))!=YES)
     {
     if(ret==RET_IGNORE) { oops; sorter->j++; continue; }
     oops;
     }
    if(dif<=0)
     {
     sorter->i++;
     if(sorter->j!=sorter->i)
      {
      if((ret=proc(sorter,SORTER_SWP,sorter->j,sorter->i,NULL,NULL))!=YES)
       {
       if(ret==RET_CANCELLED) { sorter->stage=600; break; }
       oops;
       }
      }
     }
    sorter->j++;
    }
   break;
*/





   case 300:
   //its=oits;
   //loops=0;
   while(1)
    {
    sorter->total_its++;
    if(sorter->j>(sorter->h-1)) {  sorter->stage=350; break; }
    if((ret=proc(sorter,SORTER_CMP,sorter->j,sorter->oh,sorter->tmp_buf,&dif))!=YES)
     {
     if(ret==RET_IGNORE) { oops; sorter->j++; continue; }
     oops;
     }
    if(dif<=0)
     {
     sorter->i++;
     if(sorter->j!=sorter->i)
      {
      if((ret=proc(sorter,SORTER_SWP,sorter->j,sorter->i,NULL,NULL))!=YES)
       {
       if(ret==RET_CANCELLED) { sorter->stage=600; break; }
       oops;
       }
      }
     }
    sorter->j++;
    //if(tis==0) { break; }
    //loops++;
    //if(loops<2) { continue; }
    if(its==0) { break; }
    its--;
    //loops=0;
    //break;
    }
   break;




   case 350:
   if((sorter->i+1)!=sorter->h)
    {
    if((ret=proc(sorter,SORTER_SWP,sorter->i+1,sorter->h,NULL,NULL))!=YES)
     {
     if(ret==RET_CANCELLED) { sorter->stage=600; break; }
     oops;
     }
    }
   sorter->p=sorter->i+1;
   if((sorter->p-1)>sorter->l)
    {
    sorter->stack[++sorter->top]=sorter->l;
    sorter->stack[++sorter->top]=sorter->p-1;
    sorter->stack_left-=2;
    if(sorter->stack_left<10) { aa_SorterStackExpand(sorter);   }
    }
   if((sorter->p+1)<sorter->h)
    {
    sorter->stack[++sorter->top]=sorter->p+1;
    sorter->stack[++sorter->top]=sorter->h;
    sorter->stack_left-=2;
    if(sorter->stack_left<10) {  aa_SorterStackExpand(sorter);     }
    }
   sorter->stage=200;
   break;
   }
  if(sorter->stage==500||sorter->stage==600) {   break;   }
  if(sorter->stage==300)
   {
   if(its!=0) { its--; }
   }
  else
   {
   if(its!=0) { its--; }
   }

  //if(its!=0) { its--; }
  }
 if(sorter->stage==500)
  {
  sorter->progress=100.0;
  return RET_YES;
  }
 if(sorter->stage==600) { return RET_CANCELLED; }
 return RET_NOTREADY;
 }




/*-----------------------------------------------------------------------*/




 B aa_ListSorterProc                   (_sorter*sorter,H cmd,G index,G parm,VP buf,NP arg)
 {
 _list*listp;
 G vala;
 BP kp,vp;
 H sl;

 listp=(_list*)sorter->data;

 switch(cmd)
  {
  case SORTER_GET:
  vala=listp->order[index];
  if(aaListGet(listp,(H)vala,&sl,(VP)&kp,0,(VP)&vp)!=YES) oof;
  //sl=listp->entry[(H)vala].key_len;
  aaStringNCopy(buf,kp,sl,YES);
  if(arg) { *arg=(N)sl;  }
  return RET_YES;

  case SORTER_CMP:
  vala=listp->order[index];
  if(aaListGet(listp,(H)vala,&sl,(VP)&kp,0,(VP)&vp)!=YES) oof;
  //sl=listp->entry[(H)vala].key_len;
  if(listp->is_case_sensitive) aaStringNCompare(kp,buf,(H)sl,arg);
  else                         aaStringNICompare(kp,buf,(H)sl,arg);
  return RET_YES;


  case SORTER_SWP:
  vala=listp->order[index];
  listp->order[index]=listp->order[parm];
  listp->order[parm]=(H)vala;
  return RET_YES;
  }

 return RET_FAILED;
 }







 B aa_ListSort                         (_list*list,H ita)
 {
 H i;
 // H j;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMissingParm(list);
 if(list->magic!=aaHPP(aaListNew)) { return RET_NOTINITIALIZED; }
 if(list->is_sort_needed==NO)  {  return RET_YES;  }
 while(1)
  {
  if(list->is_sort_needed==YES)
   {
   list->sort_counter++;
   aaSorterNew(&list->sorter,list->count,list,aa_ListSorterProc);
   for(i=0;i<list->count;i++) {  list->order[i]=i;   }
   list->is_sort_needed=3;
   return RET_NOTREADY;
   }
  if(list->is_sort_needed==3)
   {
   if(aaSorterSort(&list->sorter,ita)==YES)
    {
    aaSorterDelete(&list->sorter);
    list->is_sort_needed=NO;
    break;
    }
   return RET_NOTREADY;
   }
  }
 return RET_YES;
 }




///----------------------------------------

 B aaListNew                           (_list*list,B dupesok,H bloomsize,B cs,B dosort)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMissingParm(list);
 aaMemoryFill(list,sizeof(_list),0);
 dupesok&=1;
 list->magic=aaHPP(aaListNew);
 list->slots=10;
 cs&=1;
 list->is_case_sensitive=cs;
 list->is_dupes_ok=dupesok;
 list->id_counter=0;
 dosort&=1;
 list->is_sortable=dosort;
 if((ret=aaMemoryAllocate((VP)&list->entry,list->slots*sizeof(_listentry)))!=YES) { oops; }
 if((ret=aaMemoryNameSet(list->entry,"listentry"))!=YES) { oops; }
 if((ret=aaMemoryUnitAllocate(&list->mun,(128+256)*list->slots))!=YES) { oops; }
 if((ret=aaMemoryNameSet(list->mun.mem,"listmun"))!=YES) { oops; }
 if(bloomsize==0) { bloomsize=_8K; }
 if((ret=aaBloomNew(&list->bloom,bloomsize,list->is_case_sensitive,NULL))!=YES) { oops; }
 list->allocs=1;
 return RET_YES;
 }





 B aaListSave                          (_list*list,H ita,VP fmt,...)
 {
 B ret;
 va_list argptr;
 B str[_2K];
 B buf[_8K];
 H han,index,tot,o;
 BP kp,vp;
 _filestreamstatus fs;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,str);
 aaMissingParm(list);
 if(list->magic!=aaHPP(aaListNew)) { return RET_NOTINITIALIZED; }
 if(ita==0) { ita=1; }

 while(1)
  {
  if(ita==0) { break; }
  ita--;

  if(list->file_stage==0)
   {
   aaFileDelete(str);
   if((ret=aaFileStreamCreateQuick(&han,str))!=YES) { oops; }
   list->file_done=0;
   list->file_li=0;
   list->file_handle=han;
   aaFileStreamStatus(list->file_handle,&fs);
   list->file_stage=100;
   continue;
   }
  else
  if(list->file_stage==100)
   {
   *(BP)&buf[0]=list->is_dupes_ok;
   *(BP)&buf[1]=list->is_sortable;
   *(HP)&buf[2]=list->bloom.bytes;
   *(BP)&buf[6]=list->is_case_sensitive;
   *(HP)&buf[7]=list->count;
   if((ret=aaFileStreamWrite(list->file_handle,11,buf))!=YES){ oops; }
   aaFileStreamStatus(list->file_handle,&fs);
   list->file_stage=200;
   continue;
   }
  else
  if(list->file_stage==200)
   {
   if((ret=aaFileStreamWrite(list->file_handle,256,list->user_data))!=YES) { oops; }
   aaFileStreamStatus(list->file_handle,&fs);
   list->file_stage=300;
   continue;
   }
  else
  if(list->file_stage==300)
   {
   if(list->file_done>=list->count)
    {
    list->file_stage=400;
    continue;
    }
   index=list->file_li;

   han=list->file_handle;
   list->file_handle=0;
   ret=aaListGet(list,index,0,(VP)&kp,0,(VP)&vp);
   list->file_handle=han;
   if(ret==RET_NOTFOUND)
    {
    list->file_li++;
    continue;
    }
   if(ret!=RET_YES) { oops; break; }
   tot=4+4+list->entry[index].key_len+list->entry[index].val_len+32;
   o=0;
   *(HP)&buf[o]=tot;  o+=4;
   *(HP)&buf[o]=list->entry[index].key_len;  o+=4;
   *(HP)&buf[o]=list->entry[index].val_len;  o+=4;
   aaMemoryCopy(&buf[o],list->entry[index].key_len,kp);   o+=list->entry[index].key_len;
   aaMemoryCopy(&buf[o],list->entry[index].val_len,vp);   o+=list->entry[index].val_len;
   aaMemoryCopy(&buf[o],32,list->entry[index].user_data); o+=32;
   if((ret=aaFileStreamWrite(list->file_handle,o,buf))!=YES) { oops; }
   aaFileStreamStatus(list->file_handle,&fs);
   list->file_done++;
   list->file_li++;
   continue;
   }
  else
  if(list->file_stage==400)
   {
   aaFileStreamDestroy(list->file_handle);
   list->file_handle=0;
   list->file_stage=0;
   list->file_li=0;
   list->file_done=0;
   return RET_YES;
   }
  }
 return RET_NOTREADY;
 }









 B aaListLoad                          (_list*list,H ita,VP fmt,...)
 {
 B ret;
 va_list argptr;
 B str[_2K];
 B buf[_8K];
 B tmp[_8K];
 B txt[_8K];
 H han,index,tot;
 H klen,vlen;
 //BP kp,vp;
 _filestreamstatus fs;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,str);
 aaMissingParm(list);
 //aaMemoryFill(list,sizeof(_list),0);

 ///if(list->magic!=aaHPP(aaListNew)) { return RET_NOTINITIALIZED; }
 if(ita==0) { ita=1; }

 while(1)
  {
  if(ita==0) { break; }
  ita--;
  if(list->magic!=aaHPP(aaListNew))
   {
   ret=aaFileStreamOpenQuick(&han,str);
   ///appLogf("%s filestreamopenquick %s = %s",__func__,str,arets);
   if(ret==RET_NOTFOUND) { return ret; }
   if(ret!=YES) { oops; }
   aaFileStreamStatus(han,&fs);
   if((ret=aaFileStreamRead(han,267,tmp))!=YES) { oops; }
   if((ret=aaListNew(list,tmp[0],*(HP)&tmp[2],tmp[6],tmp[1]))!=YES) { oops; }
   //c=*(HP)&tmp[6];
   //aaDebugf("%s calling listnew (%i,%i,%i) = %s",__func__,tmp[0],*(HP)&tmp[1],tmp[5],arets);

   aaMemoryCopy(&list->user_data[0],256,&tmp[11]);
   list->file_handle=han;
   list->file_li=0;
   list->file_done=0;
   list->file_stage=1000;
   list->file_count=*(HP)&tmp[7];
   continue;
   }
  if(list->file_stage==1000)
   {
   if(list->file_done>=list->file_count)  {  list->file_stage=1200;   continue;    }
   if((ret=aaFileStreamRead(list->file_handle,4,buf))!=YES) { oops; }
   tot=*(HP)&buf[0];
   if((ret=aaFileStreamRead(list->file_handle,tot,buf))!=YES) { oops; }
   klen=*(HP)&buf[0];
   vlen=*(HP)&buf[4];
   aaStringNCopy(txt,&buf[8],klen,YES);
   han=list->file_handle;
   list->file_handle=0;
   if(vlen==0)    {    ret=aaListAppend(list,&index,txt,vlen,NULL);    }
   else           {    ret=aaListAppend(list,&index,txt,vlen,&buf[8+klen]);    }
   list->file_handle=han;
   if(ret!=YES) { oops; }
   aaMemoryCopy(&list->entry[index].user_data[0],32,&buf[8+klen+vlen]);
   aaFileStreamStatus(han,&fs);
   list->file_done++;
   continue;
   }
  else
  if(list->file_stage==1200)
   {
   aaFileStreamDestroy(list->file_handle);
   list->file_handle=0;
   list->file_stage=0;
   list->file_li=0;
   list->file_done=0;
   return RET_YES;
   }
  }
 return RET_NOTREADY;
 }





 B aaListCancel                        (_list*list)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMissingParm(list);
 if(list->magic!=aaHPP(aaListNew)) { return RET_NOTINITIALIZED; }
 if(list->file_handle)  {  aaFileStreamDestroy(list->file_handle);  }
 list->file_handle=0;
 list->file_stage=0;
 list->file_li=0;
 list->file_done=0;
 return RET_YES;
 }





 B aaListDelete                        (_list*list)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMissingParm(list);
 if(list->magic!=aaHPP(aaListNew)) { return RET_NOTINITIALIZED; }
 if(list->entry!=NULL) { aaMemoryRelease(list->entry);  }
 if(list->mun.bytes)   { aaMemoryUnitRelease(&list->mun); }
 if(list->sorter.magic) { aaSorterDelete(&list->sorter); }
 if(list->bloom.magic) { aaBloomDelete(&list->bloom); ;}
 if(list->order!=NULL) { aaMemoryRelease(list->order); }
 if(list->file_handle)  {  aaFileStreamDestroy(list->file_handle);  }
 aaMemoryFill(list,sizeof(_list),0);
 return RET_YES;
 }






 B aaListAppend                        (_list*list,HP index,VP key,H bytes,VP val)
 {
 B ret;
 H hash,left,add,checked;
 Q xi;
 H ksl,vsl,li,i;
 B keybuf[_8K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMissingParm(list);
 if(list->magic!=aaHPP(aaListNew)) { return RET_NOTINITIALIZED; }
 if(list->file_handle)  {  return RET_BADSTATE;  }

 aaStringNull(keybuf);
 if(key!=NULL)  { aaStringCopyLen(keybuf,&ksl,key);                    }
 else           { aaStringCopyfLen(keybuf,&ksl,"id%I64u",list->id_counter);  }
 if(ksl==0)     { aaDebugf("ksl=0, key=[%s]",key); return RET_BADPARM; }

 if(val!=NULL)
  {
  if(bytes==0) { aaStringLen(val,&bytes); }
  }
 vsl=bytes;

 hash=0;
 if(list->is_dupes_ok==NO&&list->count!=0)
  {
  //aaDebugf("dupes_ok=no count=%i",list->count);
  ret=aaBloomFind(&list->bloom,ksl,keybuf);
  //aaDebugf("blooom=%s ksl=%i [%s]",arets,ksl,keybuf);
  if(ret!=RET_NOTFOUND&&ret!=RET_POSSIBLE) { oops; }
  if(ret==RET_POSSIBLE)
   {
   checked=0;
   aaStringHashGet(keybuf,ksl,&hash,list->is_case_sensitive);
   if(hash==0) { oof; }
   for(i=0;i<list->slots;i++)
    {
    if(checked>=list->count) { break; }
    if(list->entry[i].key_len==0) { continue; }
    checked++;
    if(list->entry[i].hash!=hash) { continue; }
    if(index) { *index=i; }
    return RET_EXISTS;
    }
   }
  }


 left=list->slots-list->count;
 if(left<5)
  {
  if(list->slots<100)   { add=20+list->slots+(list->slots*.3);   } else
  if(list->slots<1000)  { add=200+list->slots+(list->slots*.5);  } else
  if(list->slots<5000)  { add=2000+list->slots+(list->slots*.6); } else
                        { add=2000+list->slots+(list->slots*.8); }
  if((ret=aaMemoryReAllocate((VP)&list->entry,add*sizeof(_listentry)))!=YES) { oops; return ret; }
  list->slots=add;
  list->allocs++;
  }
 left=list->mun.bytes-list->offset;
 if(left<(ksl+vsl+_4K))
  {
  if(list->mun.bytes<_4K)   {  add=list->mun.bytes+(list->mun.bytes*.2)+ksl+vsl+_5K;   } else
  if(list->mun.bytes<_64K)  {  add=list->mun.bytes+(list->mun.bytes*.3)+ksl+vsl+_8K;   } else
  if(list->mun.bytes<_256K) {  add=list->mun.bytes+(list->mun.bytes*.4)+ksl+vsl+_32K;  } else
                            {  add=list->mun.bytes+(list->mun.bytes*.5)+ksl+vsl+_128K; }
  if((ret=aaMemoryUnitReAllocate(&list->mun,add))!=YES) { oops; return ret; }
  list->allocs++;
  }

 if(list->order==NULL)
  {
  if((ret=aaMemoryAllocate((VP)&list->order,list->slots*sizeof(H)))!=YES) { oops; }
  }
 else
  {
  if((ret=aaMemoryBytesGet(list->order,&bytes))!=YES) {  oops; }
  if(list->slots>(bytes/4))
   {
   if((ret=aaMemoryReAllocate((VP)&list->order,list->slots*sizeof(H)))!=YES) { oops; }
   }
  }


 if(list->remove_count==0)
  {
  li=list->count;
  if(list->entry[li].key_len!=0) { oof; }
  }
 else
  {
  for(li=0;li<list->slots;li++)
   {
   if(list->entry[li].key_len==0) { break; }
   }
  if(li==list->slots) { oof; }
  }
 xi=list->id_counter;
 if(hash==0)
  {
  aaStringHashGet(keybuf,ksl,&hash,list->is_case_sensitive);
  }
 list->entry[li].id=xi;
 list->entry[li].key_len=ksl;
 list->entry[li].val_len=vsl;
 list->entry[li].hash=hash;
 if(list->entry[li].rsvd[1]>=(ksl+2))
  {
  aaStringNCopy(&list->mun.mem[list->entry[li].rsvd[0]],keybuf,ksl,YES);
  list->entry[li].key_off=list->entry[li].rsvd[0];
  }
 else
  {
  aaStringNCopy(&list->mun.mem[list->offset],keybuf,ksl,YES);
  list->entry[li].key_off=list->offset;
  list->offset+=(ksl+2);
  }

 if(list->entry[li].rsvd[3]>=(vsl+2))
  {
  if(val==NULL)    {   aaMemoryFill(&list->mun.mem[list->entry[li].rsvd[2]],vsl,0);     }
  else             {   aaMemoryCopy(&list->mun.mem[list->entry[li].rsvd[2]],vsl,val);   }
  list->entry[li].val_off=list->entry[li].rsvd[2];
  list->mun.mem[list->entry[li].val_off+vsl]=NULL_CHAR;
  }
 else
  {
  if(val==NULL)   {   aaMemoryFill(&list->mun.mem[list->offset],vsl,0);     }
  else            {   aaMemoryCopy(&list->mun.mem[list->offset],vsl,val);   }
  list->mun.mem[list->offset+vsl]=NULL_CHAR;
  list->entry[li].val_off=list->offset;
  list->offset+=(vsl+2);
  }

 list->entry[li].rsvd[0]=list->entry[li].rsvd[1]=list->entry[li].rsvd[2]=list->entry[li].rsvd[3]=0;
 if(index) { *index=li; }
 list->count++;
 list->id_counter++;
 list->order[li]=li;

 if((ret=aaBloomAdd(&list->bloom,ksl,keybuf))!=YES) { oops; }

 if(list->sorter.magic)  {  oof;  aaSorterDelete(&list->sorter);  }
 list->is_sort_needed=YES;

 return RET_YES;
 }



 B aaListRemove                        (_list*list,H index)
 {
 B ret;
 _list temp_list;
 H i;
 BP kp,vp;
 H kl,vl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 aaMissingParm(list);
 if(list->magic!=aaHPP(aaListNew)) { return RET_NOTINITIALIZED; }
 if((ret=aaListNew(&temp_list,YES,list->bloom.bytes,list->is_case_sensitive,list->is_sortable))!=YES) { oops; }
 for(i=0;i<list->slots;i++)
  {
  if(i==index) { continue; }
  ret=aaListGet(list,i,&kl,(VP)&kp,&vl,(VP)&vp);
  if(ret!=RET_YES) { continue; }
  //kl=list->entry[i].key_len;
  //vl=list->entry[i].val_len;
  ret=aaListAppend(&temp_list,0,(kl==0)?0:kp,vl,vp);
  if(ret!=RET_YES) { oops; return ret; }
  }
 temp_list.is_dupes_ok=list->is_dupes_ok;
 if(list->is_sortable)
  {
  if(list->is_sort_needed==NO)
   {
   while(1)
    {
    if(aaListSort(&temp_list,100)==YES) { break; }
    }
   }
  }
 if((ret=aaListDelete(list))!=YES) { oops; }
 aaMemoryCopy(list,sizeof(_list),&temp_list);
 return RET_YES;
 }




 B aaListFind                          (_list*list,HP index,PP key,PP val,VP fmt,...)
 {
 B ret;
 va_list argptr;
 B str[_32K];
 H sl,ii,hs;
 register H i,hash,ksl,checked;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMissingParm(list);
 if(list->magic!=aaHPP(aaListNew)) { return RET_NOTINITIALIZED; }
 if(list->file_handle)  {  return RET_BADSTATE;  }
 if(key) { *key=NULL; }
 if(val) { *val=NULL; }

 if(fmt==NULL) { return RET_BADPARM; }

 aaFmt(fmt,argptr,str);
 aaStringLen(str,&sl);
 ksl=sl;
 if(ksl==0)         { return RET_NOTFOUND; }
 if(list->count==0) { return RET_NOTFOUND; }
 //if(from>=list->slots) { return RET_NOTFOUND; }

 if(list->is_sort_needed==NO&&list->is_sortable==YES)
  {
  ret=aaListSearch(list,&ii,key,val,"%s",str);
  i=ii;
  if(index) { *index=i; }
  return ret;
  }


 ret=aaBloomFind(&list->bloom,ksl,str);
 if(ret==RET_NOTFOUND) { return RET_NOTFOUND;  }
 if(ret!=RET_POSSIBLE) { oops; }

 hs=0;
 aaStringHashGet(str,ksl,&hs,list->is_case_sensitive);
 hash=hs;
 checked=0;
 for(i=0;i<list->slots;i++)
  {
  if(checked>=list->count) { break; }
  if(list->entry[i].key_len==0) { continue; }
  checked++;
  if(list->entry[i].hash!=hash) { continue; }
  if(index) { *index=i; }
  if(key||val) { if(aaListGet(list,i,0,key,0,val)!=YES) { oof; } }
  return RET_YES;
  }
 return RET_NOTFOUND;
 }




 B aaListSearch                        (_list*list,HP index,PP key,PP val,VP fmt,...)
 {
 B ret;
 va_list argptr;
 B str[_32K];
 H ksl,kl;
 register H mid,lo,hi;
 N res;
 BP kp,vp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMissingParm(list);
 if(list->magic!=aaHPP(aaListNew)) { return RET_NOTINITIALIZED; }
 if(list->file_handle)  {  return RET_BADSTATE;  }
 if(fmt==NULL) { return RET_BADPARM; }

  if(key) { *key=NULL; }
  if(val) { *val=NULL; }


 aaFmt(fmt,argptr,str);
 aaStringLen(str,&ksl);
 if(index) { *index=0; }
 if(ksl==0)            { return RET_NOTFOUND; }
 if(list->count==0)    { return RET_NOTFOUND; }
 //if(from>=list->slots) { return RET_NOTFOUND; }
 //if(index) { *index=from; }
 //ret=aaBloomFind(&list->bloom,ksl,str);
 //if(ret==RET_NOTFOUND) { return RET_NOTFOUND;  }
 //if(ret!=RET_POSSIBLE) { oops; }

 if(list->is_sortable==NO)
  {
  return(aaListFind(list,index,key,val,"%s",str));
  }

 if(list->is_sort_needed!=NO)
  {
  while(1)
   {
   ret=aaListSort(list,1000);
   if(ret==RET_YES) { break; }
   if(ret!=RET_NOTREADY) { oops; break; }
   }
  }

 lo=0;
 hi=list->count;//slots;
 while((N)lo<=(N)hi)
  {
  mid=lo+((hi-lo)/2);
  if((ret=aaListGet(list,list->order[mid],&kl,(VP)&kp,0,(VP)&vp))!=YES) { oops; break; }
  //kl=list->entry[list->order[mid]].key_len;
  if(list->is_case_sensitive) { aaStringNCompare(str,kp,kl,&res);  }
  else                        { aaStringNICompare(str,kp,kl,&res); }
  //aaDebugf("compare [%s] [%s] = %i",str,kp,res);

  if(res==0||res>0)
   {
   if(index) { *index=list->order[mid]; }
   }
  if(res==0)
   {
   if(key||val) {  if(aaListGet(list,list->order[mid],0,key,0,val)!=YES) { oof; } }
   return RET_YES;
   }
  if(res>0)  { lo=mid+1;  }
  else       { hi=mid-1;  }
  }

 if(key||val)  { if(aaListGet(list,list->order[mid],0,key,0,val)!=YES) { oof; } }
 return RET_NOTFOUND;
 }





 B aaListGet                           (_list*list,H index,HP keylen,PP key,HP vallen,PP val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMissingParm(list);
 if(list->magic!=aaHPP(aaListNew)) { return RET_NOTINITIALIZED; }
 if(keylen) { *keylen=0; }
 if(vallen) { *vallen=0; }
 if(list->file_handle)  {  return RET_BADSTATE;  }
 if(list->count==0)  { return RET_NOTFOUND; }
 if(index>=list->slots) { return RET_NOTFOUND; }
 if(list->entry[index].key_len==0) { return RET_NOTFOUND; }
 if(key) { *key=&list->mun.mem[list->entry[index].key_off]; }
 if(val) { *val=&list->mun.mem[list->entry[index].val_off]; }
 if(keylen) { *keylen=list->entry[index].key_len; }
 if(vallen) { *vallen=list->entry[index].val_len; }
 return RET_YES;
 }






 B aaListReset                         (_list*list)
 {
 H o,i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 aaMissingParm(list);
 if(list->magic!=aaHPP(aaListNew)) { return RET_NOTINITIALIZED; }
 list->is_sort_needed=NO;
 list->count=0;
 list->offset=0;

 if(list->file_handle)  {  aaFileStreamDestroy(list->file_handle);  }
 list->file_handle=0;
 list->file_stage=0;
 list->file_li=0;
 list->file_done=0;
 if(list->sorter.magic)  {  aaSorterDelete(&list->sorter);  }
 if(list->order)
  {
  if(aaMemoryBytesGet(list->order,&o)!=YES) oof;
  if((o%4)!=0) oof;
  o/=4;
  for(i=0;i<o;i++) {  list->order[i]=i;   }
  }
 if(list->bloom.magic)
  {
  list->bloom.items=0;
  list->bloom.possibles=0;
  list->bloom.misses=0;
  list->bloom.add_loops=0;
  list->bloom.find_loops=0;
  if(list->bloom.bytes)
   {
   aaMemoryFill(list->bloom.filter,list->bloom.bytes,0);
   }
  }
 list->mun.used=0;
 aaMemoryFill(list->entry,list->slots*sizeof(_listentry),0);
 return RET_YES;
 }




 B aaListSort                          (_list*list,H ita)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMissingParm(list);
 if(list->magic!=aaHPP(aaListNew)) { return RET_NOTINITIALIZED; }
 if(list->file_handle)  {  return RET_BADSTATE;  }
 if(list->is_sortable==NO) { return RET_BADSTATE;  }
 if(ita==0) ita=0xffffffff;
 while(1)
  {
  ret=aa_ListSort(list,ita);
  if(ita!=0xffffffff) {  ita--; }
  if(ret==RET_NOTREADY)
   {
   if(ita!=0) { continue; }
   return ret;
   }
  if(ret!=RET_YES) { oops; return ret; }
  break;
  }
 return RET_YES;
 }


/*-----------------------------------------------------------------------*/




 B aaOptionsNew                        (_options*options)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 aaMissingParm(options);
 aaMemoryFill(options,sizeof(_options),0);
 aaMagicSet(options,aaOptionsNew);
 aaListNew(&options->list,NO,0,0,1);

 aaMemoryNameSet(options->list.entry,"optslistentry");
 aaMemoryNameSet(options->list.mun.mem,"optslistmun");

 return RET_YES;
 }





 B aaOptionsDelete                     (_options*options)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 aaMagicCheck(options,aaOptionsNew);
 if(options->list.magic==aaHPP(aaListNew)) { aaListDelete(&options->list); }
 aaMemoryFill(options,sizeof(_options),0);
 return RET_YES;
 }





 B aaOptionsSet                        (_options*options,VP data,...)
 {
 B ret;
 B str[_4K];
 B txt[2][_2K];
 H bytes,cha,index;
 _parser pa;
 va_list argptr;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(options==NULL) { return RET_BADPARM; }
 aaFmt(data,argptr,str);
 aaStringLen(str,&bytes);
 if(options->magic!=aaHPP(aaOptionsNew))
  {
  if((ret=aaOptionsNew(options))!=RET_YES) { oops; return ret; }
  }
 aaParserInit(&pa,str,bytes);
 if(aaParserSeekToVisibleChar(&pa,YES,YES)!=YES) oof;
 aaParserStackPush(&pa);
 aaParserSeekToCharList(&pa,"= ",YES,YES);
 if(pa.ch=='=')
  {
  aaParserStackString(&pa,&cha,sizeof(txt[0]),txt[0],YES);
  aaParserSeek(&pa,1);
  }
 else
 if(pa.ch==' ')
  {
  aaParserStackString(&pa,&cha,sizeof(txt[0]),txt[0],YES);
  aaParserSeekToChar(&pa,'=',YES,YES);
  aaParserSeek(&pa,1);
  }
 aaParserSeekToVisibleChar(&pa,YES,YES);
 aaStringCopy(txt[1],pa.bp);
 aaStringRemoveSpaces(txt[1],0,YES,YES);
 ret=aaListFind(&options->list,&index,NULL,NULL,"%s",txt[0]);
 if(ret==RET_NOTFOUND)
  {
  if((ret=aaListAppend(&options->list,&index,txt[0],0,txt[1]))!=YES) { oops; }
  //if((ret=aaListAppendf(&options->list,&index,txt[0],"%s",txt[1]))!=YES) { oops; }
  return RET_YES;
  }
 if(ret!=RET_YES) { oops; }
 ///if((ret=aaListRemove(&options->list,index))!=YES) { oops; }
 //if((ret=aaListAppendf(&options->list,&index,txt[0],"%s",txt[1]))!=YES) { oops; }
 if((ret=aaListAppend(&options->list,&index,txt[0],0,txt[1]))!=YES) { oops; }
 return RET_YES;
 }




VP aaOptionsGet                        (_options*options,DP num,VP data,...)
 {
 B ret;
 B str[_4K];
 H bytes,index;
 D dub;
 BP vp,kp;
 va_list argptr;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(options==NULL) { return NULL; }
 if(aaMagicIsNot(options,aaOptionsNew)) { return NULL; }
 aaFmt(data,argptr,str);
 aaStringLen(str,&bytes);
 aaStringRemoveSpaces(str,bytes,YES,YES);
 aaStringLen(str,&bytes);
 if(aaListFind(&options->list,&index,NULL,NULL,"%s",str)!=YES) {  return NULL; }
 if((ret=aaListGet(&options->list,index,0,(VP)&kp,0,(VP)&vp))!=RET_YES) { oops; return NULL; }

 if(aaStringIsNumerical(vp,YES,YES,options->list.entry[index].val_len)==YES)
  {
  aaStringToDouble(vp,options->list.entry[index].val_len,&dub);
  if(num) { *num=dub; }
  aaMemoryCopy(options->buf,options->list.entry[index].val_len,vp);
  options->buf[options->list.entry[index].val_len]=0;
  }
 else
  {
  if(num) { *num=666.666; }
  aaMemoryCopy(options->buf,options->list.entry[index].val_len,vp);
  options->buf[options->list.entry[index].val_len]=0;
  }
 return options->buf;
 }





/*-----------------------------------------------------------------------*/


 B aaDataAllocate                      (_data*data)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(data==NULL) { return RET_BADPARM; }
 aaMemoryFill(data,sizeof(_data),0);
 data->field_slots=1;
 if((ret=aaMemoryMake((VP)&data->field_array,data->field_slots*sizeof(HP)))!=YES)
  {
  aaMemoryFill(data,sizeof(_data),0);
  return ret;
  }
 if((ret=aa_MemoryProtect(data->field_array,YES))!=YES) { oops; }
 data->magic=aa_DATA_MAGIC;
 return RET_YES;
 }




 B aaDataRelease                       (_data*data)
 {
 B ret;
 BP ff;
 H i,by;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(data==NULL) { return RET_BADPARM; }
 if(data->magic!=aa_DATA_MAGIC) { return RET_NOTSTARTED; }
 if(data->field_slots!=0)
  {
  for(i=0;i<data->field_slots;i++)
   {
   if(data->field_array[i]!=0)
    {
    aaCast(ff,VP,data->field_array[i]);
    if((ret=aa_MemoryProtect(ff,NO))!=YES) { oops; }
    if((ret=aaMemoryBytesGet(ff,&by))!=YES) { oops; }
    aaMemoryRelease(ff);
    data->total_bytes-=(by-8);
    data->field_array[i]=0;
    data->field_count--;
    }
   }
  if(data->field_count!=0) { oof; }
  if((ret=aa_MemoryProtect(data->field_array,NO))!=YES) { oops; }
  if((ret=aaMemoryRelease(data->field_array))!=YES) { oops; }
  }
 aaMemoryFill(data,sizeof(_data),0);
 return RET_YES;
 }





 B aaDataReset                         (_data*data)
 {
 B ret;
 BP ff;
 H i,by;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(data==NULL) { return RET_BADPARM; }
 if(data->magic!=aa_DATA_MAGIC) { return RET_NOTSTARTED; }
 if(data->field_slots!=0)
  {
  for(i=0;i<data->field_slots;i++)
   {
   if(data->field_array[i]!=0)
    {
    aaCast(ff,VP,data->field_array[i]);
    if((ret=aa_MemoryProtect(ff,NO))!=YES) { oops; }
    if((ret=aaMemoryBytesGet(ff,&by))!=YES) { oops; }
    aaMemoryRelease(ff);
    data->total_bytes-=(by-8);
    data->field_array[i]=0;
    data->field_count--;
    }
   }
  if(data->field_count!=0) { oof; }
  aaMemoryFill(data->field_array,data->field_slots*sizeof(H),0);
  }
 return RET_YES;
 }




 B aaDataFieldAdd                      (_data*data,HP index,H bytes,H alias,PP mem)
 {
 B ret;
 H left,i,add;
 BP ff;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(data==NULL) { return RET_BADPARM; }
 if(data->magic!=aa_DATA_MAGIC) { return RET_NOTSTARTED; }
 if(index) { *index=0xffffffff; }
 if(bytes==0) { return RET_BADPARM; }
 if(mem!=NULL) { *mem=NULL; }
 left=data->field_slots-data->field_count;
 if(left==0)
  {
  add=6+(data->field_slots/16);
  if((ret=aa_MemoryProtect(data->field_array,NO))!=YES) { oops; }
  if((ret=aaMemoryMake((VP)&data->field_array,(data->field_slots+add)*sizeof(HP)))!=YES) { oops; }
  if((ret=aa_MemoryProtect(data->field_array,YES))!=YES) { oops; }
  data->field_slots+=add;
  }
 for(i=0;i<data->field_slots;i++)
  {
  if(data->field_array[i]==0) { break; }
  }
 if(i==data->field_slots) { oof; }
 aaCast(ff,VP,data->field_array[i]);
 if((ret=aaMemoryMake((VP)&ff,bytes+8))!=YES) { oops; }
 if((ret=aa_MemoryProtect(ff,YES))!=YES) { oops; }
 *(HP)&ff[0]=alias;
 *(HP)&ff[4]=bytes;
 data->total_bytes+=(bytes);
 #ifdef WAGO
 data->field_array[i]=(H)ff;
 #else
 (VP)data->field_array[i]=ff;
 #endif
 if(index) { *index=i; }
 if(mem)   { *mem=&ff[8]; }
 data->field_count++;
 return RET_YES;
 }





 B aaDataFieldRemove                   (_data*data,H index)
 {
 B ret;
 BP ff;
 H by;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(data==NULL) { return RET_BADPARM; }
 if(data->magic!=aa_DATA_MAGIC) { return RET_NOTSTARTED; }
 if(index>=data->field_slots) { return RET_BADHANDLE; }
 if(data->field_array[index]==0) { return RET_YES; }
 aaCast(ff,VP,data->field_array[index]);
 if(ff==NULL) { oof; }
 if((ret=aa_MemoryProtect(ff,NO))!=YES) { oops; }
 if((ret=aaMemoryBytesGet(ff,&by))!=YES) { oops; }
 data->total_bytes-=(by-8);
 if((ret=aaMemoryRelease((VP)ff))!=YES) { oops; }
 data->field_array[index]=0;
 data->field_count--;
 return RET_YES;
 }




 B aaDataFieldWrite                    (_data*data,HP index,H bytes,H alias,VP mem)
 {
 BP ptr;
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(data==NULL) { return RET_BADPARM; }
 if(data->magic!=aa_DATA_MAGIC) { return RET_NOTSTARTED; }
 if(index) { *index=0xffffffff; }
 if(mem==NULL) { return RET_BADPARM; }
 if(bytes==0)  {  aaStringLen(mem,&bytes);  }
 if(bytes==0) { return RET_BADPARM; }
 ret=aaDataFieldAdd(data,index,bytes,alias,(VP)&ptr);
 if(ret!=YES) { return ret; }
 aaMemoryCopy(ptr,bytes,mem);
 ptr[bytes]=0;
 return RET_YES;
 }





 B aaDataFieldWritef                   (_data*data,HP index,H alias,VP fmt,...)
 {
 va_list argptr;
 B str[_8K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,str);
 return(aaDataFieldWrite(data,index,0,alias,str));
 }




 B aaDataFieldRead                     (_data*data,H index,HP bytes,HP alias,H maxbytes,VP mem)
 {
 B ret;
 BP ff;
 H by;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bytes) { *bytes=0; }
 if(alias) { *alias=0; }
 if(data==NULL) { return RET_BADPARM; }
 if(data->magic!=aa_DATA_MAGIC) { return RET_NOTSTARTED; }
 if(index>=data->field_slots) { return RET_BADHANDLE; }
 if(data->field_array[index]==0) { return RET_BADHANDLE; }
 aaCast(ff,VP,data->field_array[index]);
 if(ff==NULL) { oof; }
 if((ret=aaMemoryBytesGet(ff,&by))!=YES) { oops; }
 if(bytes)
  {
  *bytes=by-8;
  }
 if(alias) { *alias=*(HP)&ff[0]; }
 if((by-8)>maxbytes) { return RET_BOUNDS; }
 if(mem) { aaMemoryCopy(mem,by-8,&ff[8]); }
 return RET_YES;
 }




 B aaDataFieldSizeSet                  (_data*data,H index,H bytes,PP mem)
 {
 B ret;
 BP ff;
 H by,al;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(data==NULL) { return RET_BADPARM; }
 if(data->magic!=aa_DATA_MAGIC) { return RET_NOTSTARTED; }
 if(index>=data->field_slots) { return RET_BADHANDLE; }
 if(data->field_array[index]==0) { return RET_BADHANDLE; }
 if(mem!=NULL) { *mem=NULL; }
 aaCast(ff,VP,data->field_array[index]);
 if(ff==NULL) { oof; }
 if((ret=aaMemoryBytesGet(ff,&by))!=YES) { oops; }
 if(bytes==0)
  {
  if((ret=aa_MemoryProtect(ff,NO))!=YES) { oops; }
  if((ret=aaMemoryRelease((VP)ff))!=YES) { oops; }
  data->total_bytes-=(by-8);
  data->field_array[index]=0;
  if(mem) { *mem=0; }
  data->field_count--;
  return RET_YES;
  }
 al=*(HP)&ff[0];
 data->total_bytes-=(by-8);
 if((ret=aa_MemoryProtect(ff,NO))!=YES) { oops; }
 if((ret=aaMemoryMake((VP)&ff,bytes+8))!=YES) { oops; }
 if((ret=aa_MemoryProtect(ff,YES))!=YES) { oops; }
 data->total_bytes+=(bytes);
 #ifdef WAGO
 data->field_array[index]=(H)ff;
 #else
 (VP)data->field_array[index]=ff;
 #endif
 *(HP)&ff[0]=al;
 *(HP)&ff[4]=(by-4);
 if(mem) { *mem=&ff[8]; }
 return RET_YES;
 }



 B aaDataFieldInfoGetByNumber          (_data*data,H numbr,HP bytes,HP index,HP alias,PP mem)
 {
 B ret;
 BP ff;
 H by,i,n;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(data==NULL) { return RET_BADPARM; }
 if(data->magic!=aa_DATA_MAGIC) { return RET_NOTSTARTED; }
 if(index) { *index=0; }
 if(alias) { *alias=0; }
 if(bytes) { *bytes=0; }
 if(mem!=NULL) { *mem=NULL; }
 if(numbr>=data->field_slots) { return RET_BADHANDLE; }
 if(numbr>=data->field_count) { return RET_BADHANDLE; }
 n=0;
 for(i=0;i<data->field_slots;i++)
  {
  if(data->field_array[i]==0) { continue; }
  if(numbr!=n) { n++; continue; }
  aaCast(ff,VP,data->field_array[i]);
  if(ff==NULL) { oof; }
  if((ret=aaMemoryBytesGet(ff,&by))!=YES) { oops; }
  if(bytes) { *bytes=by-8;}
  if(index) { *index=i;  }
  if(alias) { *alias=*(HP)&ff[0]; }
  if(mem) { *mem=&ff[8]; }
  return RET_YES;
  }
 return RET_FAILED;
 }





 B aaDataFieldInfoGetByAlias           (_data*data,H alias,HP bytes,HP index,PP mem)
 {
 B ret;
 BP ff;
 H i,by;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(data==NULL) { return RET_BADPARM; }
 if(data->magic!=aa_DATA_MAGIC) { return RET_NOTSTARTED; }
 if(index) { *index=0xffffffff; }
 if(bytes) { *bytes=0; }
 if(mem!=NULL) { *mem=NULL; }
 for(i=0;i<data->field_slots;i++)
  {
  if(data->field_array[i]==0) { continue;  }
  aaCast(ff,VP,data->field_array[i]);
  if(ff==NULL) { continue; }
  if(*(HP)&ff[0]!=alias) { continue; }
  if(bytes)
   {
   if((ret=aaMemoryBytesGet(ff,&by))!=YES) { oops; }
   *bytes=by-4;
   }
  if(index) { *index=i; }
  if(mem) { *mem=&ff[8]; }
  return RET_YES;
  }
 return RET_NOTFOUND;
 }





 B aaDataFieldInfoGetByIndex           (_data*data,H index,HP bytes,HP alias,PP mem)
 {
 B ret;
 BP ff;
 H by;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(data==NULL) { return RET_BADPARM; }
 if(data->magic!=aa_DATA_MAGIC) { return RET_NOTSTARTED; }
 if(alias) { *alias=0; }
 if(bytes) { *bytes=0; }
 if(mem!=NULL) { *mem=NULL; }
 if(index>=data->field_slots) { return RET_BADHANDLE; }
 if(data->field_array[index]==0) { return RET_BADHANDLE; }
 aaCast(ff,VP,data->field_array[index]);
 if(ff==NULL) { oof; }
 if(bytes)
  {
  if((ret=aaMemoryBytesGet(ff,&by))!=YES) { oops; }
  *bytes=by-8;
  }
 if(alias) { *alias=*(HP)&ff[0]; }
 if(mem) { *mem=&ff[8]; }
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/



 B aa_PageSystemStart                  (V)
 {
 B ret;

 logg("aa_PageSystemStart()");
 logg("{");
 aa.page_system.bytes_per_page=aa_PAGE_BYTES;
 aa.page_system.books_per_system=aa_PAGE_MAX_BOOKS;
 aa.page_system.pages_per_system=aa_PAGE_MAX_BOOKS*aa_PAGE_PER_BOOK;
 aa.page_system.bytes_per_book=aa.page_system.bytes_per_page*aa_PAGE_PER_BOOK;
 aa.page_system.bytes_accessable=aa.page_system.bytes_per_book*aa.page_system.books_per_system;
 logg("aa_PageSystemStart calling aa_MemoryAlloc()");
 if((ret=aa_MemoryAllocate((VP)&aa.page_system.book,aa.page_system.books_per_system*sizeof(_aa_pagebook),"AllBooks",NO))!=RET_YES) {  return ret;  }
 aa_MemoryProtect(aa.page_system.book,YES);
 logg("bytes per page = %i",aa.page_system.bytes_per_page);
 logg("pages per book = %i",aa_PAGE_PER_BOOK);
 logg("bytes per book = %i",aa.page_system.bytes_per_book);
 logg("books per system = %i",aa.page_system.books_per_system);
 logg("pages per system= %i",aa.page_system.pages_per_system);
 logg("bytes accessable = %i",aa.page_system.bytes_accessable);
 #if USE_PAGE_CRITICAL_SECTION==1
 InitializeCriticalSection(&aa.page_system.mutex);
 #endif
 logg("}");
 logg("");
 return RET_YES;
 }



 V aa_PageSystemStop                   (V)
 {
 B ret;
 N b,p;

 logg("aa_PageSystemStop()");
 if(aa.page_system.book!=NULL)
  {
  logg("Pages commited: %i",aa.page_system.pages_commited);
  logg("Pages allocated: %i",aa.page_system.pages_allocated);
  if(aa.page_system.pages_allocated!=0)
   {
   for(b=(aa_PAGE_MAX_BOOKS-1);b>=0;b--)
    {
    if(aa.page_system.book[b].mem!=NULL)
     {
     for(p=0;p<aa_PAGE_PER_BOOK;p++)
      {
      if(aa.page_system.book[b].in_use[p]!=NO)
       {
       logg("book[%i].page[%i] was in use at aa_PageSystemStop()",b,p);
       }
      }
     }
    }
   }
  for(b=(aa_PAGE_MAX_BOOKS-1);b>=0;b--)
   {
   if(aa.page_system.book[b].mem!=NULL)
    {
    if(aa_MemoryRelease(aa.page_system.book[b].mem)!=RET_YES) { oof; Boop; }
    aa.page_system.pages_commited-=aa_PAGE_PER_BOOK;
    aa.page_system.pages_allocated-=aa.page_system.book[b].usage;
    logg("Book[%i] released (%i pages de-commited) ( and with it %i pages deallocated)",b,aa_PAGE_PER_BOOK,aa.page_system.book[b].usage);
    aaMemoryFill(&aa.page_system.book[b],sizeof(_aa_pagebook),0);
    }
   }
  aa_MemoryProtect(aa.page_system.book,NO);
  if((ret=aa_MemoryRelease(aa.page_system.book))!=YES) { oops; }
  aa.page_system.book=NULL;
  }
 #if USE_PAGE_CRITICAL_SECTION==1
 DeleteCriticalSection(&aa.page_system.mutex);
 #endif
 logg("");
 }



 B aa_PageAllocate                     (HP handle,PP mem,VP name)
 {
 H b,p;
 H fb;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==NULL)  { return RET_BADPARM; }
 #if USE_PAGE_CRITICAL_SECTION==1
 EnterCriticalSection(&aa.page_system.mutex);
 #endif
 logg("aa_PageAllocate(%s) currently ( %i commited, %i allocated )",name,aa.page_system.pages_commited,aa.page_system.pages_allocated);
 fb=0xffffffff;
 for(b=0;b<aa_PAGE_MAX_BOOKS;b++)
  {
  if(aa.page_system.book[b].mem==NULL&&fb==0xffffffff) { fb=b; }
  if(aa.page_system.book[b].mem!=NULL&&aa.page_system.book[b].usage<aa_PAGE_PER_BOOK)
   {
   for(p=0;p<aa_PAGE_PER_BOOK;p++)
    {
    if(aa.page_system.book[b].in_use[p]==NO) { break; }
    }
   if(p==aa_PAGE_PER_BOOK) { oof;  Boop; Boop; }
   if(name) { aaStringNCopy(aa.page_system.book[b].name[p],name,10,YES); }
   aa.page_system.book[b].in_use[p]=YES;
   aa.page_system.book[b].usage++;
   aaMemoryFill(&aa.page_system.book[b].mem[p*aa.page_system.bytes_per_page],aa.page_system.bytes_per_page,0); // is this needed ?? ashot
   if(mem) { *mem=&aa.page_system.book[b].mem[p*aa.page_system.bytes_per_page]; }
   *handle=aa_PAGE_BASE_HANDLE+(b*aa_PAGE_PER_BOOK)+p;
   aa.page_system.pages_allocated++;
   if(aa.page_system.pages_allocated>aa.memory_system.status.peak_pages_allocated)
    {
    aa.memory_system.status.peak_pages_allocated=aa.page_system.pages_allocated;
    }
   #if USE_PAGE_CRITICAL_SECTION==1
   LeaveCriticalSection(&aa.page_system.mutex);
   #endif
   return RET_YES;
   }
  }
 if(fb==0xffffffff) { aaNote(0,"bubble head %s",name); }
 b=fb; p=0;
 if(aa_MemoryAllocate((VP)&aa.page_system.book[b].mem,aa.page_system.bytes_per_page*aa_PAGE_PER_BOOK,"bookmem",NO)!=YES) { oof; }
 logg(" (%s) [%i][%i] is YES",name,b,p);
 aa.page_system.book[b].in_use[p]=YES;
 aaMemoryFill(&aa.page_system.book[b].mem[p*aa.page_system.bytes_per_page],aa.page_system.bytes_per_page,0);
 if(mem) { *mem=&aa.page_system.book[b].mem[p*aa.page_system.bytes_per_page]; }
 *handle=aa_PAGE_BASE_HANDLE+(b*aa_PAGE_PER_BOOK)+p;
 aa.page_system.book[b].usage=1;
 if(name) { aaStringNCopy(aa.page_system.book[b].name[p],name,10,YES); }
 aa.page_system.pages_allocated++;
 if(aa.page_system.pages_allocated>aa.memory_system.status.peak_pages_allocated)
  {
  aa.memory_system.status.peak_pages_allocated=aa.page_system.pages_allocated;
  }
 aa.page_system.pages_commited+=aa_PAGE_PER_BOOK;
 if(aa.page_system.pages_commited>aa.memory_system.status.peak_pages_commited)
  {
  aa.memory_system.status.peak_pages_commited=aa.page_system.pages_commited;
  }
 logg("aa_PageAllocate(%s) now: alloc=%i commit=%i",aa.page_system.book[b].name[p],aa.page_system.pages_allocated,aa.page_system.pages_commited);
 logg("book[%i] created",b);
 #if USE_PAGE_CRITICAL_SECTION==1
 LeaveCriticalSection(&aa.page_system.mutex);
 #endif
 return RET_YES;
 }





 B aa_PageRelease                      (H handle)
 {
 B ret,isp;
 H b,p;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_PageStatus(handle,NULL,&isp,NULL))!=RET_YES) { return ret; }
 if(isp==YES)
  {
  logg("cannot released protected page");
  oof;
  return RET_FORBIDDEN;
  }
 #if USE_PAGE_CRITICAL_SECTION==1
 EnterCriticalSection(&aa.page_system.mutex);
 #endif
 handle-=aa_PAGE_BASE_HANDLE;
 b=handle/aa_PAGE_PER_BOOK;
 p=handle%aa_PAGE_PER_BOOK;
 aa.page_system.book[b].in_use[p]=NO;
 aa.page_system.pages_allocated--;
 aa.page_system.book[b].usage--;
 aa.page_system.book[b].name[p][0]=NULL_CHAR;
 if(aa.page_system.book[b].usage==0&&aa.page_system.pages_allocated!=0)
  {
  }
 #if USE_PAGE_CRITICAL_SECTION==1
 LeaveCriticalSection(&aa.page_system.mutex);
 #endif
 return RET_YES;
 }





 B aa_PageProtect                      (H handle,B state)
 {
 B ret,isp;
 H b,p;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_PageStatus(handle,NULL,&isp,NULL))!=RET_YES) { return ret; }
 #if USE_PAGE_CRITICAL_SECTION==1
 EnterCriticalSection(&aa.page_system.mutex);
 #endif
 handle-=aa_PAGE_BASE_HANDLE;
 b=handle/aa_PAGE_PER_BOOK;
 p=handle%aa_PAGE_PER_BOOK;
 if(state==YES) { aa.page_system.book[b].protection[p]=YES; }
 else             { aa.page_system.book[b].protection[p]=NO; }
 #if USE_PAGE_CRITICAL_SECTION==1
 LeaveCriticalSection(&aa.page_system.mutex);
 #endif
 return RET_YES;
 }









 B aa_PageStatus                       (H handle,PP mem,BP isprotected,BP isuser)
 {
 H b,p;
 B ret;
 N dif;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(isuser) { *isuser=NO; }
 if(isprotected) { *isprotected=NO; }
 if(mem) { *mem=NULL; }
 if(handle<aa_PAGE_BASE_HANDLE) {  return RET_BADHANDLE; }
 handle-=aa_PAGE_BASE_HANDLE;
 b=handle/aa_PAGE_PER_BOOK;
 if(b>=aa_PAGE_MAX_BOOKS)  {   return RET_BADHANDLE; }
 p=handle%aa_PAGE_PER_BOOK;
 if(aa.page_system.book[b].mem==NULL) {   return RET_BADHANDLE; }
 if(aa.page_system.book[b].in_use[p]==NO) {  return RET_BADHANDLE; }
 if(aa.page_system.book[b].usage==0)
  {
  logg("what the hell");
  return RET_FAILED;
  }
 if(isuser)
  {
  ret=aaStringCompare(aa.page_system.book[b].name[p],"userpage",&dif);
  if(ret==RET_YES&&dif==0) { *isuser=YES; }
  }
 if(mem) { *mem=&aa.page_system.book[b].mem[p*aa.page_system.bytes_per_page]; }
 if(isprotected) { *isprotected=aa.page_system.book[b].protection[p]; }
 return RET_YES;
 }





 B aa_PageArrayIo                      (HP harray,H hcount,H offset,H bytes,VP data,B writemode)
 {
 B ret;
 H last_offset;
 BP ptr;
 register BP bp;
 H p,o,todo,go;
 H icnt,istr,ioff,iby,ihan,ih;
 H stride;
 B txt[_2K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(harray==NULL) { return RET_BADPARM; }
 if(hcount==0)  {   return RET_BADPARM; }
 stride=aa.page_system.bytes_per_page;
 ///if(stride!=aa.page_system.bytes_per_page) { aaNote(0,"stride=%i bytes_per_page=%i",stride,aa.page_system.bytes_per_page); }
 ///if(stride>aa.page_system.bytes_per_page) { return RET_FAILED; }
 last_offset=(hcount*stride);
 if(offset>=last_offset)
  {
  logg("hc=%i st=%i lo=%i off=%i ",hcount,stride,last_offset,offset);
  aaNote(0,"hc=%i st=%i lo=%i off=%i ",hcount,stride,last_offset,offset);
  return RET_BOUNDS;
  }
 if(bytes>(last_offset-offset)) {  return RET_BOUNDS; }
 if(bytes==0) {  return RET_YES; }
 if(data==NULL) { return RET_BADPARM; }
 #if USE_PAGE_CRITICAL_SECTION==1
 EnterCriticalSection(&aa.page_system.mutex);
 #endif
 ihan=harray[offset/stride];
 icnt=hcount;
 istr=stride;
 ioff=offset;
 iby=bytes;
 aaCast(bp,BP,data);
 go=0;
 ih=harray[0];
 while(1)
  {
  p=offset/stride;
  o=offset%stride;
  if((ret=aa_PageStatus(harray[p],(VP)&ptr,NULL,NULL))!=YES)
   {
   aa_craperr++;
   aaStringCopyf(txt,"Please report this as a screenshot to apakian@gmail.com\r\n%s handle=%i p=%i o=%i write=%i (cnt=%i str=%i off=%i by=%i) first han=%i go=%i ih=%i",ret_string[ret],harray[p],p,o,writemode,icnt,istr,ioff,iby,ihan,go,ih);
   aaStringAppendf(txt,"\n   ....  %s handle=%i p=%i o=%i write=%i (cnt=%i str=%i off=%i by=%i) first han=%i go=%i",ret_string[ret],harray[p],p,o,writemode,icnt,istr,ioff,iby,ihan,go);
   aaStringAppendf(txt,"\n . .. .LINE=%i %s handle=%i p=%i write=%i (cnt=%i str=%i off=%i by=%i)",__LINE__,ret_string[ret],harray[p],p,writemode,icnt,istr,ioff,iby);
   aaHistory(-1,"%s",txt);
   break;
   }
  todo=bytes;
  if(todo>=(stride-o)) { todo=(stride-o); }
  if((todo==bytes)&&bytes==1)
   {
   if(writemode==YES) {  ptr[o]=bp[0]; }
   else               {  bp[0]=ptr[o]; }
   break;
   }
  if(writemode==YES) {  aaMemoryCopy(&ptr[o],todo,bp); }
  else               {  aaMemoryCopy(bp,todo,&ptr[o]); }
  offset+=todo;
  bytes-=todo;
  if(bytes==0) { break; }
  bp+=todo;
  go++;
  }
 #if USE_PAGE_CRITICAL_SECTION==1
 LeaveCriticalSection(&aa.page_system.mutex);
 #endif
 return RET_YES;
 }








 B aa_PageArrayFill                    (HP harray,H hcount,H offset,H bytes,B val)
 {
 H last_offset;
 BP ptr;
 H p,o,todo;
 H stride=0;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(harray==NULL) { return RET_BADPARM; }
 if(hcount==0)  { return RET_BADPARM; }
 if(stride==0) { stride=aa.page_system.bytes_per_page; }
 if(stride>aa.page_system.bytes_per_page) { return RET_FAILED; }
 last_offset=(hcount*stride);
 if(offset>=last_offset) { return RET_BOUNDS; }
 if(bytes>(last_offset-offset)) { return RET_BOUNDS; }
 if(bytes==0) { return RET_YES; }
 #if USE_PAGE_CRITICAL_SECTION==1
 EnterCriticalSection(&aa.page_system.mutex);
 #endif
 while(1)
  {
  p=offset/stride;
  o=offset%stride;
  if(aa_PageStatus(harray[p],(VP)&ptr,NULL,NULL)!=RET_YES) { oof; Boop; }
  todo=bytes;
  if(todo>(stride-o)) todo=(stride-o);
  aaMemoryFill(&ptr[o],todo,val);
  offset+=todo;
  bytes-=todo;
  if(bytes==0) { break; }
  }
 #if USE_PAGE_CRITICAL_SECTION==1
 LeaveCriticalSection(&aa.page_system.mutex);
 #endif
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/



 B aa_ObjectSystemStart                (V)
 {
 logg("aa_ObjectSystemStart()");
 aa.object_system.id_head=1;
 aa.object_system.sesh_counter=aa.core_system.launch_tik;
 logg("");
 return RET_YES;
 }





 V aa_ObjectSystemStop                 (V)
 {
 N i;

 logg("aa_ObjectSystemStop()");
 for(i=127;i>-1;i--)
  {
  aa_ObjectUndefine((B)i);
  }
 logg("");
 }




 B aa_ObjectDefine                     (B id,H bytes,H limit,H initial,B(*Destructor)(H),VP name)
 {
 B txt[129];
 B ret;
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaStringNull(txt);
 if(name)
  {
  if((ret=aaStringLen(name,&sl))!=RET_YES) { return ret; }
  if(sl>13) { sl=13; }
  aaStringNCopy(txt,name,sl,YES);
  }
 if(txt[0]==NULL_CHAR) { aaStringCopyf(txt,"obj#%i",id); }
 if(bytes==0)  { return RET_BADPARM; }
 if(id==0)     { return RET_FORBIDDEN; }
 if(aa.object_system.object[id].instance_limit!=0) { return RET_EXISTS; }
 if(limit==0) { return RET_BOUNDS; }
 if(limit>aa_OBJ_MAX_PER_ID) { return RET_BOUNDS; }
 aaMemoryFill(&aa.object_system.object[id],sizeof(_aa_object),0);
 aa.object_system.object[id].instance_limit=limit;
 aa.object_system.object[id].instance_bytes=bytes;
 aa.object_system.object[id].instance_initial=initial;
 if(Destructor) { aa.object_system.object[id].Destructor=Destructor;  }
 aaStringCopy(aa.object_system.object[id].name,txt);
 return RET_YES;
 }





 B aa_ObjectUndefine                   (B id)
 {
 H h,base;
 B isprot;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aa.object_system.object[id].instance_limit==0) {  return RET_NOTFOUND; }
 base=id*aa_OBJ_MAX_PER_ID;
 base+=aa_OBJ_BASE_HANDLE;
 aa_last_line_executed=__LINE__;
 if(aa.object_system.object[id].instance_slots!=0&&aa.object_system.object[id].instance_count!=0)
  {
  aa_last_line_executed=__LINE__;
   {
   }
  //aaLog(-777,"aa_objectUndefine(%-3i) instance_slots=%-5i instance_count=%-5i (%s)",id,aa.object_system.object[id].instance_slots,aa.object_system.object[id].instance_count,aa.object_system.object[id].name);
  }
 aa_last_line_executed=__LINE__;
 if(id==aa.surface_system.object_id)
  {
  aa_last_line_executed=__LINE__;
  for(h=(aa.object_system.object[id].instance_slots-1);h!=0xffffffff;h--)
   {
   if(aa.object_system.object[id].instance_count==0) { break; }
   if(aa_ObjectCheck((B)id,base+h,NULL,&isprot)==RET_YES)
    {
    if(isprot) { aa_ObjectProtect(id,base+h,NO); }
    if(aa.object_system.object[id].Destructor) { aa.object_system.object[id].Destructor(base+h);   }
    else                                       { aa_ObjectDestroy((B)id,base+h);   }
    }
   }
  }
 else
  {
  aa_last_line_executed=__LINE__;
  for(h=0;h<aa.object_system.object[id].instance_slots;h++)
   {
   if(aa.object_system.object[id].instance_count==0) { break; }
   if(aa_ObjectCheck((B)id,base+h,NULL,&isprot)==RET_YES)
    {
    if(isprot) { aa_ObjectProtect(id,base+h,NO); }
    if(aa.object_system.object[id].Destructor)   { aa.object_system.object[id].Destructor(base+h);  }
    else                                         { aa_ObjectDestroy((B)id,base+h);   }
    }
   }
  }
 aa_last_line_executed=__LINE__;
 if(aa.object_system.object[id].instance_count!=0) { aaDebugf("line=%i",__LINE__); return RET_FAILED;  }
 if(aa.object_system.object[id].instance_slots!=0)
  {
  if(aa_MemoryRelease(aa.object_system.object[id].instance_mem)!=RET_YES)
   {
   aaDebugf("line=%i",__LINE__);
   logg("** aa_ObjectUndefine(%i) failed to release memory",id);
   oof;
   Boop;
   }
  aa.object_system.object[id].instance_slots=0;
  aa.object_system.object[id].instance_mem=NULL;
  }
 return RET_YES;
 }






 B aa_ObjectCreate                     (B id,HP handle,PP mem)
 {
 B ret;
 H available_slots;
 H slots_to_add;
 H bytes;
 BP bp;
 _aa_objectinstanceheader*oih;
 H instance_stride;
 H base,h;
 B txt[129];

 #if aa_USE_GLOBAL_MUTEX==1
 EnterCriticalSection(&global_mutex);
 #endif
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==NULL) { oof; return RET_BADPARM; }
 *handle=0;
 if(mem) { *mem=NULL; }
 if(aa.object_system.object[id].instance_limit==0) { aaNote(0,"%s id=%i",__func__,id); aaNote(0,"and=%i",aa.object_system.object[id].instance_count);     return RET_NOTFOUND; }
 if(aa.object_system.object[id].instance_count>=aa.object_system.object[id].instance_limit)
  {
  aaNote(0,"id=%i instance_count=%i instance_limit=%i %s",id,aa.object_system.object[id].instance_count,aa.object_system.object[id].instance_limit,aa.object_system.object[id].name);
  #if aa_USE_GLOBAL_MUTEX==1
  LeaveCriticalSection(&global_mutex);
  #endif
  return RET_NOMEMORY;
  }
 available_slots=aa.object_system.object[id].instance_slots-aa.object_system.object[id].instance_count;
 if(available_slots<2)
  {
  if(available_slots==0&&aa.object_system.object[id].instance_count==0)
   {
   slots_to_add=aa.object_system.object[id].instance_initial;
   if(slots_to_add==0) { slots_to_add=4; }
   }
  else
   {
   slots_to_add=aa.object_system.object[id].instance_slots/8;
   slots_to_add=aaNumMin(slots_to_add,8);
   slots_to_add=aaNumFloor(slots_to_add,2);
   }
  slots_to_add=aaNumRoof(slots_to_add,(aa.object_system.object[id].instance_limit-aa.object_system.object[id].instance_slots));
  if(slots_to_add!=0)
   {
   if(aa.object_system.object[id].instance_slots==0)
    {
    if(id==1||id==2)     {     slots_to_add=32;     }
    bytes=aa.object_system.object[id].instance_bytes+sizeof(_aa_objectinstanceheader);
             /* aaLog(-555,"ma  sta=%i by=%i ===%i",slots_to_add,bytes,bytes*slots_to_add); */
    aaStringCopyf(txt,"%s.instdata",aa.object_system.object[id].name);
    if((ret=aa_MemoryAllocate((VP)&bp,bytes*slots_to_add,txt,NO))!=RET_YES)    { oof;   Boop;    return ret;    }
    aa.object_system.object[id].instance_mem=bp;
    }
   else
    {
    bytes=aa.object_system.object[id].instance_bytes+sizeof(_aa_objectinstanceheader);
    bp=aa.object_system.object[id].instance_mem;
             /* aaLog(-555,"mb  sta=%i by=%i ==%i",slots_to_add,bytes,bytes*(slots_to_add+aa.object_system.object[id].instance_slots)); */
    if((ret=aa_MemoryReAllocate((VP)&bp,bytes*(slots_to_add+aa.object_system.object[id].instance_slots)))!=RET_YES)    { oof;   Boop;    return ret;    }
    aa.object_system.object[id].instance_mem=bp;
    }
   }
  aa.object_system.object[id].instance_slots+=slots_to_add;
  }
 instance_stride=aa.object_system.object[id].instance_bytes+sizeof(_aa_objectinstanceheader);
 bp=aa.object_system.object[id].instance_mem;
 for(h=0;h<aa.object_system.object[id].instance_slots;h++)
  {
  aaCast(oih,_aa_objectinstanceheader*,bp);
  if(oih->in_use==NO)
   {
   oih->in_use=YES;
   oih->sesh=(aa.object_system.object[id].sesh_counter*32)+aa.object_system.sesh_counter;
   aa.object_system.sesh_counter++;
   aa.object_system.object[id].sesh_counter++;
   base=(H)id*aa_OBJ_MAX_PER_ID;
   base+=aa_OBJ_BASE_HANDLE;
   *handle=(base+h);
   bp+=sizeof(_aa_objectinstanceheader);
   aaMemoryFill(bp,aa.object_system.object[id].instance_bytes,0);
   if(mem)    {    *mem=bp;    }
   bp-=sizeof(_aa_objectinstanceheader);
   aa.object_system.object[id].instance_count++;
   aa.object_system.total_count++;
   #if aa_USE_GLOBAL_MUTEX==1
   LeaveCriticalSection(&global_mutex);
   #endif
   return RET_YES;
   }
  bp+=(instance_stride);
  }
 Boop;
 oof;
 #if aa_USE_GLOBAL_MUTEX==1
 LeaveCriticalSection(&global_mutex);
 #endif
 return RET_FAILED;
 }






 B aa_ObjectCheck                      (B id,H handle,PP mem,BP isprotected)
 {
 register BP bp;
 _aa_objectinstanceheader*oih;
 H base,h,instance_stride;

 #ifdef aa_DIAGNOSE
 aa_ZIAG(__FUNCTION__);
 aa.object_system.object_check_count[id]++;
 #endif
 if(mem)         { *mem=NULL; }
 if(isprotected) { *isprotected=NO; }
 if(aa.object_system.object[id].instance_limit==0) {  return RET_BADHANDLE; }
 base=(H)id*aa_OBJ_MAX_PER_ID;
 base+=aa_OBJ_BASE_HANDLE;
 if(handle<base) {   return RET_BADHANDLE; }
 h=handle-base;
 if(h>=aa.object_system.object[id].instance_slots) {    return RET_BADHANDLE; }
 instance_stride=aa.object_system.object[id].instance_bytes+sizeof(_aa_objectinstanceheader);
 bp=aa.object_system.object[id].instance_mem;
 bp+=(h*instance_stride);
 aaCast(oih,_aa_objectinstanceheader*,bp);
 if(oih->in_use==NO) {  return RET_BADHANDLE; }
 if(isprotected)     {  *isprotected=oih->is_protected; }
 if(mem)             {  bp+=sizeof(_aa_objectinstanceheader);  *mem=bp;  }
 return RET_YES;
 }






 B aa_ObjectProtect                    (B id,H handle,B state)
 {
 B ret;
 BP mem;
 _aa_objectinstanceheader*oih;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(id,handle,(VP)&mem,NULL))!=RET_YES) { return ret; }
 mem-=sizeof(_aa_objectinstanceheader);
 aaCast(oih,_aa_objectinstanceheader*,mem);
 if(state)   { oih->is_protected=YES; }
 else        { oih->is_protected=NO;  }
 return RET_YES;
 }





 B aa_ObjectDestroy                    (B id,H handle)
 {
 B ret;
 BP mem;
 _aa_objectinstanceheader*oih;

 #if aa_USE_GLOBAL_MUTEX==1
 EnterCriticalSection(&global_mutex);
 #endif
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(id,handle,(VP)&mem,NULL))!=RET_YES)
  {
  #if aa_USE_GLOBAL_MUTEX==1
  LeaveCriticalSection(&global_mutex);
  #endif
  return ret;
  }
 mem-=sizeof(_aa_objectinstanceheader);
 aaCast(oih,_aa_objectinstanceheader*,mem);
 if(oih->is_protected==YES) { oof; return RET_FORBIDDEN; }
 aaMemoryFill(mem,aa.object_system.object[id].instance_bytes,0);
 oih->in_use=NO;
 aa.object_system.object[id].instance_count--;
 aa.object_system.total_count--;
 #if aa_USE_GLOBAL_MUTEX==1
 LeaveCriticalSection(&global_mutex);
 #endif
 return RET_YES;
 }




 B aa_ObjectIdNew                      (BP id)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(id==NULL) { return RET_BADPARM; }
 *id=aa.object_system.id_head++;
 return RET_YES;
 }







 B aa_ObjectNext                       (B id,HP handle,PP mem,HP iterationcounter)
 {
 register BP bp;
 _aa_objectinstanceheader*oih;
 H base,h,instance_stride;
 register H i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==NULL&&mem==NULL)  {  return RET_BADPARM;  }
 if(handle) { *handle=0; }
 if(mem)    { *mem=NULL; }
 if(iterationcounter==NULL)  {  return RET_BADPARM;  }
 if(aa.object_system.object[id].instance_limit==0) { return RET_FAILED; }
 if(aa.object_system.object[id].instance_count==0) { return RET_NOTFOUND; }
 instance_stride=aa.object_system.object[id].instance_bytes+sizeof(_aa_objectinstanceheader);
 base=(H)id*aa_OBJ_MAX_PER_ID;
 base+=aa_OBJ_BASE_HANDLE;
 h=*iterationcounter;
 for(i=0;i<aa.object_system.object[id].instance_slots;i++)
  {
  if(h>=aa.object_system.object[id].instance_slots) { h=0; }
  bp=aa.object_system.object[id].instance_mem;
  bp+=(h*instance_stride);
  aaCast(oih,_aa_objectinstanceheader*,bp);
  if(oih->in_use==YES)
   {
   if(handle) {  *handle=(base+h);  }
   *iterationcounter=h+1;
   if(mem) { bp+=sizeof(_aa_objectinstanceheader); *mem=bp;    }
   return RET_YES;
   }
  h++;
  }
 *iterationcounter=h+1;
 return RET_NOTFOUND;
 }




 B aa_ObjectFromHandle                 (BP id,H handle)
 {
 H base,i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==0) { return RET_BADHANDLE; }
 if(id!=NULL) { *id=0; }
 for(i=0;i<256;i++)
  {
  base=(H)i*aa_OBJ_MAX_PER_ID;
  base+=aa_OBJ_BASE_HANDLE;
  if(aa.object_system.object[i].instance_limit==0) {  continue; }
  if(handle<base) { continue; }
  if(handle>=(base+aa.object_system.object[i].instance_limit)) { continue; }
  if(id) { *id=(B)i; }
  break;
  }
 if(i==256) { return RET_FAILED; }
 return RET_YES;
 }



 B aa_ObjectHandleToIndex              (B id,H handle,HP index)
 {
 H base,i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==0) { return RET_BADHANDLE; }
 if(index!=NULL) { *index=0; }
 i=(H)id;
 while(1)
  {
  base=(H)i*aa_OBJ_MAX_PER_ID;
  base+=aa_OBJ_BASE_HANDLE;
  if(aa.object_system.object[i].instance_limit==0) {  return RET_BADHANDLE; }
  if(handle<base) { return RET_BADHANDLE; }
  if(handle>=(base+aa.object_system.object[i].instance_limit)) { return RET_BADHANDLE; }
  if(index) { *index=(handle-base); }
  break;
  }
 return RET_YES;
 }



 B aa_ObjectIndexToHandle              (B id,H index,HP handle)
 {
 H base,i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==0) { return RET_BADHANDLE; }
 if(handle!=NULL) { *handle=0; }
 i=(H)id;
 while(1)
  {
  base=(H)i*aa_OBJ_MAX_PER_ID;
  base+=aa_OBJ_BASE_HANDLE;
  if(aa.object_system.object[i].instance_limit==0) {  return RET_BADHANDLE; }
  if(index>=aa.object_system.object[i].instance_limit) { return RET_BOUNDS; }
  if(handle) { *handle=(index+base); }
  break;
  }
 return RET_YES;
 }


/*-----------------------------------------------------------------------*/



 B aa_ThreadSystemStart                (V)
 {
 aa_ObjectIdNew(&aa.thread_system.object_id);
 logg("aa_ThreadSystemStart()");
 aa_ObjectDefine(aa.thread_system.object_id,sizeof(_aa_threadobject),1024,512,aaThreadDestroy,"Thread");
 logg("");
 return RET_YES;
 }



 V aa_ThreadSystemStop                 (V)
 {
 logg("aa_ThreadSystemStop()");
 aa_ObjectUndefine(aa.thread_system.object_id);
 logg("");
 }


/*-----------------------------------------------------------------------*/





 B aa_PoolSystemStart                  (V)
 {
 aa_ObjectIdNew(&aa.pool_system.object_id);
 logg("aa_PoolSystemStart()");
 aa_ObjectDefine(aa.pool_system.object_id,sizeof(_aa_poolobject),512,64,aaPoolDestroy,"Pool");
 logg("");
 return RET_YES;
 }



 V aa_PoolSystemStop                   (V)
 {
 logg("aa_PoolSystemStop()");
 aa_ObjectUndefine(aa.pool_system.object_id);
 logg("");
 }





 B aa_PoolSystemAddPages               (PP ptr,H qty)
 {
 B ret;
 _aa_poolobject*poop;
 H bytes,add,from;

 aaCast(poop,_aa_poolobject*,*ptr);
 if(qty==0) { return RET_YES; }
 add=poop->pages_allocated+qty;
 bytes=sizeof(_aa_poolpage)*add;
 if(poop->pages_allocated==0)
  {
  ret=aaMemoryAllocate((VP)&poop->page,bytes);
  aaMemoryNameSet(poop->page,"pppage");
  }
 else
  {
  ret=aaMemoryReAllocate((VP)&poop->page,bytes);
  }
 if(ret!=YES) { oops; }
 for(from=0;from<qty;from++)
  {
  aaMemoryFill(&poop->page[poop->pages_allocated+from],sizeof(_aa_poolpage),0);
  }
 poop->pages_allocated=add;
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/

 B aa_ProcessSystemStart               (V)
 {
 aa_ObjectIdNew(&aa.process_system.object_id);
 logg("aa_ProcessSystemStart()");
 aa_ObjectDefine(aa.process_system.object_id,sizeof(_aa_processobject),512,64,aaProcessDestroy,"Process");
 logg("");
 return RET_YES;
 }


 V aa_ProcessSystemStop                (V)
 {
 logg("aa_ProcessSystemStop()");
 aa_ObjectUndefine(aa.process_system.object_id);
 logg("");
 }






 B aa_ProcessSystemCreate              (HP handle,VP processfilename,VP commandline,B clmode,B inherit,B startpaused,B detach,B newroot,W showcmd,B isconsole,VP desktop)
 {
 B ret;
 _aa_processobject*prop;
 B pat[_2K];
 H fl;
 BOOL bo;
 C one[_2K];
 C two[_2K];
 C txt[_2K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(processfilename!=NULL)
  {
  if(aaFileExists(processfilename)!=YES) { return RET_NOTFOUND; }
  }
 if((ret=aa_ObjectCreate(aa.process_system.object_id,handle,(VP)&prop))!=RET_YES) { oops; return ret; }
 prop->self_handle=*handle;
 aaMemoryFill(&prop->si,sizeof(STARTUPINFO),0);
 aaMemoryFill(&prop->pi,sizeof(PROCESS_INFORMATION),0);
 prop->si.cb=sizeof(prop->si.cb);
 prop->si.dwFlags=STARTF_USESHOWWINDOW;
 prop->si.wShowWindow=showcmd;
 if(showcmd==F16)     { prop->si.dwFlags=0;  prop->si.wShowWindow=SW_HIDE;  }
 GetStartupInfo(&prop->si);
 aaStringNull(pat);
  fl=0;
  fl|=CREATE_SUSPENDED;
  if(detach)           { fl|=DETACHED_PROCESS; }
  if(showcmd==SW_HIDE) { fl|=CREATE_NO_WINDOW; }
  if(newroot)          { fl|=CREATE_NEW_PROCESS_GROUP; }
  if(detach)      { prop->status.is_detached=YES; }
  if(newroot)     { prop->status.is_newroot=YES; }
  if(inherit)     { prop->status.is_inherit=YES; }
  if(aaStringIsNull(desktop)==NO)
   {
   aaStringCopyf(prop->status.desktop,"%s",desktop);
   aaStringCopyf(prop->si.lpDesktop,"%s",desktop);
   }
  if(clmode==0||clmode==1)
   {
   aaStringCopyf(one,"%s",processfilename);
   aaStringCopyf(two,"%s",commandline);
   aaStringCopyf(txt,"\"%s\" %s",one,two);
   bo=CreateProcess(NULL,(LPTSTR)txt,NULL,NULL,(inherit==YES)?TRUE:FALSE,fl,NULL,NULL,&prop->si,&prop->pi);
   }
  else
  if(clmode==2)
   {
   aaStringCopyf(one,"%s",processfilename);
   aaStringCopyf(two,"\"%s\"",commandline);
   bo=CreateProcess((LPTSTR)one,(LPTSTR)two,NULL,NULL,(inherit==YES)?TRUE:FALSE,fl,NULL,NULL,&prop->si,&prop->pi);
   }
  if(bo==0)
   {
   oow;
   aa_ObjectDestroy(aa.process_system.object_id,*handle);
   *handle=0;
   return RET_FAILED;
   }
  if(startpaused==YES) {  prop->status.is_paused=YES; }
  else                 {  ResumeThread(prop->pi.hThread);  }
  aaTimerTikGet(&prop->ms_root);
  if(isconsole) {  prop->status.is_console=YES; }
  else          {  prop->status.is_console=NO; }
  prop->status.tid=prop->pi.dwThreadId;
  prop->status.pid=prop->pi.dwProcessId;
  prop->status.thread_handle=prop->pi.hThread;
  prop->status.process_handle=prop->pi.hProcess;
 if(processfilename) {   aaStringCopyf(prop->status.file_name,"%s",processfilename); }
 aaStringCopyf(prop->status.cmd_line,"%s",commandline);
 return RET_YES;
 }





 BOOL CALLBACK aa_ProcessSystemEnum    (HWND hwnd,LPARAM lParam)
 {
 Z cl,tl;
 B txt[_2K];
 B str[_2K];
 _aa_processobject*prop;

 prop=(_aa_processobject*)lParam;
 aaStringNull(txt);
 aaStringNull(str);
 cl=GetClassName(hwnd,(LPSTR)txt,_1K);
 tl=GetWindowText(hwnd,(LPSTR)str,_1K);
 if(cl&&tl)
  {
  prop->status.hwnd=hwnd;
  return FALSE;
  }
 return TRUE;
 }



/*-----------------------------------------------------------------------*/


 B aa_WinEnumSystemStart               (V)
 {
 logg("aa_WinEnumSystemStart()");
 aa_ObjectIdNew(&aa.winenum_system.object_id);
 aa_ObjectDefine(aa.winenum_system.object_id,sizeof(_aa_winenumobject),512,8,aaWinEnumDestroy,"WinEnum");
 logg("");
 return RET_YES;
 }




 V aa_WinEnumSystemStop                (V)
 {
 logg("aa_WinEnumSystemStop()");
 aa_ObjectUndefine(aa.winenum_system.object_id);
 logg("");
 }




/*-----------------------------------------------------------------------*/



 B aa_DynbufSystemStart                (V)
 {
 logg("aa_DynbufSystemStart()");
 aa_ObjectIdNew(&aa.dynbuf_system.object_id);
 aa_ObjectDefine(aa.dynbuf_system.object_id,sizeof(_aa_dynbufobject),8192,256,aaDynbufDestroy,"Dynbuf");
 logg("");
 return RET_YES;
 }





 V aa_DynbufSystemStop                 (V)
 {
 logg("aa_DynbufSystemStop()");
 aa_ObjectUndefine(aa.dynbuf_system.object_id);
 logg("");
 }




 B aa_DynbufSystemExtend               (PP ptr,H by)
 {
 B ret;
 _aa_dynbufobject*dynp;
 H bytes;

 aaCast(dynp,_aa_dynbufobject*,*ptr);
 if(by==0) { return RET_YES; }
 bytes=dynp->status.bytes_allocated+by;
 if(dynp->status.bytes_allocated!=0)
  {
  if((ret=aa_MemoryProtect(dynp->status.mem,NO))!=YES) { oops; }
  if((ret=aa_MemoryReAllocate((VP)&dynp->status.mem,bytes))!=YES) { oops; }
  }
 else
  {
  if((ret=aa_MemoryAllocate((VP)&dynp->status.mem,bytes,"dynbyf",NO))!=YES) { oops; }
  }
 if((ret=aa_MemoryProtect(dynp->status.mem,YES))!=YES) { oops; }

 dynp->status.bytes_allocated=bytes;
 dynp->status.bytes_left=dynp->status.bytes_allocated-dynp->status.bytes_used;
 return RET_YES;
 }





/*-----------------------------------------------------------------------*/



 B aa_QueSystemStart                   (V)
 {
 logg("aa_QueSystemStart()");
 aa_ObjectIdNew(&aa.que_system.object_id);
 aa_ObjectDefine(aa.que_system.object_id,sizeof(_aa_queobject),_64K,512,aaQueDestroy,"Que");

 logg("");
 return RET_YES;
 }



 V aa_QueSystemStop                    (V)
 {
 logg("aa_QueSystemStop()");
 aa_ObjectUndefine(aa.que_system.object_id);
 logg("");
 }




 B aa_QueSystemExtendPageSlots         (PP mem,H by)
 {
 B ret;
 _aa_queobject*quep;
 BP vmem;
 H bytes;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(mem==NULL) { return RET_BADPARM; }
 aaCast(quep,_aa_queobject*,*mem);
 if(by==0) { return RET_YES; }
 if(quep->slots_allocated==0)
  {
  aa_last_line_executed=__LINE__;
  bytes=by*sizeof(H);
  if((ret=aa_MemoryAllocate((VP)&vmem,bytes,"QuePgeSlot",NO))!=RET_YES) { return ret; }
  aaCast(quep->pge_slot,HP,vmem);
  quep->slots_allocated=by;
  }
 else
  {
  aa_last_line_executed=__LINE__;
  bytes=(quep->slots_allocated+by)*sizeof(H);
  aaCast(vmem,BP,quep->pge_slot);
  if((ret=aa_MemoryReAllocate((VP)&vmem,bytes))!=RET_YES) { return ret; }
  aaCast(quep->pge_slot,HP,vmem);
  quep->slots_allocated+=by;
  }
 aa_last_line_executed=__LINE__;
 return RET_YES;
 }


/*-----------------------------------------------------------------------*/


 V aa_huffmanWriteTreeAndMakeTable     (BP out,HP outbitctr,H outlen,_aahuff_enctable*et,H code,Y bits,struct _aahuff_node *t)
 {
 _aahuff_enctable *eti;
 Y i;
 H byte_index;

 byte_index=(*outbitctr)++>>3;
 byte_index*=(byte_index<outlen);
 if(t->lr[0])
  {
  out[byte_index]<<=1;
  aa_huffmanWriteTreeAndMakeTable(out,outbitctr,outlen,et,code,bits+1,t->lr[0]);
  aa_huffmanWriteTreeAndMakeTable(out,outbitctr,outlen,et,code|(1<<bits),bits+1,t->lr[1]);
  }
 else
  {
  out[byte_index]=(out[byte_index]<<1)|1;
  for(i=0;i<9;++i)
   {
   byte_index=(*outbitctr)++>>3;
   if(byte_index>=outlen) return;
   out[byte_index]=(out[byte_index]<<1)|((B)((t->c>>i)&1));
   }
  eti=&(et[t->c]);
  eti->code=code;
  eti->bits=bits;
  }
 }



 B aa_huffmanReadTree                  (BP in,HP inbitctr,H inlen,BP *heapptr,BP heapend,struct _aahuff_node**hnptr)
 {
 struct _aahuff_node *n;
 Y i;
 H byte_index;

 n=(struct _aahuff_node *)(*heapptr);
 *heapptr+=sizeof(struct _aahuff_node);
 if(*heapptr>heapend)
  {
  *hnptr=(struct _aahuff_node *)0;
  return RET_YES;
  }
 byte_index=*inbitctr>>3;
 byte_index*=(byte_index<inlen);
 if(((in[byte_index]>>(~((*inbitctr)++)&7))&1))
  {
  n->lr[0]=(struct _aahuff_node *)0;
  n->lr[1]=(struct _aahuff_node *)0;
  n->c=0;
  for(i=0;i<9;++i)
   {
   byte_index=*inbitctr>>3;
   if(byte_index>=inlen)
    {
    *hnptr=(struct _aahuff_node *)0;
    return RET_YES;
    }
   n->c|=(((Y)(in[byte_index]>>(~((*inbitctr)++)&7)))&1)<<i;
   }
  }
 else
  {
  aa_huffmanReadTree(in,inbitctr,inlen,heapptr,heapend,&n->lr[0]);
  aa_huffmanReadTree(in,inbitctr,inlen,heapptr,heapend,&n->lr[1]);
  if(!((n->lr[0])&&(n->lr[1])))
   {
   *hnptr=(struct _aahuff_node *)0;
   return RET_YES;
   }
  }
 *hnptr=n;
 return RET_YES;
 }





 H aa_huffmanCompress                  (BP in,H inlen,BP out,H outlen,VP huffheap)
 {
 _aahuff_enctable *et,*eti;
 struct _aahuff_node *t,*n;
 struct _aahuff_node *pair[2];
 BP heapptr=(BP)huffheap;
 H i,code,byte_index,outbitctr;
 Y bits,b;
 DP counts;
 D lowest_prob,total_symbols;

 counts=(DP)heapptr;
 heapptr+=(sizeof(D)*257);
 for(i=0;i<256;++i) counts[i]=0.0;
 counts[256]=1.0;
 for(i=0;i<inlen;++i) counts[(H)in[i]]+=1.0;
 t=(struct _aahuff_node *)0;
 total_symbols=(D)(inlen+1);
 for(i=0;i<=256;++i)
  {
  if(counts[i]>0.0)
   {
   n=(struct _aahuff_node *)heapptr;
   heapptr+=sizeof(struct _aahuff_node);
   if(t) t->qprev=n;
   n->qprev=(struct _aahuff_node *)0;
   n->qnext=t;
   n->lr[0]=(struct _aahuff_node *)0;
   n->lr[1]=(struct _aahuff_node *)0;
   n->prob=counts[i]/total_symbols;
   n->c=(Y)i;
   t=n;
   }
  }
 while(t->qnext)
  {
  for(i=0;i<2;++i)
   {
   lowest_prob=1.0;
   pair[i]=(struct _aahuff_node *)0;
   n=t;
   while(n)
    {
    if(n->prob<=lowest_prob) { lowest_prob=n->prob; pair[i]=n;	}
    n=n->qnext;
    }
   if(pair[i]->qprev) pair[i]->qprev->qnext=pair[i]->qnext;
   else                t=pair[i]->qnext;
   if(pair[i]->qnext) pair[i]->qnext->qprev=pair[i]->qprev;
   }
  n=(struct _aahuff_node *)heapptr;
  heapptr+=sizeof(struct _aahuff_node);
  n->lr[0]=pair[0];
  n->lr[1]=pair[1];
  n->prob=pair[0]->prob+pair[1]->prob;
  if(t) t->qprev=n;
  n->qprev=(struct _aahuff_node *)0;
  n->qnext=t;
  t=n;
  }
 et=(_aahuff_enctable *)heapptr;
 heapptr+=(sizeof(_aahuff_enctable)*257);
 outbitctr=0;
 aa_huffmanWriteTreeAndMakeTable(out,&outbitctr,outlen,et,0,0,t);
 for(i=0;i<inlen;++i)
  {
  eti=&(et[(H)in[i]]);
  code=eti->code;
  bits=eti->bits;
  for(b=0;b<bits;++b)
   {
   byte_index=outbitctr++>>3;
   if(byte_index>=outlen) { return (0xffffffff-1); }
   out[byte_index]=(out[byte_index]<<1)|(B)(code&1);
   code>>=1;
   }
  }
 code=et[256].code;
 bits=et[256].bits;
 for(b=0;b<bits;++b)
  {
  byte_index=outbitctr++>>3;
  if(byte_index>=outlen) { oof; return 0xffffffff; }
  out[byte_index]=(out[byte_index]<<1)|(B)(code&1);
  code>>=1;
  }
 if(outbitctr>(outlen<<3)) { oof; return 0xffffffff; }
 else
 if((outbitctr&7)) { out[i=(outbitctr>>3)]<<=8 - (outbitctr&7); return (i+1);	}
 return (outbitctr>>3);
 }




 H aa_huffmanDecompress                (BP in,H inlen,BP out,H outlen,VP huffheap,H hs)
 {
 struct _aahuff_node *t,*n;
 BP heapptr=(BP)huffheap;
 H inbitctr,outptr;
 H byte_index=0;

 inbitctr=0;
 aa_huffmanReadTree(in,&inbitctr,inlen,&heapptr,heapptr+hs,&t);
 if(!t) return 0;
 outptr=0;
 for(;;)
  {
  n=t;
  while(n->lr[0])
   {
   byte_index=inbitctr>>3;
   if(byte_index>=inlen) { return 0xffffffff; }
   n=n->lr[((H)(in[byte_index]>>(~(inbitctr++)&7)))&1];
   }
  if(n->c==256) break;
  if(outptr==outlen) { return (0xffffffff-1); }
  out[outptr++]=(B)n->c;
  }
 return outptr;
 }


/*-----------------------------------------------------------------------*/




 B aa_NetSystemStart                   (V)
 {
 B ret;
 B buf[_1K];
 H i;
 _localip lip;

 logg("aa_NetSystemStart()");

 if(WSAStartup(MAKEWORD(2,2),&aa.net_system.ws_data))  { oof; return RET_FAILED;  }
 aa.core_system.SleepFunction=aa_CoreSystemSleepPrecise;
 while(1)
  {
  ret=RET_FAILED;
  aaStringCopyf(buf,"aa.Sniff.Msg.Name.%lu",GetTickCount());
  if((aa.net_system.sniff_message_id=RegisterWindowMessage((CP)buf))==0) { oow; break; }
  aaStringCopyf(buf,"aa.Icmp.Msg.Name.%lu",GetTickCount());
  if((aa.net_system.icmp_message_id=RegisterWindowMessage((CP)buf))==0) { oow; break; }
  aaStringCopyf(buf,"aa.Dns.Msg.Name.%lu",GetTickCount());
  if((aa.net_system.dns_message_id=RegisterWindowMessage((CP)buf))==0) { oow; break; }
  aaStringCopyf(buf,"aa.Tcp.Msg.Name.%lu",GetTickCount());
  if((aa.net_system.tcp_message_id=RegisterWindowMessage((CP)buf))==0) { oow; break; }
  ret=RET_YES;
  break;
  }
 if(ret==RET_FAILED)  { oof; WSACleanup();  return RET_FAILED;  }
 aaStringCopyf(aa.net_system.class_name,"aa.net_system.Class.Name.%lu",GetTickCount());
 WinWndClassExSet(&aa.net_system.class_data,0,aa_NetSystemProc,aa.net_system.class_name);
 if(RegisterClassEx(&aa.net_system.class_data)==0)  {  oof; WSACleanup();  return RET_FAILED;  }
 aa.net_system.window=CreateWindowEx(WS_EX_TOOLWINDOW,(LPCTSTR)aa.net_system.class_name,NULL,0,10,10,4,4,NULL,NULL,aa.core_system.this_instance,NULL);
 if(aa.net_system.window==NULL)
  {
  oow;
  WSACleanup();
  UnregisterClass((LPCTSTR)aa.net_system.class_name,aa.core_system.this_instance);
  aa.net_system.class_name[0]=NULL_CHAR;
  return RET_FAILED;
  }
 logg("%s:%i net_system.window hwnd=%x",__func__,__LINE__,aa.net_system.window);
 if(SetWindowText(aa.net_system.window,(LPSTR)"aa.net_system.window")==0) { oof; }

 aa_ObjectIdNew(&aa.net_system.dns_object_id);
 aa_ObjectIdNew(&aa.net_system.sniff_object_id);
 aa_ObjectIdNew(&aa.net_system.icmp_object_id);
 aa_ObjectIdNew(&aa.net_system.udp_object_id);
 aa_ObjectIdNew(&aa.net_system.stunclient_object_id);
 aa_ObjectIdNew(&aa.net_system.tcpport_object_id);
 aa_ObjectIdNew(&aa.net_system.tcpcall_object_id);
 aa_ObjectIdNew(&aa.net_system.cgiclient_object_id);
 aa_ObjectIdNew(&aa.net_system.server_object_id);
 aa_ObjectDefine(aa.net_system.dns_object_id,sizeof(_aa_netdnsobject),aa_NET_MAX_DNS_OBJECTS,256,aaNetDnsDestroy,"Dns");
 aa_ObjectDefine(aa.net_system.sniff_object_id,sizeof(_aa_netsniffobject),512,4,aaNetSniffDestroy,"Sniff");
 aa_ObjectDefine(aa.net_system.icmp_object_id,sizeof(_aa_neticmpobject),512,8,aaNetIcmpDestroy,"Icmp");
 aa_ObjectDefine(aa.net_system.udp_object_id,sizeof(_aa_netudpobject),aa_NET_MAX_UDP_OBJECTS,64,aaNetUdpDestroy,"Udp");
 aa_ObjectDefine(aa.net_system.stunclient_object_id,sizeof(_aa_netstunclientobject),512,4,aaNetStunClientDestroy,"StunCli");
 aa_ObjectDefine(aa.net_system.tcpcall_object_id,sizeof(_aa_nettcpcallobject),aa_NET_MAX_TCP_CALLS,256,aaNetTcpCallDestroy,"TcpCall");
 aa_ObjectDefine(aa.net_system.tcpport_object_id,sizeof(_aa_nettcpportobject),aa_NET_MAX_TCP_PORTS,32,aaNetTcpPortDestroy,"Tcp-Port");
 aa_ObjectDefine(aa.net_system.cgiclient_object_id,sizeof(_aa_netcgiclientobject),_32K,64,aaNetCgiClientDestroy,"CgiCli");
 aa_ObjectDefine(aa.net_system.server_object_id,sizeof(_aa_netserverobject),_32K,32,aaNetServerDestroy,"Server");
 aa.net_system.net_status.max_tcp_calls=aa_NET_MAX_TCP_CALLS;
 aa.net_system.net_status.max_tcp_ports=aa_NET_MAX_TCP_PORTS;
 if((ret=aaNetLocalIpGet(&lip,NO,YES))!=YES) { oops; }
 for(i=0;i<32;i++)
  {
  if(lip.ip[i]==0) continue;
  if(lip.type[i]!='P') continue;
  aa.net_system.net_status.public_ip[aa.net_system.net_status.public_ip_count]=lip.ip[i];
  aa.net_system.net_status.broadcast_ip[aa.net_system.net_status.public_ip_count]=lip.bcast_ip[i];
  aa.net_system.net_status.public_ip_count++;
  }
 //for(i=0;i<3;i++) {  aaTimerTikGet(&aa.net_system.sub_yield_tik[i]); }
 return RET_YES;
 }






 V aa_NetSystemStop                    (V)
 {
 logg("aa_NetSystemStop() %i,%i",aa_is_quit_called,aa_is_quit_received);
 aaNetPortListStop();

 aa_last_line_executed=__LINE__;
 aa_ObjectUndefine(aa.net_system.server_object_id);
 aa_last_line_executed=__LINE__;
 aa_ObjectUndefine(aa.net_system.cgiclient_object_id);
 aa_last_line_executed=__LINE__;
 aa_ObjectUndefine(aa.net_system.tcpport_object_id);
 aa_last_line_executed=__LINE__;
 aa_ObjectUndefine(aa.net_system.tcpcall_object_id);
 aa_last_line_executed=__LINE__;
 aa_ObjectUndefine(aa.net_system.stunclient_object_id);
 aa_ObjectUndefine(aa.net_system.udp_object_id);
 aa_ObjectUndefine(aa.net_system.icmp_object_id);
 aa_ObjectUndefine(aa.net_system.sniff_object_id);
 aa_last_line_executed=__LINE__;
 aa_ObjectUndefine(aa.net_system.dns_object_id);
 logg("%s about to wsa cleanup",__func__);
 WSACleanup();
 aa.core_system.SleepFunction=aa_CoreSystemSleepStandard;
 logg("%s about to destroy window %x",__func__,aa.net_system.window);
 DestroyWindow(aa.net_system.window);
 logg("%s about to unregister class",__func__);
 UnregisterClass((LPCTSTR)aa.net_system.class_name,aa.core_system.this_instance);
 logg("%s about to delete dns",__func__);
 if(aa.net_system.dns_cache.magic==aaHPP(aaListNew))
  {
  aaListDelete(&aa.net_system.dns_cache);
  }
 aa.net_system.window=NULL;
 aa.net_system.class_name[0]=NULL_CHAR;
 logg("");
 }






 B aa_NetSystemLocalEmailCheck         (V)
 {
 DWORD type,len;
 HKEY sub;
 LONG r;
 B buf[_1K];
 H index,ei;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 ei=0;
 if(RegOpenKeyEx(HKEY_CURRENT_USER,"Software\\Microsoft\\Internet Account Manager\\Accounts\\00000001",0L,KEY_READ|0x100,&sub)==ERROR_SUCCESS)
  {
  len=63; type=REG_SZ;
  r=RegQueryValueEx(sub,"HTTPMail User Name",NULL,&type,(BP)buf,&len);
  if(len<_1K) { buf[len]=NULL_CHAR; }
  if(r==ERROR_SUCCESS) {  aaStringCopy(aa.net_system.local_email[ei++],buf);  }
  len=63; type=REG_SZ;
  r=RegQueryValueEx(sub,"SMTP Email Address",NULL,&type,(BP)buf,&len);
  if(len<_1K) { buf[len]=NULL_CHAR; }
  if(r==ERROR_SUCCESS) {   aaStringCopy(aa.net_system.local_email[ei++],buf);  }
  RegCloseKey(sub);
  }
 if(RegOpenKeyEx(HKEY_CURRENT_USER,"Software\\Microsoft\\Windows\\CurrentVersion\\UnreadMail",0,KEY_READ|0x100,&sub)==ERROR_SUCCESS)
  {
  index=0;
  while(1)
   {
   len=63;
   r=RegEnumKey(sub,index,(CP)buf,len);
   if(r==   ERROR_NO_MORE_ITEMS) { break; }
   if(r==ERROR_SUCCESS)
    {
    aaStringLen(buf,&len);
    if(len>0&&len<64)  {  aaStringCopy(aa.net_system.local_email[ei++],buf);     break;     }
    }
   else   { aaNote(0,"check line %i",__LINE__); }
   index++;
   }
  RegCloseKey(sub);
  }
 aa.net_system.local_email_count=(B)ei;
 aa.net_system.local_email_checked=YES;
 return RET_YES;
 }





 B aa_NetSystemResolveIpPortPair       (SOCKET sock,HP locip,WP locport,HP remip,WP remport)
 {
 N len;
 struct sockaddr_in addr;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(locip)   { *locip=0; }
 if(locport) { *locport=0; }
 if(remip)   { *remip=0; }
 if(remport) { *remport=0; }

 if(locip!=NULL||locport!=NULL)
  {
  len=sizeof(addr);
  WinSockAddrSet(&addr,AF_INET,0,0);
  if(getsockname(sock,(struct sockaddr *)&addr,(VP)&len)!=SOCKET_ERROR)
   {
   if(locport) { *locport=htons(addr.sin_port); }
   if(locip)
    {
    *locip=*((HP)&addr.sin_addr);
    if(*locip==0)
     {
     aa_last_line_executed=__LINE__;
     aa_NetSystemLocalHostGet(locip,1);
     if(*locip==0) { return RET_FAILED; }
     }
    }
   }
  else {    return RET_FAILED; }
  }
 if(remip!=NULL||remport!=NULL)
  {
  len=sizeof(addr);
  WinSockAddrSet(&addr,AF_INET,0,0);
  if(getpeername(sock,(struct sockaddr *)&addr,(VP)&len)!=SOCKET_ERROR)
   {
   if(remport) { *remport=htons(addr.sin_port); }
   if(remip)   { *remip=*(HP)&addr.sin_addr; }
   }
  else { return RET_FAILED; }
  }
 return RET_YES;
 }





 B aa_NetSystemFindDnsByResolverHandle (HP handle,PP mem,HANDLE resolverhandle)
 {
 BP bp;
 _aa_objectinstanceheader*oih;
 _aa_netdnsobject*dnsp;
 H base,h,instance_stride,checked;
 B id;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 id=aa.net_system.dns_object_id;
 if(aa.object_system.object[id].instance_limit==0) { return RET_FAILED; }
 instance_stride=aa.object_system.object[id].instance_bytes+sizeof(_aa_objectinstanceheader);
 base=(H)id*aa_OBJ_MAX_PER_ID;
 base+=aa_OBJ_BASE_HANDLE;
 bp=aa.object_system.object[id].instance_mem;
 checked=0;
 for(h=0;h<aa.object_system.object[id].instance_slots;h++)
  {
  if(checked>=aa.object_system.object[id].instance_count) { break; }
  aaCast(oih,_aa_objectinstanceheader*,bp);
  if(oih->in_use==YES)
   {
   checked++;
   bp+=sizeof(_aa_objectinstanceheader);
   aaCast(dnsp,_aa_netdnsobject*,bp);
   if(dnsp->resolver_handle==resolverhandle)
    {
    if(handle) { *handle=base+h; }
    if(mem)    { *mem=bp; }
    return RET_YES;
    }
   bp-=sizeof(_aa_objectinstanceheader);
   }
  bp+=instance_stride;
  }
 return RET_NOTFOUND;
 }





 B aa_NetSystemFindSniffBySock         (HP handle,PP mem,SOCKET sock)
 {
 BP bp;
 _aa_objectinstanceheader*oih;
 _aa_netsniffobject*snifp;
 H base,h,instance_stride,checked;
 B id;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 id=aa.net_system.sniff_object_id;
 if(aa.object_system.object[id].instance_limit==0) { return RET_FAILED; }
 instance_stride=aa.object_system.object[id].instance_bytes+sizeof(_aa_objectinstanceheader);
 base=(H)id*aa_OBJ_MAX_PER_ID;
 base+=aa_OBJ_BASE_HANDLE;
 bp=aa.object_system.object[id].instance_mem;
 checked=0;
 for(h=0;h<aa.object_system.object[id].instance_slots;h++)
  {
  if(checked>=aa.object_system.object[id].instance_count) { break; }
  aaCast(oih,_aa_objectinstanceheader*,bp);
  if(oih->in_use==YES)
   {
   checked++;
   bp+=sizeof(_aa_objectinstanceheader);
   aaCast(snifp,_aa_netsniffobject*,bp);
   if(snifp->sock==sock)
    {
    if(handle) { *handle=base+h; }
    if(mem)    { *mem=bp; }
    return RET_YES;
    }
   bp-=sizeof(_aa_objectinstanceheader);
   }
  bp+=instance_stride;
  }
 return RET_NOTFOUND;
 }




 B aa_NetSystemFindIcmpBySock          (HP handle,PP mem,SOCKET sock)
 {
 BP bp;
 _aa_objectinstanceheader*oih;
 _aa_neticmpobject*icmpp;
 H base,h,instance_stride,checked;
 B id;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 id=aa.net_system.icmp_object_id;
 if(aa.object_system.object[id].instance_limit==0) { return RET_FAILED; }
 instance_stride=aa.object_system.object[id].instance_bytes+sizeof(_aa_objectinstanceheader);
 base=(H)id*aa_OBJ_MAX_PER_ID;
 base+=aa_OBJ_BASE_HANDLE;
 bp=aa.object_system.object[id].instance_mem;
 checked=0;
 for(h=0;h<aa.object_system.object[id].instance_slots;h++)
  {
  if(checked>=aa.object_system.object[id].instance_count) { break; }
  aaCast(oih,_aa_objectinstanceheader*,bp);
  if(oih->in_use==YES)
   {
   checked++;
   bp+=sizeof(_aa_objectinstanceheader);
   aaCast(icmpp,_aa_neticmpobject*,bp);
   if(icmpp->sock==sock)
    {
    if(handle) { *handle=base+h; }
    if(mem)    { *mem=bp; }
    return RET_YES;
    }
   bp-=sizeof(_aa_objectinstanceheader);
   }
  bp+=instance_stride;
  }
 return RET_NOTFOUND;
 }






 B aa_NetSystemFindPortBySock          (HP handle,PP mem,SOCKET sock)
 {
 BP bp;
 _aa_objectinstanceheader*oih;
 _aa_nettcpportobject*prtp;
 H base,h,instance_stride,checked;
 B id;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 id=aa.net_system.tcpport_object_id;
 if(aa.object_system.object[id].instance_limit==0) { return RET_FAILED; }
 instance_stride=aa.object_system.object[id].instance_bytes+sizeof(_aa_objectinstanceheader);
 base=(H)id*aa_OBJ_MAX_PER_ID;
 base+=aa_OBJ_BASE_HANDLE;
 bp=aa.object_system.object[id].instance_mem;
 checked=0;
 for(h=0;h<aa.object_system.object[id].instance_slots;h++)
  {
  if(checked>=aa.object_system.object[id].instance_count) { break; }
  aaCast(oih,_aa_objectinstanceheader*,bp);
  if(oih->in_use==YES)
   {
   checked++;
   bp+=sizeof(_aa_objectinstanceheader);
   aaCast(prtp,_aa_nettcpportobject*,bp);
   if(prtp->sock==sock&&prtp->socket_used==YES)
    {
    if(handle) { *handle=base+h; }
    if(mem)    { *mem=bp; }
    return RET_YES;
    }
   bp-=sizeof(_aa_objectinstanceheader);
   }
  bp+=instance_stride;
  }
 return RET_NOTFOUND;
 }








 B aa_NetSystemFindCallBySock          (HP handle,PP mem,SOCKET sock,B mustbeincall,B mustbeoutcall)
 {
 BP bp;
 _aa_objectinstanceheader*oih;
 _aa_nettcpcallobject*calp;
 H base,h,instance_stride;
 H checked;
 B id,ok;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mustbeoutcall==YES&&mustbeincall==YES) { return RET_BADPARM; }
 id=aa.net_system.tcpcall_object_id;
 if(aa.object_system.object[id].instance_limit==0) { return RET_FAILED; }
 instance_stride=aa.object_system.object[id].instance_bytes+sizeof(_aa_objectinstanceheader);
 base=(H)id*aa_OBJ_MAX_PER_ID;
 base+=aa_OBJ_BASE_HANDLE;
 bp=aa.object_system.object[id].instance_mem;
 checked=0;
 for(h=0;h<aa.object_system.object[id].instance_slots;h++)
  {
  if(checked>=aa.object_system.object[id].instance_count) { break; }
  aaCast(oih,_aa_objectinstanceheader*,bp);
  if(oih->in_use==YES)
   {
   checked++;
   bp+=sizeof(_aa_objectinstanceheader);
   aaCast(calp,_aa_nettcpcallobject*,bp);
   if(calp->sock==sock&&calp->socket_used==YES)
    {
    ok=NO;
    if(mustbeincall==NO&&mustbeoutcall==NO) { ok=YES; }
    else
     {
     if(mustbeincall==YES&&calp->status.is_incoming==YES) { ok=YES; }
     if(mustbeoutcall==YES&&calp->status.is_incoming==NO) { ok=YES; }
     }
    if(ok==YES)
     {
     if(handle) { *handle=base+h; }
     if(mem)    { *mem=bp; }
     return RET_YES;
     }
    }
   bp-=sizeof(_aa_objectinstanceheader);
   }
  bp+=instance_stride;
  }
 return RET_NOTFOUND;
 }






 B aa_NetSystemFindCallByPortSock      (HP handle,PP mem,SOCKET sock)
 {
 BP bp;
 _aa_objectinstanceheader*oih;
 _aa_nettcpcallobject*calp;
 H base,h,instance_stride,checked;
 B id;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 id=aa.net_system.tcpcall_object_id;
 if(aa.object_system.object[id].instance_limit==0) { return RET_FAILED; }
 instance_stride=aa.object_system.object[id].instance_bytes+sizeof(_aa_objectinstanceheader);
 base=(H)id*aa_OBJ_MAX_PER_ID;
 base+=aa_OBJ_BASE_HANDLE;
 bp=aa.object_system.object[id].instance_mem;
 checked=0;
 for(h=0;h<aa.object_system.object[id].instance_slots;h++)
  {
  if(checked>=aa.object_system.object[id].instance_count) { break; }
  aaCast(oih,_aa_objectinstanceheader*,bp);
  if(oih->in_use==YES)
   {
   checked++;
   bp+=sizeof(_aa_objectinstanceheader);
   aaCast(calp,_aa_nettcpcallobject*,bp);
   if(calp->port_sock==sock&&calp->socket_used==YES)
    {
    if(calp->status.is_incoming==YES)
     {
     if(handle) { *handle=base+h; }
     if(mem)    { *mem=bp; }
     return RET_YES;
     }
    }
   bp-=sizeof(_aa_objectinstanceheader);
   }
  bp+=instance_stride;
  }
 return RET_NOTFOUND;
 }




 B aa_NetSystemFindUdpByAddress        (HP handle,PP mem,H ip,W port)
 {
 BP bp;
 _aa_objectinstanceheader*oih;
 _aa_netudpobject*udpp;
 H base,h,instance_stride;
 H checked;
 B id;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 id=aa.net_system.udp_object_id;
 if(aa.object_system.object[id].instance_limit==0) { return RET_FAILED; }
 instance_stride=aa.object_system.object[id].instance_bytes+sizeof(_aa_objectinstanceheader);
 base=(H)id*aa_OBJ_MAX_PER_ID;
 base+=aa_OBJ_BASE_HANDLE;
 bp=aa.object_system.object[id].instance_mem;
 checked=0;
 for(h=0;h<aa.object_system.object[id].instance_slots;h++)
  {
  if(checked>=aa.object_system.object[id].instance_count) { break; }
  aaCast(oih,_aa_objectinstanceheader*,bp);
  if(oih->in_use==YES)
   {
   checked++;
   bp+=sizeof(_aa_objectinstanceheader);
   aaCast(udpp,_aa_netudpobject*,bp);
   if(udpp->status.local_adr.ip==ip&&udpp->status.local_adr.port==port)
    {
    if(handle) { *handle=base+h; }
    if(mem)    { *mem=bp; }
    return RET_YES;
    }
   bp-=sizeof(_aa_objectinstanceheader);
   }
  bp+=instance_stride;
  }
 return RET_NOTFOUND;
 }





 B aa_NetSystemLocalHostGet            (HP localip,H count)
 {
 B txt[129];
 struct hostent *phe;
 H i,c;
 struct in_addr addr;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(localip==NULL) { return RET_BADPARM; }
 if(count==0) { return RET_BADPARM; }
 aaMemoryFill(localip,count*4,0);
 logg("Calling get host name");
 aa_last_line_executed=__LINE__;
 if(gethostname((CP)txt,sizeof(txt))==SOCKET_ERROR)
  {
  logg("gethostname failuree");
  return RET_FAILED;
  }
 logg("host name = %s  (calling gethostbyname)",txt);
 aa_last_line_executed=__LINE__;
 phe=gethostbyname((CP)txt);
 if(phe==NULL) {  return RET_FAILED; }
 c=0;
 for(i=0;phe->h_addr_list[i]!=0;++i)
  {
  localip[c]=0;
  aaMemoryCopy(&addr,sizeof(struct in_addr),phe->h_addr_list[i]);
  localip[c]=*((HP)&addr);
  if(localip[c]!=0) { c++; }
  if(c==count)  { break;  }
  }
  aa_last_line_executed=__LINE__;
 if(c==0) {  return RET_NOTFOUND; }
 return RET_YES;
 }





 B aa_NetSystemTcpCallCreate           (HP handle,H ip,W port,H sip,W sport)
 {
 B ret,isprot;
 _aa_nettcpcallobject*calp;
 SOCKET sock;
 struct sockaddr_in addr;
 N error;
 N oval,olen;
 UNUSE(oval);
 UNUSE(olen);
 UNUSE(sip);
 UNUSE(sport);

 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,*handle,(VP)&calp,&isprot))!=RET_YES) { oops; return ret; }
 if(isprot==YES)      { oof; return RET_FORBIDDEN; }
 if(calp->dns_handle) { oof; return RET_BADSTATE; }
 sock=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
 if(sock==INVALID_SOCKET)  {   aa_ObjectDestroy(aa.net_system.tcpcall_object_id,*handle);  *handle=0;  return RET_FAILED;  }

 if((sip||sport))//&&calp->status.is_incoming)
  {
  WinSockAddrSet(&addr,AF_INET,sip,htons(sport));
  if(bind(sock,(struct sockaddr *)&addr,sizeof(addr)))
   {
   oow;
   aa_ObjectDestroy(aa.net_system.tcpport_object_id,*handle);
   closesocket(sock);
   *handle=0;
   return RET_INUSE;
   }
  }

  calp->socket_used=YES;
  WinSockAddrSet(&addr,AF_INET,ip,htons(port));
  while(1)
   {
   if(WSAAsyncSelect(sock,aa.net_system.window,aa.net_system.tcp_message_id,FD_CONNECT|FD_CLOSE)) { oof; oow; ret=RET_FAILED; break; }
   error=connect(sock,(struct sockaddr *)&addr,sizeof(addr));
   if(error==0) { oof; ret=RET_FAILED; break; }
   if(error==SOCKET_ERROR)
    {
    error=WSAGetLastError();
    if(error==WSAENOBUFS||error!=WSAEWOULDBLOCK)
     {
     aaNote(0,"line=%i error=%i (%i,%i)",__LINE__,error,WSAENOBUFS,WSAEWOULDBLOCK);
     aaDebugf("line=%i error=%i (%i,%i)",__LINE__,error,WSAENOBUFS,WSAEWOULDBLOCK);
     ret=RET_FAILED;
     break;
     }
    }
   if((ret=aaQueCreate(&calp->xmit_que))!=RET_YES) {  break; }
   if((ret=aaQueCreate(&calp->rcve_que))!=RET_YES) {  break; }
   logg("tcpcallcreate xmit que handle = %i",calp->xmit_que);
   logg("tcpcallcreate rcve que handle = %i",calp->rcve_que);
   break;
   }
  if(ret!=RET_YES)
   {
   oops;
   logg("oops=%i line=%i",ret,__LINE__);
   aa_ObjectDestroy(aa.net_system.tcpcall_object_id,*handle);
   *handle=0;
   return RET_FAILED;
   }
  calp->sock=sock;
  calp->status.sock=sock;
  calp->status.remote_adr.ip=ip;
  calp->status.remote_adr.port=port;
  if((ret=aa_NetSystemResolveIpPortPair(calp->sock,&calp->status.local_adr.ip,&calp->status.local_adr.port,0,0))!=YES)
   {
   oops;
   }
  aaNetAdrToString(&calp->status.remote_adr,calp->status.remote_dot);
  aaNetAdrToString(&calp->status.local_adr,calp->status.local_dot);
  calp->inactive_rcve_ms_root=calp->ms_root;
  calp->inactive_xmit_ms_root=calp->ms_root;
  aa.net_system.net_status.current_outgoing_tcp_call_count++;
  aa.net_system.net_status.total_outgoing_tcp_call_count++;
  aaNetTcpCallSlicerLengthSet(*handle,_8K,_8K);
  aaNetTcpCallBufferLengthSet(*handle,_32K,_32K);
  calp->status.user_data=calp->user_data;
  calp->status.user_bytes=sizeof(calp->user_data);
 aaNetTcpCallStatus(*handle,0);
 return RET_YES;
 }




 B aa_NetSystemNextTcpCall             (HP handle,PP ptr,W matchport,HP iterationcounter)
 {
 BP bp;
 _aa_objectinstanceheader*oih;
 H base,h,instance_stride,i;
 B id;
 _aa_nettcpcallobject*calp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(ptr) { *ptr=NULL; }
 if(handle==NULL)            {  return RET_BADPARM;  }
 if(iterationcounter==NULL)  {  return RET_BADPARM;  }
 id=aa.net_system.tcpcall_object_id;
 if(aa.object_system.object[id].instance_limit==0) { return RET_FAILED; }
 instance_stride=aa.object_system.object[id].instance_bytes+sizeof(_aa_objectinstanceheader);
 base=(H)id*aa_OBJ_MAX_PER_ID;
 base+=aa_OBJ_BASE_HANDLE;
 h=*iterationcounter;
 for(i=0;i<aa.object_system.object[id].instance_slots;i++)
  {
  if(h>=aa.object_system.object[id].instance_slots) { h=0; }
  bp=aa.object_system.object[id].instance_mem;
  bp+=(h*instance_stride);
  aaCast(oih,_aa_objectinstanceheader*,bp);
  if(oih->in_use==YES)
   {
   calp=(_aa_nettcpcallobject*)(bp+sizeof(_aa_objectinstanceheader));
   if(matchport==0||calp->status.local_adr.port==matchport)
    {
    *handle=(base+h);
    *iterationcounter=h+1;
    if(ptr) {  bp+=sizeof(_aa_objectinstanceheader);    *ptr=bp;    }
    return RET_YES;
    }
   }
  h++;
  }
 *iterationcounter=h+1;
 return RET_NOTFOUND;
 }







 B aa_NetSystemProcessTcp              (PP mem)
 {
 B ret;
 _questatus qs;
 _aa_nettcpcallobject*calp;
 _aa_queobject*quep;
 N done;
 H todo,err;
 B temp[_64K];
 H max_todo;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL)  { return RET_BADPARM; }
 aaCast(calp,_aa_nettcpcallobject*,*mem);

 if(calp->status.is_closed_by_local==YES)
  {
  aaTimerTikElapsed(calp->local_closed_ms_root,&calp->status.local_closed_ms);
  calp->status.closed_ms=calp->status.local_closed_ms;
  }
 if(calp->status.is_closed_by_remote==YES)
  {
  aaTimerTikElapsed(calp->remote_closed_ms_root,&calp->status.remote_closed_ms);
  calp->status.closed_ms=calp->status.remote_closed_ms;
  }
 max_todo=calp->status.rcve_slicer_length;
 if(calp->is_rcve_backoff==YES) { max_todo=1; }
 if(calp->status.rcve_then_pause>0) { max_todo=1; }

 if(calp->status.is_rcve_paused==NO&&calp->is_rcve_backoff==NO)
  {
  if((ret=aa_ObjectCheck(aa.que_system.object_id,calp->rcve_que,(VP)&quep,NULL))!=RET_YES) { return ret; }
  done=recv(calp->sock,(CP)temp,max_todo,0);
  if(done==0)
   {
   err=WSAGetLastError();
   if(calp->status.is_closed_by_remote!=YES) aaTimerTikGet(&calp->remote_closed_ms_root);
   calp->status.is_closed_by_remote=YES;
   }
  if(done==SOCKET_ERROR)
   {
   err=WSAGetLastError();
   if(err==WSAECONNRESET)
    {
    if(calp->status.is_closed_by_remote!=YES) aaTimerTikGet(&calp->remote_closed_ms_root);
    calp->status.is_closed_by_remote=YES;
    }
   }
  if(done!=SOCKET_ERROR&&done!=0)
   {
   if((ret=aaQueWrite(calp->rcve_que,done,temp))!=RET_YES) { oof; Boop; return ret; }
   aaQueStatus(calp->rcve_que,&qs);
   calp->status.rcve_bytes=qs.bytes;
   aa.net_system.net_status.total_tcp_bytes_in+=(Q)(done);
   calp->status.rcve_bytes_total+=(Q)done;
   aaTimerTikGet(&calp->inactive_rcve_ms_root);
   calp->status.rcve_inactivity=0;
   if(calp->status.rcve_then_pause>0)
    {
    if((H)done>=calp->status.rcve_then_pause) { calp->status.rcve_then_pause=0;  }
    else                                     { calp->status.rcve_then_pause-=(H)done; }
    if(calp->status.rcve_then_pause==0) { calp->status.is_rcve_paused=YES; }
    }
   }
  }
 max_todo=calp->status.xmit_slicer_length;
 if(calp->is_xmit_slowdown||calp->is_xmit_backoff==YES) { max_todo=1;   }
 if(calp->status.xmit_then_pause>0) { max_todo=1; }

 if(calp->status.is_xmit_paused==NO)
  {
  if((ret=aa_ObjectCheck(aa.que_system.object_id,calp->xmit_que,(VP)&quep,NULL))!=RET_YES) { return ret; }
  if(quep->status.bytes!=0)
   {
   todo=quep->status.bytes;
   todo=aaNumRoof(todo,max_todo);
   todo=aaNumRoof(todo,sizeof(temp));
   if((ret=aaQuePeek(calp->xmit_que,0,todo,temp))!=RET_YES) { oof; Boop; return ret; }
   done=send(calp->sock,(CP)temp,todo,0);
   if(done==SOCKET_ERROR)
    {
    err=WSAGetLastError();
    if(err==10035||err==10055)
     {
     if(calp->is_xmit_slowdown<100)
      {
      calp->is_xmit_slowdown++;
      }
     }
    if(err==WSAECONNRESET)
     {
     if(calp->status.is_closed_by_remote!=YES) aaTimerTikGet(&calp->remote_closed_ms_root);
     calp->status.is_closed_by_remote=YES;
     }
    }
   if(done!=SOCKET_ERROR)
    {
    if(done!=0)
     {
     if((ret=aaQueDiscard(calp->xmit_que,done))!=RET_YES) { oof; Boop;return ret; }
     aaQueStatus(calp->xmit_que,&qs);
     calp->status.xmit_bytes=qs.bytes;
     aaTimerTikGet(&calp->inactive_xmit_ms_root);
     calp->status.xmit_inactivity=0;
     if(calp->is_xmit_slowdown) { calp->is_xmit_slowdown--;  }
     if(calp->status.xmit_then_pause>0)
      {
      if((H)done>=calp->status.xmit_then_pause) { calp->status.xmit_then_pause=0; }
      else                                      { calp->status.xmit_then_pause-=(H)done; }
      if(calp->status.xmit_then_pause==0) {     calp->status.is_xmit_paused=YES; }
      }

     }
    calp->status.xmit_bytes_total+=(Q)(done);
    aa.net_system.net_status.total_tcp_bytes_out+=(Q)(done);
    }
   }
  }
 else
  {
  //aaDebugf("eoke");
  }
 if((ret=aaQueStatus(calp->rcve_que,&qs))!=RET_YES) { oof; Boop; return ret; }
 calp->status.rcve_bytes=qs.bytes;
  if((ret=aaQueStatus(calp->xmit_que,&qs))!=RET_YES) { oof; Boop;return ret; }
  calp->status.xmit_bytes=qs.bytes;
 if(calp->status.max_rcve_rate!=0)
  {
  if(calp->is_rcve_backoff==NO&&calp->status.rcve_rate>(calp->status.max_rcve_rate*1.0))  {  calp->is_rcve_backoff=YES; }
  else
  if(calp->is_rcve_backoff==YES&&calp->status.rcve_rate<calp->status.max_rcve_rate) { calp->is_rcve_backoff=NO;  }
  }
 if(calp->status.max_xmit_rate!=0)
  {
  if(calp->is_xmit_backoff==NO&&calp->status.xmit_rate>(calp->status.max_xmit_rate*1.0))  {  calp->is_xmit_backoff=YES; }
  else
  if(calp->is_xmit_backoff==YES&&calp->status.xmit_rate<calp->status.max_xmit_rate) { calp->is_xmit_backoff=NO;  }
  }
 return RET_YES;
 }




 B aa_NetSystemCalculateUdpTimers      (PP mem)
 {
 _aa_netudpobject*udpp;
 D d1,d2;
 H tik,el;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL)  { return RET_BADPARM; }
 aaCast(udpp,_aa_netudpobject*,*mem);

 udpp->calc_timer_cycle++;
 aaTimerTikGet(&tik);
 aaTimerTikElapsedUsingTik(udpp->sub_tik,tik,&el);
 if((el>=(H)(1000.0/500.0))||udpp->calc_timer_cycle<20)
  {
  udpp->sub_tik=tik;
  aaTimerTikElapsed(udpp->ms_root,&udpp->status.ms);
  aaTimerTikElapsed(udpp->inactive_ms_root,&udpp->status.inactivity);
  }
 aaTimerProfilerUpdate(&udpp->recent_profiler,1);
 if(udpp->recent_profiler.nano<=10000) { return RET_YES; }

 d1=udpp->recent_profiler.ms+aa_NET_RECENT_FREQ;
 d2=udpp->rcve_bytes_total_recent+udpp->rcve_bytes_total_previous;   d2=d2/d1;   udpp->status.rcve_byte_rate=(H)d2;
 d2=udpp->xmit_bytes_total_recent+udpp->xmit_bytes_total_previous;   d2=d2/d1;   udpp->status.xmit_byte_rate=(H)d2;
 d2=udpp->rcve_pkts_total_recent+udpp->rcve_pkts_total_previous;     d2=d2/d1;   udpp->status.rcve_pkt_rate=(H)d2;
 d2=udpp->xmit_pkts_total_recent+udpp->xmit_pkts_total_previous;     d2=d2/d1;   udpp->status.xmit_pkt_rate=(H)d2;
  if(udpp->recent_profiler.ms>=aa_NET_RECENT_FREQ)
   {
   aaTimerProfilerInit(&udpp->recent_profiler,1);
   udpp->rcve_bytes_total_previous=udpp->rcve_bytes_total_recent;
   udpp->xmit_bytes_total_previous=udpp->xmit_bytes_total_recent;
   udpp->rcve_pkts_total_previous=udpp->rcve_pkts_total_recent;
   udpp->xmit_pkts_total_previous=udpp->xmit_pkts_total_recent;
   udpp->rcve_bytes_total_recent=0;
   udpp->xmit_bytes_total_recent=0;
   udpp->rcve_pkts_total_recent=0;
   udpp->xmit_pkts_total_recent=0;
   }
 return RET_YES;
 }







 B aa_NetSystemProcessUdp              (PP mem)
 {
 B ret;
 _questatus qs;
 _aa_netudpobject*udpp;
 struct sockaddr_in addr;
 N len,bytes;
 B tmp[128];
 fd_set set;
 struct timeval tv;
 Z flags;
 Z val;
 B can_xmit;
 B isok;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL)  { return RET_BADPARM; }
 aaCast(udpp,_aa_netudpobject*,*mem);
 aa_NetSystemCalculateUdpTimers((VP)&udpp);
  FD_ZERO(&set);
  FD_SET(udpp->sock,&set);
  WSASetLastError(0);
  tv.tv_sec=0;
  tv.tv_usec=0;
  val=select(0,&set,0,0,&tv);
  if(val==SOCKET_ERROR) { oof;  oow; }
  if(val>=1)
  {
  if(FD_ISSET(udpp->sock,&set)!=0)
   {
   len=sizeof(addr);
   flags=0;
   if((bytes=recvfrom(udpp->sock,(CP)&aa.net_system.tmpbuf[sizeof(addr)+4],0x10000,flags,(struct sockaddr *)&addr,(ZP)&len))>=0)
    {
    aaMemoryCopy(&aa.net_system.tmpbuf[0],sizeof(addr),&addr);
    *(HP)&aa.net_system.tmpbuf[sizeof(addr)]=bytes;
    if((ret=aaQueWrite(udpp->rcve_que,sizeof(addr)+4+bytes,aa.net_system.tmpbuf))!=RET_YES) { oops; return ret; }
    if(flags==MSG_PEEK) {   recvfrom(udpp->sock,0,0,0,0,0); }
    udpp->status.rcve_bytes_total+=(Q)bytes;
    udpp->rcve_bytes_total_recent+=(bytes+8);
    udpp->rcve_pkts_total_recent++;
    udpp->status.rcve_pkts_qued++;
    aa.net_system.net_status.total_udp_packets_received++;
    aaTimerTikGet(&udpp->inactive_ms_root);
    udpp->status.inactivity=0;
    }
   }
  }
 if(udpp->status.xmit_pkts_qued!=0)
  {
  can_xmit=YES;
  if(udpp->status.xmit_speed!=0.0)
   {
   aaTimerProfilerUpdate(&udpp->xmit_profiler,1);
   if(udpp->xmit_profiler.ms<udpp->status.xmit_speed)
    {
    if(udpp->status.xmit_pkts_total!=udpp->last_total_pkts_sent)
     {
     udpp->status.xmit_que_misses++;
     udpp->last_total_pkts_sent=udpp->status.xmit_pkts_total;
     }
    can_xmit=NO;
    }
   }
  if(can_xmit==YES)
   {
   isok=YES;
   if(udpp->status.is_flowcontrol_set==YES)
    {
    isok=NO;
    FD_ZERO(&set);
    FD_SET(udpp->sock,&set);
    WSASetLastError(0);
    tv.tv_sec=0;
    tv.tv_usec=0;
    val=select(0,0,&set,0,&tv);
    if(val==SOCKET_ERROR) { oof; oow; }
    if(FD_ISSET(udpp->sock,&set)!=0) { isok=YES; }
    }

   if(isok==YES)
    {
    aaQueStatus(udpp->xmit_que,&qs);
    if(qs.bytes<(sizeof(addr)+4))   { return RET_YES; }
    if((ret=aaQuePeek(udpp->xmit_que,0,sizeof(addr)+4,tmp))!=RET_YES) { return ret; }
    aaMemoryCopy(&addr,sizeof(addr),&tmp[0]);
    aaMemoryPeekDword(&tmp[sizeof(addr)],0,(HP)&bytes);
    if(qs.bytes<(sizeof(addr)+4+bytes)) { return RET_YES; }
    if(aaQuePeek(udpp->xmit_que,0,sizeof(addr)+4+bytes,aa.net_system.tmpbuf)!=RET_YES) { return RET_FAILED; }
    if((len=sendto(udpp->sock,(CP)&aa.net_system.tmpbuf[sizeof(addr)+4],bytes,0,(struct sockaddr *)&addr,sizeof(addr)))>=0)
     {
     if(len!=bytes) { oof; return RET_FAILED; }
     udpp->status.xmit_bytes_total+=bytes;
     udpp->xmit_bytes_total_recent+=(bytes+8);
     udpp->xmit_pkts_total_recent++;
     if((ret=aaQueDiscard(udpp->xmit_que,bytes+sizeof(addr)+4))!=RET_YES)  { oops; return ret; }
     udpp->status.xmit_pkts_total++;
     udpp->status.xmit_pkts_qued--;
     aa.net_system.net_status.total_udp_packets_sent++;
     if(udpp->status.xmit_speed!=0.0)  {   aaTimerProfilerInit(&udpp->xmit_profiler,1); }
     }
    }
   }
  }
 return RET_YES;
 }





 B aa_NetSystemProcessIcmp             (PP mem,B doread,B dowrite)
 {
 B ret;
 _questatus qs;
 _aa_neticmpobject*icmpp;
 _aa_netipheader*iph;
 struct sockaddr_in addr;
 N len,bytes;
 BP tmpbuf=NULL_POINTR;
 B tmp[128];
 D d1,d2;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL)  { return RET_BADPARM; }
 aaCast(icmpp,_aa_neticmpobject*,*mem);
 if((ret=aa_MemoryTemp((VP)&tmpbuf,_64K+_1K,aa_MEMORYTEMP_IcmpProc))!=RET_YES) { return ret; }
 icmpp->calc_timer_cycle++;
 if(icmpp->calc_timer_cycle%10==0||icmpp->calc_timer_cycle<20)
  {
  aaTimerTikElapsed(icmpp->ms_root,&icmpp->status.ms);
  aaTimerTikElapsed(icmpp->inactive_ms_root,&icmpp->status.inactivity);
  d1=(D)icmpp->status.ms/1000.0;
  if(d1!=0.0)
   {
   d2=icmpp->status.total_bytes_sent;     d2=d2/d1; icmpp->status.xmit_byte_rate=(H)d2;
   d2=icmpp->status.total_bytes_received; d2=d2/d1; icmpp->status.rcve_byte_rate=(H)d2;
   d2=icmpp->status.total_pkts_sent;      d2=d2/d1; icmpp->status.xmit_pkt_rate=(H)d2;
   d2=icmpp->status.total_pkts_received;  d2=d2/d1; icmpp->status.rcve_pkt_rate=(H)d2;
   }
  }
 if(doread)
  {
  len=sizeof(addr);
  if((bytes=recvfrom(icmpp->sock,(CP)tmpbuf,0x10000,0,(struct sockaddr *)&addr,(ZP)&len))>=0)
   {
   if((ret=aaQueWrite(icmpp->rcve_que,sizeof(addr),&addr))!=RET_YES) { return ret; }
   bytes-=sizeof(_aa_netipheader);
   bytes-=sizeof(_aa_neticmpheader);
   if((ret=aaQueWrite(icmpp->rcve_que,4,&bytes))!=RET_YES) { return ret; }
   aaCast(iph,_aa_netipheader*,tmpbuf);
   if((ret=aaQueWrite(icmpp->rcve_que,4,&iph->dst_ip.s_addr))!=RET_YES) { return ret; }
   if((ret=aaQueWrite(icmpp->rcve_que,sizeof(_aa_neticmpheader),&tmpbuf[sizeof(_aa_netipheader)]))!=RET_YES) { return ret; }
   if(bytes!=0)
    {
    if((ret=aaQueWrite(icmpp->rcve_que,bytes,&tmpbuf[sizeof(_aa_netipheader)+sizeof(_aa_neticmpheader)]))!=RET_YES) { return ret; }
    }
   icmpp->status.rcve_pkts_qued++;
   }
  }
 if(dowrite&&icmpp->status.xmit_pkts_qued!=0)
  {
  aaQueStatus(icmpp->xmit_que,&qs);
  if(qs.bytes<(sizeof(addr)+4+sizeof(_aa_neticmpheader)))   { return RET_YES; }
  if((ret=aaQuePeek(icmpp->xmit_que,0,sizeof(addr)+4+sizeof(_aa_neticmpheader),tmp))!=RET_YES) { return ret; }
  aaMemoryCopy(&addr,sizeof(addr),&tmp[0]);
  aaMemoryPeekDword(&tmp[sizeof(addr)],0,(HP)&bytes);
  if(qs.bytes<(sizeof(addr)+4+sizeof(_aa_neticmpheader)+bytes)) { return RET_YES; }
  if(aaQuePeek(icmpp->xmit_que,sizeof(addr)+4,sizeof(_aa_neticmpheader)+bytes,tmpbuf)!=RET_YES) { return RET_FAILED; }
  if((len=sendto(icmpp->sock,(CP) tmpbuf,sizeof(_aa_neticmpheader)+bytes,0,(struct sockaddr *)&addr,sizeof(addr)))>=0)
   {
   if(len!=(N)(sizeof(_aa_neticmpheader)+bytes)) { oof; Boop; return RET_FAILED; }
   if((ret=aaQueDiscard(icmpp->xmit_que,sizeof(addr)+4+len))!=RET_YES)  { return ret; }
   icmpp->status.total_pkts_sent++;
   icmpp->status.xmit_pkts_qued--;
   }
  }
 return RET_YES;
 }





 B aa_NetSystemProcessSniff            (PP mem)
 {
 B ret;
 _aa_netsniffobject*snifp;
 D d1,d2;
 BP tmpbuf=NULL_POINTR;
 N bytes;
 _sniffheaderip*snh;
 _sniffheadertcp*snhtcp;
 WP wp;
 BP actual_data_ptr;
 H actual_data_len;
 H val;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL)  { return RET_BADPARM; }
 aaCast(snifp,_aa_netsniffobject*,*mem);
 snifp->calc_timer_cycle++;
 if(snifp->calc_timer_cycle%5==0||snifp->calc_timer_cycle<20)
  {
  aaTimerTikElapsed(snifp->ms_root,&snifp->status.ms);
  aaTimerTikElapsed(snifp->inactive_ms_root,&snifp->status.inactivity);
  d1=(D)snifp->status.ms/1000.0;
  if(d1!=0.0)
   {
   d2=snifp->status.total_bytes_received; d2=d2/d1; snifp->status.rcve_byte_rate=(H)d2;
   d2=snifp->status.total_pkts_received;  d2=d2/d1; snifp->status.rcve_pkt_rate=(H)d2;
   }
  }
 if((ret=aa_MemoryTemp((VP)&tmpbuf,_64K+_1K,aa_MEMORYTEMP_SniffProc))!=RET_YES) { oops; return ret; }
 bytes=recv(snifp->sock,(CP)tmpbuf,65535,0);

 if(bytes!=SOCKET_ERROR)
  {
  if(bytes>1500) { aaNote(0,"lll %i",bytes); }
  if(bytes>=(int)sizeof(_sniffheaderip))
   {
   snh=(_sniffheaderip*)tmpbuf;
   snh->tot_len=aaNumSwapWord(snh->tot_len);
   snh->packet_id=aaNumSwapWord(snh->packet_id);
   snh->hdr_crc=aaNumSwapWord(snh->hdr_crc);
   wp=(WP)&tmpbuf[6];
   *wp=aaNumSwapWord(*wp);
   if(snh->frag_offset!=0) { aaNote(0,"fragoff=%i",snh->frag_offset); return RET_NO; }
   if(snh->protocol!=6) { return RET_NO; }
   if(snh->protocol==6)
    {
    snhtcp=(_sniffheadertcp*)&tmpbuf[sizeof(_sniffheaderip)];
    snhtcp->src_port=aaNumSwapWord(snhtcp->src_port);
    snhtcp->dst_port=aaNumSwapWord(snhtcp->dst_port);
    snhtcp->seq_number=aaNumSwapDword(snhtcp->seq_number);
    snhtcp->ack_number=aaNumSwapDword(snhtcp->ack_number);
    snhtcp->window=aaNumSwapWord(snhtcp->window);
    snhtcp->crc=aaNumSwapWord(snhtcp->crc);
    actual_data_ptr=(BP)&tmpbuf[sizeof(_sniffheaderip)+(snhtcp->data_offset*4)];
    actual_data_len=(bytes-(actual_data_ptr-tmpbuf));
    if((ret=aaQueWrite(snifp->rcve_que,sizeof(Q),&aa_msrunning))!=RET_YES) { oops; return ret; }
    val=bytes;
    if((ret=aaQueWrite(snifp->rcve_que,sizeof(H),&val))!=RET_YES) { oops; return ret; }
    val=snh->hlen*4;
    if((ret=aaQueWrite(snifp->rcve_que,sizeof(H),&val))!=RET_YES) { oops; return ret; }
    if((ret=aaQueWrite(snifp->rcve_que,val,snh))!=RET_YES) { oops; return ret; }
    val=(snhtcp->data_offset*4);
    if((ret=aaQueWrite(snifp->rcve_que,sizeof(H),&val))!=RET_YES) { oops; return ret; }
    if((ret=aaQueWrite(snifp->rcve_que,val,snhtcp))!=RET_YES) { oops; return ret; }
    val=actual_data_len;
    if((ret=aaQueWrite(snifp->rcve_que,sizeof(H),&val))!=RET_YES) { oops; return ret; }
    if(val>0)
     {
     if((ret=aaQueWrite(snifp->rcve_que,val,actual_data_ptr))!=RET_YES) { oops; return ret; }
     }
    snifp->status.rcve_pkts_qued++;
    return RET_YES;
    }
   }
  else
   {
   }
  }
 else
  {
  int e=WSAGetLastError();
  if(e!=WSAEWOULDBLOCK) {}
  }

 return RET_NO;
 }






 K aa_NetSystemProc                    (HWND wnd,UINT msg,WPARAM wparm,LPARAM lparm)
 {
 _aa_netdnsobject*dnsp;
 _aa_netsniffobject*snifp;
 _aa_neticmpobject*icmpp;
 _aa_nettcpportobject*prtp;
 _aa_nettcpcallobject*calp;
 N len;
 struct sockaddr_in addr;
 SOCKET new_sock;
 H call_handle,go,prq;
 BP bp;
 _aa_objectinstanceheader*oih;
 H sh;
 S B isin=0;

 if(isin==0)  {  isin=1;  }
 else         {  logg("zzzalready in %i msg=%i",isin,msg);  }

 if(aa_is_quit_called||aa_is_quit_received)
  {
  logg("dns_msg=%x tcp_msg=%x",aa.net_system.dns_message_id,aa.net_system.tcp_message_id);
  logg("%s msgid=%x lo=%x hi=%x",__func__,msg,LOWORD(lparm),HIWORD(lparm));
  }
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(msg==aa.net_system.dns_message_id)
  {
  if(aa_NetSystemFindDnsByResolverHandle(NULL,(VP)&dnsp,(HANDLE)wparm)==YES)
   {
   switch(HIWORD(lparm))
    {
    case 0:                dnsp->stage=3;   break; // complete
    case WSAHOST_NOT_FOUND: dnsp->stage=2;   break; // dns not found
    case WSANO_DATA: dnsp->stage=2;   break; // dns not found ( but i think this could mean something else )
    default:    dnsp->stage=1; break; // dns failed
    }
   logg("NetSystemProc: DnsEvent: = %i",HIWORD(lparm));
   }
  isin=0;
  return 0;
  }


 if(msg==aa.net_system.sniff_message_id)
  {
  if(aa_NetSystemFindSniffBySock(NULL,(VP)&snifp,(SOCKET)wparm)==YES)
   {
   switch(LOWORD(lparm))
    {
    case FD_READ:
    prq=snifp->status.rcve_pkts_qued;
    for(go=0;go<256;go++)
     {
     aa_NetSystemProcessSniff((VP)&snifp);
     if(snifp->status.rcve_pkts_qued==prq) break;
     prq=snifp->status.rcve_pkts_qued;
     }
    break;
    case FD_WRITE:    break;
    case FD_ACCEPT:    break;
    case FD_CLOSE:    break;
    case FD_CONNECT:    break;
    }
   }
  isin=0;
  return 0;
  }

 if(msg==aa.net_system.icmp_message_id)
  {
  if(aa_NetSystemFindIcmpBySock(NULL,(VP)&icmpp,(SOCKET)wparm)==YES)
   {
   switch(LOWORD(lparm))
    {
    case FD_WRITE:    aa_NetSystemProcessIcmp((VP)&icmpp,NO,YES);    break;
    case FD_READ:     aa_NetSystemProcessIcmp((VP)&icmpp,YES,NO);    break;
    default:    break;
    }
   }
  isin=0;
  return 0;
  }

 if(msg==aa.net_system.tcp_message_id)
  {
  switch(LOWORD(lparm))
   {
   case FD_ACCEPT:
   if(aa_NetSystemFindPortBySock(NULL,(VP)&prtp,(SOCKET)wparm)==YES)
    {
    len=sizeof(addr);
    if((new_sock=accept(wparm,(struct sockaddr *)&addr,(Z FAR*)&len))==INVALID_SOCKET) { break; }
    if(aa_ObjectCreate(aa.net_system.tcpcall_object_id,&call_handle,(VP)&calp)!=YES) { oof; Boop; }
    calp->self_handle=call_handle;
    calp->status.is_inprogress=YES;
    calp->status.is_incoming=YES;
    calp->status.index=call_handle-((aa.net_system.tcpcall_object_id*aa_OBJ_MAX_PER_ID)+aa_OBJ_BASE_HANDLE);
    calp->sock=new_sock;
    calp->status.sock=new_sock;
    calp->port_sock=wparm;
    calp->socket_used=YES;
    if(aa_NetSystemResolveIpPortPair(calp->sock,&calp->status.local_adr.ip,&calp->status.local_adr.port,&calp->status.remote_adr.ip,&calp->status.remote_adr.port)!=YES)
     {
     logg("jesse");
     }
    aaTimerTikGet(&calp->ms_root);
    calp->inactive_rcve_ms_root=calp->ms_root;
    calp->inactive_xmit_ms_root=calp->ms_root;
    calp->status.rcve_inactivity=0;
    calp->status.xmit_inactivity=0;
    prtp->status.calls_waiting++;
    prtp->status.calls_total++;
    prtp->status.calls_inuse++;
    aaCast(bp,BP,calp);
    bp-=sizeof(_aa_objectinstanceheader);
    aaCast(oih,_aa_objectinstanceheader*,bp);
    calp->status.session=oih->sesh;
    calp->status.rcve_slicer_length=_4K;
    calp->status.xmit_slicer_length=_4K;
    calp->status.number=aa.net_system.net_status.total_tcp_call_count;

  aaStringCopyf(calp->status.hancock,"%s",aa_common_name[calp->status.is_incoming][calp->status.number%26]);
  if((calp->status.number/26)>0) aaStringAppendf(calp->status.hancock,"%u",(calp->status.number/26));
    aa.net_system.net_status.total_tcp_call_count++;
    aa.net_system.net_status.current_incoming_tcp_call_count++;
    aa.net_system.net_status.total_incoming_tcp_call_count++;
    aaNetAdrToString(&calp->status.local_adr,calp->status.local_dot);
    aaNetAdrToString(&calp->status.remote_adr,calp->status.remote_dot);
    logg("--call local sock = %i",calp->sock);
    logg("--port sock wparm = %i",calp->port_sock);
    }
   else
    {
    oof;
    closesocket((SOCKET)wparm);
    }
   break;


   case FD_CONNECT:
   if(aa_NetSystemFindCallBySock(NULL,(VP)&calp,(SOCKET)wparm,NO,YES)==YES)
    {
    if(HIWORD(lparm))
     {
     if(calp->status.is_closed_by_local==NO)
      {
      if(calp->status.is_closed_by_remote!=YES) aaTimerTikGet(&calp->remote_closed_ms_root);
      calp->status.is_closed_by_remote=YES;
      }
     calp->status.is_closed=YES;
     break;
     }
    if(WSAAsyncSelect(calp->sock,aa.net_system.window,aa.net_system.tcp_message_id,FD_CLOSE))
     {
     oof;
     oow;
     calp->status.is_failed=YES;
     break;
     }
    if(aa_NetSystemResolveIpPortPair(calp->sock,&calp->status.local_adr.ip,&calp->status.local_adr.port,&calp->status.remote_adr.ip,&calp->status.remote_adr.port)!=YES)
     {
     aaNote(0,"ewdkewo");
     }
    aaNetAdrToString(&calp->status.local_adr,calp->status.local_dot);
    aaNetAdrToString(&calp->status.remote_adr,calp->status.remote_dot);
    aa.net_system.net_status.current_tcp_calls_connected++;
    calp->status.is_connected=YES;
    if(calp->status.is_tls==NO)
     {
     calp->status.is_ready=YES;
     }
    if(calp->status.is_nodelay)
     {
     Z bnod=(Z)calp->status.is_nodelay;
     setsockopt(calp->sock,IPPROTO_TCP,TCP_NODELAY,(CP)&bnod,sizeof(Z));
     }
    }
   break;


   case FD_CLOSE:
   if(aa_NetSystemFindCallBySock(NULL,(VP)&calp,(SOCKET)wparm,NO,NO)==YES)
    {
    if(calp->status.is_closed_by_remote!=YES) aaTimerTikGet(&calp->remote_closed_ms_root);
    calp->status.is_closed_by_remote=YES;
    calp->status.is_closed=YES;
    }
   break;

   default:
   break;
   }
    isin=0;
  return 0;
  }




/*
  if(aa_SurfaceSystemFindSurfaceByHwnd(&sh,NULL,(HWND)wparm)!=YES)
   {
   return 1;
   }
*/

#if 1
 if(msg==WM_QUIT)
  {
  logg("NetSystemProc: Window %i got WM_QUIT",(H)wnd);
  }

 if(msg==WM_SETFOCUS)
  {
  logg("set efo");
  aaDebugf("fofo");
  logg("set fo");
  if(aa_SurfaceSystemFindSurfaceByHwnd(&sh,NULL,(HWND)wparm)==YES)
   {
   aaSurfaceFocus(sh);
   }
  else
   {
   }
  }
/*
 if(msg==WM_ACTIVATEAPP)
  {
  aaDebugf("acti");
  isin=0;
  return 0;
  }

*/
#endif

 aa_last_line_executed=__LINE__;
 aaStringCopyf(aa_last_info,"wnd=%x msg=%x wp=%x lp=%x",wnd,msg,wparm,lparm);

 isin=0;
 return DefWindowProc(wnd,msg,wparm,lparm);
 }







 B aa_NetSystemYield                   (V)
 {
 _aa_netudpobject*udpp;
 _aa_nettcpcallobject*calp;
 //H tik,i,el[6];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 //aaTimerTikGet(&tik);
 //for(i=0;i<3;i++)  {  aaTimerTikElapsedUsingTik(aa.net_system.sub_yield_tik[i],tik,&el[i]);  }

// if(el[0]>=(H)(1000.0/2.0))
// if(el[0]>=20)//..0.0/2.0))
  {
  if(aa_ObjectNext(aa.net_system.tcpcall_object_id,0,(VP)&calp,&aa.net_system.yield_tcpcall_counter)==YES)
   {
   aa_NetSystemProcessTcp((VP)&calp);
   aa_NetTlsYield((VP)&calp);
   }
  //aa.net_system.sub_yield_tik[0]=tik;
  }
 //if(el[1]>=(H)(1000.0/1.5))
  {
  if(aa_ObjectNext(aa.net_system.udp_object_id,0,(VP)&udpp,&aa.net_system.yield_udp_counter)==YES) {  aa_NetSystemProcessUdp((VP)&udpp); }
  //aa.net_system.sub_yield_tik[1]=tik;
  }
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/



 B aa_FontSystemStart                  (V)
 {
 B ret;
 _aa_fontobject*fntp;
 H i,x,y,off,img_off,nd;

 logg("aa_FontSystemStart()");
 font_4x8=0;
 font_4x16=0;
 font_8x8=0;
 font_8x16=0;
 font_8x32=0;
 font_16x16=0;
 font_16x32=0;
 aa_ObjectIdNew(&aa.font_system.object_id);
 aa_ObjectDefine(aa.font_system.object_id,sizeof(_aa_fontobject),300,16,aaFontDestroy,"Font");
 if((ret=aa_ObjectCreate(aa.font_system.object_id,&font_8x8,(VP)&fntp))!=RET_YES) { oops; return ret; }
 fntp->self_handle=font_8x8;
 fntp->instance++;
 fntp->status.is_mono_width=YES;
 fntp->status.is_mono_forced=NO;
 aaStringCopy(fntp->status.face_name,"aa.system.font8x8");
 aaSizeSet(&fntp->size,8,8);
 aaSizeCopy(&fntp->status.size,&fntp->size);
 aaSizeCopy(&fntp->status.curr_mono_size,&fntp->size);
 aaSizeCopy(&fntp->status.init_mono_size,&fntp->status.curr_mono_size);
 if((ret=aa_MemoryAllocate((VP)&fntp->status.img,8*8*256,"SysFont",NO))!=RET_YES) { aa_ObjectDestroy(aa.font_system.object_id,font_8x8); oops; return ret; }
 aa_ObjectProtect(aa.font_system.object_id,font_8x8,YES);
 for(i=0;i<256;i++)
  {
  fntp->status.char_width[i]=8;
  off=i*8;
  img_off=((i/16)*(16*64))+((i%16)*8);
  for(y=0;y<8;y++)
   {
   nd=(y*16*8);
   for(x=0;x<8;x++)
    {
    if(aaBitGet(aa_fontdos[off],x)==YES) { fntp->status.img[img_off+(nd)+x]=255; }
    else                                 { fntp->status.img[img_off+(nd)+x]=0; }
    }
   off++;
   }
  }

 if((ret=aa_ObjectCreate(aa.font_system.object_id,&font_8x16,(VP)&fntp))!=RET_YES) { oops; return ret; }
 fntp->self_handle=font_8x16;
 fntp->instance++;
 fntp->status.is_mono_width=YES;
 fntp->status.is_mono_forced=NO;
 aaStringCopy(fntp->status.face_name,"aa.system.font8x16");
 aaSizeSet(&fntp->size,8,16);
 aaSizeCopy(&fntp->status.size,&fntp->size);
 aaSizeCopy(&fntp->status.curr_mono_size,&fntp->size);
 aaSizeCopy(&fntp->status.init_mono_size,&fntp->status.curr_mono_size);
 if((ret=aa_MemoryAllocate((VP)&fntp->status.img,8*16*256,"SysFont",NO))!=RET_YES) { aa_ObjectDestroy(aa.font_system.object_id,font_8x16); oops; return ret; }
 aa_ObjectProtect(aa.font_system.object_id,font_8x16,YES);
 for(i=0;i<256;i++)
  {
  fntp->status.char_width[i]=8;
  off=i*8;
  img_off=((i/16)*(16*128))+((i%16)*8);
  for(y=0;y<16;y++)
   {
   nd=(y*16*8);
   for(x=0;x<8;x++)
    {
    if(aaBitGet(aa_fontdos[off],x)==YES) { fntp->status.img[img_off+(nd)+x]=255; }
    else                                   { fntp->status.img[img_off+(nd)+x]=0; }
    }
   if((y%2)==1){   off++; }
   }
  }

 if((ret=aa_ObjectCreate(aa.font_system.object_id,&font_8x32,(VP)&fntp))!=RET_YES) { oops; return ret; }
 fntp->self_handle=font_8x32;
 fntp->instance++;
 fntp->status.is_mono_width=YES;
 fntp->status.is_mono_forced=NO;
 aaStringCopy(fntp->status.face_name,"aa.system.font8x32");
 aaSizeSet(&fntp->size,8,32);
 aaSizeCopy(&fntp->status.size,&fntp->size);
 aaSizeCopy(&fntp->status.curr_mono_size,&fntp->size);
 aaSizeCopy(&fntp->status.init_mono_size,&fntp->status.curr_mono_size);
 if((ret=aa_MemoryAllocate((VP)&fntp->status.img,8*32*256,"SysFont",NO))!=RET_YES) { aa_ObjectDestroy(aa.font_system.object_id,font_8x32); oops; return ret; }
 aa_ObjectProtect(aa.font_system.object_id,font_8x32,YES);
 for(i=0;i<256;i++)
  {
  fntp->status.char_width[i]=8;
  off=i*8;
  img_off=((i/16)*(16*256))+((i%16)*8);
  for(y=0;y<32;y++)
   {
   nd=(y*16*8);
   for(x=0;x<8;x++)
    {
    if(aaBitGet(aa_fontdos[off],x)==YES) { fntp->status.img[img_off+(nd)+x]=255; }
    else                                 { fntp->status.img[img_off+(nd)+x]=0; }
    }
   if((y%4)==3){   off++; }
   }
  }
 if((ret=aa_ObjectCreate(aa.font_system.object_id,&font_4x8,(VP)&fntp))!=RET_YES) { oops; return ret; }
 fntp->self_handle=font_4x8;
 fntp->instance++;
 fntp->status.is_mono_width=YES;
 fntp->status.is_mono_forced=NO;
 aaStringCopy(fntp->status.face_name,"aa.system.font4x8");
 aaSizeSet(&fntp->size,4,8);
 aaSizeCopy(&fntp->status.size,&fntp->size);
 aaSizeCopy(&fntp->status.curr_mono_size,&fntp->size);
 aaSizeCopy(&fntp->status.init_mono_size,&fntp->status.curr_mono_size);
 if((ret=aa_MemoryAllocate((VP)&fntp->status.img,4*8*256,"SysFont",NO))!=RET_YES) { aa_ObjectDestroy(aa.font_system.object_id,font_8x16); oops; return ret; }
 aa_ObjectProtect(aa.font_system.object_id,font_4x8,YES);
 for(i=0;i<256;i++)
  {
  fntp->status.char_width[i]=4;
  off=i*8;
  img_off=((i/16)*(16*32))+((i%16)*4);
  for(y=0;y<8;y++)
   {
   nd=(y*16*4);
   for(x=0;x<4;x++)
    {
    if(aaBitGet(aa_fontdos[off],(x*2))==YES) { fntp->status.img[img_off+(nd)+x]=255; }
    else                                       { fntp->status.img[img_off+(nd)+x]=0; }
    }
   off++;
   }
  }
 if((ret=aa_ObjectCreate(aa.font_system.object_id,&font_4x16,(VP)&fntp))!=RET_YES) { oops; return ret; }
 fntp->self_handle=font_4x16;
 fntp->instance++;
 fntp->status.is_mono_width=YES;
 fntp->status.is_mono_forced=NO;
 aaStringCopy(fntp->status.face_name,"aa.system.font4x16");
 aaSizeSet(&fntp->size,4,16);
 aaSizeCopy(&fntp->status.size,&fntp->size);
 aaSizeCopy(&fntp->status.curr_mono_size,&fntp->size);
 aaSizeCopy(&fntp->status.init_mono_size,&fntp->status.curr_mono_size);
 if((ret=aa_MemoryAllocate((VP)&fntp->status.img,4*16*256,"SysFont",NO))!=RET_YES) { aa_ObjectDestroy(aa.font_system.object_id,font_8x16); oops; return ret; }
 aa_ObjectProtect(aa.font_system.object_id,font_4x16,YES);
 for(i=0;i<256;i++)
  {
  fntp->status.char_width[i]=4;
  off=i*8;
  img_off=((i/16)*(16*64))+((i%16)*4);
  for(y=0;y<16;y++)
   {
   nd=(y*16*4);
   for(x=0;x<4;x++)
    {
    if(aaBitGet(aa_fontdos[off],(x*2))==YES) { fntp->status.img[img_off+(nd)+x]=255; }
    else                                      { fntp->status.img[img_off+(nd)+x]=0; }
    }
   if((y%2)==1){   off++; }
   }
  }

 if((ret=aa_ObjectCreate(aa.font_system.object_id,&font_16x16,(VP)&fntp))!=RET_YES) { oops; return ret; }
 fntp->self_handle=font_16x16;
 fntp->instance++;
 fntp->status.is_mono_width=YES;
 fntp->status.is_mono_forced=NO;
 aaStringCopy(fntp->status.face_name,"aa.system.font16x16");
 aaSizeSet(&fntp->size,16,16);
 aaSizeCopy(&fntp->status.size,&fntp->size);
 aaSizeCopy(&fntp->status.curr_mono_size,&fntp->size);
 aaSizeCopy(&fntp->status.init_mono_size,&fntp->status.curr_mono_size);
 if((ret=aa_MemoryAllocate((VP)&fntp->status.img,16*16*256,"SysFont",NO))!=RET_YES) { aa_ObjectDestroy(aa.font_system.object_id,font_8x8); oops; return ret; }
 aa_ObjectProtect(aa.font_system.object_id,font_16x16,YES);

 for(i=0;i<256;i++)
  {
  fntp->status.char_width[i]=16;
  off=i*8;
  img_off=((i/16)*(16*256))+((i%16)*16);
  for(y=0;y<16;y++)
   {
   nd=(y*16*16);
   for(x=0;x<16;x++)
    {
    if(aaBitGet(aa_fontdos[off],x/2)==YES)     {     fntp->status.img[img_off+(nd)+x]=255;     }
    else                                         {     fntp->status.img[img_off+(nd)+x]=0;     }
    }
   if((y%2)==1){   off++; }
   }
  }

 if((ret=aa_ObjectCreate(aa.font_system.object_id,&font_16x32,(VP)&fntp))!=RET_YES) { oops; return ret; }
 fntp->self_handle=font_16x32;
 fntp->instance++;
 fntp->status.is_mono_width=YES;
 fntp->status.is_mono_forced=NO;
 aaStringCopy(fntp->status.face_name,"aa.system.font16x32");
 aaSizeSet(&fntp->size,16,32);
 aaSizeCopy(&fntp->status.size,&fntp->size);
 aaSizeCopy(&fntp->status.curr_mono_size,&fntp->size);
 aaSizeCopy(&fntp->status.init_mono_size,&fntp->status.curr_mono_size);
 if((ret=aa_MemoryAllocate((VP)&fntp->status.img,16*32*256,"SysFont",NO))!=RET_YES) { aa_ObjectDestroy(aa.font_system.object_id,font_8x8); oops; return ret; }
 aa_ObjectProtect(aa.font_system.object_id,font_16x32,YES);
 for(i=0;i<256;i++)
  {
  fntp->status.char_width[i]=16;
  off=i*8;
  img_off=((i/16)*(16*512))+((i%16)*16);
  for(y=0;y<32;y++)
   {
   nd=(y*16*16);
   for(x=0;x<16;x++)
    {
    if(aaBitGet(aa_fontdos[off],x/2)==YES)     {     fntp->status.img[img_off+(nd)+x]=255;     }
    else                                         {     fntp->status.img[img_off+(nd)+x]=0;     }
    }
   if((y%4)==3){   off++; }
   }
  }
 aa.font_system.font_4x8=font_4x8;
 aa.font_system.font_4x16=font_4x16;
 aa.font_system.font_8x8=font_8x8;
 aa.font_system.font_8x16=font_8x16;
 aa.font_system.font_8x32=font_8x32;
 aa.font_system.font_16x16=font_16x16;
 aa.font_system.font_16x32=font_16x32;
 logg("");
 return RET_YES;
 }







 V aa_FontSystemStop                   (V)
 {
 B ret;

 aa_ObjectProtect(aa.font_system.object_id,font_4x8,NO);
 aaFontDestroy(aa.font_system.font_4x8);
 aa_ObjectProtect(aa.font_system.object_id,font_4x16,NO);
 aaFontDestroy(aa.font_system.font_4x16);
 aa_ObjectProtect(aa.font_system.object_id,font_8x8,NO);
 aaFontDestroy(aa.font_system.font_8x8);
 aa_ObjectProtect(aa.font_system.object_id,font_8x16,NO);
 aaFontDestroy(aa.font_system.font_8x16);
 aa_ObjectProtect(aa.font_system.object_id,font_8x32,NO);
 aaFontDestroy(aa.font_system.font_8x32);
 aa_ObjectProtect(aa.font_system.object_id,font_16x16,NO);
 aaFontDestroy(aa.font_system.font_16x16);
 aa_ObjectProtect(aa.font_system.object_id,font_16x32,NO);
 aaFontDestroy(aa.font_system.font_16x32);
 aa_ObjectUndefine(aa.font_system.object_id);
 if(aa.font_system.font_pixel.slots!=0)
  {
  if((ret=aa_MemoryRelease(aa.font_system.font_pixel.mem))!=YES) { oops; }
  aa.font_system.font_pixel.slots=0;
  aa.font_system.font_pixel.count=0;
  aa.font_system.font_pixel.mem=NULL;
  }

 logg("aa_FontSystemStop()");
 logg("");
 }




 B aa_FontSystemPixelSlotsExpand       (V)
 {
 B ret;
 D div;
 H slots,state,add;

 slots=aa.font_system.font_pixel.slots;
 if(slots<0x0100) { state=0; add=0x0150; } else
 if(slots<0x0200) { state=1; add=0x0300; } else
 if(slots<0x0400) { state=2; add=0x0450; } else
                  { state=3; add=0x0600; }
 div=(30+(state*10))/100.0;
 add=(add+slots)+(slots*div);
 if(add==aa.font_system.font_pixel.slots) { oof; }
 if(aa.font_system.font_pixel.slots==0)   {  ret=aa_MemoryAllocate((VP)&aa.font_system.font_pixel.mem,add*sizeof(_fontpixel),"fontpixels",NO);     }
 else                                     {  ret=aa_MemoryReAllocate((VP)&aa.font_system.font_pixel.mem,add*sizeof(_fontpixel));   }
 if(ret!=RET_YES)           {  oops;  }
 aa.font_system.font_pixel.slots=add;
 return RET_YES;
 }






 B aa_FontSystemFind                   (HP handle,VP facettf,H resnum,N logw,N logh,B weight,B italic,B underline,B smoothed,H charset)
 {
 H i,mx,han;
 _aa_fontobject*fntp;

 mx=aa.object_system.object[aa.font_system.object_id].instance_limit;
 for(i=0;i<mx;i++)
  {
  if(aa_ObjectIndexToHandle(aa.font_system.object_id,i,&han)!=YES) { continue; }
  if(aa_ObjectCheck(aa.font_system.object_id,han,(VP)&fntp,0)!=RET_YES) { continue; }
  if(resnum!=0)
   {
   if(fntp->status.res_num!=resnum) { continue; }
   }
  else
   {
   if(aaStringICompare(facettf,fntp->status.face_name,0)!=YES) { continue; }
   }
  if(logw!=fntp->status.logw) { continue; }
  if(logh!=fntp->status.logh) { continue; }
  if(weight!=fntp->status.weight) { continue; }
  if(italic!=fntp->status.is_italic) { continue; }
  if(underline!=fntp->status.is_underline) { continue; }
  if(smoothed!=fntp->status.is_smoothed) { continue; }
  if(charset!=fntp->status.charset) { continue; }
  if(handle) { *handle=han; }
  return RET_YES;
  }
 return RET_NOTFOUND;
 }









 K aa_FontCallBack                     (ENUMLOGFONT FAR*lpelf,NEWTEXTMETRIC FAR*lpntm,Z FontType,LPARAM lParam)
 {
 B ret;
 BP mem,prv;
 _data*dp;
 H sl;

 if(lpntm||FontType||lParam) {}
 aaCast(dp,_data*,lParam);
 if(dp==NULL) { return 0; }
 aaStringLen(lpelf->elfFullName,&sl);
 if(sl>32) { return 1; }
 oof;
 if(dp->field_count!=0)    { aaDataFieldInfoGetByIndex(dp,dp->field_count-1,0,0,(VP)&prv); }
 else                      { prv=NULL; }
 if(prv!=NULL)             { if(aaStringICompare(lpelf->elfFullName,prv,0)==YES) { return 1; }  }
 if((ret=aaDataFieldAdd(dp,0,33,0,(VP)&mem))!=YES) { oops; }
 aaStringCopy(mem,lpelf->elfFullName);
 return 1;
 }



/*-----------------------------------------------------------------------*/


/* http://www.catch22.net/tuts/tips2
void ForceVisibleDisplay(HWND hwnd)
{
    RECT rect;
    GetWindowRect(hwnd, &rect);

    // check if the specified window-rectangle is visible on any display
    if(NULL==MonitorFromRect(&rect, MONITOR_DEFAULTTONULL))
    {
        HMONITOR hMonitor;
        MONITORINFO mi = { sizeof(mi) };

        // find the nearest display to the rectangle
        hMonitor = MonitorFromRect(&rect, MONITOR_DEFAULTTONEAREST);

        GetMonitorInfo(hMonitor, &mi);

        // center window rectangle
        rect.left = mi.rcWork.left + ((mi.rcWork.right - mi.rcWork.left) - (rect.right-rect.left))/2;
        rect.top  = mi.rcWork.top  + ((mi.rcWork.bottom - mi.rcWork.top) - (rect.bottom-rect.top))/2;

        SetWindowPos(hwnd, 0, rect.left, rect.top, 0, 0, SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOSIZE);
    }
}

*/

 B aa_DisplaySystemStart               (V)
 {
 logg("aa_DisplaySystemStart()");
 if(aaDisplayInfoGet(&aa.display_system.di,F8)!=YES) { oof; }
 return RET_YES;
 }



 V aa_DisplaySystemStop                (V)
 {
 logg("aa_DisplaySystemStop()");
 if(aa.display_system.is_revert==YES)  {  oof;  }
 if(aa.display_system.gdi32_module!=NULL)
  {
  FreeLibrary(aa.display_system.gdi32_module);
  aa.display_system.gdi32_module=NULL;
  }
 }





 B aa_DisplaySystemLoadModules         (V)
 {
 HANDLE mod;

 logg("aa_DisplaySystemLoadModules");
 if(aa.display_system.gdi32_module==NULL)
  {
  if((mod=LoadLibrary("gdi32.dll"))==NULL) {  return RET_FAILED; }
  aa.display_system.gdi32_module=mod;
  if((aa.display_system.GetDeviceGammaRamp=(getDeviceGammaRamp)GetProcAddress(aa.display_system.gdi32_module,"GetDeviceGammaRamp"))==NULL) { oof; oow; }
  if((aa.display_system.SetDeviceGammaRamp=(setDeviceGammaRamp)GetProcAddress(aa.display_system.gdi32_module,"SetDeviceGammaRamp"))==NULL) { oof; oow; }
  }
 return RET_YES;
 }




 B aa_DisplayGetMonitorSizeFromEDID    (HKEY hDevRegKey,WP WidthMm,WP HeightMm)
 {
 N retValue,i;
 H dwType,AcutalValueNameLength,edidsize;
 TCHAR valueName[NAME_SIZE];
 B EDIDdata[_1K];

 AcutalValueNameLength=NAME_SIZE;
 edidsize=sizeof(EDIDdata);
 for(i=0,retValue=ERROR_SUCCESS;retValue!=ERROR_NO_MORE_ITEMS;++i)
  {
  retValue=RegEnumValue(hDevRegKey,i,&valueName[0],&AcutalValueNameLength,NULL,&dwType,EDIDdata,&edidsize);
  if(retValue!=ERROR_SUCCESS)                   { continue; }
  if(aaStringICompare(valueName,"EDID",0)!=YES) { continue; }
  *WidthMm=((EDIDdata[21]))*10;
  *HeightMm=((EDIDdata[22]))*10;
  return 1;
  }
 return 0;
 }




 B aa_DisplayGetSizeForDevID           (CP TargetDevID,WP WidthMm,WP HeightMm)
 {
 B bRes;
 H i;
 SP_DEVINFO_DATA devInfoData;
 VP devInfo;
 HKEY hDevRegKey;

 UNUSE(TargetDevID);
 devInfo=SetupDiGetClassDevsExA(&GUID_CLASS_MONITOR,NULL,NULL,DIGCF_PRESENT,NULL,NULL,NULL);
 if(NULL==devInfo) return 0;
 bRes=0;
 for(i=0;ERROR_NO_MORE_ITEMS!=GetLastError();++i)
  {
  memset(&devInfoData,0,sizeof(devInfoData));
  devInfoData.cbSize=sizeof(devInfoData);
  if(SetupDiEnumDeviceInfo(devInfo,i,&devInfoData))
   {
   hDevRegKey=SetupDiOpenDevRegKey(devInfo,&devInfoData,DICS_FLAG_GLOBAL,0,DIREG_DEV,KEY_READ);
   if(!hDevRegKey||(hDevRegKey==INVALID_HANDLE_VALUE)) { continue; }
   bRes=aa_DisplayGetMonitorSizeFromEDID(hDevRegKey,WidthMm,HeightMm);
   RegCloseKey(hDevRegKey);
   if(bRes) { break; }
   }
  }
 SetupDiDestroyDeviceInfoList(devInfo);
 return bRes;
 }




/*-----------------------------------------------------------------------*/




 B aa_SurfaceSystemStart               (V)
 {
 logg("aa_SurfaceSystemStart()");
 aa_ObjectIdNew(&aa.surface_system.object_id);
 aa_ObjectDefine(aa.surface_system.object_id,sizeof(_aa_surfaceobject),1000,16,aaSurfaceDestroy,"Surface");
 logg("");
 return RET_YES;
 }




 V aa_SurfaceSystemStop                (V)
 {
 logg("aa_SurfaceSystemStop()");
 aa_ObjectUndefine(aa.surface_system.object_id);
 logg("");
 }




 B aa_SurfaceSystemFindSurfaceByHwnd   (HP handle,PP mem,HWND hwnd)
 {
 BP bp;
 _aa_objectinstanceheader*oih;
 _aa_surfaceobject*surp;
 H base,h,instance_stride;
 B id;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle) { *handle=0; }
 if(mem) { *mem=0; }
 id=aa.surface_system.object_id;
 if(aa.object_system.object[id].instance_limit==0) { return RET_FAILED; }
 instance_stride=aa.object_system.object[id].instance_bytes+sizeof(_aa_objectinstanceheader);
 base=(H)id*aa_OBJ_MAX_PER_ID;
 base+=aa_OBJ_BASE_HANDLE;
 bp=aa.object_system.object[id].instance_mem;
 for(h=0;h<aa.object_system.object[id].instance_slots;h++)
  {
  aaCast(oih,_aa_objectinstanceheader*,bp);
  if(oih->in_use==YES)
   {
   bp+=sizeof(_aa_objectinstanceheader);
   aaCast(surp,_aa_surfaceobject*,bp);
   if(surp->status.hwnd==hwnd)
    {
    if(handle) { *handle=base+h; }
    if(mem)    { *mem=bp; }
    return RET_YES;
    }
   bp-=sizeof(_aa_objectinstanceheader);
   }
  bp+=instance_stride;
  }
 return RET_NOTFOUND;
 }





 V aa_SurfaceSystemYuvTablesInit       (V)
 {
 H i;

 if(aa.surface_system.yuva_tables_init!=YES)
  {
  for(i=0;i<256;i++)
   {
   aa.surface_system.RGB_Y_tab[i]=FIX_OUT(RGB_Y_OUT)*(i-Y_ADD_OUT);
   aa.surface_system.B_U_tab[i]=FIX_OUT(B_U_OUT)*(i-U_ADD_OUT);
   aa.surface_system.G_U_tab[i]=FIX_OUT(G_U_OUT)*(i-U_ADD_OUT);
   aa.surface_system.G_V_tab[i]=FIX_OUT(G_V_OUT)*(i-V_ADD_OUT);
   aa.surface_system.R_V_tab[i]=FIX_OUT(R_V_OUT)*(i-V_ADD_OUT);
   }
  aa.surface_system.yuva_tables_init=YES;
  }
 }



 B aaSurfacePixelPutProc               (VP surfs,N x,N y,_rgba*p1)
 {
 B ret;
 H off;
 _aa_surfaceobject*surp;
 _rgba*pn;
 _rgba temp_rgba;
 N a1,a2;
 register N xx,yy,px,py,zx,zy;
 _pixelstyle*pstylep;
 N xs,xe;
 N ys,ye;
 N mx,my;
 B alpha;
 B falpha;
 B halpha;
 D lumr,lumg,lumb;
 D dubr,dubg,dubb;

 aaCast(surp,_aa_surfaceobject*,surfs);
 pstylep=(_pixelstyle*)&surp->status.pixl_style;
 xx=x;
 yy=y;
 if(p1==NULL) { return RET_BADPARM; }

 if(pstylep->mode==0)
  {
  while(1)
   {
   if(xx<0||yy<0||xx>=(N)surp->status.size.w||yy>=(N)surp->status.size.h) { ret=RET_BOUNDS; break; }
   if(p1->a==0)                                                           { ret=RET_YES;    break; }
   if(surp->status.is_clipper)
    {
    if(xx<surp->status.clipper_rect.x||yy<surp->status.clipper_rect.y)   { ret=RET_BOUNDS; break; }
    if(xx>=(N)(surp->status.clipper_rect.x+surp->status.clipper_rect.w)) { ret=RET_BOUNDS; break; }
    if(yy>=(N)(surp->status.clipper_rect.y+surp->status.clipper_rect.h)) { ret=RET_BOUNDS; break; }
    }
   pn=surp->status.mem;
   if(surp->status.is_vflip==YES) { off=(((surp->status.size.h-yy)-1)*surp->status.size.w)+xx; }
   else                           { off=(yy*surp->status.size.w)+xx; }

   if(surp->status.is_masknot)
    {
    if(surp->status.mask_not.r!=pn[off].r||surp->status.mask_not.g!=pn[off].g||surp->status.mask_not.b!=pn[off].b)
     {
     ret=RET_YES;
     break;
     }
    }
   if(surp->status.is_mask)
    {
    if(surp->status.mask.r==pn[off].r&&surp->status.mask.g==pn[off].g&&surp->status.mask.b==pn[off].b)
     {
     ret=RET_YES;
     break;
     }
    }

   if(p1->a==255)
    {
    pn[off]=*p1;
    }
   else
    {
    temp_rgba=pn[off];
    a1=(N)(255-p1->a);
    a2=(N)(p1->a);
    pn[off].b=(B)(((a1*temp_rgba.b)+(a2*p1->b))>>8);
    pn[off].g=(B)(((a1*temp_rgba.g)+(a2*p1->g))>>8);
    pn[off].r=(B)(((a1*temp_rgba.r)+(a2*p1->r))>>8);
    pn[off].a=255;
    }
   ret=RET_YES;
   break;
   }
  return ret;
  }


 if(pstylep->mode==1) // fill brush
  {
  xs=xx-pstylep->nparm0; xe=xx+pstylep->nparm0;
  ys=yy-pstylep->nparm1; ye=yy+pstylep->nparm1;
  ret=RET_YES;
  for(yy=ys;yy<ye;yy++)
   {
   for(xx=xs;xx<xe;xx++)
    {
    if(xx<0||yy<0||xx>=(N)surp->status.size.w||yy>=(N)surp->status.size.h) {  ret=RET_BOUNDS; continue; }
    if(p1->a==0) { ret=RET_YES; continue; }
    if(surp->status.is_clipper)
     {
     if(xx<surp->status.clipper_rect.x||yy<surp->status.clipper_rect.y)   { ret=RET_BOUNDS; continue; }
     if(xx>=(N)(surp->status.clipper_rect.x+surp->status.clipper_rect.w)) { ret=RET_BOUNDS; continue; }
     if(yy>=(N)(surp->status.clipper_rect.y+surp->status.clipper_rect.h)) { ret=RET_BOUNDS; continue; }
     }
    pn=surp->status.mem;
    if(surp->status.is_vflip==YES) { off=(((surp->status.size.h-yy)-1)*surp->status.size.w)+xx; }
    else                           { off=(yy*surp->status.size.w)+xx; }

    if(p1->a==255)
     {
     pn[off]=*p1;
     }
    else
     {
     temp_rgba=pn[off];
     a1=(N)(255-p1->a);
     a2=(N)(p1->a);
     pn[off].b=(B)(((a1*temp_rgba.b)+(a2*p1->b))>>8);
     pn[off].g=(B)(((a1*temp_rgba.g)+(a2*p1->g))>>8);
     pn[off].r=(B)(((a1*temp_rgba.r)+(a2*p1->r))>>8);
     pn[off].a=255;
     }
    ret=RET_YES;
    }
   }
  return ret;
  }


 if(pstylep->mode==2) // soft brush
  {
  xe=pstylep->nparm0;
  ye=pstylep->nparm1;
  falpha=p1->a;
  halpha=falpha/2;
  alpha=falpha;
  ret=RET_YES;
  for(py=0;py<ye;py++)
   {
   zy=(yy+py);
   zy=zy-(ye/2);
   if(zy<0||zy>=(N)surp->status.size.h) { continue; }
   for(px=0;px<xe;px++)
    {
    zx=(xx+px);
    zx=zx-(xe/2);
    if(zx<0||zy>=(N)surp->status.size.w) { continue; }
    if(surp->status.is_clipper)
     {
     if(zx<surp->status.clipper_rect.x||zy<surp->status.clipper_rect.y)   { ret=RET_BOUNDS; continue; }
     if(zx>=(N)(surp->status.clipper_rect.x+surp->status.clipper_rect.w)) { ret=RET_BOUNDS; continue; }
     if(zy>=(N)(surp->status.clipper_rect.y+surp->status.clipper_rect.h)) { ret=RET_BOUNDS; continue; }
     }
    pn=surp->status.mem;
    if(surp->status.is_vflip==YES) { off=(((surp->status.size.h-zy)-1)*surp->status.size.w)+zx; }
    else                           { off=(zy*surp->status.size.w)+zx; }
    lumr=1.0;
    lumg=1.0;
    lumb=1.0;
    alpha=falpha;
    if(px>3) alpha=halpha;
    if(py<3) { lumr=0.3; lumg=0.4; lumb=0.2; }
    if(px>5) { lumr=2.3; lumg=2.3; lumb=2.3; }
    if(alpha!=0)
     {
     if(alpha==255)
      {
      pn[off]=*p1;
      }
     else
      {
      temp_rgba=pn[off];
      a1=(N)(255-alpha);
      a2=(N)(alpha);

      dubr=p1->r*lumr;
      dubg=p1->g*lumg;
      dubb=p1->b*lumb;

      dubr=dubr*(D)a2;
      dubg=dubg*(D)a2;
      dubb=dubb*(D)a2;


      pn[off].b=(B)((((a1*temp_rgba.b)+(N)dubr))>>8);
      pn[off].g=(B)((((a1*temp_rgba.g)+(N)dubg))>>8);
      pn[off].r=(B)((((a1*temp_rgba.r)+(N)dubb))>>8);
      pn[off].a=255;
      }
     }
    ret=RET_YES;
    }
   }
  return ret;
  }



 if(pstylep->mode==5) // dotted brush
  {
  xs=xx-pstylep->nparm0; xe=xx+pstylep->nparm0;
  ys=yy-pstylep->nparm1; ye=yy+pstylep->nparm1;
  mx=pstylep->nparm2;
  my=pstylep->nparm3;
  if(mx<=0) { mx=1; }
  if(my<=0) { my=1; }

  ret=RET_YES;
  for(yy=ys;yy<ye;yy++)
   {
   for(xx=xs;xx<xe;xx++)
    {
    if(xx<0||yy<0||xx>=(N)surp->status.size.w||yy>=(N)surp->status.size.h) {  ret=RET_BOUNDS; continue; }
    if(p1->a==0) { ret=RET_YES; continue; }
    if((x%mx)!=0) { ret=RET_YES; continue; }
    if((y%my)!=0) { ret=RET_YES; continue; }
    if(surp->status.is_clipper)
     {
     if(xx<surp->status.clipper_rect.x||yy<surp->status.clipper_rect.y)   { ret=RET_BOUNDS; continue; }
     if(xx>=(N)(surp->status.clipper_rect.x+surp->status.clipper_rect.w)) { ret=RET_BOUNDS; continue; }
     if(yy>=(N)(surp->status.clipper_rect.y+surp->status.clipper_rect.h)) { ret=RET_BOUNDS; continue; }
     }
    pn=surp->status.mem;
    if(surp->status.is_vflip==YES) { off=(((surp->status.size.h-yy)-1)*surp->status.size.w)+xx; }
    else                           { off=(yy*surp->status.size.w)+xx; }

    if(p1->a==255)
     {
     pn[off]=*p1;
     }
    else
     {
     temp_rgba=pn[off];
     a1=(N)(255-p1->a);
     a2=(N)(p1->a);
     pn[off].b=(B)(((a1*temp_rgba.b)+(a2*p1->b))>>8);
     pn[off].g=(B)(((a1*temp_rgba.g)+(a2*p1->g))>>8);
     pn[off].r=(B)(((a1*temp_rgba.r)+(a2*p1->r))>>8);
     pn[off].a=255;
     }
    ret=RET_YES;
    }
   }
  return ret;
  }




 return RET_YES;
 }







/*
  case aa_PIXELSTYLE_FILL:
  aaRectSet(&r1,x-pxsz,y-pxsz,pxsz*2,pxsz*2);
  aaSurfacePixelPutProcGet(sp->self_handle,&proc_save);
  aaSurfacePixelPutProcSet(sp->self_handle,NULL);
  aaSurfaceFill(sp->self_handle,&r1,&pa);
  aaSurfacePixelPutProcSet(sp->self_handle,proc_save);
  break;
  */



 B aaSurfacePixelSetProc               (VP surfs,N x,N y,_rgba*p1)
 {
 H off;
 _aa_surfaceobject*surp;
 _rgba*pn;


 if(p1==NULL) { return RET_BADPARM; }
 aaCast(surp,_aa_surfaceobject*,surfs);
 if(x<0||y<0)              { return RET_BOUNDS; }
 if(x>=(N)surp->status.size.w) { return RET_BOUNDS; }
 if(y>=(N)surp->status.size.h) { return RET_BOUNDS; }
 if(surp->status.is_clipper)
  {
  if(x<surp->status.clipper_rect.x) { return RET_BOUNDS; }
  if(y<surp->status.clipper_rect.y) { return RET_BOUNDS; }
  if(x>=(N)(surp->status.clipper_rect.x+surp->status.clipper_rect.w)) { return RET_BOUNDS; }
  if(y>=(N)(surp->status.clipper_rect.y+surp->status.clipper_rect.h)) { return RET_BOUNDS; }
  }
 pn=surp->status.mem;
 if(surp->status.is_vflip==YES) { off=(((surp->status.size.h-y)-1)*surp->status.size.w)+x; }
 else                           { off=(y*surp->status.size.w)+x; }
 pn[off]=*p1;
 return RET_YES;
 }





 B aaSurfacePixelGetProc               (VP surfs,N x,N y,_rgba*p1)
 {
 H off;
 _aa_surfaceobject*surp;
 _rgba*pn;

 if(p1==NULL) { return RET_BADPARM; }
 aaCast(surp,_aa_surfaceobject*,surfs);
 if(x<0||y<0)              { p1->a=0; return RET_BOUNDS; }
 if(x>=(N)surp->status.size.w) { p1->a=0; return RET_BOUNDS; }
 if(y>=(N)surp->status.size.h) { p1->a=0; return RET_BOUNDS; }

 pn=surp->status.mem;
 if(surp->status.is_vflip==YES) { off=(((surp->status.size.h-y)-1)*surp->status.size.w)+x; }
 else                             { off=(y*surp->status.size.w)+x; }
 *p1=pn[off];
 return RET_YES;
 }





 B aa_SurfaceDecodeTgaRle              (NP duppixcount,NP blockcount,HP off,VP mem,B bits,_rgba*p1)
 {
 N dup_pixel_count;
 N block_count,i;
 H o;
 B source_pixel_size;
 BP bp;
 BP tga_pixel;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 source_pixel_size=(B)(bits/7);
 dup_pixel_count=*duppixcount;
 block_count=*blockcount;
 o=*off;
 aaCast(bp,BP,mem);
 aaCast(tga_pixel,BP,p1);
 while(1)
  {
  if(dup_pixel_count>0) { dup_pixel_count--; break; }
  if(--block_count<0)
   {
   i=bp[o++];
   if(i&0x80)
    {
    dup_pixel_count=i&0x7F;
    block_count=0;
    }
   else
    {
    block_count=i&0x7F;
    }
   }
  for(i=0;i<source_pixel_size;i++)   {  tga_pixel[i]=bp[o++]; }
  break;
  }
 *duppixcount=dup_pixel_count;
 *blockcount=block_count;
 *off=o;
 return RET_YES;
 }






 B aa_SurfaceSortSpots                 (PP mem)
 {
 B ret;
 _aa_surfaceobject*surp;
 _surfacespot*sspot;
 H i,bytes,nbytes,bbytes,obytes,obbytes;
 Z smoff;
 Z mx,my,hs;
 Z spot_num[_4K];
 Z spot_dep[_4K];
 Z spot_ord[_4K];
 _rect rc1,rc2;
 Z xx,yy;
 Q tm;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 tm=aaMicrosecsRunning();
 aaCast(surp,_aa_surfaceobject*,*mem);
 aaRectSet(&surp->status.spot_depth_rect,0,0,0,0);
 aa_stats[23]++;
 if(surp->status.spot_count==0)
  {
  surp->status.spot_order_ok=YES;
  return RET_YES;
  }
 aa_stats[24]++;
 for(i=0;i<surp->status.spot_count;i++)
  {
  if(aaSurfaceSpotFindByNumber(surp->status.self_handle,i,&sspot)!=YES) { oof; continue; }
  spot_num[i]=sspot->id;
  spot_dep[i]=sspot->depth;
  }
 if((ret=aaMemoryOrderSort(spot_dep,surp->status.spot_count,4,0,sizeof(Z),YES,NO,(HP)spot_ord))!=YES) { oops; }
 for(i=0;i<surp->status.spot_count;i++)
  {
  surp->status.spot_id_order[i]=spot_num[spot_ord[i]];
  surp->status.spot_index_order[i]=spot_ord[i];
  }
 aaRectSet(&rc2,0,0,0,0);
 aaRectSet(&rc1,0,0,0,0);
 for(i=0;i<surp->status.spot_count;i++)
  {
  hs=(surp->status.spot_count-1)-i;
  if((ret=aaSurfaceSpotFindById(surp->status.self_handle,surp->status.spot_id_order[hs],&sspot))!=YES) { oops; break; }
  if(i==0)     {     aaRectCopy(&rc1,&sspot->rect);     }
  else         {     aaRectAdd(&rc1,&sspot->rect,&rc1);     }
  }
 aaRectCopy(&surp->status.spot_depth_rect,&rc1);
  bytes=bbytes=0;
 nbytes=surp->status.spot_depth_rect.w*surp->status.spot_depth_rect.h*sizeof(Z);
 if(nbytes==0) { nbytes=1; }
 if(surp->status.spot_depth_map!=NULL) { aaMemoryBytesGet(surp->status.spot_depth_map,&bytes);  }
 if(surp->status.spot_id_map!=NULL)    { aaMemoryBytesGet(surp->status.spot_id_map,&bbytes);  }
 if(nbytes>=bytes)
  {
  if(bytes==0)
   {
   ret=aaMemoryAllocate((VP)&surp->status.spot_depth_map,nbytes);
   aaMemoryNameSet(surp->status.spot_depth_map,"spdpemap");
   }
  else            { ret=aaMemoryReAllocate((VP)&surp->status.spot_depth_map,nbytes);    }
  if(ret!=YES)    { oops; }
  }
 if(nbytes>=bbytes)
  {
  if(bbytes==0)
   {
   ret=aaMemoryAllocate((VP)&surp->status.spot_id_map,nbytes);
   aaMemoryNameSet(surp->status.spot_id_map,"spidmap");
   }
  else            { ret=aaMemoryReAllocate((VP)&surp->status.spot_id_map,nbytes);    }
  if(ret!=YES)    { oops; }
  }
 if(aaMemoryBytesGet(surp->status.spot_depth_map,&obytes)!=YES) oof;
 if(aaMemoryBytesGet(surp->status.spot_id_map,&obbytes)!=YES) oof;
 for(i=0;i<surp->status.spot_count;i++)
   {
  hs=(surp->status.spot_count-1)-i;
  hs=i;
  if(aaSurfaceSpotFindById(surp->status.self_handle,surp->status.spot_id_order[hs],&sspot)!=YES) { oof; break; }
  for(my=0;my<(N)sspot->rect.h;my++)
   {
   for(mx=0;mx<(N)sspot->rect.w;mx++)
    {
    yy=sspot->rect.y;
    xx=sspot->rect.x;
    smoff=(yy-surp->status.spot_depth_rect.y)+my;
    smoff=smoff*surp->status.spot_depth_rect.w;
    smoff=smoff+((xx-surp->status.spot_depth_rect.x)+mx);
    surp->status.spot_depth_map[smoff]=sspot->depth;
    surp->status.spot_id_map[smoff]=sspot->id;
    }
   }
  }
 tm=aaMicrosecsRunning()-tm;
 surp->status.spot_order_ok=YES;
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/




 B aa_PngReadBit                       (HP bitpointer,BP bitstream)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 B result=(B)((bitstream[(*bitpointer)>>3]>>((*bitpointer)&0x7))&1);
 (*bitpointer)++;
 return result;
 }



 H aa_PngReadBits                      (HP bitpointer,BP bitstream,H nbits)
 {
 H result=0,i;
 for(i=0;i<nbits; i++) result|=((H)aa_PngReadBit(bitpointer,bitstream))<<i;
 return result;
 }




 V aa_PngHuffmanTreeInit               (pnghufftree*tree,HP buffer,H numcodes,H maxbitlen)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 tree->tree2d=buffer;
 tree->numcodes=numcodes;
 tree->maxbitlen=maxbitlen;
 }




 V aa_PngHuffmanTreeCreateLengths      (upng_t*upng,pnghufftree*tree,HP bitlen)
 {
 H tree1d[PNG_MAX_SYMBOLS];
 H blcount[PNG_MAX_BIT_LENGTH];
 H nextcode[PNG_MAX_BIT_LENGTH];
 H bits,n,i;
 B bit;
 H nodefilled=0;
 H treepos=0;

 aaMemoryFill(blcount,sizeof(blcount),0);
 aaMemoryFill(nextcode,sizeof(nextcode),0);
 for(bits=0; bits<tree->numcodes; bits++) {	blcount[bitlen[bits]]++;	}
 for(bits=1; bits<=tree->maxbitlen; bits++) {	nextcode[bits]=(nextcode[bits-1]+blcount[bits-1])<<1;	}
 for(n=0; n<tree->numcodes; n++) { if(bitlen[n]!=0) {tree1d[n]=nextcode[bitlen[n]]++; } }
 for(n=0; n<tree->numcodes*2; n++) { tree->tree2d[n]=32767;}
 for  (n=0; n<tree->numcodes; n++)
  {
  for(i=0;i<bitlen[n]; i++)
   {
   bit=(B)((tree1d[n]>>(bitlen[n]-i-1))&1);
   if(treepos>tree->numcodes-2) { PNG_SET_ERROR(upng,RET_CORRUPTED);	return;		}
   if(tree->tree2d[2*treepos+bit]==32767)
    {
    if(i+1==bitlen[n]) { tree->tree2d[2*treepos+bit]=n; treepos=0; }
    else                    { nodefilled++; tree->tree2d[2*treepos+bit]=nodefilled+tree->numcodes; treepos=nodefilled;	}
    }
   else { treepos=tree->tree2d[2*treepos+bit]-tree->numcodes; }
   }
  }
 for(n=0; n<tree->numcodes*2; n++) { if(tree->tree2d[n]==32767) { tree->tree2d[n]=0; } }
 }




 H aa_PngHuffmanDecodeSymbol           (upng_t*upng,BP in,HP bp,pnghufftree*codetree,H inlength)
 {
 H treepos=0,ct;
 B bit;
 for(;;)
  {
  if(((*bp)&0x07)==0&&((*bp)>>3)>inlength) { PNG_SET_ERROR(upng,RET_CORRUPTED);	return 0;		}
  bit=aa_PngReadBit(bp,in);
  ct=codetree->tree2d[(treepos<<1)|bit];
  if(ct<codetree->numcodes) { return ct; }
  treepos=ct-codetree->numcodes;
  if(treepos>=codetree->numcodes) {	PNG_SET_ERROR(upng,RET_CORRUPTED);	return 0;		}
  }
 }



 V aa_PngGetTreeInflateDynamic          (upng_t*upng,pnghufftree*codetree,pnghufftree*codetreeD,pnghufftree*codelengthcodetree,BP in,HP bp,H inlength)
 {
 H codelengthcode[PNG_NUM_CODE_LENGTH_CODES];
 H bitlen[PNG_NUM_DEFLATE_CODE_SYMBOLS];
 H bitlenD[PNG_NUM_DISTANCE_SYMBOLS];
 H n,hlit,hdist,hclen,i,code,replength,value;

 if((*bp)>>3>=inlength-2) { PNG_SET_ERROR(upng,RET_CORRUPTED); return;	}
 aaMemoryFill(bitlen,sizeof(bitlen),0);
 aaMemoryFill(bitlenD,sizeof(bitlenD),0);
 hlit=aa_PngReadBits(bp,in,5)+257;
 hdist=aa_PngReadBits(bp,in,5)+1;
 hclen=aa_PngReadBits(bp,in,4)+4;
 for(i=0;i<PNG_NUM_CODE_LENGTH_CODES; i++)
  {
  if(i<hclen) { codelengthcode[PNG_CLCL[i]]=aa_PngReadBits(bp,in,3); }
  else         { codelengthcode[PNG_CLCL[i]]=0;	}
  }
 aa_PngHuffmanTreeCreateLengths(upng,codelengthcodetree,codelengthcode);
 if(upng->error!=RET_YES) {	return;	}
 i=0;
 while(i<hlit+hdist)
  {
  code=aa_PngHuffmanDecodeSymbol(upng,in,bp,codelengthcodetree,inlength);
  if(upng->error!=RET_YES) { break; }
  if(code<=15)
   {
   if(i<hlit) {bitlen[i]=code;}
   else          {bitlenD[i-hlit]=code;}
   i++;
   }
  else
  if(code==16)
   {
   replength=3;
   if((*bp)>>3>=inlength) { PNG_SET_ERROR(upng,RET_CORRUPTED); break; }
   replength+=aa_PngReadBits(bp,in,2);
   if((i-1)<hlit) {	value=bitlen[i-1];}
   else                { value=bitlenD[i-hlit-1]; }
    for(n=0; n<replength; n++)
    {
    if(i>=hlit+hdist) { PNG_SET_ERROR(upng,RET_CORRUPTED); break; }
    if(i<hlit) { bitlen[i]=value; }
    else          { bitlenD[i-hlit]=value; }
    i++;
    }
   }
  else
  if(code==17)
   {
   replength=3;
   if((*bp)>>3>=inlength) { PNG_SET_ERROR(upng,RET_CORRUPTED); break; }
   replength+=aa_PngReadBits(bp,in,3);
   for(n=0; n<replength; n++)
    {
    if(i>=hlit+hdist) {PNG_SET_ERROR(upng,RET_CORRUPTED); break; }
    if(i<hlit) {bitlen[i]=0;	}
    else          {bitlenD[i-hlit]=0; }
    i++;
    }
   }
  else
  if(code==18)
   {
   replength=11;
   if((*bp)>>3>=inlength) {PNG_SET_ERROR(upng,RET_CORRUPTED); break; }
   replength+=aa_PngReadBits(bp,in,7);
   for(n=0; n<replength; n++)
    {
    if(i>=hlit+hdist) {  PNG_SET_ERROR(upng,RET_CORRUPTED); break; }
    if(i<hlit) bitlen[i]=0;
    else          bitlenD[i-hlit]=0;
    i++;
    }
   }
  else
   {
   PNG_SET_ERROR(upng,RET_CORRUPTED);
   break;
   }
  }
 if(upng->error==RET_YES&&bitlen[256]==0) {	PNG_SET_ERROR(upng,RET_CORRUPTED);	}
 if(upng->error==RET_YES) { aa_PngHuffmanTreeCreateLengths(upng,codetree,bitlen); }
 if(upng->error==RET_YES) { aa_PngHuffmanTreeCreateLengths(upng,codetreeD,bitlenD);	}
 }





 V aa_PngInflateHuffman                             (upng_t*upng,BP out,H outsize,BP in,HP bp,HP pos,H inlength,H btype)
 {
 H codetree_buffer[PNG_DEFLATE_CODE_BUFFER_SIZE];
 H codetreeD_buffer[PNG_DISTANCE_BUFFER_SIZE];
 H codelengthcodetree_buffer[PNG_CODE_LENGTH_BUFFER_SIZE];
 pnghufftree codelengthcodetree;
 H code,done=0;
 pnghufftree codetree;
 pnghufftree codetreeD;
 H length,codeD,distance,numextrabitsD;
 H start,forward,backward,numextrabits;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(btype==1)
  {
  aa_PngHuffmanTreeInit(&codetree,(HP)PNG_FIXED_DEFLATE_CODE_TREE,PNG_NUM_DEFLATE_CODE_SYMBOLS,PNG_DEFLATE_CODE_BITLEN);
  aa_PngHuffmanTreeInit(&codetreeD,(HP)PNG_FIXED_DISTANCE_TREE,PNG_NUM_DISTANCE_SYMBOLS,PNG_DISTANCE_BITLEN);
  }
 else
 if(btype==2)
  {
  aa_PngHuffmanTreeInit(&codetree,codetree_buffer,PNG_NUM_DEFLATE_CODE_SYMBOLS,PNG_DEFLATE_CODE_BITLEN);
  aa_PngHuffmanTreeInit(&codetreeD,codetreeD_buffer,PNG_NUM_DISTANCE_SYMBOLS,PNG_DISTANCE_BITLEN);
  aa_PngHuffmanTreeInit(&codelengthcodetree,codelengthcodetree_buffer,PNG_NUM_CODE_LENGTH_CODES,PNG_CODE_LENGTH_BITLEN);
  aa_PngGetTreeInflateDynamic(upng,&codetree,&codetreeD,&codelengthcodetree,in,bp,inlength);
  }
 while(done==0)
  {
  code=aa_PngHuffmanDecodeSymbol(upng,in,bp,&codetree,inlength);
  if(upng->error!=RET_YES) { return; }
  if(code==256) { done=1; }
  else
  if(code<=255)
   {
   if((*pos)>=outsize) { PNG_SET_ERROR(upng,RET_CORRUPTED); return;	}
   out[(*pos)++]=(B)(code);
   }
  else
  if(code>=PNG_FIRST_LENGTH_CODE_INDEX&&code<=PNG_LAST_LENGTH_CODE_INDEX)
   {
   length=PNG_LENGTH_BASE[code-PNG_FIRST_LENGTH_CODE_INDEX];
   numextrabits=PNG_LENGTH_EXTRA[code-PNG_FIRST_LENGTH_CODE_INDEX];
   if(((*bp)>>3)>=inlength) {	PNG_SET_ERROR(upng,RET_CORRUPTED); return;}
   length+=aa_PngReadBits(bp,in,numextrabits);
   codeD=aa_PngHuffmanDecodeSymbol(upng,in,bp,&codetreeD,inlength);
   if(upng->error!=RET_YES) { return; }
   if(codeD>29) { PNG_SET_ERROR(upng,RET_CORRUPTED); return; }
   distance=PNG_DISTANCE_BASE[codeD];
   numextrabitsD=PNG_DISTANCE_EXTRA[codeD];
   if(((*bp)>>3)>=inlength) { PNG_SET_ERROR(upng,RET_CORRUPTED); return; }
   distance+=aa_PngReadBits(bp,in,numextrabitsD);
   start=(*pos);
   backward=start-distance;
   if((*pos)+length>=outsize) { PNG_SET_ERROR(upng,RET_CORRUPTED); return; }
   for(forward=0; forward<length; forward++)
    {
    out[(*pos)++]=out[backward];
    backward++;
    if(backward>=start) { backward=start-distance; }
    }
   }
  }
 }





 V aa_PngInflateUncompressed           (upng_t*upng,BP out,H outsize,BP in,HP bp,HP pos,H inlength)
 {
 H p,len,nlen,n;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 while(((*bp)&0x7)!=0) { (*bp)++;	}
 p=(*bp)/8;
 if(p>=inlength-4) {	PNG_SET_ERROR(upng,RET_CORRUPTED);return;	}
 len=in[p]+256*in[p+1];
 p+=2;
 nlen=in[p]+256*in[p+1];
 p+=2;
 if(len+nlen!=65535) { PNG_SET_ERROR(upng,RET_CORRUPTED); return; }
 if((*pos)+len>=outsize) { PNG_SET_ERROR(upng,RET_CORRUPTED); return; }
 if(p+len>inlength) { PNG_SET_ERROR(upng,RET_CORRUPTED); return; }
 for(n=0; n<len; n++) { out[(*pos)++]=in[p++];	}
 (*bp)=p*8;
 }





 B aa_PngUzInflateData                 (upng_t*upng,BP out,H outsize,BP in,H insize,H inpos)
 {
 H bp=0;
 H pos=0;
 H done=0;

 while(done==0)
  {
  H btype;
  if((bp>>3)>=insize) { PNG_SET_ERROR(upng,RET_CORRUPTED); return upng->error;	}
  done=aa_PngReadBit(&bp,&in[inpos]);
  btype=aa_PngReadBit(&bp,&in[inpos])|(aa_PngReadBit(&bp,&in[inpos])<<1);
  if(btype==3) { PNG_SET_ERROR(upng,RET_CORRUPTED);return upng->error;		}
  else
  if(btype==0) { aa_PngInflateUncompressed(upng,out,outsize,&in[inpos],&bp,&pos,insize); }
  else            {aa_PngInflateHuffman(upng,out,outsize,&in[inpos],&bp,&pos,insize,btype); }
  if(upng->error!=RET_YES) { return upng->error; }
  }
 return upng->error;
 }





 B aa_PngUzInflate                     (upng_t*upng,BP out,H outsize,BP in,H insize)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(insize<2) { PNG_SET_ERROR(upng,RET_CORRUPTED);  return upng->error;	}
 if((in[0]*256+in[1])%31!=0) { PNG_SET_ERROR(upng,RET_CORRUPTED); return upng->error; }
 if((in[0]&15)!=8||((in[0]>>4)&15)>7) { PNG_SET_ERROR(upng,RET_CORRUPTED); return upng->error; }
 if(((in[1]>>5)&1)!=0) { PNG_SET_ERROR(upng,RET_CORRUPTED); return upng->error; }
 aa_PngUzInflateData(upng,out,outsize,in,insize,2);
 return upng->error;
 }




 Z aa_PngPathPredictor                 (Z a,Z b,Z c)
 {
 Z p=a+b-c;
 Z pa=p>a?p-a : a-p;
 Z pb=p>b?p-b : b-p;
 Z pc=p>c?p-c : c-p;
 if(pa<=pb&&pa<=pc) return a;
 else
 if(pb<=pc) return b;
 else       return c;
 }




 V aa_PngUnfilterScanLine              (upng_t*upng,BP recon,BP scanline,BP precon,H bytewidth,B filterType,H length)
 {
 H i;
 switch (filterType)
  {
  case 0: for(i=0;i<length; i++) 	recon[i]=scanline[i];	break;
  case 1: for(i=0;i<bytewidth; i++) recon[i]=scanline[i];
          for(i=bytewidth;i<length; i++) recon[i]=scanline[i]+recon[i-bytewidth];
          break;
  case 2: if(precon) for(i=0;i<length; i++)	recon[i]=scanline[i]+precon[i];
          else        for(i=0;i<length; i++)	recon[i]=scanline[i];
          break;
  case 3: if(precon)
           {
           for(i=0;i<bytewidth; i++) recon[i]=scanline[i]+precon[i]/2;
           for(i=bytewidth;i<length; i++) recon[i]=scanline[i]+((recon[i-bytewidth]+precon[i])/2);
           }
          else
           {
           for(i=0;i<bytewidth; i++) recon[i]=scanline[i];
           for(i=bytewidth;i<length; i++) recon[i]=scanline[i]+recon[i-bytewidth]/2;
           }
          break;
  case 4: if(precon)
           {
           for(i=0;i<bytewidth; i++) recon[i]=(B)(scanline[i]+aa_PngPathPredictor(0,precon[i],0));
           for(i=bytewidth;i<length; i++) recon[i]=(B)(scanline[i]+aa_PngPathPredictor(recon[i-bytewidth],precon[i],precon[i-bytewidth]));
           }
          else
           {
           for(i=0;i<bytewidth; i++) recon[i]=scanline[i];
           for(i=bytewidth;i<length; i++) recon[i]=(B)(scanline[i]+aa_PngPathPredictor(recon[i-bytewidth],0,0));
           }
          break;
  default: PNG_SET_ERROR(upng,RET_CORRUPTED); break;
  }
 }


 V aa_PngUnfilter                      (upng_t*upng,BP out,BP in,H w,H h,H bpp)
 {
 BP prevline=0;
 H bytewidth=(bpp+7)/8;
 H linebytes=(w*bpp+7)/8;
 H outindex,y;
 H inindex;
 B filterType;

 for(y=0; y<h; y++)
  {
  outindex=linebytes*y;
  inindex=(1+linebytes)*y;
  filterType=in[inindex];
  aa_PngUnfilterScanLine(upng,&out[outindex],&in[inindex+1],prevline,bytewidth,filterType,linebytes);
  if(upng->error!=RET_YES) { return;	}
  prevline=&out[outindex];
  }
 }





 V aa_PngRemovePaddingBits             (BP out,BP in,H olinebits,H ilinebits,H h)
 {
 B bit;
 H x,y,diff=ilinebits-olinebits;
 H obp=0,ibp=0;
 for(y=0; y<h; y++)
  {
  for(x=0; x<olinebits; x++)
   {
   bit=(B)((in[(ibp)>>3]>>(7-((ibp)&0x7)))&1);
   ibp++;
   if(bit==0) out[(obp)>>3]&=(B)(~(1<<(7-((obp)&0x7))));
   else       out[(obp)>>3]|=(1<<(7-((obp)&0x7)));
   ++obp;
   }
  ibp+=diff;
  }
 }





 V aa_PngPostProcessScanLines          (upng_t*upng,BP out,BP in,upng_t*info_png)
 {
 H bpp=info_png->bpp;
 H w=info_png->width;
 H h=info_png->height;
 if(bpp==0) {PNG_SET_ERROR(upng,RET_CORRUPTED);	return;	}
 if(bpp<8&&w*bpp!=((w*bpp+7)/8)*8)
  {
  aa_PngUnfilter(upng,in,in,w,h,bpp); if(upng->error!=RET_YES) { return; }
  aa_PngRemovePaddingBits(out,in,w*bpp,((w*bpp+7)/8)*8,h);
  }
 else { aa_PngUnfilter(upng,out,in,w,h,bpp);	}
 }




 B aa_PngHeader                        (upng_t*upng)
 {
 if(upng->error!=RET_YES) {  return upng->error; }
 if(upng->state!=PNG_NEW) {  return upng->error; }
 if(upng->source.size<29) {PNG_SET_ERROR(upng,RET_BADFORMAT);	  return upng->error;	}
 if(upng->source.buffer[0]!=137||upng->source.buffer[1]!=80||upng->source.buffer[2]!=78||upng->source.buffer[3]!=71||upng->source.buffer[4]!=13||upng->source.buffer[5]!=10||upng->source.buffer[6]!=26||upng->source.buffer[7]!=10)
  {
  PNG_SET_ERROR(upng,RET_BADFORMAT);
  return upng->error;
  }
 if(PNG_MAKE_DWORD_PTR(upng->source.buffer+12)!=PNG_CHUNK_IHDR) { PNG_SET_ERROR(upng,RET_CORRUPTED);   return upng->error; }
 upng->width=PNG_MAKE_DWORD_PTR(upng->source.buffer+16);
 upng->height=PNG_MAKE_DWORD_PTR(upng->source.buffer+20);
 upng->color_depth=upng->source.buffer[24];
 upng->color_type=upng->source.buffer[25];
 switch(upng->color_type)
  {
  case PNG_LUM: upng->components=1; break;
  case PNG_RGB: upng->components=3; break;
  case PNG_LUMA: upng->components=2; break;
  case PNG_RGBA: upng->components=4; break;
  default: upng->components=0;  break;
  }
 switch (upng->color_type)
  {
  case PNG_LUM:
  switch (upng->color_depth)
   {
   case 1:	upng->format=PNG_LUMINANCE1; break;
   case 2:	upng->format=PNG_LUMINANCE2; break;
   case 4:	upng->format=PNG_LUMINANCE4; break;
   case 8:	upng->format=PNG_LUMINANCE8; break;
   default:	upng->format=PNG_BADFORMAT;  break;
   }
  break;
  case PNG_RGB:
  switch (upng->color_depth)
   {
   case 8:	upng->format=PNG_RGB8; break;
   case 16:	upng->format=PNG_RGB16; break;
   default:	upng->format=PNG_BADFORMAT; break;
   }
  break;
  case PNG_LUMA:
  switch (upng->color_depth)
   {
   case 1:   upng->format=PNG_LUMINANCE_ALPHA1; break;
   case 2:   upng->format=PNG_LUMINANCE_ALPHA2; break;
   case 4:   upng->format=PNG_LUMINANCE_ALPHA4; break;
   case 8:   upng->format=PNG_LUMINANCE_ALPHA8; break;
   default:  upng->format=PNG_BADFORMAT; break;
   }
  break;
  case PNG_RGBA:
  switch (upng->color_depth)
   {
   case 8:  upng->format=PNG_RGBA8; break;
   case 16: upng->format=PNG_RGBA16; break;
   default: upng->format=PNG_BADFORMAT; break;
   }
  break;
  default:
  upng->format=PNG_BADFORMAT;
  break;
  }
 if(upng->format==PNG_BADFORMAT) { PNG_SET_ERROR(upng,RET_BADFORMAT); return upng->error;	}
 if(upng->source.buffer[26]!=0) { PNG_SET_ERROR(upng,RET_CORRUPTED); return upng->error;	}
 if(upng->source.buffer[27]!=0) { PNG_SET_ERROR(upng,RET_CORRUPTED); return upng->error;	}
 if(upng->source.buffer[28]!=0) { PNG_SET_ERROR(upng,RET_NOTSUPPORTED); return upng->error;	}
 upng->bpp=upng->color_depth*upng->components;
 upng->state=PNG_HEADER;
 return upng->error;
 }





 B aa_PngDecode                        (upng_t*upng)
 {
 BP chunk;
 BP compressed;
 BP inflated;
 H compressed_size=0,compressed_index=0;
 H inflated_size,length;
 BP data;
 B error;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(upng->error!=RET_YES)    {  return upng->error;	}
 aa_PngHeader(upng);
 if(upng->error!=RET_YES)    { return upng->error; }
 if(upng->state!=PNG_HEADER) { return upng->error; }
 if(upng->buffer!=0) {	aaMemoryRelease(upng->buffer); upng->buffer=0; upng->size=0; }
 chunk=upng->source.buffer+33;
 while(chunk<upng->source.buffer+upng->source.size)
  {
  if((H)(chunk-upng->source.buffer+12)>upng->source.size) { PNG_SET_ERROR(upng,RET_CORRUPTED);  return upng->error; }
  length=PNG_MAKE_DWORD_PTR(chunk);
  if(length>INT_MAX) {	PNG_SET_ERROR(upng,RET_CORRUPTED);	return upng->error; }
  if((H)(chunk-upng->source.buffer+length+12)>upng->source.size) { PNG_SET_ERROR(upng,RET_CORRUPTED);	return upng->error;
  }
 data=chunk+8;
 if(PNG_MAKE_DWORD_PTR((chunk)+4)==PNG_CHUNK_IDAT) { compressed_size+=length; }
 else
 if(PNG_MAKE_DWORD_PTR((chunk)+4)==PNG_CHUNK_IEND) { break; }
 else
 if((((chunk)[4]&32)==0)) { PNG_SET_ERROR(upng,RET_NOTSUPPORTED);  return upng->error;  }
 chunk+=PNG_MAKE_DWORD_PTR(chunk)+12;
 }
 if(aaMemoryAllocate((VP)&compressed,compressed_size)!=YES) { PNG_SET_ERROR(upng,RET_NOMEMORY); return upng->error; }
 chunk=upng->source.buffer+33;
 while(chunk<upng->source.buffer+upng->source.size)
  {
  length=PNG_MAKE_DWORD_PTR(chunk);
  data=chunk+8;
  if(PNG_MAKE_DWORD_PTR((chunk)+4)==PNG_CHUNK_IDAT) { aaMemoryCopy(compressed+compressed_index,length,data); compressed_index+=length; }
  else
  if(PNG_MAKE_DWORD_PTR((chunk)+4)==PNG_CHUNK_IEND) { break;}
  chunk+=PNG_MAKE_DWORD_PTR(chunk)+12;
  }
 inflated_size=((upng->width*(upng->height*upng->bpp+7))/8)+upng->height;
 if(aaMemoryAllocate((VP)&inflated,inflated_size)!=YES) { aaMemoryRelease(compressed);	PNG_SET_ERROR(upng,RET_NOMEMORY); return upng->error; }
 error=aa_PngUzInflate(upng,inflated,inflated_size,compressed,compressed_size);
 if(error!=RET_YES) { aaMemoryRelease(compressed); aaMemoryRelease(inflated);	return upng->error;	}
 aaMemoryRelease(compressed);
 upng->size=(upng->height*upng->width*upng->bpp+7)/8;
 if(aaMemoryAllocate((VP)&upng->buffer,upng->size)!=YES) { aaMemoryRelease(inflated); upng->size=0; PNG_SET_ERROR(upng,RET_NOMEMORY);	return upng->error;	}
 aa_PngPostProcessScanLines(upng,upng->buffer,inflated,upng);
 aaMemoryRelease(inflated);
 if(upng->error!=RET_YES) { aaMemoryRelease(upng->buffer);	upng->buffer=NULL;	upng->size=0;	}
 else                      { upng->state=PNG_DECODED;	}
 if(upng->source.owning!=0) { aaMemoryRelease(upng->source.buffer);	}
 upng->source.buffer=NULL;
 upng->source.size=0;
 upng->source.owning=0;
 return upng->error;
 }





 V aa_PngFree                          (upng_t*upng)
 {
 if(upng->buffer!=NULL) {aaMemoryRelease(upng->buffer);	}
 if(upng->source.owning!=0) { aaMemoryRelease(upng->source.buffer);	}
 upng->source.buffer=NULL;
 upng->source.size=0;
 upng->source.owning=0;
 aaMemoryRelease(upng);
 }



 upng_t*aa_PngNew                      (V)
 {
 upng_t*upng;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aaMemoryAllocate((VP)&upng,sizeof(upng_t))!=YES) { return NULL;	}
 upng->buffer=NULL;
 upng->size=0;
 upng->width=upng->height=0;
 upng->color_type=PNG_RGBA;
 upng->color_depth=8;
 upng->format=PNG_RGBA8;
 upng->state=PNG_NEW;
 upng->error=RET_YES;
 upng->error_line=0;
 upng->source.buffer=NULL;
 upng->source.size=0;
 upng->source.owning=0;
 return upng;
 }


 upng_t*aa_PngNewFromBytes             (BP buffer,H size)
 {
 upng_t*upng;

 if((upng=aa_PngNew())==NULL) { return NULL; }
 upng->source.buffer=buffer;
 upng->source.size=size;
 upng->source.owning=0;
 aa_PngDecode(upng);
 if(upng->error!=RET_YES)
  {
  aa_PngFree(upng);
  return NULL;
  }
 aa_PngHeader(upng);
 if(upng->error!=RET_YES)
  {
  aa_PngFree(upng);
  return NULL;
  }
 return upng;
 }



 upng_t*aa_PngNewFromFile              (CP filename)
 {
 upng_t* upng;
 BP buffer;
 B ret;
 _filestreamunit fsu;

 if((upng=aa_PngNew())==NULL) { return NULL; }
 if((ret=aaFileStreamCreate(&fsu.handle,filename,aa_FILECREATE_OPEN,3,3,0,0))!=RET_YES) { PNG_SET_ERROR(upng,RET_NOTFOUND); return upng; }
 aaFileStreamStatus(fsu.handle,&fsu.status);
 if(aaMemoryAllocate((VP)&buffer,(H)fsu.status.bytes)!=YES) { aaFileStreamDestroy(fsu.handle); PNG_SET_ERROR(upng,RET_NOMEMORY); return upng; }
 if((ret=aaFileStreamRead(fsu.handle,(H)fsu.status.bytes,buffer))!=RET_YES) { oops; }
 aaFileStreamDestroy(fsu.handle);
 upng->source.buffer=buffer;
 upng->source.size=(H)fsu.status.bytes;
 upng->source.owning=1;
 aa_PngDecode(upng);
 if(upng->error!=RET_YES)
  {
  aa_PngFree(upng);
  return NULL;
  }
 aa_PngHeader(upng);
 if(upng->error!=RET_YES)
  {
  aa_PngFree(upng);
  return NULL;
  }
 return upng;
 }



 B aa_PngFromImage                     (VP imgdata,N width,N height,N stride,VP outbuf,N maxout,HP outbytes)
 {
 BP sptr,dptr,idptr,idsptr,rs;
 H idsz,crc,Bpp;
 H i,line_size,val;
 Z x,y,psz;

 psz=sizeof(aa_png_header)+(((N)width*4+6)*(N)height)+8+sizeof(aa_png_trailer);
 if(maxout<psz) { return RET_BOUNDS; }
   Bpp=4;
   dptr=(BP)outbuf;
   for(i=0;i<sizeof(aa_png_header); i++) {    dptr[i]=aa_png_header[i];    }
   dptr[PNG_HEADER_OFFSET_WIDTH+0]=(width>>24)&F8; dptr[PNG_HEADER_OFFSET_WIDTH+1]=(width>>16)&F8;
   dptr[PNG_HEADER_OFFSET_WIDTH+2]=(width>> 8)&F8; dptr[PNG_HEADER_OFFSET_WIDTH+3]=(width>> 0)&F8;
   dptr[PNG_HEADER_OFFSET_HEIGHT+0]=(height>>24)&F8; dptr[PNG_HEADER_OFFSET_HEIGHT+1]=(height>>16)&F8;
   dptr[PNG_HEADER_OFFSET_HEIGHT+2]=(height>> 8)&F8; dptr[PNG_HEADER_OFFSET_HEIGHT+3]=(height>> 0)&F8;
   dptr[PNG_HEADER_OFFSET_FORMAT]=(6);
   val=0xffffffff;
   aaMemoryCrcGet(&dptr[PNG_HEADER_OFFSET_IHDR],PNG_HEADER_SIZE_IHDR,&val);
   dptr[PNG_HEADER_OFFSET_IHDR_CRC+0]=(val>>24)&F8; dptr[PNG_HEADER_OFFSET_IHDR_CRC+1]=(val>>16)&F8;
   dptr[PNG_HEADER_OFFSET_IHDR_CRC+2]=(val>> 8)&F8; dptr[PNG_HEADER_OFFSET_IHDR_CRC+3]=(val>> 0)&F8;
   idsptr=&dptr[PNG_HEADER_OFFSET_IDAT_SIZE];
   idptr=&dptr[PNG_HEADER_OFFSET_IDAT_DATA];
   dptr+=sizeof(aa_png_header);
   sptr=(BP)imgdata;
   crc=1;
   for(y=0;y<height;y++,sptr+=(stride-width)*4)
    {
    rs=dptr+5;
    line_size=1+width*Bpp;
    dptr[0]=(y==height-1)?0x01:0x00;
    dptr[1]=(line_size>>0)&F8;
    dptr[2]=(line_size>>8)&F8;
    dptr[3]=~dptr[1];
    dptr[4]=~dptr[2];
    dptr[5]=0;
    dptr+=6;
    for(x=0;x<width;x++,sptr+=4,dptr+=Bpp)
     {
     dptr[0]=sptr[2];
     dptr[1]=sptr[1];
     dptr[2]=sptr[0];
     dptr[3]=sptr[ 3];
     }
    aaMemoryAdlerCrcGet(rs,line_size,&crc);
    }
 idsz=(dptr+4)-idptr;
 idsptr[0]=(idsz>>24)&F8; idsptr[1]=(idsz>>16)&F8;
 idsptr[2]=(idsz>> 8)&F8; idsptr[3]=(idsz>> 0)&F8;
 dptr[0]=(crc>>24)&F8; dptr[1]=(crc>>16)&F8;
 dptr[2]=(crc>> 8)&F8; dptr[3]=(crc>> 0)&F8;
 val=0xffffffff;
 aaMemoryCrcGet(idptr-4,idsz+4,&val);
 dptr[4+0]=(val>>24)&F8; dptr[4+1]=(val>>16)&F8;
 dptr[4+2]=(val>> 8)&F8; dptr[4+3]=(val>> 0)&F8;
 dptr+=8;
 for(i=0;i<sizeof(aa_png_trailer); i++) {     dptr[i]=aa_png_trailer[i];    }
 dptr+=sizeof(aa_png_trailer);
 *outbytes=dptr-(BP)outbuf;
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/

 B aa_JpegChunkNext                    (_jpegchunk*ic)
 {
 ic->x_pos+=16;
 if(ic->x_pos>=ic->width) {   ic->y_pos+=8;    ic->x_pos=0;  }
 return (ic->y_pos<ic->height);
 }


 V aa_JpegChunkCopyY1                  (_jpegchunk*ic,IP destination)
 {
 B x,y;
 BP pointer=NULL;
 BP base=ic->data+2*(ic->x_pos+ic->y_pos*ic->width);
 if(ic==NULL) { oof; }
 for(y=8;y;--y)
  {
  pointer=base;
  for(x=8;x;--x) {  *destination=*pointer-128;   ++destination;      pointer+=2;    }
  base+=2*ic->width;
  }
 }


 V aa_JpegChunkCopyY2                  (_jpegchunk*ic,IP destination)
 {
 B x,y;
 BP pointer=NULL;
 BP base=ic->data+2*(ic->x_pos+8+ic->y_pos*ic->width);
 if(ic==NULL) { oof; }
 for(y=8;y;--y)
  {
  pointer=base;
  for(x=8;x;--x) {  *destination=*pointer-128;    ++destination;      pointer+=2;    }
  base+=2*ic->width;
  }
 }


 V aa_JpegChunkCopyCr                  (_jpegchunk*ic,IP destination)
 {
 B x,y;
 BP pointer=NULL;
 BP base=ic->data+2*(ic->x_pos+ic->y_pos*ic->width)+3;
 if(ic==NULL) { oof; }
 for(y=8;y;--y)
  {
  pointer=base;
  for(x=8;x;--x) {   *destination=*pointer-128;    ++destination;     pointer+=4;    }
  base+=2*ic->width;
  }
 }


 V aa_JpegChunkCopyCb                  (_jpegchunk*ic,IP destination)
 {
 B x,y;
 BP pointer=NULL;
 BP base=ic->data+2*(ic->x_pos+ic->y_pos*ic->width)+1;
 if(ic==NULL) { oof; }
 for(y=8;y;--y)
  {
  pointer=base;
  for(x=8;x;--x) {   *destination=*pointer-128;    ++destination;      pointer+=4;    }
  base+=2*ic->width;
  }
 }




 V aa_JpegAdd                          (_jpegbuf*buffer,Y bits,B length)
 {
 BP wp,rp;
 Z i;

 bits=bits<<(sizeof(bits)*8-length-(buffer->bit_size&0x07));
 wp=buffer->data+(buffer->bit_size>>3);
 rp=((BP)&bits)+sizeof(bits)-1;
 for(i=0;i<length+8;i+=8,++wp,--rp,*wp=0)
  {
  *wp|=*rp;
  if(*wp==0xff) { ++wp; buffer->bit_size+=8; *wp=0; }
  }
 buffer->bit_size+=length;
 }




 V aa_JpegAddAC                        (_jpegbuf*buffer,WP table,B run,I value)
 {
 B xlen;
 I xval;
 W uvalue=value<0 ? value-1 : value;
 xlen=0;
 xval=value;
 if(xval<0) { xval=-xval; }
 while(xval) {   xval>>=1; xlen++; }
 B length=xlen;
 W code=table[length*16+run];

 if((code&0x000f)>11)
  {
  aa_JpegAdd(buffer,(code>>4)|(0x0f00<<((code&0x000f)-11)),(code&0x000f)+1);
  }
 else
  {
  aa_JpegAdd(buffer,code>>4,(code&0x000f)+1);
  }
 if(length!=0) {  aa_JpegAdd(buffer,uvalue&((1<<length)-1),length); }
 }




 V aa_JpegAddDC                        (_jpegbuf*buffer,WP table,I value)
 {
 B xlen;
 I xval;
 W uvalue=value<0 ? value-1 : value;
 xlen=0;
 xval=value;
 if(xval<0) { xval=-xval; }
 while(xval) {   xval>>= 1; xlen++; }
 B length=xlen;
 W code=table[length];
 aa_JpegAdd(buffer,code>>4,code&0x000f);
 if(length!=0) {  aa_JpegAdd(buffer,uvalue&((1<<length)-1),length); }
 }



 V aa_JpegEncode                       (_jpegctx*jpegctx,IP last_dc,WP dc_table,WP ac_table,IP block)
 {
 B run,i;
 W HUF_Y_AC[0xb0]={0x00c3,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
                   0x0000,0x0000,0x0000,0x0000,0xff3b,0x0001,0x00a3,0x01b4,0x03a5,0x03b5,0x0786,
                   0x07b6,0x0f97,0x1f48,0x1f78,0x1f88,0x3f59,0x3f89,0x3fa9,0x7f6a,0xfedc,0x0011,
                   0x01c4,0x0f87,0x1f68,0x3f69,0x3f99,0xff2b,0xff5b,0xfecc,0xfe0d,0xfe1d,0xfc4e,
                   0xf8df,0xf9af,0xf9bf,0xfaef,0x0042,0x07a6,0x3f79,0x7f7a,0xfddd,0xfdfd,0xfc5e,
                   0xf8cf,0xf9ef,0xf91f,0xf92f,0xf93f,0xf99f,0xfaaf,0xfaff,0xfb0f,0x00b3,0x1f58,
                   0xff4b,0xfded,0xf8ff,0xf96f,0xf97f,0xf98f,0xfa3f,0xfa4f,0xfa7f,0xfa8f,0xfb1f,
                   0xfb2f,0xfb3f,0xfb4f,0x01a4,0x3f49,0xfdcd,0xf8ef,0xfa5f,0xfabf,0xfb5f,0xfb6f,
                   0xfb7f,0xfb8f,0xfb9f,0xfbaf,0xfbbf,0xfbcf,0xfbdf,0xfbef,0x0796,0x7f8a,0xf9df,
                   0xf94f,0xfa6f,0xfa9f,0xfbff,0xfc0f,0xfc1f,0xfc2f,0xfc3f,0xfc4f,0xfc5f,0xfc6f,
                   0xfc7f,0xfc8f,0x1f98,0xf95f,0xf90f,0xfc9f,0xfcaf,0xfcbf,0xfccf,0xfcdf,0xfcef,
                   0xfcff,0xfd0f,0xfd1f,0xfd2f,0xfd3f,0xfd4f,0xfd5f,0xf9cf,0xfa1f,0xfacf,0xfd6f,
                   0xfd7f,0xfd8f,0xfd9f,0xfdaf,0xfdbf,0xfdcf,0xfddf,0xfdef,0xfdff,0xfe0f,0xfe1f,
                   0xfe2f,0xf9ff,0xfa2f,0xfe3f,0xfe4f,0xfe5f,0xfe6f,0xfe7f,0xfe8f,0xfe9f,0xfeaf,
                   0xfebf,0xfecf,0xfedf,0xfeef,0xfeff,0xff0f,0xfa0f,0xfadf,0xff1f,0xff2f,0xff3f,
                   0xff4f,0xff5f,0xff6f,0xff7f,0xff8f,0xff9f,0xffaf,0xffbf,0xffcf,0xffdf,0xffef};
 aa_JpegAddDC(&jpegctx->buffy,dc_table,block[0]-*last_dc);
 *last_dc=block[0];
 for(i=1;i<64;++i)
  {
  run=0;
  while(i<64&&block[aa_math_scan_zigzag[i]]==0) {    ++i;     ++run;    }
  if(i==64) {  aa_JpegAddAC(&jpegctx->buffy,ac_table,0,0);     break;    }
  else      {  while(run>=16) {  aa_JpegAddAC(&jpegctx->buffy,ac_table,15,0);  run-=16;   } }
  aa_JpegAddAC(&jpegctx->buffy,HUF_Y_AC,run,block[aa_math_scan_zigzag[i]]);
  }
 }


 V aa_JpegQuantize                     (_jpegctx*jpegctx,IP block)
 {
 Z i;
 C mm;
 CP qm=(CP)jpegctx->quant;

 for(i=0;i<64;++i,++block,++qm)
  {
  mm=*qm;
  *block=2**block/mm;
  switch (*block&0x80000001)
   {
   case 0x80000001: *block=*block/2-1; break;
   case 0x00000001: *block=*block/2+1; break;
   default: *block/=2;
   }
  }
 }




 Z aa_JpegWrite                        (_jpegctx*p,BP destination,Z size)
 {
 Z bytes_written;
 I block[64];
 int to_copy;
 W HUF_Y_AC[0xb0]={0x00c3,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
                   0x0000,0x0000,0x0000,0x0000,0xff3b,0x0001,0x00a3,0x01b4,0x03a5,0x03b5,0x0786,
                   0x07b6,0x0f97,0x1f48,0x1f78,0x1f88,0x3f59,0x3f89,0x3fa9,0x7f6a,0xfedc,0x0011,
                   0x01c4,0x0f87,0x1f68,0x3f69,0x3f99,0xff2b,0xff5b,0xfecc,0xfe0d,0xfe1d,0xfc4e,
                   0xf8df,0xf9af,0xf9bf,0xfaef,0x0042,0x07a6,0x3f79,0x7f7a,0xfddd,0xfdfd,0xfc5e,
                   0xf8cf,0xf9ef,0xf91f,0xf92f,0xf93f,0xf99f,0xfaaf,0xfaff,0xfb0f,0x00b3,0x1f58,
                   0xff4b,0xfded,0xf8ff,0xf96f,0xf97f,0xf98f,0xfa3f,0xfa4f,0xfa7f,0xfa8f,0xfb1f,
                   0xfb2f,0xfb3f,0xfb4f,0x01a4,0x3f49,0xfdcd,0xf8ef,0xfa5f,0xfabf,0xfb5f,0xfb6f,
                   0xfb7f,0xfb8f,0xfb9f,0xfbaf,0xfbbf,0xfbcf,0xfbdf,0xfbef,0x0796,0x7f8a,0xf9df,
                   0xf94f,0xfa6f,0xfa9f,0xfbff,0xfc0f,0xfc1f,0xfc2f,0xfc3f,0xfc4f,0xfc5f,0xfc6f,
                   0xfc7f,0xfc8f,0x1f98,0xf95f,0xf90f,0xfc9f,0xfcaf,0xfcbf,0xfccf,0xfcdf,0xfcef,
                   0xfcff,0xfd0f,0xfd1f,0xfd2f,0xfd3f,0xfd4f,0xfd5f,0xf9cf,0xfa1f,0xfacf,0xfd6f,
                   0xfd7f,0xfd8f,0xfd9f,0xfdaf,0xfdbf,0xfdcf,0xfddf,0xfdef,0xfdff,0xfe0f,0xfe1f,
                   0xfe2f,0xf9ff,0xfa2f,0xfe3f,0xfe4f,0xfe5f,0xfe6f,0xfe7f,0xfe8f,0xfe9f,0xfeaf,
                   0xfebf,0xfecf,0xfedf,0xfeef,0xfeff,0xff0f,0xfa0f,0xfadf,0xff1f,0xff2f,0xff3f,
                   0xff4f,0xff5f,0xff6f,0xff7f,0xff8f,0xff9f,0xffaf,0xffbf,0xffcf,0xffdf,0xffef};
 W HUF_Y_DC[0x0c]={0x0063,0x0053,0x0033,0x0023,0x0003,0x0013,0x0043,0x00e4,0x01e5,0x03e6,0x07e7,0x0fe8};

 bytes_written=0;
 while(bytes_written<size-512)
  {
  if((p->buffy.bit_size>>3)>0)
   {
   to_copy=(p->buffy.bit_size>>3);
   aaMemoryCopy(destination,to_copy,p->buffy.data);
   p->buffy.data[0]=p->buffy.data[p->buffy.bit_size/8];
   p->buffy.bit_size&=0x07;
   destination+=to_copy;
   bytes_written+=to_copy;
   }
  else
   {
   if(aa_JpegChunkNext(&p->chunk))
    {
    aa_JpegChunkCopyY1(&p->chunk,block);
    aaMathDct(block,YES,YES);
    aa_JpegQuantize(p,block);
    aa_JpegEncode(p,&p->prev_y1dc,HUF_Y_DC,HUF_Y_AC,block);
    aa_JpegChunkCopyY2(&p->chunk,block);
    aaMathDct(block,YES,YES);
    aa_JpegQuantize(p,block);
    aa_JpegEncode(p,&p->prev_y1dc,HUF_Y_DC,HUF_Y_AC,block);
    aa_JpegChunkCopyCr(&p->chunk,block);
    aaMathDct(block,YES,YES);
    aa_JpegQuantize(p,block);
    aa_JpegEncode(p,&p->prev_crdc,HUF_Y_DC,HUF_Y_AC,block);
    aa_JpegChunkCopyCb(&p->chunk,block);
    aaMathDct(block,YES,YES);
    aa_JpegQuantize(p,block);
    aa_JpegEncode(p,&p->prev_cbdc,HUF_Y_DC,HUF_Y_AC,block);
    p->blocks_n+=1;
    }
   else
    {
    p->x_pos+=p->chunk.width;
    if(p->x_pos>=p->img_w)  {  p->x_pos=0;   p->y_pos+=p->chunk.height; }
    if(p->y_pos>=p->img_h)
     {
     if(p->eoi) { break; }
     else
      {
      p->buffy.bit_size=((p->buffy.bit_size+15)/8)*8; p->buffy.data[p->buffy.bit_size/8]=0xff;
      p->buffy.bit_size=((p->buffy.bit_size+15)/8)*8; p->buffy.data[p->buffy.bit_size/8]=0xd9;
      p->buffy.bit_size=((p->buffy.bit_size+15)/8)*8; p->buffy.data[p->buffy.bit_size/8]=0xd9;
      p->eoi =1;
      }
     }
    else
     {
     break;
     }
    }
   }
  }
 return bytes_written;
 }




 B aa_JpegNew                          (_jpegctx*jpegctx)
 {
 if(jpegctx==NULL) { return RET_BADPARM; }
 aaMemoryFill(jpegctx,sizeof(_jpegctx),0);
 jpegctx->magic=aaHPP(aa_JpegNew);
 return RET_YES;
 }





 B aa_JpegDelete                       (_jpegctx*jpegctx)
 {
 if(jpegctx==NULL) { return RET_BADPARM; }
 if(jpegctx->magic!=aaHPP(aa_JpegNew)) { return RET_NOTINITIALIZED; }
 if(jpegctx->out.bytes) { aaMemoryUnitRelease(&jpegctx->out); }
 if(jpegctx->yuv.bytes) { aaMemoryUnitRelease(&jpegctx->yuv); }
 aaMemoryFill(jpegctx,sizeof(_jpegctx),0);
 return RET_YES;
 }



 B aa_JpegCompress                     (_jpegctx*jpegctx,B quality,H w,H h,VP img)
 {
 B ret;
 H ioff,ooff,bytes;
 H fo,bb,i;
 F r1,g1,b1,r2,g2,b2;
 F cb1,cb2,cr1,cr2;
 F ycbcr[2048*8]; // max img width=2048
 N xx,yy,zz,jj;
 BP imgrgb;
 B hdr_data[338]={
   255,216,255,224,0,16,0x4a,0x46,0x49,0x46,0,1,0,0,0,1,0,1,0,0,255,0xdb,0,0x43,0,0,0,0,0,0,0,0,
   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
   0,0,0,0,0,0,0,0,0,0,0,255,0xc0,0,17,8,0,0,0,0,3,1,33,0,2,17,0,3,17,0,255,0xc4,0,31,0,0,0,7,1,
   1,1,1,1,0,0,0,0,0,0,0,0,4,5,3,2,6,1,0,7,8,9,10,11,255,0xc4,0,0xb5,16,0,2,1,3,3,2,4,2,6,7,3,4,
   2,6,2,0x73,1,2,3,17,4,0,5,33,18,0x31,0x41,0x51,6,19,0x61,0x22,0x71,0x81,20,0x32,0x91,0xa1,7,21,
   0xb1,0x42,0x23,0xc1,0x52,0xd1,0xe1,0x33,22,0x62,0xf0,0x24,0x72,0x82,0xf1,0x25,0x43,0x34,0x53,
   0x92,0xa2,0xb2,0x63,0x73,0xc2,0x35,0x44,0x27,0x93,0xa3,0xb3,0x36,23,0x54,0x64,0x74,0xc3,0xd2,
   0xe2,8,0x26,0x83,9,10,24,25,0x84,0x94,0x45,0x46,0xa4,0xb4,0x56,0xd3,0x55,0x28,26,0xf2,0xe3,
   0xf3,0xc4,0xd4,0xe4,0xf4,0x65,0x75,0x85,0x95,0xa5,0xb5,0xc5,0xd5,0xe5,0xf5,0x66,0x76,0x86,0x96,
   0xa6,0xb6,0xc6,0xd6,0xe6,0xf6,0x37,0x47,0x57,0x67,0x77,0x87,0x97,0xa7,0xb7,0xc7,0xd7,0xe7,0xf7,
   0x38,0x48,0x58,0x68,0x78,0x88,0x98,0xa8,0xb8,0xc8,216,0xe8,0xf8,0x29,0x39,0x49,0x59,0x69,0x79,
   0x89,0x99,0xa9,0xb9,0xc9,0xd9,0xe9,0xf9,0x2a,0x3a,0x4a,0x5a,0x6a,0x7a,0x8a,0x9a,0xaa,0xba,0xca,
   0xda,0xea,0xfa,255,0xda,0,12,3,1,0,2,0,3,0,0,0x3f,0
   };
 if(jpegctx==NULL) { return RET_BADPARM; }
 if(jpegctx->magic!=aaHPP(aa_JpegNew)) { return RET_NOTINITIALIZED; }
 if(img==NULL) { return RET_BADPARM; }
 if(w==0||h==0) { return RET_BOUNDS; }
 if(w>=2000||h>=2000) { return RET_BOUNDS; }
 quality=aaNumClamp(quality,1,252);
 quality=quality/2;
 quality=127-quality;
 jpegctx->img_w=w;
 jpegctx->img_h=h;
 jpegctx->prev_y1dc=0;
 jpegctx->prev_y2dc=0;
 jpegctx->prev_crdc=0;
 jpegctx->prev_cbdc=0;
 jpegctx->x_pos=0;
 jpegctx->y_pos=0;
 jpegctx->eoi=NO;
 jpegctx->blocks_n=0;
 jpegctx->header.length=338;
 jpegctx->header.img_w_off=96;
 jpegctx->header.img_h_off=94;
 aaMemoryCopy(&jpegctx->header.data[0],jpegctx->header.length,&hdr_data[0]);
 for(i=0;i<64;i++)  {  jpegctx->quant[i]=(C)quality;  }
 for(i=0;i<64;i++)  {  jpegctx->header.data[25+i]=jpegctx->quant[i];  }
 jpegctx->header.data[jpegctx->header.img_w_off+0]=(B)(jpegctx->img_w>>8);
 jpegctx->header.data[jpegctx->header.img_w_off+1]=(B)(jpegctx->img_w&0xff);
 jpegctx->header.data[jpegctx->header.img_h_off+0]=(B)(jpegctx->img_h>>8);
 jpegctx->header.data[jpegctx->header.img_h_off+1]=(B)(jpegctx->img_h&0xff);
 aaMemoryFill(&jpegctx->buffy,sizeof(_jpegbuf),0);
 jpegctx->out_len=0;
 bytes=((jpegctx->img_w*jpegctx->img_h)*3)+_32K;
 if(jpegctx->out.bytes<bytes)
  {
  if(jpegctx->out.bytes==0) { ret=aaMemoryUnitAllocate(&jpegctx->out,bytes); }
  else                      { ret=aaMemoryUnitReAllocate(&jpegctx->out,bytes); }
  if(ret!=RET_YES) { oops; }
  }
 bytes=((jpegctx->img_w*jpegctx->img_h)*2)+_16K;
 if(jpegctx->yuv.bytes<bytes)
  {
  if(jpegctx->yuv.bytes==0) { ret=aaMemoryUnitAllocate(&jpegctx->yuv,bytes); }
  else                      { ret=aaMemoryUnitReAllocate(&jpegctx->yuv,bytes); }
  if(ret!=RET_YES) { oops; }
  }
 ioff=ooff=0;
 imgrgb=(BP)img;
 zz=0;
 for(yy=0;yy<(N)jpegctx->img_h;yy++)
  {
  for(xx=0;xx<(N)jpegctx->img_w;xx+=2)
   {
   ioff=4*(xx+(yy*jpegctx->img_w));
   r1=imgrgb[ioff+2];
   g1=imgrgb[ioff+1];
   b1=imgrgb[ioff+0];
   r2=imgrgb[ioff+6];
   g2=imgrgb[ioff+5];
   b2=imgrgb[ioff+4];
   cb1=128.0-(0.168736*r1)-(0.331264*g1)+(0.5*b1);
   cb2=128.0-(0.168736*r2)-(0.331264*g2)+(0.5*b2);
   cr1=128.0+(0.5*r1)-(0.418688*g1)-(0.081312*b1);
   cr2=128.0+(0.5*r2)-(0.418688*g2)-(0.081312*b2);
   ycbcr[zz+0]=0.299*r1+0.587*g1+0.114*b1;
   ycbcr[zz+2]=0.299*r2+0.587*g2+0.114*b2;
   ycbcr[zz+3]=(cb1+cb2)/2;
   ycbcr[zz+1]=(cr1+cr2)/2;
   zz+=4;
   }
  if((yy&2))
   {
   for(jj=0;jj<zz;jj++) { jpegctx->yuv.mem[ooff++]=(B)ycbcr[jj];    }
   zz=0;
   }
  }
 fo=0;
 aaMemoryCopy(&jpegctx->out.mem[fo],jpegctx->header.length,jpegctx->header.data);
 fo+=jpegctx->header.length;
 jpegctx->chunk.data=jpegctx->yuv.mem;
 jpegctx->chunk.width=jpegctx->img_w;
 jpegctx->chunk.height=jpegctx->img_h;
 jpegctx->chunk.x_pos=-16;
 jpegctx->chunk.y_pos=0;
 bb=aa_JpegWrite(jpegctx,&jpegctx->out.mem[fo],jpegctx->out.bytes);
 fo+=bb;
 jpegctx->out_len=fo;
 return RET_YES;
 }









/*-----------------------------------------------------------------------*/


 V aa_JpegDecRowIDCT                   (_jpegdecctx*jpegdecctx,ZP blk)
 {
 register Z x0,x1,x2,x3,x4,x5,x6,x7,x8;
 UNUSE(jpegdecctx);
 if(!((x1=blk[4]<<11)|(x2=blk[6])|(x3=blk[2])|(x4=blk[1])|(x5=blk[7])|(x6=blk[5])|(x7=blk[3])))
  {
  blk[0]=blk[1]=blk[2]=blk[3]=blk[4]=blk[5]=blk[6]=blk[7]=blk[0]<<3;
  return;
  }
 x0=(blk[0]<<11)+128;
 x8=aa_JPEGDEC_W7*(x4+x5);
 x4=x8+(aa_JPEGDEC_W1-aa_JPEGDEC_W7)*x4;
 x5=x8-(aa_JPEGDEC_W1+aa_JPEGDEC_W7)*x5;
 x8=aa_JPEGDEC_W3*(x6+x7);
 x6=x8-(aa_JPEGDEC_W3-aa_JPEGDEC_W5)*x6;
 x7=x8-(aa_JPEGDEC_W3+aa_JPEGDEC_W5)*x7;
 x8=x0+x1;
 x0-=x1;
 x1=aa_JPEGDEC_W6*(x3+x2);
 x2=x1-(aa_JPEGDEC_W2+aa_JPEGDEC_W6)*x2;
 x3=x1+(aa_JPEGDEC_W2-aa_JPEGDEC_W6)*x3;
 x1=x4+x6;
 x4-=x6;
 x6=x5+x7;
 x5-=x7;
 x7=x8+x3;
 x8-=x3;
 x3=x0+x2;
 x0-=x2;
 x2=(181*(x4+x5)+128)>>8;
 x4=(181*(x4-x5)+128)>>8;
 blk[0]=(x7+x1)>>8;
 blk[1]=(x3+x2)>>8;
 blk[2]=(x0+x4)>>8;
 blk[3]=(x8+x6)>>8;
 blk[4]=(x8-x6)>>8;
 blk[5]=(x0-x4)>>8;
 blk[6]=(x3-x2)>>8;
 blk[7]=(x7-x1)>>8;
 }

 V aa_JpegDecColIDCT                   (_jpegdecctx*jpegdecctx,ZP blk,BP out,Z stride)
 {
 register Z x0,x1,x2,x3,x4,x5,x6,x7,x8;
 UNUSE(jpegdecctx);
 if(!((x1=blk[8*4]<<8)| (x2=blk[8*6])|(x3=blk[8*2])|(x4=blk[8*1])|(x5=blk[8*7])|(x6=blk[8*5])|(x7=blk[8*3])))
  {
  x1=aaNumClamp(((blk[0]+32)>>6)+128,0,255);
  for(x0=8;x0;--x0)    {  *out=(B)x1;   out+=stride;        }
  return;
  }
 x0=(blk[0]<<8)+8192;
 x8=aa_JPEGDEC_W7*(x4+x5)+4;
 x4=(x8+(aa_JPEGDEC_W1-aa_JPEGDEC_W7)*x4)>>3;
 x5=(x8-(aa_JPEGDEC_W1+aa_JPEGDEC_W7)*x5)>>3;
 x8=aa_JPEGDEC_W3*(x6+x7)+4;
 x6=(x8-(aa_JPEGDEC_W3-aa_JPEGDEC_W5)*x6)>>3;
 x7=(x8-(aa_JPEGDEC_W3+aa_JPEGDEC_W5)*x7)>>3;
 x8=x0+x1;
 x0-=x1;
 x1=aa_JPEGDEC_W6*(x3+x2)+4;
 x2=(x1-(aa_JPEGDEC_W2+aa_JPEGDEC_W6)*x2)>>3;
 x3=(x1+(aa_JPEGDEC_W2-aa_JPEGDEC_W6)*x3)>>3;
 x1=x4+x6;
 x4-=x6;
 x6=x5+x7;
 x5-=x7;
 x7=x8+x3;
 x8-=x3;
 x3=x0+x2;
 x0-=x2;
 x2=(181*(x4+x5)+128)>>8;
 x4=(181*(x4-x5)+128)>>8;
 *out=aaNumClamp(((x7+x1)>>14)+128,0,255);  out+=stride;
 *out=aaNumClamp(((x3+x2)>>14)+128,0,255);  out+=stride;
 *out=aaNumClamp(((x0+x4)>>14)+128,0,255);  out+=stride;
 *out=aaNumClamp(((x8+x6)>>14)+128,0,255);  out+=stride;
 *out=aaNumClamp(((x8-x6)>>14)+128,0,255);  out+=stride;
 *out=aaNumClamp(((x0-x4)>>14)+128,0,255);  out+=stride;
 *out=aaNumClamp(((x3-x2)>>14)+128,0,255);  out+=stride;
 *out=aaNumClamp(((x7-x1)>>14)+128,0,255);
 }


 Z aa_JpegDecShowBits                  (_jpegdecctx*jpegdecctx,Z bits)
 {
 B newbyte;
 if (!bits) return 0;
 while(jpegdecctx->bufbits<bits)
  {
  if(jpegdecctx->size<=0) {  jpegdecctx->buf=(jpegdecctx->buf<<8)|0xFF;    jpegdecctx->bufbits+=8;  continue;        }
  newbyte=*jpegdecctx->pos++;
  jpegdecctx->size--;
  jpegdecctx->bufbits+=8;
  jpegdecctx->buf=(jpegdecctx->buf<<8)|newbyte;
  if(newbyte==0xFF)
   {
   if(jpegdecctx->size)
    {
    B marker=*jpegdecctx->pos++;
    jpegdecctx->size--;
    switch (marker)
     {
     case 0x00:
     case 0xFF:
     break;
     case 0xD9: jpegdecctx->size=0;
     break;
     default:
     if((marker&0xF8)!=0xD0)  { jpegdecctx->error=RET_FAILED; }
     else                     { jpegdecctx->buf=(jpegdecctx->buf<<8)|marker; jpegdecctx->bufbits+=8;          }
     }
    }
   else
    {
    jpegdecctx->error=RET_FAILED;
    }
   }
  }
 return(jpegdecctx->buf>>(jpegdecctx->bufbits-bits))&((1<<bits)-1);
 }


 Z aa_JpegDecGetBits                   (_jpegdecctx*jpegdecctx,Z bits)
 {
 Z res=aa_JpegDecShowBits(jpegdecctx,bits);
 if(jpegdecctx->bufbits<bits)  (void)aa_JpegDecShowBits(jpegdecctx,bits);
 jpegdecctx->bufbits-=bits;
 return res;
 }


 W aa_JpegDecDecode16                  (_jpegdecctx*jpegdecctx,BP pos)
 {
 UNUSE(jpegdecctx);
 return(pos[0]<<8)|pos[1];
 }

 V aa_JpegDecDecodeLength              (_jpegdecctx*jpegdecctx)
 {
 if(jpegdecctx->size<2) aa_JpegDec_Throw(jpegdecctx,RET_FAILED);
 jpegdecctx->length=aa_JpegDecDecode16(jpegdecctx,jpegdecctx->pos);
 if(jpegdecctx->length>jpegdecctx->size) aa_JpegDec_Throw(jpegdecctx,RET_FAILED);
 jpegdecctx->pos+=2;    jpegdecctx->size-=2;    jpegdecctx->length-=2;
 if(jpegdecctx->size<0) jpegdecctx->error=RET_FAILED;
 }

 V aa_JpegDecSkipMarker                (_jpegdecctx*jpegdecctx)
 {
 Z s;
 aa_JpegDecDecodeLength(jpegdecctx);
 s=jpegdecctx->length; jpegdecctx->pos+=s;    jpegdecctx->size-=s;    jpegdecctx->length-=s;
 if(jpegdecctx->size<0) jpegdecctx->error=RET_FAILED;
 }



 V aa_JpegDecDecodeSOF                 (_jpegdecctx*jpegdecctx)
 {
 Z s,i,ssxmax=0,ssymax=0;
 _jpegdeccomponent*c;
 aa_JpegDecDecodeLength(jpegdecctx);
 aa_JpegDec_CheckError(jpegdecctx);
 if(jpegdecctx->length<9)  aa_JpegDec_Throw(jpegdecctx,RET_FAILED);
 if(jpegdecctx->pos[0]!=8) aa_JpegDec_Throw(jpegdecctx,RET_NOTSUPPORTED);
 jpegdecctx->height=aa_JpegDecDecode16(jpegdecctx,jpegdecctx->pos+1);
 jpegdecctx->width=aa_JpegDecDecode16(jpegdecctx,jpegdecctx->pos+3);
 if(!jpegdecctx->width||!jpegdecctx->height) aa_JpegDec_Throw(jpegdecctx,RET_FAILED);
 jpegdecctx->ncomp=jpegdecctx->pos[5];
 s=6; jpegdecctx->pos+=s;    jpegdecctx->size-= s;    jpegdecctx->length-=s;
 if (jpegdecctx->size<0) jpegdecctx->error=RET_FAILED;
 if(jpegdecctx->ncomp!=1&&jpegdecctx->ncomp!=3) aa_JpegDec_Throw(jpegdecctx,RET_NOTSUPPORTED);
 if(jpegdecctx->length<(jpegdecctx->ncomp*3))   aa_JpegDec_Throw(jpegdecctx,RET_FAILED);
 for(i=0,c=jpegdecctx->comp;i<jpegdecctx->ncomp;++i,++c)
  {
  c->cid=jpegdecctx->pos[0];
  if(!(c->ssx=jpegdecctx->pos[1]>>4)) aa_JpegDec_Throw(jpegdecctx,RET_FAILED);
  if(c->ssx&(c->ssx-1)) aa_JpegDec_Throw(jpegdecctx,RET_NOTSUPPORTED);  // non-power of two
  if(!(c->ssy=jpegdecctx->pos[1]&15)) aa_JpegDec_Throw(jpegdecctx,RET_FAILED);
  if(c->ssy&(c->ssy-1)) aa_JpegDec_Throw(jpegdecctx,RET_NOTSUPPORTED);  // non-power of two
  if((c->qtsel=jpegdecctx->pos[2])&0xFC) aa_JpegDec_Throw(jpegdecctx,RET_FAILED);
  s=3; jpegdecctx->pos+=s;    jpegdecctx->size-=s;    jpegdecctx->length-=s;
  if(jpegdecctx->size<0) jpegdecctx->error=RET_FAILED;
  jpegdecctx->qtused|=1<<c->qtsel;
  if(c->ssx>ssxmax) ssxmax=c->ssx;
  if(c->ssy>ssymax) ssymax=c->ssy;
  }
 if (jpegdecctx->ncomp==1)
  {
  c=jpegdecctx->comp;
  c->ssx=c->ssy=ssxmax=ssymax=1;
  }
 jpegdecctx->mbsizex=ssxmax<<3;
 jpegdecctx->mbsizey=ssymax<<3;
 jpegdecctx->mbwidth=(jpegdecctx->width+jpegdecctx->mbsizex-1)/jpegdecctx->mbsizex;
 jpegdecctx->mbheight=(jpegdecctx->height+jpegdecctx->mbsizey-1)/jpegdecctx->mbsizey;
 for(i=0,c=jpegdecctx->comp;i<jpegdecctx->ncomp;++i,++c)
  {
  c->width=(jpegdecctx->width*c->ssx+ssxmax-1)/ssxmax;
  c->height=(jpegdecctx->height*c->ssy+ssymax-1)/ssymax;
  c->stride=jpegdecctx->mbwidth*c->ssx<<3;
  if(((c->width<3)&&(c->ssx!=ssxmax))||((c->height<3)&&(c->ssy!=ssymax)))            aa_JpegDec_Throw(jpegdecctx,RET_NOTSUPPORTED);
  if(aaMemoryAllocate((VP)&c->pixels,c->stride*jpegdecctx->mbheight*c->ssy<<3)!=YES) aa_JpegDec_Throw(jpegdecctx,RET_NOMEMORY);
  }
 if (jpegdecctx->ncomp==3)
  {
  if(jpegdecctx->rgb==NULL)
   {
   if(aaMemoryAllocate((VP)&jpegdecctx->rgb,jpegdecctx->width*jpegdecctx->height*4)!=YES) aa_JpegDec_Throw(jpegdecctx,RET_NOMEMORY);
   }
  }
 s=jpegdecctx->length;jpegdecctx->pos+=s;    jpegdecctx->size-=s;    jpegdecctx->length-=s;
 if(jpegdecctx->size<0) jpegdecctx->error=RET_FAILED;
 }


 V aa_JpegDecDecodeDHT                 (_jpegdecctx*jpegdecctx)
 {
 Z codelen,currcnt,remain,spread,i,j,s;
 _jpegdecvlccode*vlc;
 static B counts[16];
 aa_JpegDecDecodeLength(jpegdecctx);
 aa_JpegDec_CheckError(jpegdecctx);
 while(jpegdecctx->length>=17)
  {
  i=jpegdecctx->pos[0];
  if(i&0xEC) aa_JpegDec_Throw(jpegdecctx,RET_FAILED);
  if(i&0x02) aa_JpegDec_Throw(jpegdecctx,RET_NOTSUPPORTED);
  i=(i|(i>>3))&3;  // combined DC/AC+tableid value
  for(codelen=1;codelen<=16;++codelen) counts[codelen-1]=jpegdecctx->pos[codelen];
  s=17; jpegdecctx->pos+=s;  jpegdecctx->size-=s;    jpegdecctx->length-=s;
  if(jpegdecctx->size<0) jpegdecctx->error=RET_FAILED;
  vlc=&jpegdecctx->vlctab[i][0];
  remain=spread=65536;
  for(codelen=1;codelen<=16;++codelen)
   {
   spread>>=1;
   currcnt=counts[codelen-1];
   if(!currcnt) continue;
   if(jpegdecctx->length<currcnt) aa_JpegDec_Throw(jpegdecctx,RET_FAILED);
   remain-=currcnt<<(16-codelen);
   if(remain<0) aa_JpegDec_Throw(jpegdecctx,RET_FAILED);
   for(i=0;i<currcnt;++i)
    {
    register B code=jpegdecctx->pos[i];
    for(j=spread;j;--j)
     {
     vlc->bits=(B)codelen;
     vlc->code=code;
     ++vlc;
     }
    }
   s=currcnt; jpegdecctx->pos+=s;    jpegdecctx->size-=s;    jpegdecctx->length-=s;
   if(jpegdecctx->size<0) jpegdecctx->error=RET_FAILED;
   }
  while (remain--) {  vlc->bits=0;   ++vlc;        }
  }
 if (jpegdecctx->length) aa_JpegDec_Throw(jpegdecctx,RET_FAILED);
 }



 V aa_JpegDecDecodeDQT                 (_jpegdecctx*jpegdecctx)
 {
 Z i,s;
 BP t;
 aa_JpegDecDecodeLength(jpegdecctx);
 aa_JpegDec_CheckError(jpegdecctx);
 while(jpegdecctx->length>=65)
  {
  i=jpegdecctx->pos[0];
  if(i&0xFC) aa_JpegDec_Throw(jpegdecctx,RET_FAILED);
  jpegdecctx->qtavail|=1<<i;
  t=&jpegdecctx->qtab[i][0];
  for(i=0;i<64;++i)  t[i]=jpegdecctx->pos[i+1];
  s=65; jpegdecctx->pos+=s;    jpegdecctx->size-=s;    jpegdecctx->length-=s;
  if(jpegdecctx->size<0) jpegdecctx->error=RET_FAILED;
  }
 if (jpegdecctx->length) aa_JpegDec_Throw(jpegdecctx,RET_FAILED);
 }


 V aa_JpegDecDecodeDRI                 (_jpegdecctx*jpegdecctx)
 {
 Z s;
 aa_JpegDecDecodeLength(jpegdecctx);
 aa_JpegDec_CheckError(jpegdecctx);
 if(jpegdecctx->length<2) aa_JpegDec_Throw(jpegdecctx,RET_FAILED);
 jpegdecctx->rstinterval=aa_JpegDecDecode16(jpegdecctx,jpegdecctx->pos);
 s=jpegdecctx->length; jpegdecctx->pos+=s;    jpegdecctx->size-=s;    jpegdecctx->length-=s;
 if(jpegdecctx->size<0) jpegdecctx->error=RET_FAILED;
 }

 Z aa_JpegDecGetVLC                    (_jpegdecctx*jpegdecctx,_jpegdecvlccode*vlc,BP code)
 {
 Z value =aa_JpegDecShowBits(jpegdecctx,16);
 Z bits = vlc[value].bits;
 if(!bits) { jpegdecctx->error=RET_FAILED; return 0; }
 if(jpegdecctx->bufbits<bits)    (void)aa_JpegDecShowBits(jpegdecctx,bits);
 jpegdecctx->bufbits-=bits;
 value=vlc[value].code;
 if(code) *code=(B)value;
 bits=value&15;
 if(!bits) return 0;
 value=aa_JpegDecGetBits(jpegdecctx,bits);
 if(value<(1<<(bits-1)))  value+=((-1)<<bits)+1;
 return value;
 }


 V aa_JpegDecDecodeBlock               (_jpegdecctx*jpegdecctx,_jpegdeccomponent*c,BP out)
 {
 B code=0;
 Z value,coef=0;
 aaMemoryFill(jpegdecctx->block,sizeof(jpegdecctx->block),0);
 c->dcpred+=aa_JpegDecGetVLC(jpegdecctx,&jpegdecctx->vlctab[c->dctabsel][0],NULL);
 jpegdecctx->block[0]=(c->dcpred)*jpegdecctx->qtab[c->qtsel][0];
 do
  {
  value=aa_JpegDecGetVLC(jpegdecctx,&jpegdecctx->vlctab[c->actabsel][0],&code);
  if(!code) break;  // EOB
  if(!(code&0x0F)&&(code!=0xF0)) aa_JpegDec_Throw(jpegdecctx,RET_FAILED);
  coef+=(code>>4)+1;
  if(coef>63) aa_JpegDec_Throw(jpegdecctx,RET_FAILED);
  jpegdecctx->block[(int) aa_math_scan_zigzag[coef]]=value*jpegdecctx->qtab[c->qtsel][coef];
  }
  while(coef<63);
 for(coef=0;coef<64;coef+=8)   aa_JpegDecRowIDCT(jpegdecctx,&jpegdecctx->block[coef]);
 for(coef=0;coef<8;++coef)     aa_JpegDecColIDCT(jpegdecctx,&jpegdecctx->block[coef],&out[coef],c->stride);
 }


 V aa_JpegDecDecodeScan                (_jpegdecctx*jpegdecctx)
 {
 Z i,mbx,mby,sbx,sby,s;
 Z rstcount=jpegdecctx->rstinterval,nextrst=0;
 _jpegdeccomponent*c;
 aa_JpegDecDecodeLength(jpegdecctx);
 aa_JpegDec_CheckError(jpegdecctx);
 if(jpegdecctx->length<(4+2*jpegdecctx->ncomp)) aa_JpegDec_Throw(jpegdecctx,RET_FAILED);
 if(jpegdecctx->pos[0]!=jpegdecctx->ncomp)      aa_JpegDec_Throw(jpegdecctx,RET_NOTSUPPORTED);
 s=1; jpegdecctx->pos+=s;    jpegdecctx->size-=s;    jpegdecctx->length-=s;
 if(jpegdecctx->size<0) jpegdecctx->error=RET_FAILED;
 for(i=0,c=jpegdecctx->comp;i<jpegdecctx->ncomp;++i,++c)
  {
  if(jpegdecctx->pos[0]!=c->cid) aa_JpegDec_Throw(jpegdecctx,RET_FAILED);
  if(jpegdecctx->pos[1]&0xEE)    aa_JpegDec_Throw(jpegdecctx,RET_FAILED);
  c->dctabsel=jpegdecctx->pos[1]>>4;
  c->actabsel=(jpegdecctx->pos[1]&1)|2;
  s=2; jpegdecctx->pos+=s;    jpegdecctx->size-=s;    jpegdecctx->length-=s;
  if(jpegdecctx->size<0) jpegdecctx->error=RET_FAILED;
  }
 if(jpegdecctx->pos[0]||(jpegdecctx->pos[1]!=63)||jpegdecctx->pos[2]) aa_JpegDec_Throw(jpegdecctx,RET_NOTSUPPORTED);
 s=jpegdecctx->length; jpegdecctx->pos+=s;    jpegdecctx->size-=s;    jpegdecctx->length-=s;
 if(jpegdecctx->size<0) jpegdecctx->error=RET_FAILED;
 for(mbx=mby=0;;)
  {
  for(i=0,c=jpegdecctx->comp;i<jpegdecctx->ncomp;++i,++c)
  for(sby=0;sby<c->ssy;++sby)
  for(sbx=0;sbx<c->ssx;++sbx)
   {
   aa_JpegDecDecodeBlock(jpegdecctx,c,&c->pixels[((mby*c->ssy+sby)*c->stride+mbx*c->ssx+sbx)<<3]);
   aa_JpegDec_CheckError(jpegdecctx);
   }
  if(++mbx>=jpegdecctx->mbwidth)
   {
   mbx=0;
   if(++mby>=jpegdecctx->mbheight) break;
   }
  if(jpegdecctx->rstinterval&&!(--rstcount))
   {
   jpegdecctx->bufbits&=0xF8;
   i=aa_JpegDecGetBits(jpegdecctx,16);
   if(((i&0xFFF8)!=0xFFD0)||((i&7)!=nextrst)) aa_JpegDec_Throw(jpegdecctx,RET_FAILED);
   nextrst=(nextrst+1)&7;
   rstcount=jpegdecctx->rstinterval;
   for(i=0;i<3;++i)  jpegdecctx->comp[i].dcpred=0;
   }
  }
 jpegdecctx->error=RET_FINISHED;
 }



 V aa_JpegDecUpSample                  (_jpegdecctx*jpegdecctx,_jpegdeccomponent*c)
 {
 Z x,y,xshift=0,yshift=0;
 BP out,lin,lout;
 while(c->width<jpegdecctx->width)   { c->width<<=1; ++xshift;  }
 while(c->height<jpegdecctx->height) { c->height<<=1; ++yshift; }
 if(aaMemoryAllocate((VP)&out,c->width*c->height)!=YES) {  aa_JpegDec_Throw(jpegdecctx,RET_NOMEMORY); }
 lin=c->pixels;
 lout=out;
 for (y=0;y<c->height;++y)
  {
  lin=&c->pixels[(y>>yshift)*c->stride];
  for(x=0;x<c->width;++x) lout[x]=lin[x>>xshift];
  lout+=c->width;
  }
 c->stride=c->width;
 aaMemoryRelease(c->pixels);
 c->pixels=out;
 }




 V aa_JpegDecConvert                   (_jpegdecctx*jpegdecctx)
 {
 Z i;
 _jpegdeccomponent*c;
 for(i=0,c=jpegdecctx->comp;i<jpegdecctx->ncomp;++i,++c)
  {
  if((c->width<jpegdecctx->width)||(c->height<jpegdecctx->height)) aa_JpegDecUpSample(jpegdecctx,c);
  if((c->width<jpegdecctx->width)||(c->height<jpegdecctx->height)) aa_JpegDec_Throw(jpegdecctx,RET_FAILED);
  }
 if(jpegdecctx->ncomp==3)
  {
  register Z x,yy;
  BP prgb=jpegdecctx->rgb;
  BP py=jpegdecctx->comp[0].pixels;
  BP pcb=jpegdecctx->comp[1].pixels;
  BP pcr=jpegdecctx->comp[2].pixels;
  for(yy=jpegdecctx->height;yy;--yy)
   {
   for(x=0;x<jpegdecctx->width;++x)
    {
    register Z y=py[x]<<8;
    register Z cb=pcb[x]-128;
    register Z cr=pcr[x]-128;
    *prgb++=aaNumClamp((y+454*cb+128)>>8,0,255);
    *prgb++=aaNumClamp((y-88*cb-183*cr+128)>>8,0,255);
    *prgb++=aaNumClamp((y+359*cr+128)>>8,0,255);
    *prgb++=255;
    }
   py+=jpegdecctx->comp[0].stride;
   pcb+=jpegdecctx->comp[1].stride;
   pcr+=jpegdecctx->comp[2].stride;
   }
  }
 else
 if(jpegdecctx->comp[0].width!=jpegdecctx->comp[0].stride)
  {
   // grayscale -> only remove stride
  BP pin=&jpegdecctx->comp[0].pixels[jpegdecctx->comp[0].stride];
  BP pout=&jpegdecctx->comp[0].pixels[jpegdecctx->comp[0].width];
  Z y;
  for(y=jpegdecctx->comp[0].height-1;y;--y)
   {
   aaMemoryCopy(pout,jpegdecctx->comp[0].width,pin);
   pin+=jpegdecctx->comp[0].stride;
   pout+=jpegdecctx->comp[0].width;
   }
  jpegdecctx->comp[0].stride=jpegdecctx->comp[0].width;
  }
 }




 B aa_JpegDecNew                       (_jpegdecctx*jpegdecctx,BP usersuppliedrgb)
 {
 aaMemoryFill(jpegdecctx,sizeof(_jpegdecctx),0);
 jpegdecctx->user_supplied_rgb=usersuppliedrgb;
 jpegdecctx->rgb=jpegdecctx->user_supplied_rgb;
 return RET_YES;
 }


 B aa_JpegDecDelete                    (_jpegdecctx*jpegdecctx)
 {
 Z i;
 for(i=0;i<3;++i)
  {
  if(jpegdecctx->comp[i].pixels) aaMemoryRelease(jpegdecctx->comp[i].pixels); //njFreeMem((void*) jpegdecctx->comp[i].pixels);
  }
 if(jpegdecctx->rgb)
  {
  if(jpegdecctx->user_supplied_rgb!=jpegdecctx->rgb)
   {
   aaMemoryRelease(jpegdecctx->rgb); //njFreeMem((void*) jpegdecctx->rgb);
   }
  }
 aaMemoryFill(jpegdecctx,sizeof(_jpegdecctx),0);
 return RET_YES;
 }



 B aa_JpegDecDecompress                (_jpegdecctx*jpegdecctx,VP jpeg,Z size)
 {
 Z s;

 jpegdecctx->pos=(BP)jpeg;
 jpegdecctx->size=size&0x7FFFFFFF;
 if(jpegdecctx->size<2) { aaNote(0,"%i",size); return RET_CORRUPTED; }
 if((jpegdecctx->pos[0]^0xFF)|(jpegdecctx->pos[1]^0xD8)) { oof; return RET_CORRUPTED; }
 s=2; jpegdecctx->pos+=s;    jpegdecctx->size-=s;    jpegdecctx->length-=s;
 if(jpegdecctx->size<0) jpegdecctx->error=RET_FAILED;
 while(!jpegdecctx->error)
  {
  if((jpegdecctx->size<2)||(jpegdecctx->pos[0]!= 0xFF)) return RET_FAILED;
  s=2; jpegdecctx->pos+=s;  jpegdecctx->size-=s;    jpegdecctx->length-=s;
  if(jpegdecctx->size<0) jpegdecctx->error=RET_FAILED;
  switch(jpegdecctx->pos[-1])
   {
   case 0xC0: aa_JpegDecDecodeSOF(jpegdecctx);  break;
   case 0xC4: aa_JpegDecDecodeDHT(jpegdecctx);  break;
   case 0xDB: aa_JpegDecDecodeDQT(jpegdecctx);  break;
   case 0xDD: aa_JpegDecDecodeDRI(jpegdecctx);  break;
   case 0xDA: aa_JpegDecDecodeScan(jpegdecctx); break;
   case 0xFE: aa_JpegDecSkipMarker(jpegdecctx); break;
   default:
   if((jpegdecctx->pos[-1]&0xF0)==0xE0)  aa_JpegDecSkipMarker(jpegdecctx);
   else                                  return RET_NOTSUPPORTED;
   }
  }
 if(jpegdecctx->error!=RET_FINISHED) return jpegdecctx->error;
 jpegdecctx->error=RET_YES;
 aa_JpegDecConvert(jpegdecctx);
 return jpegdecctx->error;
 }



/*-----------------------------------------------------------------------*/



 B aa_CursorSystemStart                (V)
 {
 logg("aa_CursorSystemStart()");
 aa.cursor_system.hand_cursor_handle=CreateCursor(aa.core_system.this_instance,6,1,32,32,aa_cursorhand,&aa_cursorhand[32*4]);
 aaCursorSet(aa_CURSOR_Arrow);
 logg("");
 return RET_YES;
 }



 V aa_CursorSystemStop                 (V)
 {
 logg("aa_CursorSystemStop()");
 if(aa.cursor_system.hand_cursor_handle!=NULL)
  {
  DestroyCursor(aa.cursor_system.hand_cursor_handle);
  aa.cursor_system.hand_cursor_handle=NULL;
  }
 logg("");
 }



/*-----------------------------------------------------------------------*/





 B aa_ColorSystemStart                 (V)
 {
 _rgba p1;
 N i,r,g,b,n;
 _rgba ref;

 logg("aa_ColorSystemStart()");
 aaRgbaSet(&col_null,0,0,0,0);
 aaRgbaSet(&aa.color_system.shadow,0,0,0,128);
 aaRgbaSet(&col_black,0,0,0,255);
 aaRgbaSet(&col_white,255,255,255,255);
 aaRgbaSet(&ref,0,0,0,255);
 aaRgbaSet(&p1,255,255,255,255); aaRgbaGradientArray(&ref,&p1,32,&col_gray[0]);
 aaRgbaSet(&p1,255,0,0,255);     aaRgbaGradientArray(&ref,&p1,32,&col_red[0]);
 aaRgbaSet(&p1,0,255,0,255);     aaRgbaGradientArray(&ref,&p1,32,&col_green[0]);
 aaRgbaSet(&p1,0,0,255,255);     aaRgbaGradientArray(&ref,&p1,32,&col_blue[0]);
 aaRgbaSet(&p1,255,0,255,255);   aaRgbaGradientArray(&ref,&p1,32,&col_purple[0]);
 aaRgbaSet(&p1,255,255,0,255);    aaRgbaGradientArray(&ref,&p1,32,&col_yellow[0]);
 aaRgbaSet(&p1,0,255,255,255);   aaRgbaGradientArray(&ref,&p1,32,&col_cyan[0]);
 aaRgbaSet(&p1,242,95,45,255);   aaRgbaGradientArray(&ref,&p1,32,&col_orange[0]);
 aaRgbaSet(&p1,27,173,242,255);   aaRgbaGradientArray(&ref,&p1,32,&col_sky[0]);
 aaRgbaSetUsingHsla(&p1,250,200,200,255); aaRgbaGradientArray(&col_red[4],&p1,32,&col_pastelred[0]);
 aaRgbaSetUsingHsla(&p1, 80,250,200,255); aaRgbaGradientArray(&col_green[4],&p1,32,&col_pastelgreen[0]);
 aaRgbaSetUsingHsla(&p1,150,250,200,255); aaRgbaGradientArray(&col_blue[4],&p1,32,&col_pastelblue[0]);
 aaRgbaSetUsingHsla(&p1,200,150,200,255); aaRgbaGradientArray(&col_purple[4],&p1,32,&col_pastelpurple[0]);
 aaRgbaSetUsingHsla(&p1, 50,200,200,255); aaRgbaGradientArray(&col_yellow[4],&p1,32,&col_pastelyellow[0]);
 aaRgbaSetUsingHsla(&p1,120,230,210,255); aaRgbaGradientArray(&col_cyan[4],&p1,32,&col_pastelcyan[0]);
 aaRgbaSet(&p1,248,168,133,255);   aaRgbaGradientArray(&col_orange[4],&p1,32,&col_pastelorange[0]);
 aaRgbaSet(&p1,106,210,248,255);   aaRgbaGradientArray(&col_sky[4],&p1,32,&col_pastelsky[0]);
 for(r=0;r<6;r++)
  {
  for(g=0;g<6;g++)
   {
   for(b=0;b<6;b++)
    {
    i=(r+g*6+b*36);
    aaRgbaSet(&aa.color_system.half_pal[i],(B)(r*51),(B)(g*51),(B)(b*51),255);
    }
   }
  }
 n=0;
 for(i=0;i<32;i++) col_map[n++]=&col_gray[i];       // 0
 for(i=0;i<32;i++) col_map[n++]=&col_red[i];        // 32
 for(i=0;i<32;i++) col_map[n++]=&col_green[i];      // 64
 for(i=0;i<32;i++) col_map[n++]=&col_blue[i];       // 96
 for(i=0;i<32;i++) col_map[n++]=&col_purple[i];     // 128
 for(i=0;i<32;i++) col_map[n++]=&col_yellow[i];     // 160
 for(i=0;i<32;i++) col_map[n++]=&col_cyan[i];       // 192
 for(i=0;i<32;i++) col_map[n++]=&col_orange[i];     // 224
 for(i=0;i<32;i++) col_map[n++]=&col_sky[i];        // 256
 for(i=0;i<32;i++) col_map[n++]=&col_pastelred[i];  // 288
 for(i=0;i<32;i++) col_map[n++]=&col_pastelgreen[i]; // 320
 for(i=0;i<32;i++) col_map[n++]=&col_pastelblue[i];  // 352
 for(i=0;i<32;i++) col_map[n++]=&col_pastelpurple[i]; // 384
 for(i=0;i<32;i++) col_map[n++]=&col_pastelyellow[i]; // 416
 for(i=0;i<32;i++) col_map[n++]=&col_pastelcyan[i];   // 448
 for(i=0;i<32;i++) col_map[n++]=&col_pastelorange[i]; // 480
 for(i=0;i<32;i++) col_map[n++]=&col_pastelsky[i];    // 512
 for(i=n;i<576;i++) col_map[i]=&col_null;
 logg("");
 return RET_YES;
 }




 V aa_ColorSystemStop                  (V)
 {
 logg("aa_ColorSystemStop()");
 logg("");
 }


/*-----------------------------------------------------------------------*/




 B aa_GifSystemStart                   (V)
 {
 logg("aa_GifSystemStart()");
 aa_ObjectIdNew(&aa.gif_system.object_id);
 aa_ObjectDefine(aa.gif_system.object_id,sizeof(_aa_gifobject),300,8,aaGifDestroy,"Gif");
 logg("");
 return RET_YES;
 }




 V aa_GifSystemStop                    (V)
 {
 logg("aa_GifSystemStop()");
 aa_ObjectUndefine(aa.gif_system.object_id);
 logg("");
 }





 B aa_GifSystemReadBytes               (PP mem,H bytes,VP buf)
 {
 H rem;
 _aa_gifobject*gifp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 aaCast(gifp,_aa_gifobject*,*mem);
 rem=gifp->file_bytes-gifp->file_offset;
 if(bytes>rem)
  {
  aaNote(0,"%i %i %i %i",rem,gifp->file_bytes,gifp->file_offset,bytes);
  return RET_BOUNDS;
  }
 aaMemoryCopy(buf,bytes,&gifp->file_mem[gifp->file_offset]);
 gifp->file_offset+=bytes;
 return RET_YES;
 }




 N aa_GifSystemBitSize                 (N value)
 {
 N i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 for(i=1;i<=8;i++) { if((1<<i)>=value) break;  }
 return(i);
 }




 B aa_GifSystemReadFrameInfo           (PP mem)
 {
 N i,bpp;
 B Buf[32],codesize;
 HP prefix;
 _aa_gifobject*gifp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 aaCast(gifp,_aa_gifobject*,*mem);
 if(aa_GifSystemReadBytes(mem,2,&gifp->frame_cord.x)==RET_FAILED||aa_GifSystemReadBytes(mem,2,&gifp->frame_cord.y)==RET_FAILED
  ||aa_GifSystemReadBytes(mem,2,&gifp->frame_size.w)==RET_FAILED||aa_GifSystemReadBytes(mem,2,&gifp->frame_size.h)==RET_FAILED)
  {
  return RET_FAILED;
  }
 if(aa_GifSystemReadBytes(mem,1,Buf)!=RET_YES)  {  return RET_FAILED;  }
 bpp=(Buf[0]&0x07)+1;
 gifp->frame_interlaced=(B)(Buf[0]&0x40);
 gifp-> frame_use_local_color=NO;
 if(Buf[0]&0x80)
  {
  if((1<<bpp)!=(1<<aa_GifSystemBitSize(1<<bpp))) return RET_FAILED;
  gifp->local_color_count=(W)(1<<bpp);
  gifp->local_color_bits=(W)aa_GifSystemBitSize((1<<bpp));
  for(i=0;i<gifp->local_color_count;i++)
   {
   if(aa_GifSystemReadBytes(mem,3,Buf)!=RET_YES)  { return RET_FAILED; }
   aaRgbaSet(&gifp->local_color_pen[i],Buf[2],Buf[1],Buf[0],255);
   }
  gifp->frame_use_local_color=YES;
  }
 gifp->PixelCount=(long)gifp->frame_size.w*(long)gifp->frame_size.h;
 if(gifp->frame_cord.x<0||gifp->frame_cord.x>=(N)gifp->status.size.w) { return RET_FAILED; }
 if(gifp->frame_cord.y<0||gifp->frame_cord.y>=(N)gifp->status.size.h) { return RET_FAILED; }
 if(gifp->frame_size.w>gifp->status.size.w) { return RET_FAILED; }
 if(gifp->frame_size.h>gifp->status.size.h) { return RET_FAILED; }
 if(gifp->frame_cord.x+gifp->frame_size.w>gifp->status.size.w) { return RET_FAILED; }
 if(gifp->frame_cord.y+gifp->frame_size.h>gifp->status.size.h) { return RET_FAILED; }
 aa_GifSystemReadBytes(mem,1,&codesize);
 bpp=codesize;
 gifp->Buf[0]=0;
 gifp->bpp=bpp;
 gifp->clear_code=(1<<bpp);
 gifp->eof_code=gifp->clear_code+1;
 gifp->RunningCode=gifp->eof_code+1;
 gifp->RunningBits=bpp+1;
 gifp->MaxCode1=1<<gifp->RunningBits;
 gifp->stack_ptr=0;
 gifp->last_code=4098;
 gifp->CrntShiftState=0;
 gifp->CrntShiftDWord=0;
 prefix=gifp->Prefix;
 for(i=0;i<=4095;i++) {  prefix[i]=4098;  }
 return RET_YES;
 }




 B aa_GifSystemReadExtension           (PP mem,NP extension_code,BP*extension)
 {
 B buf;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aa_GifSystemReadBytes(mem,1,&buf)!=RET_YES)  {  return RET_FAILED;  }
 *extension_code=buf;
 return aa_GifSystemReadExtensionNext(mem,extension);
 }





 B aa_GifSystemReadExtensionNext       (PP mem,BP*extension)
 {
 B buf;
 _aa_gifobject*gifp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 aaCast(gifp,_aa_gifobject*,*mem);
 if(aa_GifSystemReadBytes(mem,1,&buf)!=RET_YES) {  return RET_FAILED;  }
 if(buf>0)
  {
  *extension=gifp->Buf;
  (*extension)[0]=buf;
  if(aa_GifSystemReadBytes(mem,buf,&((*extension)[1]))!=RET_YES)  {  return RET_FAILED;  }
  }
 else {  *extension=NULL;  }
 return RET_YES;
 }





 B aa_GifSystemReadLine                (PP mem,BP line,N linelen)
 {
 BP dummy;
 _aa_gifobject*gifp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 aaCast(gifp,_aa_gifobject*,*mem);
 if(!linelen) {  linelen=(I)gifp->frame_size.w;  }
 if((gifp->PixelCount-=linelen)>0xffff0000) {  return RET_FAILED; }
 if(aa_GifSystemDecompressLine(mem,line,linelen)==RET_YES)
  {
  if(gifp->PixelCount==0)
   {
   do { if(aa_GifSystemGetCodeNext(mem,&dummy)==RET_FAILED)  {  return RET_FAILED;   }   } while(dummy!=NULL);
   }
  return RET_YES;
  }
 return RET_FAILED;
 }




 B aa_GifSystemGetCodeNext             (PP mem,BP*codeblock)
 {
 B buf;
 _aa_gifobject*gifp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 aaCast(gifp,_aa_gifobject*,*mem);
 if(aa_GifSystemReadBytes(mem,1,&buf)!=RET_YES) {  return RET_FAILED;  }

 if(buf>0)
  {
  *codeblock=gifp->Buf;
  (*codeblock)[0]=buf;
  if(aa_GifSystemReadBytes(mem,buf,&((*codeblock)[1]))!=RET_YES)  {  return RET_FAILED; }
  }
 else
  {
  *codeblock=NULL;
  gifp->Buf[0]=0;
  gifp->PixelCount=0;
  }
 return RET_YES;
 }





 B aa_GifSystemDecompressLine          (PP mem,BP line,N linelen)
 {
 N i,j,crnt_code,eof_code,clear_code,crnt_prefix,last_code,stack_ptr;
 BP stack,suffix;
 HP prefix;
 _aa_gifobject*gifp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 i=0;
 if(mem==NULL) { return RET_BADPARM; }
 aaCast(gifp,_aa_gifobject*,*mem);
 stack_ptr=gifp->stack_ptr;
 prefix=gifp->Prefix;
 suffix=gifp->Suffix;
 stack=gifp->Stack;
 eof_code=gifp->eof_code;
 clear_code=gifp->clear_code;
 last_code=gifp->last_code;

 if(stack_ptr!=0)
  {
  while(stack_ptr!=0&&i<linelen)
   {
   if(line) line[i++]=stack[--stack_ptr];
   else { i++; --stack_ptr; }
   }
  }
 while(i<linelen)
  {
  if(aa_GifSystemDecompressInput(mem,&crnt_code)==RET_FAILED) {  return RET_FAILED; }
  if(crnt_code==eof_code)
   {
   if(i!=linelen-1||gifp->PixelCount!=0)  { return RET_FAILED; }
   i++;
   }
  else if(crnt_code==clear_code)
   {
   for(j=0;j<=4095;j++)  { prefix[j]=4098; }
   gifp->RunningCode=gifp->eof_code+1;
   gifp->RunningBits=gifp->bpp+1;
   gifp->MaxCode1=1<<gifp->RunningBits;
   last_code=gifp->last_code=4098;
   }
  else
   {
   if(crnt_code<clear_code)
    {
    if(line) { line[i++] =(B) crnt_code; }
    else     { i++; }
    }
   else
    {
    if(prefix[crnt_code]==4098)
     {
     if(crnt_code==(N)gifp->RunningCode - 2)
      {
      crnt_prefix=last_code;
      suffix[gifp->RunningCode - 2]=stack[stack_ptr++]=aa_GifSystemGetPrefixChar(prefix,last_code,clear_code);
      }
     else { return RET_FAILED; }
     }
    else
     {
     crnt_prefix=crnt_code;
     }
     j=0;
     while(j++<=4095&&crnt_prefix>clear_code&&crnt_prefix<=4095)
      {
      stack[stack_ptr++]=suffix[crnt_prefix];
      crnt_prefix=prefix[crnt_prefix];
      }
     if(j>=4095||crnt_prefix>4095) {  return RET_FAILED;  }
     stack[stack_ptr++]=(B)crnt_prefix;
     while(stack_ptr!=0&&i<linelen)
      {
      if(line) { line[i++]=stack[--stack_ptr]; }
      else     { i++; --stack_ptr; }
      }
     }
   if(last_code!=4098)
    {
    prefix[gifp->RunningCode - 2]=last_code;
    if(crnt_code==(N)gifp->RunningCode-2) { suffix[gifp->RunningCode-2]=aa_GifSystemGetPrefixChar(prefix,last_code,clear_code);  }
    else                                  { suffix[gifp->RunningCode-2]=aa_GifSystemGetPrefixChar(prefix,crnt_code,clear_code);  }
    }
   last_code=crnt_code;
   }
  }
 gifp->last_code=last_code;
 gifp->stack_ptr=stack_ptr;
 return RET_YES;
 }




 B aa_GifSystemGetPrefixChar           (HP prefix,N Code,N clear_code)
 {
 N i=0;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 while(Code>clear_code&&i++<=4095) Code=prefix[Code];
 return (B)Code;
 }



 B aa_GifSystemDecompressInput         (PP mem,NP Code)
 {
 B NextByte;
 _aa_gifobject*gifp;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 aaCast(gifp,_aa_gifobject*,*mem);
 while(gifp->CrntShiftState<gifp->RunningBits)
  {
  if(gifp->Buf[0]==0)
   {
   if(aa_GifSystemReadBytes(mem,1,gifp->Buf)!=RET_YES)   {  return RET_FAILED; }
   if(aa_GifSystemReadBytes(mem,gifp->Buf[0],&gifp->Buf[1])!=RET_YES) { return RET_FAILED; }
   NextByte=gifp->Buf[1];
   gifp->Buf[1]=2;
   gifp->Buf[0]--;
   }
  else
   {
   NextByte=gifp->Buf[gifp->Buf[1]++];
   gifp->Buf[0]--;
   }
  gifp->CrntShiftDWord|=((H)NextByte)<<gifp->CrntShiftState;
  gifp->CrntShiftState+=8;
  }
 *Code=gifp->CrntShiftDWord&aa_GifCodeMasks[gifp->RunningBits];
 gifp->CrntShiftDWord>>=gifp->RunningBits;
 gifp->CrntShiftState-=gifp->RunningBits;
 if(++gifp->RunningCode>gifp->MaxCode1&&gifp->RunningBits<12)
  {
  gifp->MaxCode1<<=1;
  gifp->RunningBits++;
  }
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/

/*
//http://hackerthedude.blogspot.com.au/2009/10/keylogger-in-c.html
//-----------
*/

/**
aa_InputKeyLoggerStart
                      KeyEvent calls aa_InputSystemKeyEventProc
    aa_InputSystemKeyEventProc writs events to ihke.que
              aa_InputStateGet calls aa_InputSystemHookedKeyProcess
aa_InputSystemHookedKeyProcess reads events from ihke.que
aa_InputSystemHookedKeyProcess calls aa_InputSystemVkeyStateSet
aaInputStateGet calls aa_InputStateGet
aaInputEngine calls aaInputStateGet
*/



 __declspec(dllexport) K KeyEvent      (int nCode,WPARAM wParam,LPARAM lParam)
 {
 LPARAM lp;
 HWND hwnd;
 H han,flag;
 KBDLLHOOKSTRUCT hooked=*((KBDLLHOOKSTRUCT*)lParam);

 if(nCode==HC_ACTION)
  {
  ///aa.input_system.logger_reset_tik=aa_msrunning;  if all works, comment back in, to reduce calls to reset
  if(wParam==WM_KEYUP||wParam==WM_KEYDOWN||wParam==WM_SYSKEYUP||wParam==WM_SYSKEYDOWN)
   {
   lp=0;
   lp=lp|(0x0000FFFF&0x00000001);
   lp=lp|(0x00FF0000&(hooked.scanCode<<16));
   lp=lp|(0x01000000&((hooked.flags&LLKHF_EXTENDED)<<23));
   lp=lp|(0x20000000&((hooked.flags&LLKHF_ALTDOWN)<<24));
   lp=lp|(0x80000000&((hooked.flags&LLKHF_UP)<<24));
   if(flag) {}
   if(han)  {}
   if(hwnd) {}
   aa_InputSystemKeyEventProc(0,wParam,hooked.vkCode,lp,1);
   }
  }
 return CallNextHookEx(aa.input_system.hKeyHook,nCode,wParam,lParam);
 }




 __declspec(dllexport) K MouseEvent      (int nCode,WPARAM wParam,LPARAM lParam)
 {
 I delta;
 MSLLHOOKSTRUCT*hooked=(MSLLHOOKSTRUCT*)lParam;

 if(nCode==HC_ACTION)
  {
  if(wParam==WM_MOUSEWHEEL)
   {
   delta=HIWORD(hooked->mouseData);
   if(delta<0)    {    aa.input_system.wheel--;    }
   else
   if(delta>0)    {    aa.input_system.wheel++;    }
   }
  }
 return CallNextHookEx(aa.input_system.hMouseHook,nCode,wParam,lParam);
 }






 B aa_InputKeyLoggerStart              (V)
 {
 HINSTANCE hExe;

 if(aa.input_system.is_logger_started==YES) { return RET_INUSE; }
 aa.input_system.logger_reset_tik=aaMsRunning();
 hExe=GetModuleHandle(NULL);
 if(!hExe) hExe=LoadLibrary(NULL);
 if(!hExe)  { oof; return RET_FAILED;  }
 if(aa.input_system.hKeyHook)            {  return RET_INUSE; }
 if(aa.input_system.hMouseHook)          {  return RET_INUSE; }
 aa.input_system.hKeyHook=SetWindowsHookEx(WH_KEYBOARD_LL,(HOOKPROC)KeyEvent,hExe,0);
 if(aa.input_system.hKeyHook==NULL) { oow; }
 aa.input_system.hMouseHook=SetWindowsHookEx(WH_MOUSE_LL,(HOOKPROC)MouseEvent,hExe,0);
 if(aa.input_system.hMouseHook==NULL) { oow; }
 aa.input_system.is_logger_started=YES;
 return RET_YES;
 }






 B aa_InputKeyLoggerReset              (V)
 {
 HINSTANCE hExe;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aa.input_system.is_logger_started==NO) { return RET_NOTSTARTED; }
 if(aa.input_system.hKeyHook)            {  UnhookWindowsHookEx(aa.input_system.hKeyHook);   aa.input_system.hKeyHook=0;   }
 if(aa.input_system.hMouseHook)          {  UnhookWindowsHookEx(aa.input_system.hMouseHook); aa.input_system.hMouseHook=0; }
 hExe=GetModuleHandle(NULL);
 if(!hExe) hExe=LoadLibrary(NULL);
 if(!hExe) { oof; return RET_FAILED;  }
 aa.input_system.hKeyHook=SetWindowsHookEx(WH_KEYBOARD_LL,(HOOKPROC)KeyEvent,hExe,0);
 if(aa.input_system.hKeyHook==NULL)   { oow; }
 aa.input_system.hMouseHook=SetWindowsHookEx(WH_MOUSE_LL,(HOOKPROC)MouseEvent,hExe,0);
 if(aa.input_system.hMouseHook==NULL) { oow; }
 aa.input_system.logger_reset_tik=aaMsRunning();
 //appLogf("%s",__func__);
 return RET_YES;
 }




 B aa_InputSystemStart                 (V)
 {
 H val,v;
 B state[256];

 logg("aa_InputSystemStart()");
 val=0;
 aa.input_system.keyboard_delay=aa.input_system.keyboard_speed=256;
 if(SystemParametersInfo(SPI_GETKEYBOARDDELAY,0,&val,0)!=0) { aa.input_system.keyboard_delay=((val+1)*256); }
 if(SystemParametersInfo(SPI_GETKEYBOARDSPEED,0,&val,0)!=0) { aa.input_system.keyboard_speed=(256-(val*7)); }
 aa.input_system.keyboard_delay*=0.8;
 aa.input_system.keyboard_speed*=1.2;
 aa.input_system.keyboard_layout=GetKeyboardLayout(0);
 if(GetKeyboardState(state)==0) { oof; }
 for(v=0;v<256;v++)   { state[v]=aaBitClr(state[v],0);  }
 if(SetKeyboardState(state)==0) { oof; oow; Boop; }
 for(v=0;v<256;v++)  {  aa.input_system.keyboard_scan_code[v]=(H)MapVirtualKeyEx(v,0,aa.input_system.keyboard_layout);  }
 aa.input_system.wheel=0;
 if(aa.input_system.tray_hwnd==NULL)
  {
  if((aa.input_system.tray_hwnd=FindWindow("Shell_TrayWnd",NULL))==NULL) { oof; }
  }
 aa.input_system.vsx=GetSystemMetrics(78);
 aa.input_system.vsy=GetSystemMetrics(79);
 aa.input_system.tray_cycle=0;
 logg("");
 return RET_YES;
 }






 V aa_InputSystemStop                  (V)
 {
 aa_InputSystemHookedKeyEngineStop();
 }



 B aa_InputSystemHookedKeyEngineStart  (V)
 {
 I k;
 HANDLE h;

 if(aa.input_system.ihke_que.handle==0)
  {
  h=0;
  aa.input_system.mutex_handle=h;
  aa.input_system.ihke_que.handle=1;
  aa.input_system.ihke_que_head=0;
  aa.input_system.ihke_que_tail=0;
  aa_ie_events_waiting=aa.input_system.ihke_events_waiting=0;
  //aa_ie_events_waiting=aa.input_system.ihke_events_waiting;
  aa.input_system.ihke_sequence=1;
  aa.input_system.sequence=1;
  aa.input_system.ihke_events_waiting_threshold=0;
  aa_ie_events_waiting_threshold=aa.input_system.ihke_events_waiting_threshold;
  k=GetKeyState(VK_CAPITAL); if(aaBitGet(k,0)) { aa.input_system.is_caps=YES; }
  k=GetKeyState(VK_NUMLOCK); if(aaBitGet(k,0)) { aa.input_system.is_numl=YES; }
  k=GetKeyState(VK_SCROLL);  if(aaBitGet(k,0)) { aa.input_system.is_scrl=YES; }
  aa_InputKeyLoggerStart();
  }
 return RET_YES;
 }







 B aa_InputSystemHookedKeyEngineStop   (V)
 {
 if(aa.input_system.mutex_handle!=0)     {  CloseHandle(aa.input_system.mutex_handle); }
 if(aa.input_system.ihke_que.handle!=0)  {  aa.input_system.ihke_que.handle=0;  }
 if(aa.input_system.vkcode!=NULL)        {  aaMemoryRelease(aa.input_system.vkcode); }
/// if(aa.input_system.memod.magic)         {  aaMemoryModuleRelease(&aa.input_system.memod); }
 if(aa.input_system.is_logger_started)
  {
  aa.input_system.is_logger_started=NO;
  if(aa.input_system.hKeyHook)            {  UnhookWindowsHookEx(aa.input_system.hKeyHook);   aa.input_system.hKeyHook=0;   }
  if(aa.input_system.hMouseHook)          {  UnhookWindowsHookEx(aa.input_system.hMouseHook); aa.input_system.hMouseHook=0; }
  }
 return RET_YES;
 }








 B aa_InputSystemCountVkeys            (V)
 {
 Z z;
 H flag;

 aa.input_system.vkey_used_count=aa.input_system.vkey_down_count=0;
 aa.input_system.vkey_held_count=aa.input_system.vkey_up_count=0;
 flag=0;
 for(z=0;z<256;z++)
  {
  if(aa.input_system.vkey_state[z]!=0)  { aa.input_system.vkey_used_count++; }
  if(aa.input_system.vkey_state[z]==1)
   {
   if(flag==0) { aaMsRunning(); flag=1; }
   //aa.input_system.vkey_ms[z]=aa_msrunning;
   aa.input_system.vkey_down_count++;
   }
  if(aa.input_system.vkey_state[z]>=2)
   {
   aa.input_system.vkey_held_count++;
   }
  if(aa.input_system.vkey_state[z]==-1) { aa.input_system.vkey_up_count++; }
  }
 return RET_YES;
 }






 B aa_InputSystemVkeyStateSet          (Z vkey,B cmd,B ismore)
 {
 B txt[_2K];

 if(cmd=='d')
  {
  if(aa.input_system.vkey_state[vkey]==0)  {   aa.input_system.vkey_state[vkey]=1;   }
  else
  if(aa.input_system.vkey_state[vkey]>=1)
   {
   if(aa.input_system.vkey_state[vkey]<126) {  aa.input_system.vkey_state[vkey]++;    }
   }
  else
   {
   aaDebugfHwnds();
   aaStringNull(txt);
   aaStringAppendf(txt,"A.. ismore=%i vkey[%02x] state=%i\n",ismore,vkey,aa.input_system.vkey_state[vkey]);
   aa.input_system.vkey_state[vkey]=1;
   aaStringAppendf(txt,"*** down line=%i vkey=%02x state=%i waiting=%I64d\n",__LINE__,vkey,aa.input_system.vkey_state[vkey],aa.input_system.ihke_events_waiting);
   aaWinEventLog(2,0,123,8555,"%s %s %i\n%s",__FILE__,__func__,__LINE__,txt);
   aa_stats[25]++;
   }
  }
 else
 if(cmd=='u')
  {
  if(aa.input_system.vkey_state[vkey]>=1)  {   aa.input_system.vkey_state[vkey]=-1;   }
  else
  if(aa.input_system.vkey_state[vkey]==0)  {   return NO;   }
  else
   {
   aaDebugfHwnds();
   aaStringNull(txt);
   aaStringAppendf(txt,"C.. ismore=%i vkey[%02x] state=%i\n",ismore,vkey,aa.input_system.vkey_state[vkey]);
   aaStringAppendf(txt,"*** up line=%i state=%i vkey=%02x\n",__LINE__,aa.input_system.vkey_state[vkey],vkey);
   aaWinEventLog(2,0,123,8777,"%s %s %i\n%s",__FILE__,__func__,__LINE__,txt);
   aa_stats[26]++;
   }
  }
 else
  {
  oof;
  }
 return RET_YES;
 }










 B aa_InputSystemKeyEventProc          (HWND wnd,H msg,WPARAM wparm,LPARAM lparm,B extflag)
 {
 S _inputhookparms ihppstat;
 S _inputhookparms*ihpp=NULL;
 N virtCode=wparm;
 N scanCode=HIWORD(lparm)&0xff;
 //B old_is_caps,old_is_numl,old_is_scrl,old_is_shift,old_is_ctrl,old_is_alt,old_is_win;

 UNUSE(wnd);
 if(aa.input_system.mutex_handle!=0)
  {
  DWORD res;
  oof;
  if((res=WaitForSingleObject(aa.input_system.mutex_handle,INFINITE))==WAIT_FAILED) {  oow; oof; return RET_FAILED; }
  if(res==WAIT_TIMEOUT)   { oof; }
  if(res==WAIT_ABANDONED) { oof; }
  if(res!=WAIT_OBJECT_0)  { oof; oow; oof; }
  }
 ihpp=&ihppstat;
 ihpp->msg=msg;
 ihpp->wparam=wparm;
 ihpp->lparam=lparm;
 ihpp->isinjected=NO;
 aaMemoryFill(&ihpp->ihke,sizeof(_aa_inputhookedkeyevent),0);
 ihpp->ihke.is_ext=extflag;
 ihpp->ihke.is_injected=NO;
 ihpp->ihke.sequence=aa.input_system.ihke_sequence;
 ihpp->ihke.microsecs=aaMicrosecsRunning();
 ihpp->ihke.skey_code=scanCode;
 ihpp->ihke.vkey_code=virtCode;

 if(ihpp->msg==WM_SYSKEYDOWN||ihpp->msg==WM_SYSKEYUP) {  ihpp->ihke.is_sys=YES;  }

 if(ihpp->msg==WM_KEYDOWN||ihpp->msg==WM_SYSKEYDOWN)  {  ihpp->ihke.msg='d'; } else
 if(ihpp->msg==WM_KEYUP||ihpp->msg==WM_SYSKEYUP)      {  ihpp->ihke.msg='u'; } else  {  oof;  }


 if(ihpp->ihke.msg=='d')
  {
  if(aa.input_system.vkey_state[ihpp->ihke.vkey_code]<1)
   {
   }
  else
  if(aa.input_system.vkey_state[ihpp->ihke.vkey_code]>=2)
   {
   if(aa.input_system.ihke_events_waiting>aa.input_system.ihke_events_waiting_threshold)
    {
    return RET_YES;
    }
   }
  }


 if(GetKeyboardState(ihpp->keyboard_state)==0) { oof; }

 if(ihpp->ihke.msg=='u'|| ihpp->ihke.msg=='d')
  {
  /*
  old_is_caps=ihpp->ihke.is_caps;
  old_is_numl=ihpp->ihke.is_numl;
  old_is_scrl=ihpp->ihke.is_scrl;
  old_is_shift=ihpp->ihke.is_shift;
  old_is_ctrl=ihpp->ihke.is_ctrl;
  old_is_alt=ihpp->ihke.is_alt;
  old_is_win=ihpp->ihke.is_win;

  ihpp->ihke.is_caps=NO;
  ihpp->ihke.is_numl=NO;
  ihpp->ihke.is_scrl=NO;
  ihpp->ihke.is_shift=NO;
  ihpp->ihke.is_ctrl=NO;
  ihpp->ihke.is_alt=NO;
  ihpp->ihke.is_win=NO;

  if(ihpp->ihke.msg=='u')
   {
   ihpp->k=GetKeyState(VK_CAPITAL);  if(aaBitGet(ihpp->k,0))  ihpp->ihke.is_caps=YES;
   ihpp->k=GetKeyState(VK_NUMLOCK);  if(aaBitGet(ihpp->k,0))  ihpp->ihke.is_numl=YES;
   ihpp->k=GetKeyState(VK_SCROLL);   if(aaBitGet(ihpp->k,0))  ihpp->ihke.is_scrl=YES;
   ihpp->k=GetKeyState(VK_SHIFT);    if(aaBitGet(ihpp->k,15)) ihpp->ihke.is_shift=YES;
   ihpp->k=GetKeyState(VK_CONTROL);  if(aaBitGet(ihpp->k,15)) ihpp->ihke.is_ctrl=YES;
   ihpp->k=GetKeyState(VK_MENU);     if(aaBitGet(ihpp->k,15)) ihpp->ihke.is_alt=YES;
   ihpp->k=GetKeyState(VK_LWIN);     if(aaBitGet(ihpp->k,15)) ihpp->ihke.is_win=YES;
   }

  if(old_is_caps||ihpp->ihke.is_caps)   {  aaDebugf("is_caps=%i  %i  %c",ihpp->ihke.is_caps,old_is_caps,ihpp->ihke.msg);   }
  if(old_is_numl||ihpp->ihke.is_numl)   {  aaDebugf("is_numl=%i  %i  %c",ihpp->ihke.is_numl,old_is_numl,ihpp->ihke.msg);   }
  if(old_is_scrl||ihpp->ihke.is_scrl)   {  aaDebugf("is_scrl=%i  %i  %c",ihpp->ihke.is_scrl,old_is_scrl,ihpp->ihke.msg);   }
  if(old_is_shift||ihpp->ihke.is_shift) {  aaDebugf("is_shift=%i  %i  %c",ihpp->ihke.is_shift,old_is_shift,ihpp->ihke.msg);   }
  if(old_is_ctrl||ihpp->ihke.is_ctrl)   {  aaDebugf("is_ctrl=%i  %i  %c",ihpp->ihke.is_ctrl,old_is_ctrl,ihpp->ihke.msg);   }
  if(old_is_alt||ihpp->ihke.is_alt)     {  aaDebugf("is_alt=%i  %i  %c",ihpp->ihke.is_alt,old_is_alt,ihpp->ihke.msg);   }
  if(old_is_win||ihpp->ihke.is_win)     {  aaDebugf("is_win=%i  %i  %c",ihpp->ihke.is_win,old_is_win,ihpp->ihke.msg);   }
  */
  }


 if(ihpp->ihke.msg=='u'|| ihpp->ihke.msg=='d')
  {
  if(ihpp->ihke.msg=='d')
   {
   ihpp->k=GetKeyState(VK_CAPITAL);  if(aaBitGet(ihpp->k,0))  ihpp->ihke.is_caps=YES;
   ihpp->k=GetKeyState(VK_NUMLOCK);  if(aaBitGet(ihpp->k,0))  ihpp->ihke.is_numl=YES;
   ihpp->k=GetKeyState(VK_SCROLL);   if(aaBitGet(ihpp->k,0))  ihpp->ihke.is_scrl=YES;
   ihpp->k=GetKeyState(VK_SHIFT);    if(aaBitGet(ihpp->k,15)) ihpp->ihke.is_shift=YES;
   ihpp->k=GetKeyState(VK_CONTROL);  if(aaBitGet(ihpp->k,15)) ihpp->ihke.is_ctrl=YES;
   ihpp->k=GetKeyState(VK_MENU);     if(aaBitGet(ihpp->k,15)) ihpp->ihke.is_alt=YES;
   ihpp->k=GetKeyState(VK_LWIN);     if(aaBitGet(ihpp->k,15)) ihpp->ihke.is_win=YES;

//   ihpp->k=GetKeyState(VK_LBUTTON);  if(aaBitGet(ihpp->k,15)) ihpp->ihke.is_left=YES;
//   ihpp->k=GetKeyState(VK_MBUTTON);  if(aaBitGet(ihpp->k,15)) ihpp->ihke.is_mid=YES;
   //ihpp->k=GetKeyState(VK_RBUTTON);  if(aaBitGet(ihpp->k,15)) ihpp->ihke.is_right=YES;

   }
  else
   {
   ihpp->k=GetKeyState(VK_CAPITAL);  if(aaBitGet(ihpp->k,0))  ihpp->ihke.is_caps=NO;
   ihpp->k=GetKeyState(VK_NUMLOCK);  if(aaBitGet(ihpp->k,0))  ihpp->ihke.is_numl=NO;
   ihpp->k=GetKeyState(VK_SCROLL);   if(aaBitGet(ihpp->k,0))  ihpp->ihke.is_scrl=NO;
   ihpp->k=GetKeyState(VK_SHIFT);    if(aaBitGet(ihpp->k,15)) ihpp->ihke.is_shift=NO;
   ihpp->k=GetKeyState(VK_CONTROL);  if(aaBitGet(ihpp->k,15)) ihpp->ihke.is_ctrl=NO;
   ihpp->k=GetKeyState(VK_MENU);     if(aaBitGet(ihpp->k,15)) ihpp->ihke.is_alt=NO;
   ihpp->k=GetKeyState(VK_LWIN);     if(aaBitGet(ihpp->k,15)) ihpp->ihke.is_win=NO;

   //ihpp->k=GetKeyState(VK_LBUTTON);  if(aaBitGet(ihpp->k,15)) ihpp->ihke.is_left=NO;
   //ihpp->k=GetKeyState(VK_MBUTTON);  if(aaBitGet(ihpp->k,15)) ihpp->ihke.is_mid=NO;
   //ihpp->k=GetKeyState(VK_RBUTTON);  if(aaBitGet(ihpp->k,15)) ihpp->ihke.is_right=NO;

// k=GetKeyState(VK_LBUTTON); if(aaBitGet(k,15)) { aa.input_system.is_left=YES;  } else { aa.input_system.is_left=NO;  }
// k=GetKeyState(VK_MBUTTON); if(aaBitGet(k,15)) { aa.input_system.is_mid=YES;   } else { aa.input_system.is_mid=NO;   }
 //k=GetKeyState(VK_RBUTTON); if(aaBitGet(k,15)) { aa.input_system.is_right=YES; } else { aa.input_system.is_right=NO; }

   }

//  aaDebugf("is_left=%i    %c",0,ihpp->ihke.msg);



  }


 ihpp->xf=MapVirtualKeyEx(ihpp->ihke.vkey_code,2,aa.input_system.keyboard_layout);
 if(aaBitGet(ihpp->xf,31)) { oof; }
 ihpp->ihke.xf=(B)LOWORD(ihpp->xf);
 if(ihpp->ihke.xf==0) { ihpp->ihke.xf=ihpp->ihke.vkey_code; }

 if(ihpp->ihke.msg=='d'||ihpp->ihke.msg=='u')
  {
  if(ihpp->ihke.is_sys==YES)   {   }
  else
   {
   ihpp->r=ToAscii(ihpp->ihke.vkey_code,ihpp->ihke.skey_code,ihpp->keyboard_state,ihpp->inBuffer,0);
   if(ihpp->r==0)    {    }
   else
   if(ihpp->r==1)
    {
    ihpp->key=(C)ihpp->inBuffer[0];
    ihpp->ihke.akey_code=ihpp->key;
    }
   else              {  oof;  }
   }
  }
 else { oof;  }


 if(ihpp->ihke.msg!=0)
  {
  aa.input_system.ihke_sequence++;
  aaMemoryCopy(&aa.input_system.ihke_que_array[aa.input_system.ihke_que_head],sizeof(_aa_inputhookedkeyevent),&ihpp->ihke);
  aa.input_system.ihke_que_head++;
  aa.input_system.ihke_que_head%=aa_INPUT_IHKE_QUEUE_SIZE;
  aa.input_system.ihke_events_waiting++;
  //aaDebugf("aa.input_system.ihke_events_waiting on line #%i = %I64d",__LINE__,aa.input_system.ihke_events_waiting);
  aa_ie_events_waiting=aa.input_system.ihke_events_waiting;
  aa.input_system.ihke_events_total++;
  if((aa.input_system.ihke_events_waiting+10)>=aa_INPUT_IHKE_QUEUE_SIZE) oof;
  }

 if(ihpp!=&ihppstat)                  {  oof;  aaMemoryRelease(ihpp);  ihpp=NULL;  }
 if(aa.input_system.mutex_handle!=0)  {  oof;  if(!ReleaseMutex(aa.input_system.mutex_handle)) { oow; }  }
 return RET_YES;
 }









 B aa_InputSystemHookedKeyProcess      (_aa_inputhookedkeyevent*aaihke)
 {
 B ret;
 _aa_inputhookedkeyevent ihke;


 if(aaihke==NULL) { oof; }
 if(aa.input_system.ihke_events_waiting==0) { return RET_NOTREADY; }
 aaMemoryCopy(&ihke,sizeof(_aa_inputhookedkeyevent),&aa.input_system.ihke_que_array[aa.input_system.ihke_que_tail]);
 ret=RET_FAILED;
 if(ihke.msg=='d')   { ret=aa_InputSystemVkeyStateSet((Z)ihke.vkey_code,'d',NO);   } else
 if(ihke.msg=='u')   { ret=aa_InputSystemVkeyStateSet((Z)ihke.vkey_code,'u',NO);   }
 if(ret==RET_FAILED) { oops; }
 if(ret==RET_NO)
  {
  aa.input_system.ihke_que_tail++;
  aa.input_system.ihke_que_tail%=aa_INPUT_IHKE_QUEUE_SIZE;
  aa.input_system.ihke_events_waiting--;
  aa_ie_events_waiting=aa.input_system.ihke_events_waiting;
  return RET_NOTREADY;
  }
 aa_InputSystemCountVkeys();
 aa.input_system.is_caps=ihke.is_caps;
 aa.input_system.is_numl=ihke.is_numl;
 aa.input_system.is_scrl=ihke.is_scrl;
 aa.input_system.is_shift=ihke.is_shift;
 aa.input_system.is_ctrl=ihke.is_ctrl;
 aa.input_system.is_alt=ihke.is_alt;
 aa.input_system.is_win=ihke.is_win;
 aaMemoryCopy(&ihke,sizeof(_aa_inputhookedkeyevent),&aa.input_system.ihke_que_array[aa.input_system.ihke_que_tail]);
 aa.input_system.ihke_que_tail++;
 aa.input_system.ihke_que_tail%=aa_INPUT_IHKE_QUEUE_SIZE;
 aaMemoryCopy(aaihke,sizeof(_aa_inputhookedkeyevent),&ihke);
 aa.input_system.ihke_events_waiting--;
 aa_ie_events_waiting=aa.input_system.ihke_events_waiting;
 return RET_YES;
 }









 B aa_InputStateGet                    (_inputstate*inputstate,B dokeys,B domouse)
 {
 B ret;
 Z z;
 H sh;
 _aa_surfaceobject*surp;
 _aa_inputhookedkeyevent ihke;
 Q ms;
 I k;
 POINT pt;
 POINT xpt;
 _surfacespot*sspot;
 _cord rcd;
 H spid,smoff,go;
 HWND actvhwnd,fochwnd,forghwnd;
 HWND pointhwnd;
 B oll;//,olm,olr;

 if(aa.input_system.ihke_que.handle==0)  {  aa_InputSystemHookedKeyEngineStart();    }
 if(inputstate==NULL) { return RET_BADPARM; }
 inputstate->is_ok=NO;
 dokeys&=1; domouse&=1;
 ms=aaMicrosecsRunning();
 #if 1
 aaMemoryFill(inputstate,sizeof(_inputstate),0);
 #endif
 inputstate->is_ok=YES;
 aaMemoryFill(&ihke,sizeof(ihke),0);

 oll=aa.input_system.is_left;
// olm=aa.input_system.is_mid;
 //olr=aa.input_system.is_right;

 k=GetKeyState(VK_LBUTTON); if(aaBitGet(k,15)) { aa.input_system.is_left=YES;  } else { aa.input_system.is_left=NO;  }
 k=GetKeyState(VK_MBUTTON); if(aaBitGet(k,15)) { aa.input_system.is_mid=YES;   } else { aa.input_system.is_mid=NO;   }
 k=GetKeyState(VK_RBUTTON); if(aaBitGet(k,15)) { aa.input_system.is_right=YES; } else { aa.input_system.is_right=NO; }

 if(oll!=aa.input_system.is_left||aa.input_system.is_left)
  {
 // aaDebugf("left %i %i",aa.input_system.is_left,oll);
  }



 //--------------------------------------------------------
 inputstate->spot_cord.x=inputstate->spot_cord.y=0;
 inputstate->spot_index=-1;
 inputstate->spot_id=0;
 inputstate->spot_type=0;
 inputstate->spot_ptr=NULL;
 inputstate->microsecs=ms;
 inputstate->seq=aa.input_system.sequence;

 inputstate->key_seq=aa.input_system.ihke_sequence; // added may 2017

 aa.input_system.sequence++;
 aaHwndGroupGet(&actvhwnd,&fochwnd,&forghwnd);
 GetCursorPos(&pt);
 pointhwnd=WindowFromPoint(pt);
 if(pointhwnd==NULL) { }
 inputstate->cord.x=pt.x;
 inputstate->cord.y=pt.y;
 inputstate->over_hwnd=pointhwnd;
 inputstate->focus_hwnd=forghwnd;
  if(inputstate->focus_hwnd!=NULL)
   {
   if(aa_SurfaceSystemFindSurfaceByHwnd(&sh,(VP)&surp,inputstate->focus_hwnd)==YES)
    {
    //aaDebugf("found by hwnd %i = %i",inputstate->focus_hwnd,sh);
    surp->status.is_focus=YES;
    if(surp->status.is_focus!=YES)
     {
     go=0;
     while(1)
      {
      SetFocus(inputstate->focus_hwnd);
      aaYieldRaw();
      aaSurfaceStatus(sh,0);
      if(surp->status.is_focus) { break; }
      go++;
      aaSleep(0);
      }
     if(go!=0)      {      }
     }
    inputstate->is_focus_surface=YES;
    inputstate->focus_handle=sh;
    aaSurfaceVisualCordToCord(sh,&inputstate->cord,&inputstate->focus_cord);
    }
   else
    {
    WinPointCopy(&xpt,&pt);
    ScreenToClient(inputstate->focus_hwnd,&xpt);
    WinPointToCord(&xpt,&inputstate->focus_cord);
    }
   }

  if(inputstate->over_hwnd!=NULL)
   {
   if(aa_SurfaceSystemFindSurfaceByHwnd(&sh,(VP)&surp,inputstate->over_hwnd)==YES)
    {
    inputstate->is_over_surface=YES;
    inputstate->over_handle=sh;
    aaSurfaceVisualCordToCord(sh,&inputstate->cord,&inputstate->over_cord);
    }
   else
    {
    WinPointToCord(&pt,&inputstate->over_cord);
    }
   }


   if(inputstate->is_over_surface)
    {
    if(aa_SurfaceSystemFindSurfaceByHwnd(&sh,(VP)&surp,inputstate->over_hwnd)!=YES) { oof; }
    if(surp->status.spot_order_ok!=YES)
     {
     aa_SurfaceSortSpots((VP)&surp);
     if(surp->status.spot_order_ok!=YES)  { oof; }
     }
    if(surp->status.spot_count>0)
     {
     rcd.x=inputstate->over_cord.x-surp->status.spot_depth_rect.x;
     rcd.y=inputstate->over_cord.y-surp->status.spot_depth_rect.y;
     if(rcd.x>=0&&rcd.y>=0&&rcd.x<(N)surp->status.spot_depth_rect.w&&rcd.y<(N)surp->status.spot_depth_rect.h)
      {
      smoff=(rcd.y*surp->status.spot_depth_rect.w)+rcd.x;
      spid=surp->status.spot_id_map[smoff];
      if(spid!=0)
       {
       if((ret=aaSurfaceSpotFindById(surp->status.self_handle,spid,&sspot))!=YES)
        {
  //      aaDebugf("%s %i %s, spid=%i",__func__,__LINE__,ret_string[ret],spid);
        }
       else
        {
        if(aaRectIsValid(&sspot->rect)==YES)
         {
         if(aaCordIsWithinRect(&inputstate->over_cord,&sspot->rect)==RET_YES)
          {
          inputstate->spot_index=sspot->index;
          inputstate->spot_id=sspot->id;
          inputstate->spot_type=sspot->type;
          aaRectCopy(&inputstate->spot_rect,&sspot->rect);
          inputstate->spot_ptr=sspot;
          }
         }
        }
       }
      }
     }
    }

  if(inputstate->spot_index!=-1)
   {
   aaCordSet(&inputstate->spot_cord,inputstate->over_cord.x-sspot->rect.x,inputstate->over_cord.y-sspot->rect.y);
   }

 inputstate->wheel=aa.input_system.wheel;



 if(aa.input_system.ihke_events_waiting!=0)
  {
  ret=aa_InputSystemHookedKeyProcess(&ihke);
  if(ret!=YES&&ret!=RET_NOTREADY) { oops; }
  if(ret==RET_YES)
   {
   if(ihke.msg=='d'||ihke.msg=='u')
    {
    inputstate->key_microsecs=ihke.microsecs;
    inputstate->key_seq=ihke.sequence;
    inputstate->key_msg=ihke.msg;
    inputstate->key_sys=ihke.is_sys;
    inputstate->skey=ihke.skey_code;
    inputstate->vkey=ihke.vkey_code;
    inputstate->akey=ihke.akey_code;
    inputstate->key_inj=ihke.is_injected;
    inputstate->xkey=ihke.xf;

//    aaDebugf("oops");
    }
   else
    {
    }
   }
  }


 //if(ihke.msg=='d'||ihke.msg=='u')
  {
  inputstate->is_caps=aa.input_system.is_caps;
  inputstate->is_numl=aa.input_system.is_numl;
  inputstate->is_scrl=aa.input_system.is_scrl;
  inputstate->is_shift=aa.input_system.is_shift;
  inputstate->is_ctrl=aa.input_system.is_ctrl;
  inputstate->is_alt=aa.input_system.is_alt;
  inputstate->is_win=aa.input_system.is_win;
  }


  inputstate->is_left=aa.input_system.is_left;
  inputstate->is_mid=aa.input_system.is_mid;
  inputstate->is_right=aa.input_system.is_right;

 if(oll!=aa.input_system.is_left)
  {
// aaDebugf("iss=%i %c",inputstate->is_left,ihke.msg);
  }


 z=VK_LBUTTON;
 if(aa.input_system.is_left==YES)      {  aa_InputSystemVkeyStateSet(z,'d',NO);  } else
 if(aa.input_system.vkey_state[z]>=1)  {  aa_InputSystemVkeyStateSet(z,'u',NO);  }

 z=VK_MBUTTON;
 if(aa.input_system.is_mid==YES)       {   aa_InputSystemVkeyStateSet(z,'d',NO);  } else
 if(aa.input_system.vkey_state[z]>=1)  {   aa_InputSystemVkeyStateSet(z,'u',NO);  }

 z=VK_RBUTTON;
 if(aa.input_system.is_right==YES)     {   aa_InputSystemVkeyStateSet(z,'d',NO);  } else
 if(aa.input_system.vkey_state[z]>=1)  {   aa_InputSystemVkeyStateSet(z,'u',NO);  }

 aa_InputSystemCountVkeys();
 inputstate->vkey_used_count=aa.input_system.vkey_used_count;
 inputstate->vkey_down_count=aa.input_system.vkey_down_count;
 inputstate->vkey_held_count=aa.input_system.vkey_held_count;
 inputstate->vkey_up_count=aa.input_system.vkey_up_count;
 for(z=0;z<256;z++)  {  inputstate->vkey_state[z]=aa.input_system.vkey_state[z];  }

 for(z=0;z<256;z++)
  {
  if(aa.input_system.vkey_state[z]==-1)  {  aa.input_system.vkey_state[z]=0;   }
  }
 aa_InputSystemCountVkeys();
 aa_ie_events_waiting=aa.input_system.ihke_events_waiting;
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/



 B aa_AudioSystemStart                 (V)
 {
 logg("aa_AudioSystemStart()");
 aa_ObjectIdNew(&aa.audio_system.object_id);
 aa_ObjectDefine(aa.audio_system.object_id,sizeof(_aa_audioobject),10,4,aaAudioDestroy,"Audio");
 logg("");
 return RET_YES;
 }





 V aa_AudioSystemStop                  (V)
 {
 logg("aa_AudioSystemStop()");
 aa_ObjectUndefine(aa.audio_system.object_id);
 logg("");
 }



//V appLogf                             (H every,VP fmt,...);



 B aa_AudioSystemModeVerify            (_audiomode*audiomode,B fix)
 {
 B m,b;
 H r;

 #ifdef aa_VERSION
 //aa_ZIAG(__FUNCTION__);
 #endif
 if(audiomode==NULL)  {  return RET_BADPARM;  }

 fix&=1;

 m=b=0;
 r=0;
 if(audiomode->frequency== 8000) { m=0; } else
 if(audiomode->frequency==11025) { m=4; } else
 if(audiomode->frequency==16000) { m=8; } else
 if(audiomode->frequency==22050) { m=12; } else
 if(audiomode->frequency==24000) { m=16; } else
 if(audiomode->frequency==32000) { m=20; } else
 if(audiomode->frequency==44100) { m=24; } else
 if(audiomode->frequency==48000) { m=28; }
 else                            {  return RET_FAILED;  }

 m++;
 r=audiomode->frequency;
 if(audiomode->bits==8)                      { m+=(B)0; } else
 if(audiomode->bits==16||audiomode->bits==0) { m+=(B)2; r<<=1; }
 else                                        {   return RET_FAILED;  }

 if(audiomode->channels==1)  { m+=(B)0;  } else
 if(audiomode->channels==2)  { m+=(B)1; r<<=1; }
 else                        {  return RET_FAILED;  }

 if((m-1)%4==0) { b=1; } else
 if((m-1)%4==1) { b=2; } else
 if((m-1)%4==2) { b=2; } else { b=4; }

 if(fix)
  {
  audiomode->mode=m;
  audiomode->rate=r;
  audiomode->bps=b;
  }

 if(audiomode->mode!=m) {  return RET_FAILED;  }
 if(audiomode->rate!=r) {  return RET_FAILED;  }
 if(audiomode->bps!=b)  {  return RET_FAILED;  }

 return RET_YES;
 }




 K aa_AudioSystemOutProc               (HWAVEOUT h,UINT msg,H data,H p1,H p2)
 {
 B ret;
 WAVEHDR*p;
 _aa_audioobject*audp;
 ///B(*theproc)(H,_audiostatus*,H,H,VP);

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 UNUSE(h);
 UNUSE(p2);
 if((ret=aa_ObjectCheck(aa.audio_system.object_id,data,(VP)&audp,NULL))!=RET_YES) { oof; Boop; return ret; }
 switch(msg)
  {
  case WOM_OPEN:
  audp->is_openreceived=YES;
  break;

  case WOM_DONE:
  aaCast(p,WAVEHDR*,p1);
  #if 0
  if(audp->status.proc)
   {
   if(audp->is_in_proc) { aaNote(0,"ais_in_proc=%i",audp->is_in_proc); }
   audp->is_in_proc=1;
   theproc=audp->status.proc;
   theproc(audp->self_handle,&audp->status,2,p->dwBufferLength/audp->status.mode.bps,p->lpData);
   audp->is_in_proc=0;
   }
  #endif
  if(!(p->dwFlags&WHDR_DONE))
   {
   }
  if(!(p->dwFlags&WHDR_PREPARED)) {  }
  break;


  default:
  ///aaDebugf("msg=%i",msg);
  break;
  }
 return 0;
 }




 K aa_AudioSystemInProc                (HWAVEOUT h,UINT msg,H data,H p1,H p2)
 {
 B ret;
 WAVEHDR*p;
 _aa_audioobject*audp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 UNUSE(h);
 UNUSE(p2);
 if((ret=aa_ObjectCheck(aa.audio_system.object_id,data,(VP)&audp,NULL))!=RET_YES) { oof; Boop; return ret; }
 switch(msg)
  {
  case WIM_OPEN:
  audp->is_openreceived=YES;
  break;

  case WIM_DATA:
  aaCast(p,WAVEHDR*,p1);
  if(p->dwBytesRecorded==0) {  break; }
  if((ret=aaQueWrite(audp->que_handle,p->dwBytesRecorded,&p->lpData[0]))!=RET_YES)   {   aaNote(0,"oops=%i line=%i",ret,__LINE__);   }
  aaQueStatus(audp->que_handle,&audp->que_status);
  break;

  default:
  break;
  }
 return 0;
 }




 B aa_AudioSystemUpdateSamplePosition  (PP mem)
 {
 _aa_audioobject*audp;
 MMTIME mmt;
 D d1;
 //B(*theproc)(H,_audiostatus*,H,H,VP);

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 aaCast(audp,_aa_audioobject*,*mem);
 aaMemoryFill(&mmt,sizeof(mmt),0);
 mmt.wType=TIME_SAMPLES;
 if(audp->status.is_record==YES)
  {
  if(waveInGetPosition((HWAVEIN)audp->handle,&mmt,sizeof(MMTIME))!=MMSYSERR_NOERROR)   {   aaDebugf("waveingetpos err");   return RET_YES;   }
  }
 else
  {
  if(waveOutGetPosition((HWAVEOUT)audp->handle,&mmt,sizeof(MMTIME))!=MMSYSERR_NOERROR)   {   aaDebugf("waveoutgetpos err");   return RET_YES;   }
  }
 if(mmt.wType==TIME_SAMPLES)
  {
  d1=(D)(mmt.u.sample);
  d1/=(audp->status.div);
  audp->status.mcs=(Q)d1;
  }
 else  {  oof;  Boop;   }
 audp->status.sample_position=mmt.u.sample;
 ///if(audp->status.is_record==NO)  {  audp->status.samples_surplus=audp->status.samples_written-audp->status.sample_position;  }
 ///else                            {  audp->status.samples_surplus=audp->status.sample_position-audp->status.samples_written;  }

 return RET_YES;
 }



 B aa_AudioSystemProcessChannels       (PP mem,HP samples,VP data)
 {
 B ret;
 _aa_audioobject*audp;
 _audiochannel*chan;
 H ci,need,samps,si;
 H bytes,have;
 B pre_block[_16K];
 B mix_block[_32K];
 IP pb;
 IP mb;
 Z plsam,prsam;
 Z mlsam,mrsam;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaCast(audp,_aa_audioobject*,*mem);
 if(audp->status.channel_count==0) { return RET_FAILED; }

 if(samples) { *samples=0; }
 need=audp->status.block_size/1;

 have=need;
 audp->status.channel_ready_count=0;
 for(ci=0;ci<audp->status.channel_count;ci++)
  {
  chan=(_audiochannel*)&audp->status.channel[ci];
  if(chan->magic==0)       { oof; } //continue; }
  if(chan->que.handle==0)  { oof; } //continue; }
  aaQueStatus(chan->que.handle,&chan->que.status);
  chan->is_ready=NO;
  //if(chan->samples_qued!=0&&chan->samples_qued<have) { have=chan->samples_qued; }
  if(chan->samples_qued<need) { continue; }
  chan->is_ready=YES;
  audp->status.channel_ready_count++;
  }
 // if(audp->status.channel_ready_count!=audp->status.channel_active_count) { return RET_NOTREADY; }
 if(audp->status.channel_ready_count==0) { return RET_NOTREADY; }
 if(audp->status.channel_ready_count!=audp->status.channel_count) { return RET_NOTREADY; }
 if(audp->status.is_mix_locked==YES) { return RET_NOTREADY; }

 samps=have;
 bytes=samps*audp->status.mode.bps;
 aaMemoryFill(mix_block,samps*4,0);
 for(ci=0;ci<audp->status.channel_count;ci++)
  {
  chan=(_audiochannel*)&audp->status.channel[ci];
  if(chan->is_ready!=YES)  { continue; }
  if((ret=aaQueRead(chan->que.handle,bytes,pre_block))!=YES) { oops; }
  aaQueStatus(chan->que.handle,&chan->que.status);
  pb=(IP)pre_block;
  mb=(IP)mix_block;
  for(si=0;si<samps;si++)
   {
   plsam=(Z)pb[0];   prsam=(Z)pb[1];
   mlsam=(Z)mb[0];   mrsam=(Z)mb[1];
   mlsam+=plsam;
   mrsam+=prsam;
   if(mlsam<-32760) { mlsam=-32760; }
   if(mlsam>+32760) { mlsam=+32760; }
   if(mrsam<-32760) { mrsam=-32760; }
   if(mrsam>+32760) { mrsam=+32760; }

   mb[0]=(Z)mlsam;
   mb[1]=(Z)mrsam;
   pb+=2;
   mb+=2;
   }
  }
 if(samples) { *samples=samps; }
 if(data)    { aaMemoryCopy(data,samps*audp->status.mode.bps,mix_block); }

 need=audp->status.block_size/1;
 audp->status.channel_ready_count=0;
 for(ci=0;ci<audp->status.channel_count;ci++)
  {
  chan=(_audiochannel*)&audp->status.channel[ci];
  if(chan->magic==0)       { oof; } //continue; }
  if(chan->que.handle==0)  { oof; } //continue; }
  aaQueStatus(chan->que.handle,&chan->que.status);

   chan->samples_qued=chan->que.status.bytes/audp->status.mode.bps;
   chan->total_samples_written=chan->que.status.total_bytes_written/audp->status.mode.bps;
   chan->total_samples_read=chan->que.status.total_bytes_read/audp->status.mode.bps;
   chan->total_blocks_read=chan->total_samples_read/audp->status.block_size;
   chan->total_blocks_written=chan->total_samples_written/audp->status.block_size;
   chan->blocks_qued=chan->samples_qued/audp->status.block_size;

  if(chan->blocks_qued>=1)
   {
   chan->is_ready=YES;
   audp->status.channel_ready_count++;
   }
  }

 return RET_YES;
 }






 B aa_AudioSystemProcessQues           (PP mem)
 {
 B ret;
 MMRESULT mr;
 WAVEHDR*p;
 H q,el;
 _aa_audioobject*audp;
 S H last_ms_known=NO;
 S H last_ms;
 IP left;
 N val;
 B(*theproc)(H,_audiostatus*,H,H,VP);
 //B(*theproc)(H,_audiostatus*,H,H,VP);


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 aaCast(audp,_aa_audioobject*,*mem);

 audp->cycle++;

 if(last_ms_known==NO)
  {
  last_ms=aa.core_system.aamain_elapsed;
  last_ms_known=YES;
  }

 if(audp->status.mixer_device!=0)
  {
  aaTimerPrimitive(aa.core_system.aamain_elapsed,last_ms,&el);
  if(el>=50)
   {
   aa_AudioSystemGetVolume((VP)&audp,audp->ctrl_master_volume,&val);
   aaCast(left,IP,&val);
   audp->status.volume=(W)left[0];
   aa_AudioSystemGetMute((VP)&audp,audp->ctrl_master_mute,&val);
   audp->status.is_mute=(B)val;
   last_ms=aa.core_system.aamain_elapsed;
   }
  }
 /// RECORD
 if(audp->status.is_record==YES)
  {
  for(q=0;q<audp->status.max_blocks;q++)
   {
   aaCast(p,WAVEHDR*,&audp->wave_hdr[q]);
   if(p->dwFlags&WHDR_DONE&&!(p->dwFlags&WHDR_INQUEUE)&&p->dwFlags&WHDR_PREPARED)
    {
    mr=waveInAddBuffer(audp->handle,p,sizeof(WAVEHDR));
    if(mr!=MMSYSERR_NOERROR&&mr!=WAVERR_STILLPLAYING)     {    aaNote(0,"waveinaddbuffer error, amr=%i",mr);     }
    }
   }
  }
else
 if(audp->status.is_record==NO) /// PLAY
  {
  aaQueStatus(audp->que_handle,&audp->que_status);

  if(audp->que_status.bytes>=(audp->status.block_size*audp->status.mode.bps*1))
   {
   for(q=0;q<audp->status.max_blocks;q++)
    {
    aaCast(p,WAVEHDR*,&audp->wave_hdr[q]);
    if(p==NULL) oof;
    if(!(p->dwFlags&WHDR_INQUEUE)&&p->dwFlags&WHDR_PREPARED)
     {
     if(p->lpData==NULL) oof;
     if((ret=aaQueRead(audp->que_handle,(audp->status.block_size*audp->status.mode.bps),p->lpData))!=RET_YES) { oops; }
     aaQueStatus(audp->que_handle,&audp->que_status);
     audp->status.samples_qued-=audp->status.block_size;

     if(audp->status.proc)
      {
      if(audp->is_in_proc) { aaNote(0,"bis_in_proc=%i",audp->is_in_proc); }
      audp->is_in_proc=1;
      theproc=audp->status.proc;
      theproc(audp->self_handle,&audp->status,1,p->dwBufferLength/audp->status.mode.bps,p->lpData);
      audp->is_in_proc=0;
      }

     if((mr=waveOutWrite((HWAVEOUT)audp->handle,p,sizeof(WAVEHDR)))!=MMSYSERR_NOERROR)  {   aaNote(0,"Waveoutwriteerror %i audp=%i",mr,audp->handle);      }
     break;
     }
    }
   }
  else
   {
//   appLogf(0,"audio que=%i",audp->status.blocks_qued,

   }

  }
 return RET_YES;
 }




#if 1

 D aa_AudioSystemAtan2                 (D x,D y)
 {
 D signx;

 if(x>0.) signx=1.;
 else signx=-1.;
 if(x==0.) return 0.;
 if(y==0.) return signx*aaPi/2.;
 return atan2(x,y);
 }


#endif


 V aa_AudioSystemFFT                   (FP fftbuffer,N framesize,N sign)
 {
 F wr,wi,arg,*p1,*p2,temp;
 F tr,ti,ur,ui,*p1r,*p1i,*p2r,*p2i;
 register N i,bitm,j,le,le2,k;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 for(i=2;i<2*framesize-2;i+=2)
  {
  for(bitm=2,j=0;bitm<2*framesize;bitm<<=1)
   {
   if(i&bitm) j++;
   j<<=1;
   }
  if(i<j)
   {
   p1=fftbuffer+i;
   p2=fftbuffer+j;
   temp=*p1;
   *(p1++)=*p2;
   *(p2++)=temp;
   temp=*p1;
   *p1=*p2;
   *p2=temp;
   }
  }
 for(k=0,le=2;k<(long)(log(framesize)/log(2.)+.5); k++)
  {
  le<<=1;
  le2=le>>1;
  ur=1.0;
  ui=0.0;
  arg=aaPi/(le2>>1);
  wr=cos(arg);
  wi=sign*sin(arg);
  for(j=0;j<le2;j+=2)
   {
   p1r=fftbuffer+j;
   p1i=p1r+1;
   p2r=p1r+le2; p2i=p2r+1;
   for(i=j;i<2*framesize;i+=le)
    {
    tr=*p2r*ur-*p2i*ui;
    ti=*p2r*ui+*p2i*ur;
    *p2r=*p1r-tr;
    *p2i=*p1i-ti;
    *p1r+=tr;
    *p1i+=ti;
    p1r+=le;
    p1i+=le;
    p2r+=le;
    p2i+=le;
    }
   tr=ur*wr-ui*wi;
   ui=ur*wi+ui*wr;
   ur=tr;
   }
  }
 }



 B aa_AudioSystemGetVolume             (PP mem,H ctrlid,NP vol)
 {
 B dat[_4K];
 BP bp;
 MMRESULT mmr;
 MIXERCONTROLDETAILS *mxdets;
 _aa_audioobject*audp;
 HMIXER Mixer;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 aaCast(audp,_aa_audioobject*,*mem);
 aaCast(bp,BP,dat);
 Mixer=audp->status.mixer_device;
 mxdets=(MIXERCONTROLDETAILS *)bp;
 mxdets->cbStruct=sizeof(MIXERCONTROLDETAILS);
 mxdets->dwControlID=ctrlid;
 #if defined(_MSC_VER)||(__GNUC__)
 mxdets->cMultipleItems=0;
 #else
 #if __BORLANDC__ >= 0x0551
 mxdets->cMultipleItems=0;
 #else
 mxdets->u.cMultipleItems=0;
 #endif
 #endif
 mxdets->cChannels=1;
 mxdets->cbDetails=sizeof(MIXERCONTROLDETAILS_UNSIGNED)*mxdets->cChannels;
 mxdets->paDetails=vol;
 mmr=mixerGetControlDetails((HMIXEROBJ)Mixer,mxdets,MIXER_GETCONTROLDETAILSF_VALUE|MIXER_OBJECTF_MIXER);
 if(mmr!=MMSYSERR_NOERROR) { return RET_FAILED; }
 return RET_YES;
 }





 B aa_AudioSystemSetVolume             (PP mem,H ctrlid,NP vol)
 {
 B dat[_4K];
 BP bp;
 MMRESULT mmr;
 MIXERCONTROLDETAILS *mxdets;
 _aa_audioobject*audp;
 HMIXER Mixer;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 aaCast(audp,_aa_audioobject*,*mem);
 aaCast(bp,BP,dat);
 Mixer=audp->status.mixer_device;
 mxdets=(LPMIXERCONTROLDETAILS)bp;
 mxdets->cbStruct=sizeof(MIXERCONTROLDETAILS);
 mxdets->dwControlID=ctrlid;
 #if defined(_MSC_VER)||(__GNUC__)
 mxdets->cMultipleItems=0;
 #else
 #if __BORLANDC__ >= 0x0551
 mxdets->cMultipleItems=0;
 #else
 mxdets->u.cMultipleItems=0;
 #endif
 #endif
 mxdets->cChannels=1;
 mxdets->cbDetails=sizeof(MIXERCONTROLDETAILS_UNSIGNED)*mxdets->cChannels;
 mxdets->paDetails=vol;
 mmr=mixerSetControlDetails((HMIXEROBJ)Mixer,mxdets,MIXER_SETCONTROLDETAILSF_VALUE|MIXER_OBJECTF_MIXER);
 if(mmr!=MMSYSERR_NOERROR) { return RET_FAILED; }
 return RET_YES;
 }




 B aa_AudioSystemGetMute               (PP mem,H ctrlid,NP mute)
 {
 B dat[_4K];
 BP bp;
 MMRESULT mmr;
 MIXERCONTROLDETAILS *mxdets;
 _aa_audioobject*audp;
 HMIXER Mixer;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 aaCast(audp,_aa_audioobject*,*mem);
 aaCast(bp,BP,dat);
 Mixer=audp->status.mixer_device;
 mxdets=(LPMIXERCONTROLDETAILS)bp;
 mxdets->cbStruct=sizeof(MIXERCONTROLDETAILS);
 mxdets->dwControlID=ctrlid;
 #if defined(_MSC_VER)||(__GNUC__)
 mxdets->cMultipleItems=0;
 #else
 #if __BORLANDC__ >= 0x0551
 mxdets->cMultipleItems=0;
 #else
 mxdets->u.cMultipleItems=0;
 #endif
 #endif
 mxdets->cChannels=1;
 mxdets->cbDetails=sizeof(MIXERCONTROLDETAILS_BOOLEAN)*mxdets->cChannels;
 mxdets->paDetails=mute;
 mmr=mixerGetControlDetails((HMIXEROBJ)Mixer,mxdets,MIXER_GETCONTROLDETAILSF_VALUE|MIXER_OBJECTF_MIXER);
 if(mmr!=MMSYSERR_NOERROR) { return RET_FAILED; }
 return RET_YES;
 }




 B aa_AudioSystemSetMute               (PP mem,H ctrlid,NP mute)
 {
 B dat[_4K];
 BP bp;
 MMRESULT mmr;
 MIXERCONTROLDETAILS *mxdets;
 _aa_audioobject*audp;
 HMIXER Mixer;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 aaCast(audp,_aa_audioobject*,*mem);
 aaCast(bp,BP,dat);
 Mixer=audp->status.mixer_device;
 mxdets=(LPMIXERCONTROLDETAILS)bp;
 mxdets->cbStruct=sizeof(MIXERCONTROLDETAILS);
 mxdets->dwControlID=ctrlid;
 #if defined(_MSC_VER)||(__GNUC__)
 mxdets->cMultipleItems=0;
 #else
 #if __BORLANDC__ >= 0x0551
 mxdets->cMultipleItems=0;
 #else
 mxdets->u.cMultipleItems=0;
 #endif
 #endif
 mxdets->cChannels=1;
 mxdets->cbDetails=sizeof(MIXERCONTROLDETAILS_BOOLEAN);
 mxdets->paDetails=mute;
 mmr=mixerSetControlDetails((HMIXEROBJ)Mixer,mxdets,MIXER_SETCONTROLDETAILSF_VALUE|MIXER_OBJECTF_MIXER);
 if(mmr!=MMSYSERR_NOERROR) { return RET_FAILED; }
 return RET_YES;
 }




 B aa_AudioSystemGetLineControls       (PP mem,MIXERLINE*mxline,H source,H dest,HP volctrl,HP mutectrl)
 {
 MMRESULT mmr;
 UINT ct;
 MIXERLINECONTROLS mxctls;
 B dat[_4K];
 BP bp;
 _aa_audioobject*audp;
 HMIXER Mixer;

 if(mem==NULL) { return RET_BADPARM; }
 aaCast(audp,_aa_audioobject*,*mem);
 aaCast(bp,BP,dat);
 Mixer=audp->status.mixer_device;
 aaMemoryFill(mxline,sizeof(MIXERLINE),0);
 mxline->cbStruct=sizeof(MIXERLINE);
 mxline->dwDestination=dest;
 mxline->dwSource=source;
 if((N)source==-1)  {  mxline->dwSource=0;  mmr=mixerGetLineInfo((HMIXEROBJ)Mixer,mxline,MIXER_OBJECTF_MIXER|MIXER_GETLINEINFOF_DESTINATION);  }
 else               {  mmr=mixerGetLineInfo((HMIXEROBJ)Mixer,mxline,MIXER_OBJECTF_MIXER|MIXER_GETLINEINFOF_SOURCE);  }
 if(mmr!=MMSYSERR_NOERROR) {}
 mxctls.cbStruct=sizeof(MIXERLINECONTROLS);
 mxctls.dwLineID=mxline->dwLineID;
 mxctls.cControls=mxline->cControls;
 mxctls.cbmxctrl=sizeof(MIXERCONTROL);
 mxctls.pamxctrl=(LPMIXERCONTROL)bp;
 mmr=mixerGetLineControls((HMIXEROBJ)Mixer,&mxctls,MIXER_OBJECTF_MIXER|MIXER_GETLINECONTROLSF_ALL);
 if(mmr==MMSYSERR_NOERROR)
  {
  for(ct=0;ct<mxctls.cControls;ct++)
   {
   if(mxctls.pamxctrl[ct].dwControlType==MIXERCONTROL_CONTROLTYPE_VOLUME)    {    *volctrl=mxctls.pamxctrl[ct].dwControlID;    }
   else
   if(mxctls.pamxctrl[ct].dwControlType==MIXERCONTROL_CONTROLTYPE_MUTE)      {    *mutectrl=mxctls.pamxctrl[ct].dwControlID;    }
   }
  }
 mxctls.pamxctrl=NULL;
 if(mmr!=MMSYSERR_NOERROR) { return RET_FAILED; }
 return RET_YES;
 }




 B aa_AudioStatus                      (PP ptr,B dochannels)
 {
 B ret;
 H samples,bytes;
 B block[_16K];
 _aa_audioobject*audp;

 aaCast(audp,_aa_audioobject*,*ptr);
 if(dochannels)
  {
  samples=0;
  if(aa_AudioSystemProcessChannels((VP)&audp,&samples,block)==YES)
   {
   bytes=samples*audp->status.mode.bps;
   if((ret=aaQueWrite(audp->que_handle,bytes,block))!=RET_YES) { oops; return ret; }
   audp->status.samples_written+=samples;
   aaQueStatus(audp->que_handle,&audp->que_status);
   }
  }
 aa_AudioSystemProcessQues((VP)&audp);
 if((ret=aa_AudioSystemUpdateSamplePosition((VP)&audp))!=RET_YES) oops;
 aaQueStatus(audp->que_handle,&audp->que_status);
 audp->status.samples_qued=audp->que_status.bytes/audp->status.mode.bps;


   audp->status.blocks_qued=audp->status.samples_qued/audp->status.block_size;
   audp->status.blocks_written=audp->que_status.total_bytes_written;
   audp->status.blocks_written/=audp->status.mode.bps;
   audp->status.blocks_written/=audp->status.block_size;
   audp->status.blocks_read=audp->que_status.total_bytes_read;
   audp->status.blocks_read/=audp->status.mode.bps;
   audp->status.blocks_read/=audp->status.block_size;
   ///audp->status.blocks_surplus=audp->status.samples_surplus/audp->status.blocksize;
   audp->status.block_position=audp->status.sample_position/audp->status.block_size;

 return RET_YES;
 }








/*-----------------------------------------------------------------------*/



 B aa_VidCapSystemStart                (V)
 {
 logg("aa_VidCapSystemStart()");
 aa_ObjectIdNew(&aa.vidcap_system.object_id);
 aa_ObjectDefine(aa.vidcap_system.object_id,sizeof(_aa_vidcapobject),10,2,aaVidCapDestroy,"VidCap");
 logg("");

 if(ICDecompressEx!=ICDecompressEx) {}
 if(ICDecompressExBegin!=ICDecompressExBegin) {}
 if(ICDecompressExQuery!=ICDecompressExQuery) {}
 if(ICSetStatusProc!=ICSetStatusProc) {}
 #ifndef __GNUC__
 if(dwICValue!=dwICValue) {}
 #endif
 if(ICDrawSuggestFormat!=ICDrawSuggestFormat) {}
 return RET_YES;
 }




 V aa_VidCapSystemStop                 (V)
 {
 logg("aa_VidCapSystemStop()");
 aa_ObjectUndefine(aa.vidcap_system.object_id);
 logg("");
 }




 H aa_VidCapThread                     (VP parm)
 {
 B ret;
 MSG msg;
 _aa_vidcapobject*vdcp;
 BOOL bl;
 aa_CAPDRIVERCAPS caps;
 _threadstatus thread_status;
 H thread_status_cycle;
 C txt[_1K];
 HP hp;
 _threadunit tu;
 H handle;

 #if aa_USE_GLOBAL_MUTEX == 1
 EnterCriticalSection(&global_mutex);
 #endif
 hp=(HP)parm;
 tu.handle=(H)&hp[0];
 if((ret=aaThreadStatus(tu.handle,&tu.status))!=RET_YES) { oops; }
 handle=tu.status.data;
 if((ret=aa_ObjectCheck(aa.vidcap_system.object_id,handle,(VP)&vdcp,NULL))!=YES) { oops; }
 aaStringCopyf(txt,"CapWin%i",vdcp->device_id);
 if((vdcp->hwnd=capCreateCaptureWindow(txt,WS_POPUP|WS_DISABLED,0,0,1,1,0,0))==NULL) { oof; oow; Boop; Boop; Boop;  }
 aa_VidCapSetCallbacks((VP)&vdcp,YES);
 if(capDriverConnect(vdcp->hwnd,vdcp->device_id)==FALSE)
  {
  vdcp->is_connect_failed=YES;
  aa_VidCapSetCallbacks((VP)&vdcp,NO);
  }
 else
  {
  if(capDriverGetCaps(vdcp->hwnd,&caps,sizeof(caps))==FALSE) { oof; oow; }
  if(caps.fHasDlgVideoSource)  vdcp->status.has_sourcebox=YES;
  if(caps.fHasDlgVideoFormat)  vdcp->has_format=YES;
  if(caps.fHasDlgVideoDisplay) vdcp->has_display=YES;
  }
 if(vdcp->is_connect_failed)
  {
  vdcp->status.is_connected=NO;
  if(DestroyWindow(vdcp->hwnd)==0) { oof; oow; Boop; }
 vdcp->hwnd=NULL;
 #if aa_USE_GLOBAL_MUTEX == 1
 LeaveCriticalSection(&global_mutex);
 #endif
 ExitThread(RET_YES);
 return(RET_YES);
 }
 if(aa_EventSignal(&vdcp->connect_event)!=YES) { oof; Boop; }
 thread_status_cycle=0;
 while(1)
  {
  #if USE_VIDCAP_CRITICAL_SECTION == 1
  aaThreadLock(thrp->self_handle,YES);
  #endif
  if(PeekMessage(&msg,0,0,0,PM_NOREMOVE))
   {
   bl=GetMessage(&msg,0,0,0);
   if(bl==0) {   break; }
   else
   if(bl==-1) { oof; }
   else
   if(bl!=0)
    {
    TranslateMessage(&msg);
    DispatchMessage(&msg);
    switch(msg.message)
     {
     case WM_QUIT:
     break;

     case WM_USER_VIDCAP_SOURCE:
     vdcp->is_sourcebox_message_received=YES;
     if(capDlgVideoSource(vdcp->hwnd)==FALSE)
      {
      }
     vdcp->is_sourcebox_closed=YES;
     break;

     default:
     break;
     }
    }
   }
  if((thread_status_cycle%aa_VIDCAP_THREAD_STATUS_CYCLE)==0)
   {
   if((ret=aaThreadStatus(vdcp->thread_handle,&thread_status))!=YES)
    {
    oops;
    Boop;
    }
   #if USE_VIDCAP_CRITICAL_SECTION == 1
   aaThreadUnLock(thrp->self_handle);
   #endif
   if(thread_status.is_exiting==YES)   { oof;   break;   }
   }
  thread_status_cycle++;
  aaSleep(aa_VIDCAP_THREAD_SLEEP);
  }
 aa_VidCapSetCallbacks((VP)&vdcp,NO);
 if(vdcp->is_connect_failed!=YES)
  {
  if(capDriverDisconnect(vdcp->hwnd)==FALSE)
   {
   }
  }
 vdcp->status.is_connected=NO;
 if(DestroyWindow(vdcp->hwnd)==0) { oof; oow; Boop; }
 vdcp->hwnd=NULL;
 #if aa_USE_GLOBAL_MUTEX == 1
 LeaveCriticalSection(&global_mutex);
 #endif
 ExitThread(RET_YES);
 }





 B aa_VidCapSetCallbacks               (PP mem,B state)
 {
 _aa_vidcapobject*vdcp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL)  {  return RET_BADPARM;  }
 aaCast(vdcp,_aa_vidcapobject*,*mem);
 if(vdcp==NULL) {  return RET_BADPARM;  }

 if(state==YES)
  {
  if(capSetCallbackOnError(vdcp->hwnd,aa_VidCapErrorProc)==FALSE) { oof; oow; Boop; }
  if(capSetCallbackOnCapControl(vdcp->hwnd,aa_VidCapControlProc)==FALSE) { oof; oow; Boop; }
  if(capSetCallbackOnStatus(vdcp->hwnd,aa_VidCapStatusProc)==FALSE) { oof;  oow; Boop;  }
  if(capSetCallbackOnVideoStream(vdcp->hwnd,aa_VidCapVideoProc)==FALSE) { oof; oow; Boop; }
  if(capSetCallbackOnFrame(vdcp->hwnd,aa_VidCapPreviewProc)==FALSE) { oof; oow; Boop; }
  logg("vidcap callbacks set");
  }
 else
  {
  capSetCallbackOnError(vdcp->hwnd,NULL);
  capSetCallbackOnCapControl(vdcp->hwnd,NULL);
  capSetCallbackOnStatus(vdcp->hwnd,NULL);
  capSetCallbackOnVideoStream(vdcp->hwnd,NULL);
  capSetCallbackOnFrame(vdcp->hwnd,NULL);
  }
 return RET_YES;
 }




 B aa_VidCapFindByCaptureHwnd          (HP handle,PP mem,HWND wnd)
 {
 BP bp;
 _aa_objectinstanceheader*oih;
 _aa_vidcapobject*vdcp;
 H base,h,instance_stride;
 B id;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 id=aa.vidcap_system.object_id;
 if(aa.object_system.object[id].instance_limit==0) { return RET_FAILED; }
 instance_stride=aa.object_system.object[id].instance_bytes+sizeof(_aa_objectinstanceheader);
 base=(H)id*aa_OBJ_MAX_PER_ID;
 base+=aa_OBJ_BASE_HANDLE;
 bp=aa.object_system.object[id].instance_mem;
 for(h=0;h<aa.object_system.object[id].instance_slots;h++)
  {
  aaCast(oih,_aa_objectinstanceheader*,bp);
  if(oih->in_use==YES)
   {
   bp+=sizeof(_aa_objectinstanceheader);
   aaCast(vdcp,_aa_vidcapobject*,bp);
   if(vdcp->hwnd==wnd)
    {
    if(handle) { *handle=base+h; }
    if(mem)    { *mem=bp; }
    return RET_YES;
    }
   bp-=sizeof(_aa_objectinstanceheader);
   }
  bp+=instance_stride;
  }
 return RET_NOTFOUND;
 }




 K aa_VidCapErrorProc                  (HWND wnd,N errorid,LPSTR errortxt)
 {
 _aa_vidcapobject*vdcp;
 H vidcap_handle;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 logg("aa_VidCapErrorProc **");
 UNUSE(errortxt);
 if(aa_VidCapFindByCaptureHwnd(&vidcap_handle,(VP)&vdcp,wnd)!=RET_YES)
  {
  oof;
  Boop;
  return FALSE;
  }
 if(errorid==0)
  {
  vdcp->error_code=0;
  return TRUE;
  }
 vdcp->error_count++;
 vdcp->error_code=errorid;
 return TRUE;
 }




 K aa_VidCapControlProc                (HWND wnd,N state)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 UNUSE(wnd);
 switch(state)
  {
  default:
  break;

  case aa_CONTROLCALLBACK_PREROLL:
  break;
  case aa_CONTROLCALLBACK_CAPTURING:
  break;
  }
 return TRUE;
 }



 K aa_VidCapStatusProc                 (HWND wnd,N id,LPCSTR str)
 {
 _aa_vidcapobject*vdcp;
 H vidcap_handle;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 UNUSE(str);
 if(aa_VidCapFindByCaptureHwnd(&vidcap_handle,(VP)&vdcp,wnd)!=RET_YES)
  {
  oof;
  Boop;
  return FALSE;
  }
 switch(id)
  {
  case aa_IDS_CAP_BEGIN:
  break;
  case aa_IDS_CAP_END:
  vdcp->is_abort_complete=YES;
  break;
  default:
  break;
  }
 return TRUE;
 }





 K aa_VidCapPreviewProc                (HWND wnd,aa_VIDEOHDR* lpvhdr)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aa_VidCapProcessFrame(wnd,lpvhdr)==RET_NO)
  {
  return FALSE;
  }
 return TRUE;
 }





 K aa_VidCapVideoProc                  (HWND wnd,aa_VIDEOHDR* lpvhdr)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aa_VidCapProcessFrame(wnd,lpvhdr)==RET_NO)
  {
  return FALSE;
  }
 return TRUE;
 }





 B aa_VidCapProcessFrame               (HWND wnd,aa_VIDEOHDR* lpvhdr)
 {
 B ret;
 _aa_vidcapobject*vdcp;
 H vidcap_handle;
 H dwSize;
 BITMAPINFO bmi;
 B type;
 BP bp;
 H s_offset;
 H d_offset;
 _rgba*p4;
 _aa_pen24*p3;
 _aa_pen16*p2;
 N x,y;
 BP yl_ptr;
 BP yr_ptr;
 BP yb_ptr;
 HP dhp;
 N rr,gg,bb,YY,UU,VV;
 H wshift;
 H WID,HIT;
 N XXX,YYY;
 //H divs,mods;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aa_VidCapFindByCaptureHwnd(&vidcap_handle,(VP)&vdcp,wnd)!=RET_YES)
  {
  oof;
  Boop;
  return RET_NO;
  }
 if(vdcp->status.is_connected!=YES)  {  return RET_NO;  }
 if(vdcp->status.is_ready!=YES)  {  return RET_NO;  }
 if(vdcp->is_frame_waiting==YES)
  {
  vdcp->status.frames_dropped++;
  return RET_NO;
  }
 if(vdcp->status.frame_number==0)
  {
  vdcp->status.ms_start=aaMsRunning();
  }
 vdcp->status.frame_number++;
 vdcp->status.fps=(D)aaMsRunning()-(D)vdcp->status.ms_start;
 vdcp->status.fps=vdcp->status.fps/1000.0;
 vdcp->status.fps=(D)vdcp->status.frame_number/vdcp->status.fps;
 dwSize=capGetVideoFormatSize(wnd);
 if(dwSize==0||dwSize>_1K)
  {
  vdcp->frames_bad++;
  return RET_NO;
  }
 if(capGetVideoFormat(wnd,&bmi,dwSize)==FALSE)
  {
  vdcp->frames_bad++;
  return RET_NO;
  }
 if(vdcp->status.size.w!=(H)bmi.bmiHeader.biWidth||vdcp->status.size.h!=(H)bmi.bmiHeader.biHeight)
  {
  vdcp->frames_bad++;
  return RET_NO;
  }
 switch (bmi.bmiHeader.biCompression)
  {
  case BI_RGB:       type=1; break; // RGB
  case BI_RLE8:      type=0; break; // RLE8
  case BI_BITFIELDS: type=0; break; // BITFIELDS
  case VAL_I420:       type=4; break; // I420
  case VAL_IYUV:       type=4; break; // I420
  #if aa_VIDCAP_ALLOW_YUY2==YES
  case VAL_YUY2:       type=5; break; // YUY2
  #endif

  case VAL_YUYV:       type=0; break;
  case VAL_V422:       type=0; break;
  case VAL_UYVY:       type=0; break;
  case VAL_YV12:       type=0; break;
  case 0x20424944:   type=0; break; // uncompressed, full frames
  case 0x64697663:   type=0; break; // cinepak by supermac
  case 0x32335649:   type=0; break; // Intel indeo video r3.2
  case 0x6376736d:   type=0; break; // ms video 1
  case 0x656c726c:   type=0; break; // Rle
  default:           type=0; break;
  }
 if(vdcp->frame_buf_bytes<(vdcp->status.size.w*vdcp->status.size.h*4))
  {
  if(vdcp->status.surface_handle!=0)
   {
   if((ret=aaSurfaceDestroy(vdcp->status.surface_handle))!=RET_YES) { oops; }
   vdcp->status.surface_handle=0;
   aaMemoryFill(&vdcp->status.surface_status,sizeof(_surfacestatus),0);
   }
  bp=vdcp->frame_buf;
  dwSize=vdcp->status.size.w*(vdcp->status.size.h+2)*4;
  if((ret=aa_MemoryReAllocate((VP)&bp,dwSize))!=RET_YES) { oops; }
  vdcp->frame_buf=bp;
  vdcp->frame_buf_bytes=dwSize;
  }
 if(vdcp->status.surface_handle==0)
  {
  if((ret=aaSurfaceMake(&vdcp->status.surface_handle,&vdcp->status.size,vdcp->frame_buf))!=RET_YES) oops;
  aaSurfaceFlipSet(vdcp->status.surface_handle,0,1);
  aaSurfaceStatus(vdcp->status.surface_handle,&vdcp->status.surface_status);
  }
 aaSurfaceStatus(vdcp->status.surface_handle,&vdcp->status.surface_status);
 if(vdcp->status.surface_status.size.w!=vdcp->status.size.w||vdcp->status.surface_status.size.h!=vdcp->status.size.h)
  {
  if((ret=aaSurfaceReMake(vdcp->status.surface_handle,&vdcp->status.size,vdcp->frame_buf))!=RET_YES) oops;
  aaSurfaceStatus(vdcp->status.surface_handle,&vdcp->status.surface_status);
  }
  XXX=0;
  YYY=0;
  WID=vdcp->status.size.w;
  HIT=vdcp->status.size.h;
 switch(type)
  {
  case 1:
  if(vdcp->status.bits==15||vdcp->status.bits==16)
   {
   bp=lpvhdr->lpData;
   aaCast(p2,_aa_pen16*,bp);
   for(y=0;y<(N)HIT;y++)
    {
    s_offset=((y+YYY)*vdcp->status.size.w)+XXX;
    d_offset=(y*WID);
    for(x=0;x<(N)WID;x++)
     {
     vdcp->status.surface_status.mem[d_offset].r=(B)(p2[s_offset].r<<3);
     vdcp->status.surface_status.mem[d_offset].g=(B)(p2[s_offset].g<<3);
     vdcp->status.surface_status.mem[d_offset].b=(B)(p2[s_offset].b<<3);
     s_offset++;
     d_offset++;
     }
    }
   }
  else
  if(vdcp->status.bits==24)
   {
   bp=lpvhdr->lpData;
   aaCast(p3,_aa_pen24*,bp);
  // divs=WID/16;   mods=WID%16;
   for(y=0;y<(N)HIT;y++)
    {
    s_offset=((y+YYY)*vdcp->status.size.w)+XXX;
    d_offset=(y*WID);
    for(x=0;x<(N)WID;x++)
     {
     aaCast(p4,_rgba*,&p3[s_offset]);
     vdcp->status.surface_status.mem[d_offset]=*p4;
     vdcp->status.surface_status.mem[d_offset].a=255;
     s_offset++;
     d_offset++;
     }
    }
   }
  else
  if(vdcp->status.bits==32)
   {
//   oof;
   bp=lpvhdr->lpData;
   aaCast(p4,_rgba*,bp);
   for(y=0;y<(N)HIT;y++)
    {
    s_offset=((y+YYY)*vdcp->status.size.w)+XXX;
    d_offset=(y*WID);
    for(x=0;x<(N)WID;x++)
     {
     vdcp->status.surface_status.mem[d_offset]=p4[s_offset];
     //if(vdcp->status.surface_status.mem[d_offset].a!=255) aaDebugf("%i,%i=%i",x,y,vdcp->status.surface_status.mem[d_offset].a);
//     vdcp->status.surface_status.mem[d_offset].a=10;
     s_offset++;
     d_offset++;
     }
    }
   }
  vdcp->is_frame_waiting=YES;
  vdcp->status.is_frameready=YES;
  return RET_YES;

  case 4:
  bp=lpvhdr->lpData;
  aaCast(yl_ptr,BP,bp);
  aaCast(yr_ptr,BP,&yl_ptr[(vdcp->status.size.w*vdcp->status.size.h)]);
  aaCast(yb_ptr,BP,&yr_ptr[(vdcp->status.size.w>>1)*(vdcp->status.size.h>>1)]);
  yl_ptr+=((YYY*(vdcp->status.size.w))+(XXX));
  yr_ptr+=(((YYY>>1)*(vdcp->status.size.w>>1))+(XXX>>1));
  yb_ptr+=(((YYY>>1)*(vdcp->status.size.w>>1))+(XXX>>1));
 #if 1
  wshift=vdcp->status.size.w>>1;
  d_offset=(HIT-1)*WID;
   for(y=0;y<(N)HIT;y++)
    {
    aaCast(dhp,HP,&vdcp->status.surface_status.mem[d_offset]);
    for(x=0;x<(N)WID;x+=2)
     {
     UU=(yr_ptr[(x>>1)])-128;
     VV=(yb_ptr[(x>>1)])-128;
     YY=(yl_ptr[x+0]-16)*76284;
     bb=(YY         +132252*VV)>>16;
     gg=(YY- 53281*UU-25625*VV)>>16;
     rr=(YY+104595*UU)>>16;
     bb=aaNumClamp(bb,0,255);
     gg=aaNumClamp(gg,0,255);
     rr=aaNumClamp(rr,0,255);
     dhp[x+0]=(0xff000000)+(bb<<16)+(gg<<8)+rr;
     YY=(yl_ptr[x+1]-16)*76284;
     bb=(YY         +132252*VV)>>16;
     gg=(YY- 53281*UU-25625*VV)>>16;
     rr=(YY+104595*UU)>>16;
     bb=aaNumClamp(bb,0,255);
     gg=aaNumClamp(gg,0,255);
     rr=aaNumClamp(rr,0,255);
     dhp[x+1]=(0xff000000)+(bb<<16)+(gg<<8)+rr;
     }
    d_offset-=WID;
    yl_ptr+=(vdcp->status.size.w);
    if((y&1)==1) { yr_ptr+=wshift;  yb_ptr+=wshift;   }
    }
 #endif
  vdcp->is_frame_waiting=YES;
  vdcp->status.is_frameready=YES;
  return RET_YES;


#if aa_VIDCAP_ALLOW_YUY2==YES
  case 5:
  bp=lpvhdr->lpData;
  aaCast(yl_ptr,BP,&bp[0]);
  aaCast(yr_ptr,BP,&bp[1]);
  aaCast(yb_ptr,BP,&bp[3]);
  d_offset=(HIT-1)*WID;
   for(y=0;y<(N)HIT;y++)
    {
    aaCast(dhp,HP,&vdcp->status.surface_status.mem[d_offset]);
    for(x=0;x<(N)WID;x+=1)
     {
     UU=(yr_ptr[0])-128;
     VV=(yb_ptr[0])-128;
     YY=(yl_ptr[0]-16)*76284;
     bb=(YY         +132252*VV)>>16;
     gg=(YY- 53281*UU-25625*VV)>>16;
     rr=(YY+104595*UU)>>16;
     bb=aaNumClamp(bb,0,255);
     gg=aaNumClamp(gg,0,255);
     rr=aaNumClamp(rr,0,255);
     dhp[x]=(255<<24)+(bb<<16)+(gg<<8)+rr;
     yl_ptr+=2;
     if((x&1)==1)      {      yr_ptr+=4;      yb_ptr+=4;      }
     }
    d_offset-=WID;
    }
  vdcp->is_frame_waiting=YES;
  vdcp->status.is_frameready=YES;
  return RET_YES;

#endif

  default:
  break;
  }
 vdcp->is_frame_waiting=NO;
 vdcp->status.is_frameready=NO;
 vdcp->frames_bad++;
 return RET_NO;
 }




 B aa_VidCapAbort                      (PP mem)
 {
 _aa_vidcapobject*vdcp;
 H go;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL)  {  return RET_BADPARM;  }
 aaCast(vdcp,_aa_vidcapobject*,*mem);
 if(vdcp==NULL) {  return RET_BADPARM;  }
 vdcp->is_abort_complete=NO;
 if(capCaptureAbort(vdcp->hwnd)==FALSE)
  {
  return RET_FAILED;
  }

/*
 if(capCaptureStop(vdcp->hwnd)==FALSE)
  {
  aaDebugf("capture abort failure");
  return RET_FAILED;
  }
  */

 go=0;
 while(1)
  {
  if(vdcp->is_abort_complete==YES) { break; }
  aaSleep(1);
  go++;
  if(go>=3200)
   {
   break;
   }
  }
 return RET_YES;
 }


/*-----------------------------------------------------------------------*/


 B aa_FileStreamSystemStart            (V)
 {
 logg("aa_FileStreamSystemStart()");
 aa_ObjectIdNew(&aa.filestream_system.object_id);
 aa_ObjectDefine(aa.filestream_system.object_id,sizeof(_aa_filestreamobject),_8K,256,aaFileStreamDestroy,"FileStream");
 logg("");
 return RET_YES;
 }




 V aa_FileStreamSystemStop             (V)
 {
 logg("aa_FileStreamSystemStop()");
 aa_ObjectUndefine(aa.filestream_system.object_id);
 logg("");
 }





/*-----------------------------------------------------------------------*/



 B aa_FileBoxSystemStart               (V)
 {
 logg("aa_FileBoxSystemStart()");
 logg("");
 return RET_YES;
 }


 V aa_FileBoxSystemStop                (V)
 {
 logg("aa_FileBoxSystemStop()");
 aaFileBoxClose();
 logg("");
 }






 H WINAPI aa_FileBoxProc               (LPVOID pa)
 {
 B ret;
 H z,tl,sl,fl;
 B thefilter[_2K];
 BOOL res;
 _aa_fileboxsystem*df;
 H dipa_toggle;
 H dipa_count;
 B ascii;
 B failure_flag;

 aaCast(df,_aa_fileboxsystem*,pa);
 if(df!=&aa.filebox_system) { oof; }
 aaMemoryFill(&aa.filebox_system.of,sizeof(aa.filebox_system.of),0);
 aaStringLen(aa.filebox_system.filter,&sl);

 tl=fl=0;
 dipa_toggle=0;
 dipa_count=0;
 failure_flag=NO;

 for(z=0;z<sl;z++)
  {
  ascii=aa.filebox_system.filter[z];
  if(ascii!='|')   {   thefilter[fl++]=ascii; thefilter[fl]=NULL_CHAR;  tl++; }
  else
   {
   if(tl==0)  {  failure_flag=1; break; }
   dipa_toggle++;
   thefilter[fl++]=NULL_CHAR;
   dipa_toggle^=1;
   tl=0;
   }
  }
 if(failure_flag==NO)
  {
  if(dipa_toggle==1&&tl==0)   {   failure_flag=2;   }
  else
  if(dipa_toggle==1&&tl!=0)   {  }
  else
  if(dipa_toggle==0)
   {
   if(dipa_count>=2&&aaNumIsNotMod(dipa_count,2)) {}
   else                                           { failure_flag=3; }
   }
  }
 thefilter[fl++]=NULL_CHAR;
 thefilter[fl++]=NULL_CHAR;
 thefilter[fl++]=NULL_CHAR;
 if(aa.filebox_system.initial_file[0]!=NULL_CHAR)
  {
  aaStringCopy(aa.filebox_system.selection,aa.filebox_system.initial_file);
  }
 aa.filebox_system.of.lStructSize=sizeof(aa.filebox_system.of);
 aa.filebox_system.of.hwndOwner=aa.filebox_system.parent_hwnd;
 aa.filebox_system.of.hInstance=aa.core_system.this_instance;
 aa.filebox_system.of.lpstrFilter=(CP)thefilter;
 aa.filebox_system.of.lpstrCustomFilter=NULL;
 aa.filebox_system.of.nMaxCustFilter=0;
 aa.filebox_system.of.nFilterIndex=1;
 aa.filebox_system.of.lpstrFile=(CP)aa.filebox_system.selection;
 if((ret=aaMemoryBytesGet(aa.filebox_system.selection,&aa.filebox_system.of.nMaxFile))!=YES) { oops; }
 aa.filebox_system.of.lpstrFileTitle=NULL;
 aa.filebox_system.of.nMaxFileTitle=0;
 if(aa.filebox_system.initial_dir[0]!=0) { aa.filebox_system.of.lpstrInitialDir=(CP)aa.filebox_system.initial_dir; }
 aa.filebox_system.of.lpstrTitle=(CP)aa.filebox_system.caption;
 aa.filebox_system.of.nFileOffset=0;
 aa.filebox_system.of.nFileExtension=0;
 aa.filebox_system.of.lpstrDefExt=NULL;
 aa.filebox_system.of.lCustData=0;
// aa.filebox_system.of.lpfnHook=OFNHookProc;
 //aa.filebox_system.of.lpfnHook=aa_CoreSystemProc;
 aa.filebox_system.of.lpTemplateName=NULL;
 if(aa.filebox_system.max_files>1)
  {
  aa.filebox_system.of.Flags=OFN_ALLOWMULTISELECT|OFN_EXPLORER;//|OFN_ENABLEHOOK;
  }
 else
  {
  aa.filebox_system.of.Flags=OFN_EXPLORER;//|OFN_ENABLEHOOK;
  }
 res=aa.core_system.GetOpenFileName(&aa.filebox_system.of);
 if(res==FALSE)
  {
  aa.filebox_system.is_cancelled=YES;
  }
 ExitThread((H)res);
 }


/*-----------------------------------------------------------------------*/

 B aa_FolderBoxSystemStart             (V)
 {
 logg("aa_FolderBoxSystemStart()");
 logg("");
 return RET_YES;
 }


 V aa_FolderBoxSystemStop              (V)
 {
 logg("aa_FolderBoxSystemStop()");
 aaFolderBoxClose();
 logg("");
 }



 Z CALLBACK aa_FolderBoxCallback       (HWND hwnd,UINT uMsg,LPARAM lp,LPARAM pData)
 {
 B path[_1K];
 UNUSE(lp);
 switch(uMsg)
  {
  case BFFM_INITIALIZED:
  if(aa.folderbox_system.dialog_hwnd==0) { aa.folderbox_system.dialog_hwnd=hwnd; }
  aaStringCopyf(path,"%s",pData);
  aaStringReplaceChar(path,0,FSLASH_CHAR,BSLASH_CHAR);
  SendMessage(hwnd,BFFM_SETSELECTION,TRUE,(LPARAM)path);
  break;
  }
 return 0;
 }




 H WINAPI aa_FolderBoxProc             (LPVOID pa)
 {
 _aa_folderboxsystem*df;

 aaCast(df,_aa_folderboxsystem*,pa);
 if(df!=&aa.folderbox_system) { oof; }
 aa.folderbox_system.pidl=SHBrowseForFolder(&aa.folderbox_system.bi);
 ExitThread(1);
 }

/*-----------------------------------------------------------------------*/

 B aa_DirSystemStart                   (V)
 {
 logg("aa_DirSystemStart()");
 aa_ObjectIdNew(&aa.dir_system.object_id);
 aa_ObjectDefine(aa.dir_system.object_id,sizeof(_aa_dirobject),_2K,16,aaDirClose,"Dir");
 logg("");
 return RET_YES;
 }



 V aa_DirSystemStop                    (V)
 {
 logg("aa_DirSystemStop()");
 aa_ObjectUndefine(aa.dir_system.object_id);
 logg("");
 }


/*-----------------------------------------------------------------------*/



 B aa_DirWalkerSystemStart                   (V)
 {
 aa_ObjectIdNew(&aa.dirwalker_system.object_id);
 aa_ObjectDefine(aa.dirwalker_system.object_id,sizeof(_aa_dirwalkerobject),_2K,16,aaDirWalkerDestroy,"Dirwalk");
 return RET_YES;
 }



 V aa_DirWalkerSystemStop              (V)
 {
 aa_ObjectUndefine(aa.dirwalker_system.object_id);
 }


/*-----------------------------------------------------------------------*/

 B aa_CpuMonitorSystemStart            (V)
 {
 logg("aa_CpuMonitorSystemStart()");
 aa.core_system.GetSystemTimes(&aa.cpumonitor_system.prev_idle_time.dword,&aa.cpumonitor_system.prev_kernel_time.dword,&aa.cpumonitor_system.prev_user_time.dword);
 logg("");
 return RET_YES;
 }




 V aa_CpuMonitorSystemStop             (V)
 {
 logg("aa_CpuMonitorSystemStop()");
 aa.cpumonitor_system.is_started=NO;
 }



/*-----------------------------------------------------------------------*/

 B aa_DigestSystemStart                (V)
 {
 logg("aa_DigestSystemStart()");
 aa_ObjectIdNew(&aa.digest_system.object_id);
 aa_ObjectDefine(aa.digest_system.object_id,sizeof(_aa_digestobject),_4K,32,aaDigestDestroy,"Digest");
 logg("");
 return RET_YES;
 }



 V aa_DigestSystemStop                 (V)
 {
 logg("aa_DigestSystemStop()");
 aa_ObjectUndefine(aa.digest_system.object_id);
 logg("");
 }




 V aa_DigestSystemCompress             (PP mem,HP block)
 {
 _aa_digestobject*digp;
 H raa,rbb,rcc,rdd,ree;
 H paa,pbb,pcc,pdd,pee;
 H pab,pac,pad;
 H a,b,c,d,e;
 HP cwp;
 H j;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaCast(digp,_aa_digestobject*,*mem);
 if(digp->status.type==aa_DIGESTTYPE_Md5)
  {
    paa= digp->status.digest[0];
    pab=digp->status.digest[1];
    pac=digp->status.digest[2];
    pad=digp->status.digest[3];
    for(j=0;j<16;j++) digp->correct_words[j]=block[j];
    cwp=digp->correct_words;
    // Round 1.
    aaMD5OP1 (paa,pab,pac,pad,7,0xd76aa478);
    aaMD5OP1 (pad,paa,pab,pac,12,0xe8c7b756);
    aaMD5OP1 (pac,pad,paa,pab,17,0x242070db);
    aaMD5OP1 (pab,pac,pad,paa,22,0xc1bdceee);
    aaMD5OP1 (paa,pab,pac,pad,7,0xf57c0faf);
    aaMD5OP1 (pad,paa,pab,pac,12,0x4787c62a);
    aaMD5OP1 (pac,pad,paa,pab,17,0xa8304613);
    aaMD5OP1 (pab,pac,pad,paa,22,0xfd469501);
    aaMD5OP1 (paa,pab,pac,pad,7,0x698098d8);
    aaMD5OP1 (pad,paa,pab,pac,12,0x8b44f7af);
    aaMD5OP1 (pac,pad,paa,pab,17,0xffff5bb1);
    aaMD5OP1 (pab,pac,pad,paa,22,0x895cd7be);
    aaMD5OP1 (paa,pab,pac,pad,7,0x6b901122);
    aaMD5OP1 (pad,paa,pab,pac,12,0xfd987193);
    aaMD5OP1 (pac,pad,paa,pab,17,0xa679438e);
    aaMD5OP1 (pab,pac,pad,paa,22,0x49b40821);
    if(cwp) {} // prevent warning
    // Round 2.
    aaMD5OP2 (aaMD5FG,paa,pab,pac,pad,1,5,0xf61e2562);
    aaMD5OP2 (aaMD5FG,pad,paa,pab,pac,6,9,0xc040b340);
    aaMD5OP2 (aaMD5FG,pac,pad,paa,pab,11,14,0x265e5a51);
    aaMD5OP2 (aaMD5FG,pab,pac,pad,paa,0,20,0xe9b6c7aa);
    aaMD5OP2 (aaMD5FG,paa,pab,pac,pad,5,5,0xd62f105d);
    aaMD5OP2 (aaMD5FG,pad,paa,pab,pac,10,9,0x02441453);
    aaMD5OP2 (aaMD5FG,pac,pad,paa,pab,15,14,0xd8a1e681);
    aaMD5OP2 (aaMD5FG,pab,pac,pad,paa,4,20,0xe7d3fbc8);
    aaMD5OP2 (aaMD5FG,paa,pab,pac,pad,9,5,0x21e1cde6);
    aaMD5OP2 (aaMD5FG,pad,paa,pab,pac,14,9,0xc33707d6);
    aaMD5OP2 (aaMD5FG,pac,pad,paa,pab,3,14,0xf4d50d87);
    aaMD5OP2 (aaMD5FG,pab,pac,pad,paa,8,20,0x455a14ed);
    aaMD5OP2 (aaMD5FG,paa,pab,pac,pad,13,5,0xa9e3e905);
    aaMD5OP2 (aaMD5FG,pad,paa,pab,pac,2,9,0xfcefa3f8);
    aaMD5OP2 (aaMD5FG,pac,pad,paa,pab,7,14,0x676f02d9);
    aaMD5OP2 (aaMD5FG,pab,pac,pad,paa,12,20,0x8d2a4c8a);
    // Round 3.
    aaMD5OP2 (aaMD5FH,paa,pab,pac,pad,5,4,0xfffa3942);
    aaMD5OP2 (aaMD5FH,pad,paa,pab,pac,8,11,0x8771f681);
    aaMD5OP2 (aaMD5FH,pac,pad,paa,pab,11,16,0x6d9d6122);
    aaMD5OP2 (aaMD5FH,pab,pac,pad,paa,14,23,0xfde5380c);
    aaMD5OP2 (aaMD5FH,paa,pab,pac,pad,1,4,0xa4beea44);
    aaMD5OP2 (aaMD5FH,pad,paa,pab,pac,4,11,0x4bdecfa9);
    aaMD5OP2 (aaMD5FH,pac,pad,paa,pab,7,16,0xf6bb4b60);
    aaMD5OP2 (aaMD5FH,pab,pac,pad,paa,10,23,0xbebfbc70);
    aaMD5OP2 (aaMD5FH,paa,pab,pac,pad,13,4,0x289b7ec6);
    aaMD5OP2 (aaMD5FH,pad,paa,pab,pac,0,11,0xeaa127fa);
    aaMD5OP2 (aaMD5FH,pac,pad,paa,pab,3,16,0xd4ef3085);
    aaMD5OP2 (aaMD5FH,pab,pac,pad,paa,6,23,0x04881d05);
    aaMD5OP2 (aaMD5FH,paa,pab,pac,pad,9,4,0xd9d4d039);
    aaMD5OP2 (aaMD5FH,pad,paa,pab,pac,12,11,0xe6db99e5);
    aaMD5OP2 (aaMD5FH,pac,pad,paa,pab,15,16,0x1fa27cf8);
    aaMD5OP2 (aaMD5FH,pab,pac,pad,paa,2,23,0xc4ac5665);
    // Round 4.
    aaMD5OP2 (aaMD5FI,paa,pab,pac,pad,0,6,0xf4292244);
    aaMD5OP2 (aaMD5FI,pad,paa,pab,pac,7,10,0x432aff97);
    aaMD5OP2 (aaMD5FI,pac,pad,paa,pab,14,15,0xab9423a7);
    aaMD5OP2 (aaMD5FI,pab,pac,pad,paa,5,21,0xfc93a039);
    aaMD5OP2 (aaMD5FI,paa,pab,pac,pad,12,6,0x655b59c3);
    aaMD5OP2 (aaMD5FI,pad,paa,pab,pac,3,10,0x8f0ccc92);
    aaMD5OP2 (aaMD5FI,pac,pad,paa,pab,10,15,0xffeff47d);
    aaMD5OP2 (aaMD5FI,pab,pac,pad,paa,1,21,0x85845dd1);
    aaMD5OP2 (aaMD5FI,paa,pab,pac,pad,8,6,0x6fa87e4f);
    aaMD5OP2 (aaMD5FI,pad,paa,pab,pac,15,10,0xfe2ce6e0);
    aaMD5OP2 (aaMD5FI,pac,pad,paa,pab,6,15,0xa3014314);
    aaMD5OP2 (aaMD5FI,pab,pac,pad,paa,13,21,0x4e0811a1);
    aaMD5OP2 (aaMD5FI,paa,pab,pac,pad,4,6,0xf7537e82);
    aaMD5OP2 (aaMD5FI,pad,paa,pab,pac,11,10,0xbd3af235);
    aaMD5OP2 (aaMD5FI,pac,pad,paa,pab,2,15,0x2ad7d2bb);
    aaMD5OP2 (aaMD5FI,pab,pac,pad,paa,9,21,0xeb86d391);
    // Put checksum in context given as argument.
    digp->status.digest[0]+=paa;
    digp->status.digest[1]+=pab;
    digp->status.digest[2]+=pac;
    digp->status.digest[3]+=pad;
 }
else
 if(digp->status.type==aa_DIGESTTYPE_Ripemd160)
  {
  raa=digp->status.digest[0];
  rbb=digp->status.digest[1];
  rcc=digp->status.digest[2];
  rdd=digp->status.digest[3];
  ree=digp->status.digest[4];
  paa=raa; pbb=rbb; pcc=rcc; pdd=rdd; pee=ree;

  aaRipemdFF(raa,rbb,rcc,rdd,ree,block[ 0],11);
  aaRipemdFF(ree,raa,rbb,rcc,rdd,block[ 1],14);
  aaRipemdFF(rdd,ree,raa,rbb,rcc,block[ 2],15);
  aaRipemdFF(rcc,rdd,ree,raa,rbb,block[ 3],12);
  aaRipemdFF(rbb,rcc,rdd,ree,raa,block[ 4],5);
  aaRipemdFF(raa,rbb,rcc,rdd,ree,block[ 5],8);
  aaRipemdFF(ree,raa,rbb,rcc,rdd,block[ 6],7);
  aaRipemdFF(rdd,ree,raa,rbb,rcc,block[ 7],9);
  aaRipemdFF(rcc,rdd,ree,raa,rbb,block[ 8],11);
  aaRipemdFF(rbb,rcc,rdd,ree,raa,block[ 9],13);
  aaRipemdFF(raa,rbb,rcc,rdd,ree,block[10],14);
  aaRipemdFF(ree,raa,rbb,rcc,rdd,block[11],15);
  aaRipemdFF(rdd,ree,raa,rbb,rcc,block[12],6);
  aaRipemdFF(rcc,rdd,ree,raa,rbb,block[13],7);
  aaRipemdFF(rbb,rcc,rdd,ree,raa,block[14],9);
  aaRipemdFF(raa,rbb,rcc,rdd,ree,block[15],8);
  aaRipemdGG(ree,raa,rbb,rcc,rdd,block[ 7],7);
  aaRipemdGG(rdd,ree,raa,rbb,rcc,block[ 4],6);
  aaRipemdGG(rcc,rdd,ree,raa,rbb,block[13],8);
  aaRipemdGG(rbb,rcc,rdd,ree,raa,block[ 1],13);
  aaRipemdGG(raa,rbb,rcc,rdd,ree,block[10],11);
  aaRipemdGG(ree,raa,rbb,rcc,rdd,block[ 6],9);
  aaRipemdGG(rdd,ree,raa,rbb,rcc,block[15],7);
  aaRipemdGG(rcc,rdd,ree,raa,rbb,block[ 3],15);
  aaRipemdGG(rbb,rcc,rdd,ree,raa,block[12],7);
  aaRipemdGG(raa,rbb,rcc,rdd,ree,block[ 0],12);
  aaRipemdGG(ree,raa,rbb,rcc,rdd,block[ 9],15);
  aaRipemdGG(rdd,ree,raa,rbb,rcc,block[ 5],9);
  aaRipemdGG(rcc,rdd,ree,raa,rbb,block[ 2],11);
  aaRipemdGG(rbb,rcc,rdd,ree,raa,block[14],7);
  aaRipemdGG(raa,rbb,rcc,rdd,ree,block[11],13);
  aaRipemdGG(ree,raa,rbb,rcc,rdd,block[ 8],12);
  aaRipemdHH(rdd,ree,raa,rbb,rcc,block[ 3],11);
  aaRipemdHH(rcc,rdd,ree,raa,rbb,block[10],13);
  aaRipemdHH(rbb,rcc,rdd,ree,raa,block[14],6);
  aaRipemdHH(raa,rbb,rcc,rdd,ree,block[ 4],7);
  aaRipemdHH(ree,raa,rbb,rcc,rdd,block[ 9],14);
  aaRipemdHH(rdd,ree,raa,rbb,rcc,block[15],9);
  aaRipemdHH(rcc,rdd,ree,raa,rbb,block[ 8],13);
  aaRipemdHH(rbb,rcc,rdd,ree,raa,block[ 1],15);
  aaRipemdHH(raa,rbb,rcc,rdd,ree,block[ 2],14);
  aaRipemdHH(ree,raa,rbb,rcc,rdd,block[ 7],8);
  aaRipemdHH(rdd,ree,raa,rbb,rcc,block[ 0],13);
  aaRipemdHH(rcc,rdd,ree,raa,rbb,block[ 6],6);
  aaRipemdHH(rbb,rcc,rdd,ree,raa,block[13],5);
  aaRipemdHH(raa,rbb,rcc,rdd,ree,block[11],12);
  aaRipemdHH(ree,raa,rbb,rcc,rdd,block[ 5],7);
  aaRipemdHH(rdd,ree,raa,rbb,rcc,block[12],5);
  aaRipemdII(rcc,rdd,ree,raa,rbb,block[ 1],11);
  aaRipemdII(rbb,rcc,rdd,ree,raa,block[ 9],12);
  aaRipemdII(raa,rbb,rcc,rdd,ree,block[11],14);
  aaRipemdII(ree,raa,rbb,rcc,rdd,block[10],15);
  aaRipemdII(rdd,ree,raa,rbb,rcc,block[ 0],14);
  aaRipemdII(rcc,rdd,ree,raa,rbb,block[ 8],15);
  aaRipemdII(rbb,rcc,rdd,ree,raa,block[12],9);
  aaRipemdII(raa,rbb,rcc,rdd,ree,block[ 4],8);
  aaRipemdII(ree,raa,rbb,rcc,rdd,block[13],9);
  aaRipemdII(rdd,ree,raa,rbb,rcc,block[ 3],14);
  aaRipemdII(rcc,rdd,ree,raa,rbb,block[ 7],5);
  aaRipemdII(rbb,rcc,rdd,ree,raa,block[15],6);
  aaRipemdII(raa,rbb,rcc,rdd,ree,block[14],8);
  aaRipemdII(ree,raa,rbb,rcc,rdd,block[ 5],6);
  aaRipemdII(rdd,ree,raa,rbb,rcc,block[ 6],5);
  aaRipemdII(rcc,rdd,ree,raa,rbb,block[ 2],12);
  aaRipemdJJ(rbb,rcc,rdd,ree,raa,block[ 4],9);
  aaRipemdJJ(raa,rbb,rcc,rdd,ree,block[ 0],15);
  aaRipemdJJ(ree,raa,rbb,rcc,rdd,block[ 5],5);
  aaRipemdJJ(rdd,ree,raa,rbb,rcc,block[ 9],11);
  aaRipemdJJ(rcc,rdd,ree,raa,rbb,block[ 7],6);
  aaRipemdJJ(rbb,rcc,rdd,ree,raa,block[12],8);
  aaRipemdJJ(raa,rbb,rcc,rdd,ree,block[ 2],13);
  aaRipemdJJ(ree,raa,rbb,rcc,rdd,block[10],12);
  aaRipemdJJ(rdd,ree,raa,rbb,rcc,block[14],5);
  aaRipemdJJ(rcc,rdd,ree,raa,rbb,block[ 1],12);
  aaRipemdJJ(rbb,rcc,rdd,ree,raa,block[ 3],13);
  aaRipemdJJ(raa,rbb,rcc,rdd,ree,block[ 8],14);
  aaRipemdJJ(ree,raa,rbb,rcc,rdd,block[11],11);
  aaRipemdJJ(rdd,ree,raa,rbb,rcc,block[ 6],8);
  aaRipemdJJ(rcc,rdd,ree,raa,rbb,block[15],5);
  aaRipemdJJ(rbb,rcc,rdd,ree,raa,block[13],6);
  aaRipemdJJJ(paa,pbb,pcc,pdd,pee,block[ 5],8);
  aaRipemdJJJ(pee,paa,pbb,pcc,pdd,block[14],9);
  aaRipemdJJJ(pdd,pee,paa,pbb,pcc,block[ 7],9);
  aaRipemdJJJ(pcc,pdd,pee,paa,pbb,block[ 0],11);
  aaRipemdJJJ(pbb,pcc,pdd,pee,paa,block[ 9],13);
  aaRipemdJJJ(paa,pbb,pcc,pdd,pee,block[ 2],15);
  aaRipemdJJJ(pee,paa,pbb,pcc,pdd,block[11],15);
  aaRipemdJJJ(pdd,pee,paa,pbb,pcc,block[ 4],5);
  aaRipemdJJJ(pcc,pdd,pee,paa,pbb,block[13],7);
  aaRipemdJJJ(pbb,pcc,pdd,pee,paa,block[ 6],7);
  aaRipemdJJJ(paa,pbb,pcc,pdd,pee,block[15],8);
  aaRipemdJJJ(pee,paa,pbb,pcc,pdd,block[ 8],11);
  aaRipemdJJJ(pdd,pee,paa,pbb,pcc,block[ 1],14);
  aaRipemdJJJ(pcc,pdd,pee,paa,pbb,block[10],14);
  aaRipemdJJJ(pbb,pcc,pdd,pee,paa,block[ 3],12);
  aaRipemdJJJ(paa,pbb,pcc,pdd,pee,block[12],6);
  aaRipemdIII(pee,paa,pbb,pcc,pdd,block[ 6],9);
  aaRipemdIII(pdd,pee,paa,pbb,pcc,block[11],13);
  aaRipemdIII(pcc,pdd,pee,paa,pbb,block[ 3],15);
  aaRipemdIII(pbb,pcc,pdd,pee,paa,block[ 7],7);
  aaRipemdIII(paa,pbb,pcc,pdd,pee,block[ 0],12);
  aaRipemdIII(pee,paa,pbb,pcc,pdd,block[13],8);
  aaRipemdIII(pdd,pee,paa,pbb,pcc,block[ 5],9);
  aaRipemdIII(pcc,pdd,pee,paa,pbb,block[10],11);
  aaRipemdIII(pbb,pcc,pdd,pee,paa,block[14],7);
  aaRipemdIII(paa,pbb,pcc,pdd,pee,block[15],7);
  aaRipemdIII(pee,paa,pbb,pcc,pdd,block[ 8],12);
  aaRipemdIII(pdd,pee,paa,pbb,pcc,block[12],7);
  aaRipemdIII(pcc,pdd,pee,paa,pbb,block[ 4],6);
  aaRipemdIII(pbb,pcc,pdd,pee,paa,block[ 9],15);
  aaRipemdIII(paa,pbb,pcc,pdd,pee,block[ 1],13);
  aaRipemdIII(pee,paa,pbb,pcc,pdd,block[ 2],11);
  aaRipemdHHH(pdd,pee,paa,pbb,pcc,block[15],9);
  aaRipemdHHH(pcc,pdd,pee,paa,pbb,block[ 5],7);
  aaRipemdHHH(pbb,pcc,pdd,pee,paa,block[ 1],15);
  aaRipemdHHH(paa,pbb,pcc,pdd,pee,block[ 3],11);
  aaRipemdHHH(pee,paa,pbb,pcc,pdd,block[ 7],8);
  aaRipemdHHH(pdd,pee,paa,pbb,pcc,block[14],6);
  aaRipemdHHH(pcc,pdd,pee,paa,pbb,block[ 6],6);
  aaRipemdHHH(pbb,pcc,pdd,pee,paa,block[ 9],14);
  aaRipemdHHH(paa,pbb,pcc,pdd,pee,block[11],12);
  aaRipemdHHH(pee,paa,pbb,pcc,pdd,block[ 8],13);
  aaRipemdHHH(pdd,pee,paa,pbb,pcc,block[12],5);
  aaRipemdHHH(pcc,pdd,pee,paa,pbb,block[ 2],14);
  aaRipemdHHH(pbb,pcc,pdd,pee,paa,block[10],13);
  aaRipemdHHH(paa,pbb,pcc,pdd,pee,block[ 0],13);
  aaRipemdHHH(pee,paa,pbb,pcc,pdd,block[ 4],7);
  aaRipemdHHH(pdd,pee,paa,pbb,pcc,block[13],5);
  aaRipemdGGG(pcc,pdd,pee,paa,pbb,block[ 8],15);
  aaRipemdGGG(pbb,pcc,pdd,pee,paa,block[ 6],5);
  aaRipemdGGG(paa,pbb,pcc,pdd,pee,block[ 4],8);
  aaRipemdGGG(pee,paa,pbb,pcc,pdd,block[ 1],11);
  aaRipemdGGG(pdd,pee,paa,pbb,pcc,block[ 3],14);
  aaRipemdGGG(pcc,pdd,pee,paa,pbb,block[11],14);
  aaRipemdGGG(pbb,pcc,pdd,pee,paa,block[15],6);
  aaRipemdGGG(paa,pbb,pcc,pdd,pee,block[ 0],14);
  aaRipemdGGG(pee,paa,pbb,pcc,pdd,block[ 5],6);
  aaRipemdGGG(pdd,pee,paa,pbb,pcc,block[12],9);
  aaRipemdGGG(pcc,pdd,pee,paa,pbb,block[ 2],12);
  aaRipemdGGG(pbb,pcc,pdd,pee,paa,block[13],9);
  aaRipemdGGG(paa,pbb,pcc,pdd,pee,block[ 9],12);
  aaRipemdGGG(pee,paa,pbb,pcc,pdd,block[ 7],5);
  aaRipemdGGG(pdd,pee,paa,pbb,pcc,block[10],15);
  aaRipemdGGG(pcc,pdd,pee,paa,pbb,block[14],8);
  aaRipemdFFF(pbb,pcc,pdd,pee,paa,block[12] ,8);
  aaRipemdFFF(paa,pbb,pcc,pdd,pee,block[15] ,5);
  aaRipemdFFF(pee,paa,pbb,pcc,pdd,block[10] ,12);
  aaRipemdFFF(pdd,pee,paa,pbb,pcc,block[ 4] ,9);
  aaRipemdFFF(pcc,pdd,pee,paa,pbb,block[ 1] ,12);
  aaRipemdFFF(pbb,pcc,pdd,pee,paa,block[ 5] ,5);
  aaRipemdFFF(paa,pbb,pcc,pdd,pee,block[ 8] ,14);
  aaRipemdFFF(pee,paa,pbb,pcc,pdd,block[ 7] ,6);
  aaRipemdFFF(pdd,pee,paa,pbb,pcc,block[ 6] ,8);
  aaRipemdFFF(pcc,pdd,pee,paa,pbb,block[ 2] ,13);
  aaRipemdFFF(pbb,pcc,pdd,pee,paa,block[13] ,6);
  aaRipemdFFF(paa,pbb,pcc,pdd,pee,block[14] ,5);
  aaRipemdFFF(pee,paa,pbb,pcc,pdd,block[ 0] ,15);
  aaRipemdFFF(pdd,pee,paa,pbb,pcc,block[ 3] ,13);
  aaRipemdFFF(pcc,pdd,pee,paa,pbb,block[ 9] ,11);
  aaRipemdFFF(pbb,pcc,pdd,pee,paa,block[11] ,11);
  pdd+=rcc+digp->status.digest[1];
  digp->status.digest[1]=digp->status.digest[2]+rdd+pee;
  digp->status.digest[2]=digp->status.digest[3]+ree+paa;
  digp->status.digest[3]=digp->status.digest[4]+raa+pbb;
  digp->status.digest[4]=digp->status.digest[0]+rbb+pcc;
  digp->status.digest[0]=pdd;
  }
else
 if(digp->status.type==aa_DIGESTTYPE_Sha1)
  {
  B workspace[64];
  T union { B c[64]; H l[16]; } CHAR64LONG16;
  CHAR64LONG16 *zblock=(CHAR64LONG16 *)workspace;
  aaMemoryCopy(zblock,64,block);
  a=digp->status.digest[0];
  b=digp->status.digest[1];
  c=digp->status.digest[2];
  d=digp->status.digest[3];
  e=digp->status.digest[4];
    aaSHA1R0(a,b,c,d,e,0); aaSHA1R0(e,a,b,c,d,1); aaSHA1R0(d,e,a,b,c,2); aaSHA1R0(c,d,e,a,b,3);
    aaSHA1R0(b,c,d,e,a,4); aaSHA1R0(a,b,c,d,e,5); aaSHA1R0(e,a,b,c,d,6); aaSHA1R0(d,e,a,b,c,7);
    aaSHA1R0(c,d,e,a,b,8); aaSHA1R0(b,c,d,e,a,9); aaSHA1R0(a,b,c,d,e,10); aaSHA1R0(e,a,b,c,d,11);
    aaSHA1R0(d,e,a,b,c,12); aaSHA1R0(c,d,e,a,b,13); aaSHA1R0(b,c,d,e,a,14); aaSHA1R0(a,b,c,d,e,15);
    aaSHA1R1(e,a,b,c,d,16); aaSHA1R1(d,e,a,b,c,17); aaSHA1R1(c,d,e,a,b,18); aaSHA1R1(b,c,d,e,a,19);
    aaSHA1R2(a,b,c,d,e,20); aaSHA1R2(e,a,b,c,d,21); aaSHA1R2(d,e,a,b,c,22); aaSHA1R2(c,d,e,a,b,23);
    aaSHA1R2(b,c,d,e,a,24); aaSHA1R2(a,b,c,d,e,25); aaSHA1R2(e,a,b,c,d,26); aaSHA1R2(d,e,a,b,c,27);
    aaSHA1R2(c,d,e,a,b,28); aaSHA1R2(b,c,d,e,a,29); aaSHA1R2(a,b,c,d,e,30); aaSHA1R2(e,a,b,c,d,31);
    aaSHA1R2(d,e,a,b,c,32); aaSHA1R2(c,d,e,a,b,33); aaSHA1R2(b,c,d,e,a,34); aaSHA1R2(a,b,c,d,e,35);
    aaSHA1R2(e,a,b,c,d,36); aaSHA1R2(d,e,a,b,c,37); aaSHA1R2(c,d,e,a,b,38); aaSHA1R2(b,c,d,e,a,39);
    aaSHA1R3(a,b,c,d,e,40); aaSHA1R3(e,a,b,c,d,41); aaSHA1R3(d,e,a,b,c,42); aaSHA1R3(c,d,e,a,b,43);
    aaSHA1R3(b,c,d,e,a,44); aaSHA1R3(a,b,c,d,e,45); aaSHA1R3(e,a,b,c,d,46); aaSHA1R3(d,e,a,b,c,47);
    aaSHA1R3(c,d,e,a,b,48); aaSHA1R3(b,c,d,e,a,49); aaSHA1R3(a,b,c,d,e,50); aaSHA1R3(e,a,b,c,d,51);
    aaSHA1R3(d,e,a,b,c,52); aaSHA1R3(c,d,e,a,b,53); aaSHA1R3(b,c,d,e,a,54); aaSHA1R3(a,b,c,d,e,55);
    aaSHA1R3(e,a,b,c,d,56); aaSHA1R3(d,e,a,b,c,57); aaSHA1R3(c,d,e,a,b,58); aaSHA1R3(b,c,d,e,a,59);
    aaSHA1R4(a,b,c,d,e,60); aaSHA1R4(e,a,b,c,d,61); aaSHA1R4(d,e,a,b,c,62); aaSHA1R4(c,d,e,a,b,63);
    aaSHA1R4(b,c,d,e,a,64); aaSHA1R4(a,b,c,d,e,65); aaSHA1R4(e,a,b,c,d,66); aaSHA1R4(d,e,a,b,c,67);
    aaSHA1R4(c,d,e,a,b,68); aaSHA1R4(b,c,d,e,a,69); aaSHA1R4(a,b,c,d,e,70); aaSHA1R4(e,a,b,c,d,71);
    aaSHA1R4(d,e,a,b,c,72); aaSHA1R4(c,d,e,a,b,73); aaSHA1R4(b,c,d,e,a,74); aaSHA1R4(a,b,c,d,e,75);
    aaSHA1R4(e,a,b,c,d,76); aaSHA1R4(d,e,a,b,c,77); aaSHA1R4(c,d,e,a,b,78); aaSHA1R4(b,c,d,e,a,79);
  digp->status.digest[0]+=a;
  digp->status.digest[1]+=b;
  digp->status.digest[2]+=c;
  digp->status.digest[3]+=d;
  digp->status.digest[4]+=e;
  }
 }





 V aa_DigestSystemMd5                  (_aa_digestobject*digp,BP inbuf,H inlen)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif


 if(digp->count==64)  {  aa_DigestSystemCompress((VP)&digp,(HP)digp->block);  }
 if(!inbuf)return;
 if(digp->count)
  {
  for(;inlen&&digp->count<64;inlen--)  digp->block[digp->count++]=*inbuf++;
  aa_DigestSystemMd5(digp,NULL,0);
  if(!inlen) return;
  }
 while(inlen>=64)
  {
  aa_DigestSystemCompress((VP)&digp,(HP)inbuf);
  digp->count=0;
  digp->counter++;
  inlen-=64;
  inbuf+=64;
  }
 for(;inlen&&digp->count<64;inlen--) digp->block[digp->count++]=*inbuf++;
 }




 static inline V aa_DigestSystemSha256Transform      (_aa_digestobject*digp)
 {
 register H i,j;
 register H a,b,c,d,e,f,g,h,T1,T2;
 H WW[16];

 a=digp->status.digest[0];
 b=digp->status.digest[1];
 c=digp->status.digest[2];
 d=digp->status.digest[3];
 e=digp->status.digest[4];
 f=digp->status.digest[5];
 g=digp->status.digest[6];
 h=digp->status.digest[7];
 for(i=0;i<16;i++)
  {
  WW[i]=((digp->block[(i<<2)+3])|(digp->block[(i<<2)+2]<<8)|(digp->block[(i<<2)+1]<< 16)|(digp->block[i<<2]<<24));
  }
 for(j=0;j<64;j++)
  {
  T1=h+aa_DigestSha2Sigma1(e)+aa_DigestSha2choice(e,f,g)+aa_DigestSha2K256[j];
  if(j<16) T1+=WW[j];
  else     T1+=aa_DigestSha2expand(WW,j);
  T2=aa_DigestSha2Sigma0(a)+aa_DigestSha2majority(a,b,c);
  h=g;
  g=f;
  f=e;
  e=aa_DigestSha2safeAdd(d,T1);
  d=c;
  c=b;
  b=a;
  a=aa_DigestSha2safeAdd(T1,T2);
  }
 digp->status.digest[0]+=a;
 digp->status.digest[1]+=b;
 digp->status.digest[2]+=c;
 digp->status.digest[3]+=d;
 digp->status.digest[4]+=e;
 digp->status.digest[5]+=f;
 digp->status.digest[6]+=g;
 digp->status.digest[7]+=h;
 }



 static inline H aa_DigestSha2rotateRight            (H n,H x)
 {
 return((x>>n)|(x<<(32-n)));
 }

 static inline H aa_DigestSha2choice                 (H x,H y,H z)
 {
 return((x&y)^(~x&z));
 }

 static inline H aa_DigestSha2majority               (H x,H y,H z)
 {
 return((x&y)^(x&z)^(y&z));
 }

 static inline H aa_DigestSha2Sigma0                 (H x)
 {
 return(aa_DigestSha2rotateRight(2,x)^aa_DigestSha2rotateRight(13,x)^aa_DigestSha2rotateRight(22,x));
 }

 static inline H aa_DigestSha2Sigma1                 (H x)
 {
 return(aa_DigestSha2rotateRight(6,x)^aa_DigestSha2rotateRight(11,x)^aa_DigestSha2rotateRight(25,x));
 }

 static inline H aa_DigestSha2sigma0                 (H x)
 {
 return(aa_DigestSha2rotateRight(7,x)^aa_DigestSha2rotateRight(18,x)^(x>>3));
 }

 static inline H aa_DigestSha2sigma1                 (H x)
 {
 return(aa_DigestSha2rotateRight(17,x)^aa_DigestSha2rotateRight(19,x)^(x>>10));
 }

 static inline H aa_DigestSha2expand                 (HP WX,H j)
 {
 return(WX[j&0x0f]+=aa_DigestSha2sigma1(WX[(j+14)&0x0f])+WX[(j+9)&0x0f]+aa_DigestSha2sigma0(WX[(j+1)&0x0f]));
 }


 static inline H aa_DigestSha2safeAdd                (H x,H y)
 {
 register H lsw,msw;
 lsw=(x&0xffff)+(y&0xffff);
 msw=(x>>16)+(y>>16)+(lsw>>16);
 return (msw<<16)|(lsw&0xffff);
 }


 static inline V aa_DigestSystemSha512Transform      (_aa_digestobject*digp,BP buf)
 {
 register int i;
 uint64_t aaS[8],aaW[80];
 register uint64_t t0,t1;
 QP qv;


 qv=(QP)digp->status.digest;
 for(i=0;i<8;i++)   {  aaS[i]=qv[i];  }
 //for(i=0;i<8;i++)   { aaS[i]=md->state[i];    }
 for(i=0;i<16;i++)  { aaSHA512LOAD64H(aaW[i],buf+(8*i));  }
 for(i=16;i<80;i++) { aaW[i]=aaSHA512Gamma1(aaW[i-2])+aaW[i-7]+aaSHA512Gamma0(aaW[i-15])+aaW[i-16];   }
 #define aaSHA512RND(a,b,c,d,e,f,g,h,i) \
 t0=h+aaSHA512Sigma1(e)+aaSHA512Ch(e,f,g)+aaSHA512aaK[i]+aaW[i]; t1=aaSHA512Sigma0(a)+aaSHA512Maj(a,b,c); d+=t0; h=t0+t1;
 for(i=0;i<80;i+=8)
  {
  aaSHA512RND(aaS[0],aaS[1],aaS[2],aaS[3],aaS[4],aaS[5],aaS[6],aaS[7],i+0);
  aaSHA512RND(aaS[7],aaS[0],aaS[1],aaS[2],aaS[3],aaS[4],aaS[5],aaS[6],i+1);
  aaSHA512RND(aaS[6],aaS[7],aaS[0],aaS[1],aaS[2],aaS[3],aaS[4],aaS[5],i+2);
  aaSHA512RND(aaS[5],aaS[6],aaS[7],aaS[0],aaS[1],aaS[2],aaS[3],aaS[4],i+3);
  aaSHA512RND(aaS[4],aaS[5],aaS[6],aaS[7],aaS[0],aaS[1],aaS[2],aaS[3],i+4);
  aaSHA512RND(aaS[3],aaS[4],aaS[5],aaS[6],aaS[7],aaS[0],aaS[1],aaS[2],i+5);
  aaSHA512RND(aaS[2],aaS[3],aaS[4],aaS[5],aaS[6],aaS[7],aaS[0],aaS[1],i+6);
  aaSHA512RND(aaS[1],aaS[2],aaS[3],aaS[4],aaS[5],aaS[6],aaS[7],aaS[0],i+7);
  }
 #undef aaSHA512RND
 qv=(QP)digp->status.digest;
 for(i=0;i<8;i++)   {   qv[i]=qv[i]+aaS[i];    }
 }


/*-----------------------------------------------------------------------*/

 B aa_CryptoSystemStart                (V)
 {
 logg("aa_CryptoSystemStart()");
 aa_ObjectIdNew(&aa.crypto_system.object_id);
 aa_ObjectDefine(aa.crypto_system.object_id,sizeof(_aa_cryptoobject),_8K,32,aaCryptoDestroy,"Crypto");
 logg("");
 return RET_YES;
 }


 V aa_CryptoSystemStop                 (V)
 {
 logg("aa_CryptoSystemStop()");
 aa_ObjectUndefine(aa.crypto_system.object_id);
 logg("");
 }



 V aa_CryptoSystemProcess              (H SK[32],B key[8])
 {
 Z i;
 H XX,YY,TT;

 (XX)=((H)(key)[(0)]<<24)|((H)(key)[(0)+1]<<16)|((H)(key)[(0)+2]<<8)|((H)(key)[(0)+3]);
 (YY)=((H)(key)[(4)]<<24)|((H)(key)[(4)+1]<<16)|((H)(key)[(4)+2]<<8)|((H)(key)[(4)+3]);
 TT=((YY>>4)^XX)&0x0F0F0F0F;  XX^=TT; YY^=(TT<<4);
 TT=((YY)^XX)&0x10101010;  XX^=TT; YY^=(TT);
 XX= (aa_crypto_des_LHs[(XX)&0xF]<<3)|(aa_crypto_des_LHs[(XX>>8)&0xF]<<2)
       |(aa_crypto_des_LHs[(XX>>16)&0xF]<<1)|(aa_crypto_des_LHs[(XX>>24)&0xF])
       |(aa_crypto_des_LHs[(XX>>5)&0xF]<<7)|(aa_crypto_des_LHs[(XX>>13)&0xF]<<6)
       |(aa_crypto_des_LHs[(XX>>21)&0xF]<<5)|(aa_crypto_des_LHs[(XX>>29)&0xF]<<4);
    YY=(aa_crypto_des_RHs[(YY>>1)&0xF]<<3)|(aa_crypto_des_RHs[(YY>>9)&0xF]<<2)
       |(aa_crypto_des_RHs[(YY>>17)&0xF]<<1)|(aa_crypto_des_RHs[(YY>>25)&0xF])
       |(aa_crypto_des_RHs[(YY>>4)&0xF]<<7)|(aa_crypto_des_RHs[(YY>>12)&0xF]<<6)
       |(aa_crypto_des_RHs[(YY>>20)&0xF]<<5)|(aa_crypto_des_RHs[(YY>>28)&0xF]<<4);
 XX&=0x0FFFFFFF;
 YY&=0x0FFFFFFF;
 for(i=0;i<16;i++)
  {
  if(i<2||i==8||i==15)
   {
   XX=((XX<<1)|(XX>>27))&0x0FFFFFFF;
   YY=((YY<<1)|(YY>>27))&0x0FFFFFFF;
   }
  else
   {
   XX=((XX<<2)|(XX>>26))&0x0FFFFFFF;
   YY=((YY<<2)|(YY>>26))&0x0FFFFFFF;
   }
        *SK++= ((XX<<4)&0x24000000)|((XX<<28)&0x10000000)
               |((XX<<14)&0x08000000)|((XX<<18)&0x02080000)
               |((XX<<6)&0x01000000)|((XX<<9)&0x00200000)
               |((XX>>1)&0x00100000)|((XX<<10)&0x00040000)
               |((XX<<2)&0x00020000)|((XX>>10)&0x00010000)
               |((YY>>13)&0x00002000)|((YY>>4)&0x00001000)
               |((YY<<6)&0x00000800)|((YY>>1)&0x00000400)
               |((YY>>14)&0x00000200)|((YY)&0x00000100)
               |((YY>>5)&0x00000020)|((YY>>10)&0x00000010)
               |((YY>>3)&0x00000008)|((YY>>18)&0x00000004)
               |((YY>>26)&0x00000002)|((YY>>24)&0x00000001);

        *SK++= ((XX<<15)&0x20000000)|((XX<<17)&0x10000000)
               |((XX<<10)&0x08000000)|((XX<<22)&0x04000000)
               |((XX>>2)&0x02000000)|((XX<<1)&0x01000000)
               |((XX<<16)&0x00200000)|((XX<<11)&0x00100000)
               |((XX<<3)&0x00080000)|((XX>>6)&0x00040000)
               |((XX<<15)&0x00020000)|((XX>>4)&0x00010000)
               |((YY>>2)&0x00002000)|((YY<<8)&0x00001000)
               |((YY>>14)&0x00000808)|((YY>>9)&0x00000400)
               |((YY)&0x00000200)|((YY<<7)&0x00000100)
               |((YY>>7)&0x00000020)|((YY>>3)&0x00000011)
               |((YY<<2)&0x00000004)|((YY>>21)&0x00000002);
  }
 }



 S inline B aa_CryptoChaCha20Xor       (BP keystream,BP*in,BP*out,H length)
 {
 BP end_keystream=keystream+length;
 do { *(*out)++=*(*in)++^*keystream++; } while (keystream<end_keystream);
 return RET_YES;
 }




 B rj_xtime                            (B x)
 {
 return(x&0x80)?((x<<1)^0x1b):(x<<1);
 }




 V aes_subBytes                        (BP buf)
 {
 register B i=16;
 while(i--) { buf[i]=aes256_sbox(buf[i]); }
 }





 V aes_subBytes_inv                    (BP buf)
 {
 register B i=16;
 //while(i--) { buf[i]=aesffecb_sboxinv[(buf[i])]; }
 while(i--) { buf[i]=aes256_sbox_inv(buf[i]); }
 }





 V aes_addRoundKey                     (BP buf,BP key)
 {
 register B i=16;
 while(i--) { buf[i]^=key[i]; }
 }






 V aes_addRoundKey_cpy                 (BP buf,BP key,BP cpk)
 {
 register B i=16;
 while(i--) { buf[i]^=(cpk[i]=key[i]),cpk[16+i]=key[16+i]; }
 }






 V aes_shiftRows                       (BP buf)
 {
 register B i,j;

 i=buf[1];  buf[1]=buf[5];  buf[5]=buf[9];   buf[9]=buf[13]; buf[13]=i;
 i=buf[10]; buf[10]=buf[2]; buf[2]=i;
 j=buf[3];  buf[3]=buf[15]; buf[15]=buf[11]; buf[11]=buf[7]; buf[7]=j;
 j=buf[14]; buf[14]=buf[6]; buf[6]=j;
 }






 V aes_shiftRows_inv                   (BP buf)
 {
 register B i,j;

 i=buf[1]; buf[1]=buf[13]; buf[13]=buf[9]; buf[9]=buf[5];   buf[5]=i;
 i=buf[2]; buf[2]=buf[10]; buf[10]=i;
 j=buf[3]; buf[3]=buf[7];  buf[7]=buf[11]; buf[11]=buf[15]; buf[15]=j;
 j=buf[6]; buf[6]=buf[14]; buf[14]=j;
 }








 V aes_mixColumns                      (BP buf)
 {
 register B i,a,b,c,d,e;

 for(i=0;i<16;i+=4)
  {
  a=buf[i]; b=buf[i+1]; c=buf[i+2]; d=buf[i+3];
  e=a^b^c^d;
  buf[i]^=e^rj_xtime(a^b);   buf[i+1]^=e^rj_xtime(b^c);
  buf[i+2]^=e^rj_xtime(c^d); buf[i+3]^=e^rj_xtime(d^a);
  }
 }







 V aes_mixColumns_inv                  (BP buf)
 {
 register B i,a,b,c,d,e,x,y,z;

 for(i=0;i<16;i+=4)
  {
  a=buf[i]; b=buf[i+1]; c=buf[i+2]; d=buf[i+3];
  e=a^b^c^d;
  z=rj_xtime(e);
  x=e^rj_xtime(rj_xtime(z^a^c));  y=e^rj_xtime(rj_xtime(z^b^d));
  buf[i]^=x^rj_xtime(a^b);   buf[i+1]^=y^rj_xtime(b^c);
  buf[i+2]^=x^rj_xtime(c^d); buf[i+3]^=y^rj_xtime(d^a);
  }
 }






 V aes_expandEncKey                    (BP k,BP rc)
 {
 register B i;

 k[0]^=aes256_sbox(k[29])^(*rc);
 k[1]^=aes256_sbox(k[30]);
 k[2]^=aes256_sbox(k[31]);
 k[3]^=aes256_sbox(k[28]);
 *rc=AESFFECB_F( *rc);
 for(i=4;i<16;i+=4)
  {
  k[i]^=k[i-4],k[i+1]^=k[i-3],k[i+2]^=k[i-2],k[i+3]^=k[i-1];
  }
 k[16]^=aes256_sbox(k[12]);
 k[17]^=aes256_sbox(k[13]);
 k[18]^=aes256_sbox(k[14]);
 k[19]^=aes256_sbox(k[15]);
 for(i=20;i<32;i+=4)
  {
  k[i]^=k[i-4],k[i+1]^=k[i-3],k[i+2]^=k[i-2],k[i+3]^=k[i-1];
  }
 }


 V aes_expandDecKey                    (BP k,BP rc)
 {
 B i;

 for(i=28;i>16;i-=4)
  {
  k[i+0]^=k[i-4],k[i+1]^=k[i-3],k[i+2]^=k[i-2],k[i+3]^=k[i-1];
  }
 k[16]^=aes256_sbox(k[12]);
 k[17]^=aes256_sbox(k[13]);
 k[18]^=aes256_sbox(k[14]);
 k[19]^=aes256_sbox(k[15]);
 for(i=12;i>0;i-=4)
  {
  k[i+0]^=k[i-4],k[i+1]^=k[i-3],k[i+2]^=k[i-2],k[i+3]^=k[i-1];
  }
 *rc=AESFFECB_FD(*rc);
 k[0]^=aes256_sbox(k[29])^(*rc);
 k[1]^=aes256_sbox(k[30]);
 k[2]^=aes256_sbox(k[31]);
 k[3]^=aes256_sbox(k[28]);
 }


/*-----------------------------------------------------------------------*/

 B aa_JsonSystemStart                  (V)
 {
 logg("aa_JsonSystemStart()");
 aa_ObjectIdNew(&aa.json_system.object_id);
 aa_ObjectDefine(aa.json_system.object_id,sizeof(_aa_jsonobject),_8K,64,aaJsonDestroy,"Json");
 logg("");
 return RET_YES;
 }


 B aa_JsonSystemStop                   (V)
 {
 logg("aa_JsonSystemStop()");
 aa_ObjectUndefine(aa.json_system.object_id);
 logg("");
 return RET_YES;
 }



 B aa_JsonSystemExtendMemory           (PP mem,H by)
 {
 B ret;
 _aa_jsonobject*jsonp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 aaCast(jsonp,_aa_jsonobject*,*mem);
 if(by==0) { return RET_YES; }
 if(jsonp->bytes_allocated==0)
  {
  if((ret=aa_MemoryAllocate((VP)&jsonp->status.mem,by,"JsonMem",NO))!=RET_YES) { oops; return ret; }
  }
 else
  {
  by+=jsonp->bytes_allocated;
  if((ret=aa_MemoryReAllocate((VP)&jsonp->status.mem,by))!=RET_YES) { oops;  return ret; }
  }
 jsonp->bytes_allocated=by;
 jsonp->bytes_left=jsonp->bytes_allocated-jsonp->status.mem_bytes;
 return RET_YES;
 }




 B aa_JsonSystemDecoderType            (PP mem,B type,H off,H bytes,VP data)
 {
 _aa_jsonobject*jsonp;
 H left,count,len;
 H rl,ad;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 UNUSE(data);
 aaCast(jsonp,_aa_jsonobject*,*mem);
 while(1)
  {
  left=jsonp->lines_allocated-jsonp->status.lines;
  if(left>5) { break; }
  ad=(jsonp->lines_allocated/2)+(jsonp->lines_allocated+50);
  count=sizeof(_jsonline)*(ad);
  if(jsonp->status.line==NULL)
   {
   if(aaMemoryAllocate((VP)&jsonp->status.line,count)!=YES) oof;
   jsonp->lines_allocated=ad;
   break;
   }
  if(aaMemoryBytesGet(jsonp->status.line,&len)!=YES) oof;
  if((len+(sizeof(_jsonline)*5))>=count) { break; }
  aaMemoryReAllocate((VP)&jsonp->status.line,sizeof(_jsonline)*ad);
  jsonp->lines_allocated=ad;
  break;
  }
 rl=jsonp->status.lines;
 if(type==JSON_TYPE_OBJOPEN||type==JSON_TYPE_ARRAYOPEN) { jsonp->depth++; }
 jsonp->status.line[rl].is_keyobj=NO;
 jsonp->status.line[rl].is_keyarray=NO;
 jsonp->status.line[rl].is_keyvalue=NO;
 jsonp->status.line[rl].depth=jsonp->depth;
 jsonp->status.line[rl].open_line=-1;
 jsonp->status.line[rl].close_line=-1;
 jsonp->status.line[rl].parent_line=-1;
 jsonp->status.line[rl].num_elements=-1;
 jsonp->status.line[rl].element_index=-1;
 jsonp->status.line[rl].next_element=-1;
 jsonp->status.line[rl].prev_element=-1;
 jsonp->status.line[rl].bytes=bytes;
 jsonp->status.line[rl].type=type;
 jsonp->status.line[rl].off=off;
 jsonp->status.line[rl].len=bytes;
 jsonp->status.line[rl].val_int=0;
 jsonp->status.line[rl].val_float=0;
 jsonp->status.line[rl].val_bool=' ';
 if(type==JSON_TYPE_INT)
  {
  aaStringToNumber(&jsonp->status.mem[off],len,0,0,&jsonp->status.line[rl].val_int,0);
  }
 else
 if(type==JSON_TYPE_FLOAT)
  {
  aaStringToDouble(&jsonp->status.mem[off],0,&jsonp->status.line[rl].val_float);
  }
 else
 if(type==JSON_TYPE_FALSE)
  {
  jsonp->status.line[rl].val_bool='f';
  }
 else
 if(type==JSON_TYPE_TRUE)
  {
  jsonp->status.line[rl].val_bool='t';
  }
 else
 if(type==JSON_TYPE_NULL)
  {
  jsonp->status.line[rl].val_bool='N';
  }
 else
 if(type==6)
  {
  oof;
  jsonp->status.line[rl-1].type=JSON_TYPE_KEY;
  return RET_YES;
  }
 if(type==JSON_TYPE_OBJCLOSE||type==JSON_TYPE_ARRAYCLOSE) { jsonp->depth--; }
 jsonp->status.lines=rl+1;
 return RET_YES;
 }





 B aa_jsonSystemDecode                 (PP mem)
 {
 _aa_jsonobject*jsonp;
 B ret;
 H sl,i,j,left,off,len,t,cnt;
 B txt[_32K+_8K];
 Z depth;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 aaCast(jsonp,_aa_jsonobject*,*mem);
 switch(jsonp->dec_stage)
  {
  case 0:
  jsonp->dec_stage=300;
  break;

  case 300:
  if((ret=aaParserSeekToVisibleChar(&jsonp->pa,YES,YES))!=YES)
   {
   jsonp->dec_stage=552;
   break;
   }
  if(jsonp->pa.ch=='{')
   {
   aa_JsonSystemDecoderType((VP)&jsonp,JSON_TYPE_OBJOPEN,jsonp->pa.offset,1,jsonp->pa.bp);
   aaParserSeek(&jsonp->pa,1);
   break;
   }
  if(jsonp->pa.ch=='[')
   {
   aa_JsonSystemDecoderType((VP)&jsonp,JSON_TYPE_ARRAYOPEN,jsonp->pa.offset,1,jsonp->pa.bp);
   aaParserSeek(&jsonp->pa,1);
   break;
   }
  if(jsonp->pa.ch=='}')
   {
   aa_JsonSystemDecoderType((VP)&jsonp,JSON_TYPE_OBJCLOSE,jsonp->pa.offset,1,jsonp->pa.bp);
   aaParserSeek(&jsonp->pa,1);
   break;
   }
  if(jsonp->pa.ch==']')
   {
   aa_JsonSystemDecoderType((VP)&jsonp,JSON_TYPE_ARRAYCLOSE,jsonp->pa.offset,1,jsonp->pa.bp);
   aaParserSeek(&jsonp->pa,1);
   break;
   }
  if(jsonp->pa.ch==DQUOTE_CHAR)
   {
   aaParserCopy(&jsonp->pb,&jsonp->pa,NO);
   aaParserSeek(&jsonp->pa,1);
   while(1)
    {
    if(jsonp->pa.bp[0]==BSLASH_CHAR&&jsonp->pa.bp[1]==DQUOTE_CHAR) { aaParserSeek(&jsonp->pa,2); continue; }
    if(jsonp->pa.bp[0]!=DQUOTE_CHAR)  { aaParserSeek(&jsonp->pa,1);  continue; }
    sl=(jsonp->pa.offset-jsonp->pb.offset)+1;
    aa_JsonSystemDecoderType((VP)&jsonp,JSON_TYPE_STRING,jsonp->pb.offset,sl,jsonp->pb.bp);
    aaParserSeek(&jsonp->pa,1);
    break;
    }
   break;
   }
  if(jsonp->pa.ch==':')
   {
   if(jsonp->status.line[jsonp->status.lines-1].type!=JSON_TYPE_STRING) { oof; }
   jsonp->status.line[jsonp->status.lines-1].type=JSON_TYPE_KEY;
   aaParserSeek(&jsonp->pa,1);
   break;
   }
  if(jsonp->pa.ch==',')
   {
   aaParserSeek(&jsonp->pa,1);
   break;
   }
  aaParserCopy(&jsonp->pb,&jsonp->pa,NO);
  aaParserSeek(&jsonp->pa,1);
  while(1)
   {
   if(aaCharIsVisible(jsonp->pa.bp[0])==NO||(jsonp->pa.bp[0]==','||jsonp->pa.bp[0]=='}'||jsonp->pa.bp[0]==']'))
    {
    sl=(jsonp->pa.offset-jsonp->pb.offset);
    if(sl==1&&(jsonp->pb.bp[0]=='}'||jsonp->pb.bp[0]==']'||jsonp->pb.bp[0]=='{'||jsonp->pb.bp[0]=='['))
     {
     aaParserCopy(&jsonp->pa,&jsonp->pb,NO);
     break;
     }
    aaStringNCopy(txt,jsonp->pb.bp,sl,YES);
    if(aaCharIsVisible(txt[0])==NO&&sl==1) { break; }
    if(aaStringIsNumerical(txt,0,1,0)==YES)  { aa_JsonSystemDecoderType((VP)&jsonp,JSON_TYPE_INT,jsonp->pb.offset,sl,txt); break; }
    if(aaStringIsNumerical(txt,1,1,0)==YES)  { aa_JsonSystemDecoderType((VP)&jsonp,JSON_TYPE_FLOAT,jsonp->pb.offset,sl,txt); break; }
    if(aaStringICompare(txt,"false",0)==YES) { aa_JsonSystemDecoderType((VP)&jsonp,JSON_TYPE_FALSE,jsonp->pb.offset,sl,txt); break; }
    if(aaStringICompare(txt,"true",0)==YES)  { aa_JsonSystemDecoderType((VP)&jsonp,JSON_TYPE_TRUE,jsonp->pb.offset,sl,txt); break; }
    if(aaStringICompare(txt,"null",0)==YES)  { aa_JsonSystemDecoderType((VP)&jsonp,JSON_TYPE_NULL,jsonp->pb.offset,sl,txt); break; }
    aa_JsonSystemDecoderType((VP)&jsonp,JSON_TYPE_UNKNOWN,jsonp->pb.offset,sl,txt);
    break;
    }
   aaParserSeek(&jsonp->pa,1);
   }
  break;

  case 552:
  i=0;
  while(i<jsonp->status.lines)
   {
   left=jsonp->status.lines-i;
   if(left==0) { break; }
   if(jsonp->status.line[i+0].type==JSON_TYPE_KEY||jsonp->status.line[i+0].type==JSON_TYPE_STRING)
    {
    jsonp->status.line[i+0].off++;
    jsonp->status.line[i+0].len-=2;
    }
   off=jsonp->status.line[i+0].off;
   len=jsonp->status.line[i+0].len;
   if(len==0) { i++; continue; }
   jsonp->status.line[i+0].hash=0;
   aaStringHashGet(&jsonp->status.mem[off],len,&jsonp->status.line[i+0].hash,YES);
   i++;
   }
  jsonp->dec_stage=560;
  break;

  case 560:
  i=0;
  while(i<jsonp->status.lines)
   {
   if(jsonp->status.line[i+0].type==JSON_TYPE_OBJOPEN) { t=JSON_TYPE_OBJCLOSE; } else
   if(jsonp->status.line[i+0].type==JSON_TYPE_ARRAYOPEN) { t=JSON_TYPE_ARRAYCLOSE; } else { i++; continue; }
   depth=jsonp->status.line[i+0].depth;
   for(j=i;j<jsonp->status.lines;j++)
    {
    if(jsonp->status.line[j+0].type!=t) { continue; }
    if(jsonp->status.line[j+0].depth!=depth) { continue; }
    jsonp->status.line[i+0].close_line=j;
    break;
    }
   i++;
   }
  i=jsonp->status.lines-1;
  while(i!=0xffffffff)
   {
   if(jsonp->status.line[i+0].type==JSON_TYPE_OBJCLOSE) { t=JSON_TYPE_OBJOPEN; } else
   if(jsonp->status.line[i+0].type==JSON_TYPE_ARRAYCLOSE) { t=JSON_TYPE_ARRAYOPEN; } else { i--; continue; }
   depth=jsonp->status.line[i+0].depth;
   for(j=i;j!=0xffffffff;j--)
    {
    if(jsonp->status.line[j+0].type!=t) { continue; }
    if(jsonp->status.line[j+0].depth!=depth) { continue; }
    jsonp->status.line[i+0].open_line=j;
    break;
    }
   i--;
   }
  jsonp->dec_stage=580;
  break;

  case 580:
  i=0;
  while(i<jsonp->status.lines)
   {
   left=jsonp->status.lines-i;
   if(left==0) { break; }
   jsonp->status.line[i+0].is_keyobj=NO;
   jsonp->status.line[i+0].is_keyarray=NO;
   jsonp->status.line[i+0].is_keyvalue=NO;
   if(left<2) { i++; continue; }
   if(jsonp->status.line[i+0].type==JSON_TYPE_KEY&&jsonp->status.line[i+1].type==JSON_TYPE_ARRAYOPEN)
    {

    if((jsonp->status.line[i+0].depth+1)!=jsonp->status.line[i+1].depth) oof;
    jsonp->status.line[i+0].is_keyarray=YES;
    i+=2;
    continue;
    }
   if(jsonp->status.line[i+0].type==JSON_TYPE_KEY&&jsonp->status.line[i+1].type==JSON_TYPE_OBJOPEN)
    {
    if((jsonp->status.line[i+0].depth+1)!=jsonp->status.line[i+1].depth) oof;
    jsonp->status.line[i+0].is_keyobj=YES;
    i+=2;
    continue;
    }
   if(jsonp->status.line[i+0].type==JSON_TYPE_KEY&&jsonp->status.line[i+1].type>=JSON_TYPE_STRING)
    {
    if((jsonp->status.line[i+0].depth)!=jsonp->status.line[i+1].depth) oof;
    jsonp->status.line[i+0].is_keyvalue=YES;
    i+=2;
    continue;
    }
   i++;
   continue;
   }
  jsonp->dec_stage=582;
  break;

  case 582:
  i=0;
  while(i<jsonp->status.lines)
   {
   if(jsonp->status.line[i+0].type!=JSON_TYPE_ARRAYOPEN) {  i++; continue; }
   depth=jsonp->status.line[i+0].depth;
   cnt=0;
   for(j=i;j<(H)jsonp->status.line[i+0].close_line;j++)
    {
    if(j==i) { continue; }
    if(jsonp->status.line[j+0].type==JSON_TYPE_OBJOPEN||jsonp->status.line[j+0].type==JSON_TYPE_ARRAYOPEN)
     {
     if(jsonp->status.line[j+0].depth!=(depth+1)) { continue; }
     jsonp->status.line[j+0].parent_line=i;
     }
    else
    if(jsonp->status.line[j+0].type>=JSON_TYPE_STRING)
     {
     if(jsonp->status.line[j+0].depth!=(depth)) { continue; }
     jsonp->status.line[j+0].parent_line=i;
     }
    else
     {
     continue;
     }
    cnt++;
    }
   jsonp->status.line[i+0].num_elements=cnt;
   i++;
   }
  jsonp->dec_stage=584;
  break;

  case 584:
  i=0;
  while(i<jsonp->status.lines)
   {
   if(jsonp->status.line[i+0].num_elements==-1) {  i++; continue; }
   cnt=0;
   t=i;
   j=i+1;
   for(;j<(H)jsonp->status.line[i+0].close_line;j++)
    {
    if(jsonp->status.line[j+0].parent_line!=(Z)i) {  continue; }
    jsonp->status.line[j+0].element_index=cnt;
    jsonp->status.line[t+0].next_element=j;
    if(cnt!=0) { jsonp->status.line[j+0].prev_element=t; }
    t=j;
    cnt++;
    }
   i++;
   }
  jsonp->dec_stage=590;
  break;


  case 590:
  jsonp->dec_stage=600;
  //break;

  case 600:
  jsonp->status.is_decoding=NO;
  jsonp->status.decode_success=YES;
  jsonp->status.decode_failure=NO;
  break;
  }
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/



 B aa_ClipBoardSystemStart             (V)
 {
 logg("aa_ClipBoardSystemStart()");
 logg("");
 return RET_YES;
 }



 V aa_ClipBoardSystemStop              (V)
 {
 logg("aa_ClipBoardSystemStop()");
 logg("");
 }


/*-----------------------------------------------------------------------*/




 B aa_DesktopSystemStart               (V)
 {
 logg("aa_DesktopSystemStart()");
 aa_ObjectIdNew(&aa.desktop_system.object_id);
 aa_ObjectDefine(aa.desktop_system.object_id,sizeof(_aa_desktopobject),1000,4,aaDesktopDestroy,"Desktop");
 logg("");
 return RET_YES;
 }



 V aa_DesktopSystemStop                (V)
 {
 logg("aa_DesktopSystemStop()");
 aa_ObjectUndefine(aa.desktop_system.object_id);
 logg("");
 }



/*-----------------------------------------------------------------------*/

 B aa_BigintSystemStart                (V)
 {
 H i;
 for(i=0;i<17;i++)
  {
  if(big_val[i].magic!=aaHPP(aaBigintNew))  {   aaBigintNew(&big_val[i]);   big_val[i].size=1;   big_val[i].data[0]=i;   }
  }
 return RET_YES;
 }



 V aa_BigintSystemStop                 (V)
 {
 H i;
 for(i=0;i<17;i++)  {  aaBigintDelete(&big_val[i]);  }
 }



/*-----------------------------------------------------------------------*/

 B aa_IpcSystemStart                   (V)
 {
 logg("aa_IpcSystemStart()");
 aa_ObjectIdNew(&aa.ipc_system.object_id);
 aa_ObjectDefine(aa.ipc_system.object_id,sizeof(_aa_ipcobject),_2K,10,aaIpcDestroy,"Ipc");
 logg("");
 return RET_YES;
 }




 V aa_IpcSystemStop                    (V)
 {
 logg("aa_IpcSystemStop()");
 aa_ObjectUndefine(aa.ipc_system.object_id);
 logg("");
 }

/*-----------------------------------------------------------------------*/


/*
 B aa_StrSpaceNeed                     (_str*str,H need)
 {
 B ret;
 H take,give;

 if(str==NULL) { return RET_BADPARM; }
 take=need+32;
 if(take>str->space)
  {
  give=(str->space/4)+take;
  if(str->bp!=(BP)str->buf)
   {
   ret=aaMemoryReAllocate((VP)&str->bp,give);
   }
  else
   {
   ret=aaMemoryAllocate((VP)&str->bp,give);
   aaMemoryNameSet((VP)str->bp,"_str");
   }
  if(ret!=YES) { oops; }
  str->space=give;
  }
 return RET_YES;
 }

*/



 B aaStrNew                            (_str*str,VP fmt,...)
 {
 B txt[_4K];
 va_list argptr;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 str->bp=str->buf;
 str->space=sizeof(str->buf);
 str->chars=0;
 str->bp[str->chars]=NULL_CHAR;
 aaFmt(fmt,argptr,txt);
 return(aaStrNCopy(str,txt,0,0xffffffff,YES));
 }





 B aaStrDelete                         (_str*str)
 {
 B ret;
 H bytes;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL)     { return RET_BADPARM; }
 if(str->bp==NULL) { return RET_NOTINITIALIZED; }
 if(str->space<sizeof(str->buf)) { return RET_NOTINITIALIZED; }
 if(str->bp!=(BP)str->buf)
  {
  if((ret=aaMemoryBytesGet(str->bp,&bytes))!=RET_YES) { oops; }
  aaMemoryRelease(str->bp);
  }
 str->chars=str->space=0;
 str->buf[str->chars]=NULL_CHAR;
 str->bp=NULL;
 return RET_YES;
 }




 B aaStrClone                          (_str*str,_str*strb)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL)  { return RET_BADPARM; }
 if(strb==NULL) { return RET_BADPARM; }
 if((ret=aaStrNew(str,0))!=RET_YES) { return ret; }
 return(aaStrNCopy(str,strb->bp,0,strb->space,NO));
 }




 B aaStrReset                          (_str*str)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 str->chars=0;
 str->buf[str->chars]=NULL_CHAR;
 str->bp[str->chars]=NULL_CHAR;
 return RET_YES;
 }




 B aaStrSpaceNeed                      (_str*str,B add,H space)
 {
 B ret;
 H need;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(add) { need=str->space+space; }
 else    { need=space; }
 if(str->space>=space) { return RET_YES; }
 if(str->bp!=(BP)str->buf)
  {
  ret=aaMemoryReAllocate((VP)&str->bp,need);
  }
 else
  {
  ret=aaMemoryAllocate((VP)&str->bp,need);
  aaMemoryNameSet((VP)str->bp,"_str");
  }
 if(ret!=YES) { oops; }
 str->space=need;
 return RET_YES;
 }






 B aaStrCopy                           (_str*str,VP string)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(string==NULL) { return RET_BADPARM; }
 return(aaStrNCopy(str,string,0,0xffffffff,YES));
 }




 B aaStrNCopy                          (_str*str,VP string,H off,H chars,B appendnull)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL)    { return RET_BADPARM; }
 if(string==NULL) { return RET_BADPARM; }
 appendnull&=1;
 if(chars==0xffffffff) { aaStringLen(string,&chars); }
 if(off==0xffffffff)   { off=str->chars; }
 if((off+chars+appendnull+32)>=str->space)
  {
  if((ret=aaStrSpaceNeed(str,NO,off+chars+appendnull+(str->space/3)+256))!=YES) { oops; }
  }
 aaStringNCopy(&str->bp[off],string,chars,appendnull);
 if(appendnull)
  {
  str->chars=off+chars;
  return RET_YES;
  }
 oof;
 return RET_YES;
 }




/*
 B aaStrAppendf                        (_str*str,VP fmt,...)
 {
 B txt[_4K];
 H sl;
 va_list argptr;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 aaFmt(fmt,argptr,txt);
 aaStringLen(txt,&sl);
 return(aaStrNCopy(str,txt,sl,YES));
 }

*/

/*-----------------------------------------------------------------------*/


 B aaStringNull                        (VP str)
 {
 CP d;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 aaCast(d,CP,str);
 *d=NULL_CHAR;
 return RET_YES;
 }




 B aaStringIsNull                      (VP str)
 {
 CP d;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 aaCast(d,CP,str);
 if(*d!=NULL_CHAR) { return RET_NO; }
 return RET_YES;
 }



 B aaStringIsEmpty                     (VP str,B onlybool)
 {
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(onlybool==YES&&str==NULL) { return RET_YES; }
 if(onlybool!=YES&&str==NULL) { return RET_BADPARM; }
 bp=(BP)str;
 if(bp[0]!=NULL_CHAR) { return RET_NO; }
 return RET_YES;
 }



 B aaStringCopy                        (VP dst,VP src)
 {
 register CP s;
 register CP d;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(dst==NULL) { return RET_BADPARM; }
 aaCast(d,CP,dst);
 if(src==NULL)
  {
  *d=NULL_CHAR;
  return RET_YES;
  }
 aaCast(s,CP,src);
 while(1)
  {
  *d=*s;
  if(*s==NULL_CHAR) break;
  d++;
  s++;
  }
 return RET_YES;
 }




 B aaStringNCopy                       (VP dst,VP src,H chars,B appendnull)
 {
 register CP s;
 register CP d;
 register C ch;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(src==NULL) { return RET_BADPARM; }
 if(dst==NULL) { return RET_BADPARM; }
 if(chars==0)
  {
  if(appendnull)   {   aaCast(d,CP,dst);   *d=NULL_CHAR;   }
  return RET_YES;
  }
 aaCast(s,CP,src);
 aaCast(d,CP,dst);
 while(1)
  {
  ch=*s;
  *d =ch;
  if(ch==NULL_CHAR) { break; }
  s++;
  d++;
  chars--;
  if(chars==0) break;
  }
 if(appendnull&&ch!=NULL_CHAR) { *d=NULL_CHAR; }
 return RET_YES;
 }



 B aaStringSolidCopy                   (VP dst,VP src)
 {
 register CP s;
 register CP d;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(dst==NULL) { return RET_BADPARM; }
 aaCast(d,CP,dst);
 if(src==NULL)
  {
  *d=NULL_CHAR;
  return RET_YES;
  }
 aaCast(s,CP,src);
 while(1)
  {
  if(aaCharIsEmpty(*s)!=YES) *d=*s;
  if(*s==NULL_CHAR) break;
  if(aaCharIsEmpty(*s)!=YES) d++;
  s++;
  }
 return RET_YES;
 }




 B aaStringNSolidCopy                   (VP dst,VP src,H chars,B appendnull)
 {
 register CP s;
 register CP d;
 register C ch;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(src==NULL) { return RET_BADPARM; }
 if(dst==NULL) { return RET_BADPARM; }
 if(chars==0)
  {
  if(appendnull)   {   aaCast(d,CP,dst);   *d=NULL_CHAR;   }
  return RET_YES;
  }
 aaCast(s,CP,src);
 aaCast(d,CP,dst);
 while(1)
  {
  ch=*s;
  if(aaCharIsEmpty(ch)!=YES) *d =ch;
  if(ch==NULL_CHAR) { break; }
  s++;
  if(aaCharIsEmpty(ch)!=YES) d++;
  chars--;
  if(chars==0) break;
  }
 if(appendnull&&ch!=NULL_CHAR) { *d=NULL_CHAR; }
 return RET_YES;
 }



 B aaStringCopyLen                     (VP dst,HP chars,VP src)
 {
 CP s,d;
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(chars) { *chars=0; }
 if(dst==NULL) { return RET_BADPARM; }
 aaCast(d,CP,dst);
 if(src==NULL)
  {
  *d=NULL_CHAR;
  return RET_YES;
  }
 aaCast(s,CP,src);
 sl=0;
 while(1)
  {
  *d=*s;
  if(*s==NULL_CHAR) break;
  d++;
  s++;
  sl++;
  }
 if(chars) { *chars=sl; }
 return RET_YES;
 }



 B aaStringLen                         (VP str,HP chars)
 {
 register CP s;
 register H count;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(chars==NULL) { return RET_BADPARM; }
 *chars=0;
 if(str==NULL) { return RET_BADPARM; }
 aaCast(s,CP,str);
 count=0;
 while(1)
  {
  if(*s==NULL_CHAR) break;
  s++;
  count++;
  }
 *chars=count;
 return RET_YES;
 }




 B aaStringNLen                        (VP str,H maxchars,HP chars)
 {
 CP s;
 H count;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(chars==NULL) { return RET_BADPARM; }
 *chars=0;
 if(str==NULL) { return RET_BADPARM; }
 if(maxchars==0) { return RET_NOTFOUND; }
 aaCast(s,CP,str);
 count=0;
 while(1)
  {
  if(*s==NULL_CHAR) break;
  s++;
  count++;
  if(count>=maxchars) { return RET_NOTFOUND; }
  }
 *chars=count;
 return RET_YES;
 }




 B aaStringLenSet                      (VP str,H chars)
 {
 CP s;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 oof;
 if(str==NULL) { return RET_BADPARM; }
 aaCast(s,CP,str);
 s[chars]=NULL_CHAR;
 return RET_YES;
 }



 B aaStringIsLength                    (VP str,H chars)
 {
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_NO; }
 aaStringLen(str,&sl);
 if(sl!=chars) { return RET_NO; }
 return RET_YES;
 }




 B aaStringFill                        (VP str,H chars,B ascii,B appendnull)
 {
 register CP s;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 aaCast(s,CP,str);
 if(chars==0) { aaStringLen(str,&chars);  }
 if(chars!=0) { aaMemoryFill(s,chars,ascii);  }
 if(appendnull==YES) { s[chars]=NULL_CHAR; }
 return RET_YES;
 }





 B aaStringAppend                      (VP dst,VP src)
 {
 B ret;
 CP s,d;
 H dest_len;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaStringLen(dst,&dest_len))!=RET_YES)  {  return ret;  }
 aaCast(d,CP,dst);
 if(src==NULL)  {  d+=dest_len;  *d=NULL_CHAR;  return RET_YES;  }
 aaCast(s,CP,src);
 d+=dest_len;
 while(1)
  {
  *d=*s;
  if(*s==NULL_CHAR) break;
  d++;
  s++;
  }
 return RET_YES;
 }








 B aaStringAppendChar                  (VP str,B ch)
 {
 B ret;
 BP d;
 H len;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaStringLen(str,&len))!=RET_YES)  {  return ret;  }
 aaCast(d,BP,str);
 d[len]=ch;
 d[len+1]=NULL_CHAR;
 return RET_YES;
 }



 B aaStringAppendChars                 (VP str,B ch,H count,B appendnull)
 {
 BP bp;
 H i,sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 bp=(BP)str;
 aaStringLen(str,&sl);
 for(i=0;i<count;i++)  {  bp[sl++]=ch;  }
 if(appendnull)  {  bp[sl]=NULL_CHAR;  }
 return RET_YES;
 }






 B aaStringPad                         (VP str,H chars,H totchars,B padchar,B dir,VP out)
 {
 B temp[_64K];
 H todo,off;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 dir&=1;
 if(str==NULL)  { return RET_MISSINGPARM;  }
 if(chars==0)   { aaStringLen(str,&chars); }
 if(chars>=totchars)
  {
  if(str==out)  { return RET_YES; }
  if(out==NULL) { return RET_YES; }
  aaStringCopy(out,str);
  return RET_YES;
  }
 todo=totchars-chars;
 if(dir==0)
  {
  aaStringFill(temp,todo,padchar,YES);
  off=todo;
  aaStringCopy(&temp[off],str);
  if(str==out||out==NULL)  { aaStringCopy(str,temp); return RET_YES; }
  aaStringCopy(out,temp);
  }
 else
  {
  aaStringCopy(temp,str);
  aaStringLen(temp,&off);
  aaStringFill(&temp[off],todo,padchar,YES);
  if(str==out||out==NULL)  { aaStringCopy(str,temp); return RET_YES; }
  aaStringCopy(out,temp);
  }
 return RET_YES;
 }



 B aaStringVSprintf                    (VP dst,VP fmt,va_list arglist)
 {
 BP bp;
 BP fm;
 B ch;
 _size*v_size;
 _cord*v_cord;
 _rect*v_rect;
 _rgba*v_rgba;
 _yuva*v_yuva;
 _hsla*v_hsla;
 C v_c;
 D v_d;
 Z v_i;
 H v_u;
 Q v_q;
 CP v_str;
 H sl;
 H i;
 C txt[_1K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaCast(bp,BP,dst);
 aaCast(fm,BP,fmt);
 *bp=NULL_CHAR;

 while(1)
  {
  ch=*fm; fm++;
  if(ch==0) { break; }
  if(ch!='%') {  *bp=ch;  bp++;  continue;   }
  ch=*fm; fm++;
  if(ch==0) { break; }
  if(ch=='c'&&*fm=='d')
   {
   fm++;
   if((v_cord=va_arg(arglist,_cord*))==NULL) { break; }
   wsprintf(txt,"%i,%i",v_cord->x,v_cord->y);
   aaStringLen(txt,&sl);
   for(i=0;i<sl;i++) {  *bp=txt[i];  bp++;     }
   continue;
   }
  if(ch=='s'&&*fm=='z')
   {
   fm++;
   if((v_size=va_arg(arglist,_size*))==NULL) { break; }
   wsprintf(txt,"%i,%i",v_size->w,v_size->h);
   aaStringLen(txt,&sl);
   for(i=0;i<sl;i++) {  *bp=txt[i];  bp++;     }
   continue;
   }
  if(ch=='r'&&*fm=='c')
   {
   fm++;
   if((v_rect=va_arg(arglist,_rect*))==NULL) { break; }
   wsprintf(txt,"%i,%i,%i,%i",v_rect->x,v_rect->y,v_rect->w,v_rect->h);
   aaStringLen(txt,&sl);
   for(i=0;i<sl;i++) {  *bp=txt[i];  bp++;     }
   continue;
   }
  if(ch=='p'&&*fm=='n')
   {
   fm++;
   if((v_rgba=va_arg(arglist,_rgba*))==NULL) { break; }
   wsprintf(txt,"%i,%i,%i,%i",v_rgba->r,v_rgba->g,v_rgba->b,v_rgba->a);
   aaStringLen(txt,&sl);
   for(i=0;i<sl;i++) {  *bp=txt[i];  bp++;     }
   continue;
   }
  if(ch=='y'&&*fm=='u')
   {
   fm++;
   if((v_yuva=va_arg(arglist,_yuva*))==NULL) { break; }
   wsprintf(txt,"%i,%i,%i,%i",v_yuva->y,v_yuva->u,v_yuva->v,v_yuva->a);
   aaStringLen(txt,&sl);
   for(i=0;i<sl;i++) {  *bp=txt[i];  bp++;     }
   continue;
   }
  if(ch=='h'&&*fm=='l')
   {
   fm++;
   if((v_hsla=va_arg(arglist,_hsla*))==NULL) { break; }
   wsprintf(txt,"%i,%i,%i,%i",v_hsla->h,v_hsla->s,v_hsla->l,v_hsla->a);
   aaStringLen(txt,&sl);
   for(i=0;i<sl;i++) {  *bp=txt[i];  bp++;     }
   continue;
   }
  if(ch=='I'&&*fm=='P')
   {
   fm++;
   v_u=va_arg(arglist,H);
   aaNetIpToString(v_u,txt);
   aaStringLen(txt,&sl);
   for(i=0;i<sl;i++) {  *bp=txt[i];  bp++;     }
   continue;
   }
  switch(ch)
   {
   default:
   break;

   case 'i':
   case 'd':
   v_i=va_arg(arglist,Z);
   sprintf(txt,"%i",v_i);
   aaStringLen(txt,&sl);
   for(i=0;i<sl;i++) {  *bp=txt[i];  bp++;     }
   break;

   case 'u':
   v_u=(H)va_arg(arglist,H);
   sprintf(txt,"%u",(Z)v_u);
   aaStringLen(txt,&sl);
   for(i=0;i<sl;i++) {  *bp=txt[i];  bp++;     }
   break;

   case 'c':
   v_c=(C)va_arg(arglist,Z);
   sprintf(txt,"%c",v_c);
   aaStringLen(txt,&sl);
   for(i=0;i<sl;i++) {  *bp=txt[i];  bp++;     }
   break;

  case 'q':
   v_q=(Q)va_arg(arglist,Q);
   sprintf(txt,"%I64u",v_q);
   aaStringLen(txt,&sl);
   for(i=0;i<sl;i++) {  *bp=txt[i];  bp++;     }
   break;


   case 'f':
   v_d=va_arg(arglist,double);
   sprintf(txt,"%f",v_d);
   aaStringLen(txt,&sl);
   for(i=0;i<sl;i++) {  *bp=txt[i];  bp++;     }
   break;


   case 's':
   v_str=va_arg(arglist,CP);
   if(v_str!=NULL)
    {
    aaStringLen(v_str,&sl);
    for(i=0;i<sl;i++)
     {
     *bp=v_str[i];
     bp++;
     }
    }
   break;
   }
  }
 *bp=NULL_CHAR;
 return RET_YES;
 }






 B aaStringNCopyf                      (VP dst,H maxchars,VP fmt,...)
 {
 B ret;
 va_list argptr;
 BP tmp=NULL_POINTR;
 B temp[_8K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaCast(tmp,BP,temp);
 if(aa.is_ready==YES) {   if((ret=aa_MemoryTemp((VP)&tmp,_256K,aa_MEMORYTEMP_StrNCopyf))!=RET_YES) { return ret; }   }
 aaFmt(fmt,argptr,tmp);
 if(dst==NULL)  {  return RET_BADPARM;  }
 if(maxchars>=_64K) { aaNote(0,"line=%i\nmaxchars=%i",__LINE__,maxchars);  }
 tmp[maxchars]=NULL_CHAR;
 return(aaStringCopy(dst,tmp));
 }






 B aaStringCopyf                       (VP dst,VP fmt,...)
 {
 B ret;
 va_list argptr;
 B temp[_64K];
 BP tmp=NULL_POINTR;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aa.is_ready==YES)
  {
  if((ret=aa_MemoryTemp((VP)&tmp,_256K,aa_MEMORYTEMP_StrCopyf))!=RET_YES)  { return ret;   }
  }
 else
  {
  aaCast(tmp,BP,temp);
  }
 aaFmt(fmt,argptr,tmp);
 if(dst==NULL)  {  return RET_BADPARM;  }
 return(aaStringCopy(dst,tmp));
 }




 B aaStringCopyfLen                    (VP dst,HP chars,VP fmt,...)
 {
 B ret;
 va_list argptr;
 H sl;
 BP tmp=NULL_POINTR;
 B temp[_64K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(chars) { *chars=0; }
 aaCast(tmp,BP,temp);
 if(aa.is_ready==YES) { if((ret=aa_MemoryTemp((VP)&tmp,_256K-100,aa_MEMORYTEMP_StrCopyfLen))!=RET_YES) {  return ret; }  }
 aaFmt(fmt,argptr,tmp);
 if(dst==NULL)  {  return RET_BADPARM;  }
 ret=aaStringCopy(dst,tmp);
 if(chars) { aaStringLen(dst,&sl); *chars=sl; }
 return ret;
 }




 B aaStringAppendf                     (VP dst,VP fmt,...)
 {
 va_list argptr;
 B ret;
 BP tmp=NULL_POINTR;
 B temp[_64K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aa.is_ready==YES)
  {
  if((ret=aa_MemoryTemp((VP)&tmp,_256K,aa_MEMORYTEMP_StrAppendf))!=RET_YES) { oops; return ret; }
  }
 else
  {
  aaCast(tmp,BP,temp);
  }
 aaFmt(fmt,argptr,tmp);
 if(dst==NULL)   {  return RET_BADPARM;  }
 return(aaStringAppend(dst,tmp));
 }




 B aaStringAppendfLen                  (VP dst,HP chars,VP fmt,...)
 {
 B ret;
 va_list argptr;
 H sl;
 B temp[_64K];
 BP tmp=NULL_POINTR;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(chars) { *chars=0; }
 aaCast(tmp,BP,temp);
 if(aa.is_ready==YES)
  {
  if((ret=aa_MemoryTemp((VP)&tmp,_256K-300,aa_MEMORYTEMP_StrCopyf))!=RET_YES) {  return ret; }
  }
 aaFmt(fmt,argptr,tmp);
 if(dst==NULL)  {  return RET_BADPARM;  }
 ret=aaStringAppend(dst,tmp);
 if(chars) { aaStringLen(dst,&sl); *chars=sl; }
 return ret;
 }


 B aaStringAppendfCrlf                 (VP dst,VP fmt,...)
 {
 va_list argptr;
 H sl;
 B ret;
 BP tmp=NULL_POINTR;
 B temp[_64K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aa.is_ready==YES)
  {
  if((ret=aa_MemoryTemp((VP)&tmp,_256K,aa_MEMORYTEMP_StrAppendf))!=RET_YES) { oops; return ret; }
  }
 else
  {
  aaCast(tmp,BP,temp);
  }
 aaFmt(fmt,argptr,tmp);
 if(dst==NULL)   {  return RET_BADPARM;  }
 aaStringLen(tmp,&sl);
 aaStringLastCharNonVisibleRemove(tmp,sl);
 aaStringLen(tmp,&sl);
 tmp[sl++]=CR_CHAR;
 tmp[sl++]=LF_CHAR;
 tmp[sl]=NULL_CHAR;
 return(aaStringAppend(dst,tmp));
 }


 B aaStringSpacedAppendf               (VP dst,VP fmt,...)
 {
 va_list argptr;
 B str[_32K];
 H dl,sl;
 BP dp,sp;
 B dch,sch;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(dst==NULL) { return RET_BADPARM; }
 aaFmt(fmt,argptr,str);
 sp=(BP)str; aaStringLen(sp,&sl);
 dp=(BP)dst; aaStringLen(dp,&dl);
 dch=NULL_CHAR; if(dl!=0) { dch=dp[dl-1];  }
 sch=NULL_CHAR; if(sl!=0) { sch=sp[0];     }
 if(dl!=0&&sl!=0)
  {
  if(dch!=SPACE_CHAR&&sch!=SPACE_CHAR)
   {
   aaStringAppendChar(dp,SPACE_CHAR);
   }
  }
 aaStringAppendf(dp,"%s",str);
 return RET_YES;
 }




/*e.g
aaStringAppendCopyf(txt,0,"%-25s ","aa_stage=%u",aa_stage);
*/


 B aaStringAppendCopyf                 (VP dst,HP chars,VP afmt,VP fmt,...)
 {
 B ret;
 va_list argptr;
 B temp[_64K];
 BP tmp=NULL_POINTR;
 H sl,tl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(chars) { *chars=0; }
 aaCast(tmp,BP,temp);
 if(aa.is_ready==YES)
  {
  if((ret=aa_MemoryTemp((VP)&tmp,_128K,aa_MEMORYTEMP_StrAppendCopyf))!=RET_YES) { return ret; }
  }
 aaFmt(fmt,argptr,tmp);
 aaStringLen(tmp,&tl);
 if(dst==NULL)  {  return RET_BADPARM;  }
 if(chars)  {  aaStringLen(dst,&sl);  *chars=sl;  }
 ret=aaStringAppendf(dst,afmt,tmp);
 if(chars)  {  aaStringLen(dst,&sl);  *chars=sl;    }
 return ret;
 }





 B aaStringConcat                      (VP str,...)
 {
 BP bp;
 B txt[_16K];
 va_list ap;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 va_start(ap,str);
 if(str==NULL) {  va_end(ap); return RET_BADPARM; }
 aaStringNull(txt);
 while(1)
  {
  if((bp=va_arg(ap,BP))==NULL) { break; }
  aaStringAppendf(txt,"%s",bp);
  }
 va_end(ap);
 aaStringAppendf(str,"%s",txt);
 return RET_YES;
 }





 B aaStringCopyx                       (VP dst,VP fmt,...)
 {
 va_list ap;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 va_start(ap,fmt);
 aaStringVSprintf(dst,fmt,ap);
 va_end(ap);
 return RET_YES;
 }




 B aaStringCompare                     (VP dst,VP src,NP dif)
 {
 register BP s1;
 register BP s2;
 register B c1;
 register B c2;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(dif!=NULL) { *dif=-1; }
 if(dst==NULL) { return RET_BADPARM; }
 if(src==NULL) { return RET_BADPARM; }
 aaCast(s1,BP,dst);
 aaCast(s2,BP,src);
 while(1)
  {
  c1=*s1;
  c2=*s2;
  if(c1!=c2)
   {
   if(dif) { *dif=(N)(c1-c2); }
   return RET_NO;
   }
  if(c1==NULL_CHAR)   {   break;   }
  s1++;
  s2++;
  }
 if(dif) { *dif=0; }
 return RET_YES;
 }





 B aaStringICompare                    (VP dst,VP src,NP dif)
 {
 register BP s1;
 register BP s2;
 register B c1;
 register B c2;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(dif!=NULL) { *dif=-1; }
 if(dst==NULL) { return RET_BADPARM; }
 if(src==NULL) { return RET_BADPARM; }
 aaCast(s1,BP,dst);
 aaCast(s2,BP,src);
 while(1)
  {
  c1=*s1;
  c2=*s2;
  if(c1>='A'&&c1<='Z') c1+=(B)32;
  if(c2>='A'&&c2<='Z') c2+=(B)32;
  if(c1!=c2)
   {
   if(dif) { *dif=(N)(c1-c2); }
   return RET_NO;
   }
  if(c1==NULL_CHAR)   {   break;   }
  s1++;
  s2++;
  }
 if(dif) { *dif=0; }
 return RET_YES;
 }





 B aaStringNCompare                    (VP dst,VP src,H chars,NP dif)
 {
 register BP s1;
 register BP s2;
 register B c1;
 register B c2;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(dif!=NULL) { *dif=-1; }
 if(dst==NULL) { return RET_BADPARM; }
 if(src==NULL) { return RET_BADPARM; }
 if(chars==0)   { aaStringLen(dst,&chars); }
 else
 if(chars==0xffffffff) { aaStringLen(src,&chars); }
 if(chars==0)  { if(dif) { *dif=0; }  return RET_YES;  }
 aaCast(s1,BP,dst);
 aaCast(s2,BP,src);
 while(chars-->0)
  {
  c1=*s1;
  c2=*s2;
  if(c1!=c2)
   {
   if(dif) { *dif=(N)(c1-c2);   }
   return RET_NO;
   }
  if(c1==NULL_CHAR)   {   break;   }
  s1++;
  s2++;
  }
 if(dif) { *dif=0; }
 return RET_YES;
 }




 B aaStringNICompare                   (VP dst,VP src,H chars,NP dif)
 {
 register BP s1;
 register BP s2;
 register B c1;
 register B c2;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(dif!=NULL) { *dif=-1; }
 if(dst==NULL) { return RET_BADPARM; }
 if(src==NULL) { return RET_BADPARM; }
 if(chars==0)   { aaStringLen(dst,&chars); }
 else
 if(chars==0xffffffff) { aaStringLen(src,&chars); }
 if(chars==0)
  {
  if(dif!=NULL) { *dif=0; }
  return RET_YES;
  }
 aaCast(s1,BP,dst);
 aaCast(s2,BP,src);
 while(chars-->0)
  {
  c1=*s1;
  c2=*s2;
  if(c1>='A'&&c1<='Z')  c1+=(B)32;
  if(c2>='A'&&c2<='Z')  c2+=(B)32;
  if(c1!=c2)
   {
   if(dif!=NULL)
    {
    *dif=(I)(c1-c2);
    }
   return RET_NO;
   }
  if(c1==NULL_CHAR)   {   break;   }
  s1++;
  s2++;
  }
 if(dif) { *dif=0; }
 return RET_YES;
 }




 B aaStringSolidCompare                (VP dst,VP src,NP dif)
 {
 register BP s1;
 register BP s2;
 register B c1;
 register B c2;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(dif!=NULL) { *dif=-1; }
 if(dst==NULL) { return RET_BADPARM; }
 if(src==NULL) { return RET_BADPARM; }
 aaCast(s1,BP,dst);
 aaCast(s2,BP,src);
 while(1)
  {
  c1=*s1;
  c2=*s2;
  if(aaCharIsEmpty(c1)==YES) { s1++; }
  if(c1!=c2)
   {
   if(dif) { *dif=(N)(c1-c2); }
   return RET_NO;
   }
  if(c1==NULL_CHAR)   {   break;   }
  s1++;
  s2++;
  }
 if(dif) { *dif=0; }
 return RET_YES;
 }





 B aaStringISolidCompare               (VP dst,VP src,NP dif)
 {
 register BP s1;
 register BP s2;
 register B c1;
 register B c2;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(dif!=NULL) { *dif=-1; }
 if(dst==NULL) { return RET_BADPARM; }
 if(src==NULL) { return RET_BADPARM; }
 aaCast(s1,BP,dst);
 aaCast(s2,BP,src);
 while(1)
  {
  c1=*s1;
  c2=*s2;
  if(aaCharIsEmpty(c1)==YES) { s1++; }
  if(c1>='A'&&c1<='Z') c1+=(B)32;
  if(c2>='A'&&c2<='Z') c2+=(B)32;
  if(c1!=c2)
   {
   if(dif) { *dif=(N)(c1-c2); }
   return RET_NO;
   }
  if(c1==NULL_CHAR)   {   break;   }
  s1++;
  s2++;
  }
 if(dif) { *dif=0; }
 return RET_YES;
 }





 B aaStringNSolidCompare               (VP dst,VP src,H chars,NP dif)
 {
 register BP s1;
 register BP s2;
 register B c1;
 register B c2;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(dif!=NULL) { *dif=-1; }
 if(dst==NULL) { return RET_BADPARM; }
 if(src==NULL) { return RET_BADPARM; }
 if(chars==0)   { aaStringLen(dst,&chars); }
 else
 if(chars==0xffffffff) { aaStringLen(src,&chars); }
 if(chars==0)  { if(dif) { *dif=0; }  return RET_YES;  }
 aaCast(s1,BP,dst);
 aaCast(s2,BP,src);
 while(chars-->0)
  {
  c1=*s1;
  c2=*s2;
  if(aaCharIsEmpty(c1)==YES) { s1++; }
  if(c1!=c2)
   {
   if(dif) { *dif=(N)(c1-c2);   }
   return RET_NO;
   }
  if(c1==NULL_CHAR)   {   break;   }
  s1++;
  s2++;
  }
 if(dif) { *dif=0; }
 return RET_YES;
 }





 B aaStringNISolidCompare              (VP dst,VP src,H chars,NP dif)
 {
 register BP s1;
 register BP s2;
 register B c1;
 register B c2;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(dif!=NULL) { *dif=-1; }
 if(dst==NULL) { return RET_BADPARM; }
 if(src==NULL) { return RET_BADPARM; }
 if(chars==0)   { aaStringLen(dst,&chars); }
 else
 if(chars==0xffffffff) { aaStringLen(src,&chars); }
 if(chars==0) {  if(dif) { *dif=0; }  return RET_YES;  }
 aaCast(s1,BP,dst);
 aaCast(s2,BP,src);
 while(chars-->0)
  {
  c1=*s1;
  c2=*s2;
  if(aaCharIsEmpty(c1)==YES) { s1++; continue; }
  if(c1>='A'&&c1<='Z')  c1+=(B)32;
  if(c2>='A'&&c2<='Z')  c2+=(B)32;
  if(c1!=c2)
   {
   if(dif)  { *dif=(I)(c1-c2); }
   return RET_NO;
   }
  if(c1==NULL_CHAR)   {   break;   }
  s1++;
  s2++;
  }
 if(dif) { *dif=0; }
 return RET_YES;
 }






 B aaStringUpper                       (VP str,H chars,VP ostr)
 {
 register BP s;
 register BP d;
 register H i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 aaCast(s,BP,str);
 if(ostr) { aaCast(d,BP,ostr); }
 else     { aaCast(d,BP,str);  }
 for(i=0;i<chars;i++)
  {
  if(s[i]>='a'&&s[i]<='z') { d[i]=(B)(s[i]-32); }
  else
  if(s!=d) { d[i]=(B)s[i]; }
  }
 d[i]=NULL_CHAR;
 return RET_YES;
 }




 B aaStringLower                       (VP str,H chars,VP ostr)
 {
 register BP s;
 register BP d;
 register H i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 aaCast(s,BP,str);
 if(ostr) { aaCast(d,BP,ostr); }
 else       { aaCast(d,BP,str);  }
 for(i=0;i<chars;i++)
  {
  if(s[i]>='A'&&s[i]<='Z') { d[i]=(B)(s[i]+32); }
  else                     { d[i]=(B)s[i]; }
  }
 d[i]=NULL_CHAR;
 return RET_YES;
 }







 B aaStringReverse                     (VP str,H chars,VP ostr,B appendnull)
 {
 BP s,tmp=NULL_POINTR;
 H i,o;
 B ret,overwrite;
 B temp[_64K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 aaCast(s,BP,str);
 aaCast(tmp,BP,temp);
 if(ostr)    {  overwrite=NO;  }
 else        {  overwrite=YES; }
 if(aa.is_ready==YES)
  {
  if((ret=aa_MemoryTemp((VP)&tmp,_256K,aa_MEMORYTEMP_StrReverse))!=RET_YES) { oops; return ret; }
  }
 i=chars-1;
 o=0;
 while(1)
  {
  tmp[o]=s[i];
  if(i==0) { break; }
  o++;
  i--;
  }
 if(appendnull)      {  tmp[o+1]=NULL_CHAR;  }
 if(overwrite==YES)  {  aaStringCopy(str,tmp); }
 else                {  aaStringCopy(ostr,tmp);  }
 return RET_YES;
 }




 B aaStringInsertChar                  (VP str,H chars,H pos,C ch)
 {
 register CP s;
 register H left;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0)   { aaStringLen(str,&chars); }
 if(pos==0xffffffff)   { pos=chars; }
 if(pos>chars)  { return RET_BOUNDS; }
 left=chars-pos;
 if(left==0)
  {
  aaCast(s,CP,str);
  s[chars]=ch;
  s[chars+1]=NULL_CHAR;
  }
 else
  {
  aaCast(s,CP,str);
  aaMemoryCopy(&s[pos+1],left,&s[pos]);
  s[pos]=ch;
  s[chars+1]=NULL_CHAR;
  }
 return RET_YES;
 }





 B aaStringInsertChars                 (VP str,H chars,H pos,C ch,H inscount)
 {
 register CP s;
 register H left,d;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0)   { aaStringLen(str,&chars); }
 if(pos==0xffffffff)   { pos=chars; }
 if(pos>chars)  { return RET_BOUNDS; }
 if(inscount==0) { return RET_YES; }
 for(d=0;d<inscount;d++)
  {
  left=chars-pos;
  if(left==0)
   {
   aaCast(s,CP,str);
   s[chars]=ch;
   s[chars+1]=NULL_CHAR;
   }
  else
   {
   aaCast(s,CP,str);
   aaMemoryCopy(&s[pos+1],left,&s[pos]);
   s[pos]=ch;
   s[chars+1]=NULL_CHAR;
   }
  chars++;
  }
 return RET_YES;
 }






 B aaStringDeleteChar                  (VP str,H chars,H pos)
 {
 register CP s;
 register H left;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0)   { aaStringLen(str,&chars); }
 if(pos==0xffffffff)   { pos=chars; }
 if(pos>chars)  { return RET_BOUNDS; }
 left=chars-pos;
 if(left==0)
  {
  if(chars==0) { return RET_YES; }
  aaCast(s,CP,str);
  s[chars-1]=NULL_CHAR;
  }
 else
  {
  aaCast(s,CP,str);
  aaMemoryCopy(&s[pos],left,&s[pos+1]);
  s[chars-1]=NULL_CHAR;
  }
 return RET_YES;
 }



 B aaStringDeleteChars                 (VP str,H chars,H pos,H delcount)
 {
 register CP s;
 register H left,d;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0)   { aaStringLen(str,&chars); }
 if(pos==0xffffffff)   { pos=chars; }
 if(pos>chars)  { return RET_BOUNDS; }
 if(delcount==0) { return RET_YES; }
 if(pos==chars)
  {
  aaCast(s,CP,str);
  s[chars-delcount]=NULL_CHAR;
  return RET_YES;
  }

 for(d=0;d<delcount;d++)
  {
  left=chars-pos;
  if(left==0)
   {
   if(chars==0) { return RET_YES; }
   aaCast(s,CP,str);
   s[chars-1]=NULL_CHAR;
   }
  else
   {
   aaCast(s,CP,str);
   aaMemoryCopy(&s[pos],left,&s[pos+1]);
   s[chars-1]=NULL_CHAR;
   }
  }
 return RET_YES;
 }




 B aaStringDeleteCharsTillChar         (VP str,H chars,B ch,B incch,HP len)
 {
 B ret;
 BP bp;
 H off;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 incch&=1;
 if(len) { *len=0; }
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0)
  {
  if(ch==NULL_CHAR) return RET_YES;
  return RET_NOTFOUND;
  }
 aaCast(bp,BP,str);
 ret=aaStringFindChar(bp,chars,&off,ch,YES,0,YES);
 if(ret==RET_NOTFOUND)
  {
  if(len) { aaStringLen(str,len); }
  return RET_NOTFOUND;
  }
 if(incch==YES)
  {
  if(off>0)
   {
   if((ret=aaStringDeleteChars(bp,chars,0,off+0))!=RET_YES) { oops; }
   }
  }
 else
  {
  if((ret=aaStringDeleteChars(bp,chars,0,off+1))!=RET_YES) { oops; }
  }
 if(len) { aaStringLen(str,len); }
 return RET_YES;
 }




 B aaStringCharGet                     (VP str,H chars,N pos,BP ch)
 {
 H off;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(ch) { *ch=NULL_CHAR; }
 if(str==NULL)  {  return RET_BADPARM;  }
 if(ch==NULL)  {  return RET_BADPARM;  }
 if(chars==0)   {  aaStringLen(str,&chars);  }
 if(pos>=0) { off=(H)pos; }
 else       { off=(H)aaNumAbs(pos); off=chars-off; }
 if(off>=chars) { return RET_BOUNDS; }
 aaCast(bp,BP,str);
 *ch=bp[off];
 return RET_YES;
 }



 B aaStringCharSet                     (VP str,H chars,N pos,B ch)
 {
 H off;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL)  {  return RET_BADPARM;  }
 if(chars==0)   {  aaStringLen(str,&chars);  }
 if(pos>=0) { off=(H)pos; }
 else       { off=(H)aaNumAbs(pos); off=chars-off; }
 if(off>=chars) {  return RET_BOUNDS; }
 aaCast(bp,BP,str);
 bp[off]=ch;
 return RET_YES;
 }




 B aaStringCharUpper                   (VP str,H chars,N pos)
 {
 B ret;
 B ascii;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaStringCharGet(str,chars,pos,&ascii))!=YES) { return ret; }
 if(aaCharIsAlphaLo(ascii)!=YES) { return RET_YES; }
 ascii-=32;
 return(aaStringCharSet(str,chars,pos,ascii));
 }



 B aaStringCharLower                   (VP str,H chars,N pos)
 {
 B ret;
 B ascii;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaStringCharGet(str,chars,pos,&ascii))!=YES) { return ret; }
 if(aaCharIsAlphaHi(ascii)!=YES) { return RET_YES; }
 ascii+=32;
 return(aaStringCharSet(str,chars,pos,ascii));
 }



 B aaStringLastCharGet                 (VP str,H chars,BP ch)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaStringCharGet(str,chars,-1,ch));
 }



 B aaStringLastCharSet                 (VP str,H chars,B ch,B appendnull)
 {
 BP s;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL)  {  return RET_BADPARM;  }
 if(chars==0)   {  aaStringLen(str,&chars);  }
 if(chars==0) { return RET_YES; }
 aaCast(s,BP,str);
 s[chars-1]=ch;
 if(appendnull) { s[chars]=NULL_CHAR; }
 return RET_YES;
 }




 B aaStringLastCharDeleteIfChar        (VP str,H chars,B ch)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 ret=aaStringIsLastChar(str,chars,ch);
 if(ret==RET_YES)
  {
  return(aaStringLastCharSet(str,chars,0,1));
  }
 return ret;
 }




 B aaStringIsLastChar                  (VP str,H chars,B ch)
 {
 B ret;
 B ascii;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaStringCharGet(str,chars,-1,&ascii))!=YES) { return ret; }
 if(ascii!=ch) { return RET_NO; }
 return RET_YES;
 }



 B aaStringLastCharNonVisibleRemove    (VP str,H chars)
 {
 BP bp;
 B ascii;
 H off,done;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 aaCast(bp,BP,str);
 off=chars;
 //aaDebugf("off=%i %i [%s]",off,bp[0],bp);
 done=0;
 while(1)
  {
  if(chars==0) { break; }
  if(off==0) { break; }
  ascii=bp[off-1];
  if(aaCharIsVisible(ascii)==YES) { break; }
  //bp[off]=NULL_CHAR;
  //if(off==0) { break; }
  off--;
  chars--;
  done++;
  }
 bp[off]=NULL_CHAR;
 if(done==0) { return RET_NOTFOUND; }
 return RET_YES;
 }


 B aaStringFirstCharNonVisibleRemove   (VP str,H chars)
 {
 BP bp;
 B ascii;
 H off,sl,done;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 sl=chars;
 aaCast(bp,BP,str);
 off=0;
 done=0;
 while(1)
  {
  if(chars==0) { break; }
  ascii=bp[off];
  if(aaCharIsVisible(ascii)==YES) { break; }
  off++;
  chars--;
  }
 if(off!=0)
  {
  done++;
  aaStringDeleteChars(str,0,0,off);
  }
 bp[sl-off]=NULL_CHAR;
 if(done==0) { return RET_NOTFOUND; }
 return RET_YES;
 }



 B aaStringInsertString                (VP str,H chars,H pos,VP istr,H ichars)
 {
 BP bp;
 BP sp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(ichars==0) { aaStringLen(istr,&ichars); }
 if(chars==0) { aaStringLen(str,&chars); }
 aaCast(bp,BP,istr);
 aaCast(sp,BP,str);
 if(ichars==0) { return RET_YES; }
 if(pos>chars) { return RET_BOUNDS; }
 UNUSE(bp);
  {
  aaMemoryCopy(&sp[pos+ichars],chars-pos,&sp[pos]);
  aaMemoryCopy(&sp[pos],ichars,istr);
  sp[pos+chars+ichars]=NULL_CHAR;
  }
 return RET_YES;
 }



 B aaStringInsertStringf               (VP str,H chars,H pos,B appendnull,VP fmt,...)
 {
 B ret;
 va_list ap;
 B txt[_64K];
 H sl;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,ap,txt);
 aaStringLen(txt,&sl);
 if(chars==0) { aaStringLen(str,&chars);}
 if(appendnull==YES) { sl++; }
 ret=aaStringInsertString(str,chars,pos,txt,sl);
 if(ret==RET_YES)
  {
  bp=(BP)str;
  bp[chars+sl]=NULL_CHAR;
  }
 return ret;
 }





 B aaStringIsString                    (VP str,NP which,...)
 {
 va_list ap;
 CP s;
 H ssl,dsl;
 N w,dif;
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(which==NULL) { return RET_BADPARM; }
 *which=-1;
 if(str==NULL) { return RET_BADPARM; }
 va_start(ap,which);
 w=0;
 aaStringLen(str,&ssl);
 while(1)
  {
  s=va_arg(ap,CP);
  if(s==NULL) { ret=NO; break; }
  aaStringLen(s,&dsl);
  if(ssl==dsl)
   {
   aaStringNCompare(str,s,dsl,&dif);
   if(dif==0)
    {
    ret=YES;
    *which=w;
    break;
    }
   }
  w++;
  }
 va_end(ap);
 return ret;
 }





 B aaStringIsIString                   (VP str,NP which,...)
 {
 va_list ap;
 CP s;
 H ssl,dsl;
 N w,dif;
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(which!=NULL) { *which=-1; }
 if(str==NULL) { return RET_BADPARM; }
 va_start(ap,which);
 w=0;
 aaStringLen(str,&ssl);
 while(1)
  {
  s=va_arg(ap,CP);
  if(s==NULL) { ret=RET_NO; break; }
  aaStringLen(s,&dsl);
  if(ssl==dsl)
   {
   if((ret=aaStringNICompare(str,s,dsl,&dif))==RET_YES)
    {
    if(which) { *which=w; }
    break;
    }
   }
  w++;
  }
 va_end(ap);
 return ret;
 }





 B aaStringIsStringPartial             (VP str,NP which,...)
 {
 va_list ap;
 CP s;
 H ssl,dsl;
 N w,dif;
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(which==NULL) { return RET_BADPARM; }
 *which=-1;
 if(str==NULL) { return RET_BADPARM; }
 va_start(ap,which);
 w=0;
 aaStringLen(str,&ssl);
 while(1)
  {
  s=va_arg(ap,CP);
  if(s==NULL) { ret=NO; break; }
  aaStringLen(s,&dsl);
  if(ssl>=dsl)
   {
   aaStringNCompare(str,s,dsl,&dif);
   if(dif==0)
    {
    ret=YES;
    *which=w;
    break;
    }
   }
  w++;
  }
 va_end(ap);
 return ret;
 }





 B aaStringIsIStringPartial            (VP str,NP which,...)
 {
 va_list ap;
 CP s;
 H ssl,dsl;
 N w,dif;
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(which==NULL) { return RET_BADPARM; }
 *which=-1;
 if(str==NULL) { return RET_BADPARM; }
 va_start(ap,which);
 w=0;
 aaStringLen(str,&ssl);
 while(1)
  {
  s=va_arg(ap,CP);
  if(s==NULL) { ret=RET_NO; break; }
  aaStringLen(s,&dsl);
  if(ssl>=dsl)
   {
   if((ret=aaStringNICompare(str,s,dsl,&dif))==RET_YES)
    {
    *which=w;
    break;
    }
   }
  w++;
  }
 va_end(ap);
 return ret;
 }




 B aaStringIsNumerical                 (VP str,B allowfloat,B allowsign,H chars)
 {
 BP s;
 H i,dotcount=0;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_NO; }
 aaCast(s,BP,str);
 for(i=0;i<chars;i++)
  {
  if(s[i]=='.'&&allowfloat==YES&&dotcount==0) { dotcount=1; continue; }
  if((s[i]=='+'||s[i]=='-')&&allowsign==YES&&i==0) { continue; }
  if(s[i]<'0'||s[i]>'9') { return RET_NO; }
  }
 return RET_YES;
 }



 B aaStringIsDeliminated               (VP str,H chars,WP type,BP mode)
 {
 BP s;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mode) { *mode=0; }
 if(type!=NULL) { *type=0; }
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 aaCast(s,BP,str);
 if(s[chars]==NULL_CHAR)
  {
  if(mode) { *mode=aa_STRINGMODE_NULL; }
  }
 if(chars==0)
  {
  return RET_NO;
  }
 if(s[chars-1]==LF_CHAR)
  {
  if(chars>=2&&s[chars-2]==CR_CHAR)
   {
   if(mode) { *mode=aa_STRINGMODE_CRLF; }
   if(type) { *type=0x0d0a;  }
   return RET_YES;
   }
   if(mode) { *mode=aa_STRINGMODE_LF; }
  if(type) { *type=0x0a; }
  return RET_YES;
  }
 if(s[chars-1]==CR_CHAR)
  {
  if(chars>=2&&s[chars-2]==LF_CHAR)
   {
   if(type) { *type=0x0a0d; }
   if(mode) { *mode=aa_STRINGMODE_LFCR; }
   return RET_YES;
   }
  if(mode) { *mode=aa_STRINGMODE_CR; }
  if(type) { *type=0x0d; }
  return RET_YES;
  }
 return RET_NO;
 }




 B aaStringCountNumbers                (VP str,H chars,HP count,B consecutive)
 {
 H i,c;
 BP s;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(count==NULL) { return RET_BADPARM; }
 *count=0;
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 aaCast(s,BP,str);
 c=0;
 for(i=0;i<chars;i++)
  {
  if(s[i]>='0'&&s[i]<='9') { c++; }
  else
   {
   if(consecutive==YES) { break; }
   }
  }
 *count=c;
 return RET_YES;
 }



 B aaStringCountHex                    (VP str,H chars,HP count,B consecutive)
 {
 H i,c;
 BP s;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(count==NULL) { return RET_BADPARM; }
 *count=0;
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 aaCast(s,BP,str);
 c=0;
 for(i=0;i<chars;i++)
  {
  if((s[i]>='0'&&s[i]<='9')||(s[i]>='a'&&s[i]<='f')||(s[i]>='A'&&s[i]<='F'))
   {
   c++;
   }
  else
   {
   if(consecutive==YES) { break; }
   }
  }
 *count=c;
 return RET_YES;
 }



 B aaStringCountAlpha                  (VP str,H chars,HP count,B upper,B lower,B underscore,B consecutive)
 {
 H i,c;
 BP s;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(count==NULL) { return RET_BADPARM; }
 *count=0;
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 aaCast(s,BP,str);
 c=0;
 for(i=0;i<chars;i++)
  {
  if((s[i]>='a'&&s[i]<='z')&&lower)   {   c++;   }
  else
  if((s[i]>='A'&&s[i]<='Z')&&upper)   {   c++;   }
  else
  if((s[i]=='_')&&underscore) {    c++;   }
  else
   {
   if(consecutive==YES) { break; }
   }
  }
 *count=c;
 return RET_YES;
 }



 B aaStringCountAlphaNum               (VP str,H chars,HP count,B upper,B lower,B underscore,B numerical,B consecutive)
 {
 H i,c;
 BP s;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(count==NULL) { return RET_BADPARM; }
 *count=0;
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 aaCast(s,BP,str);
 c=0;
 for(i=0;i<chars;i++)
  {
  if((s[i]>='a'&&s[i]<='z')&&lower)   {   c++;   }
  else
  if((s[i]>='A'&&s[i]<='Z')&&upper)   {   c++;   }
  else
  if((s[i]=='_')&&underscore) {    c++;   }
  else
  if((s[i]>='0'&&s[i]<='9')&&numerical) { c++; }
  else
   {
   if(consecutive==YES) { break; }
   }
  }
 *count=c;
 return RET_YES;
 }



 B aaStringCountVisibleChars           (VP str,H chars,HP count,B logic,B consecutive,B fwd)
 {
 H i,c;
 BP s;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(count==NULL) { return RET_BADPARM; }
 fwd&=1;
 logic&=1;
 *count=0;
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 aaCast(s,BP,str);
 c=0;
 if(fwd==YES)
  {
  for(i=0;i<chars;i++)
   {
   if(logic==YES&&aaCharIsVisible(s[i])==YES)   {   c++;   }
   else
   if(logic==NO&&aaCharIsVisible(s[i])!=YES)   {   c++;   }
   else
    {
    if(consecutive==YES) { break; }
    }
   }
  }
 else
  {
  for(i=0;i<chars;i++)
   {
   if(logic==YES&&aaCharIsVisible(s[chars-i-1])==YES)   {   c++;   }
   else
   if(logic==NO&&aaCharIsVisible(s[chars-i-1])!=YES)   {   c++;   }
   else
    {
    if(consecutive==YES) { break; }
    }
   }
  }

 *count=c;
 return RET_YES;
 }






 B aaStringCountCharList               (VP str,H chars,HP count,B logic,VP chlist)
 {
 H i,j,c,sl;
 BP ch,s;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(count==NULL)  { return RET_BADPARM; }
 *count=0;
 if(str==NULL)    { return RET_BADPARM; }
 if(chars==0)     { aaStringLen(str,&chars); }
 if(chars==0)     { return RET_YES; }
 if(chlist==NULL) { return RET_MISSINGPARM; }
 aaStringLen(chlist,&sl);
 aaCast(s,BP,str);
 c=0;
 for(i=0;i<chars;i++)
  {
  ch=(BP)chlist;
  if(logic==YES)
   {
   for(j=0;j<sl;j++)
    {
    if(s[i]==ch[j]) { break; }
    }
   if(j!=sl) { c++; }
   }
  else
   {
   for(j=0;j<sl;j++)
    {
    if(s[i]==ch[j]) { break; }
    }
   if(j==sl) { c++; }
   }
  }


 if(count) { *count=c; }
 return RET_YES;
 }







 B aaStringIsPrintable                 (VP str,H chars)
 {
 BP s;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_NO; }
 aaCast(s,BP,str);
 while(1)
  {
  if(aaCharIsPrintable(*s)!=YES) { return RET_NO; }
  chars--;
  if(chars==0) { break; }
  s++;
  }
 return RET_YES;
 }





 B aaStringCountPrintable              (VP str,H chars,HP count)
 {
 BP s;
 H c=0;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(count) { *count=0; }
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_NO; }
 aaCast(s,BP,str);
 while(1)
  {
  if(aaCharIsPrintable(*s)==YES) { c++; }
  chars--;
  if(chars==0) { break; }
  s++;
  }
 if(count) { *count=c; }
 return RET_YES;
 }








 B aaStringToDouble                    (VP str,H chars,DP dub)
 {
 BP s;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(dub) *dub=0;
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 aaCast(s,BP,str);
 *dub=atof((CP)s);
 return RET_YES;
 }





 B aaStringToNumber                    (VP str,H chars,HP loh,HP hih,GP gv,QP qv)
 {
 BP s;
 //D v,h;
 G v,h;
 H ch;
 N isneg;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(loh!=NULL) { *loh=0; }
 if(hih!=NULL) { *hih=0; }
 if(gv!=NULL) { *gv=0; }
 if(qv!=NULL) { *qv=0; }
 if(str==NULL) { return RET_BADPARM; }
 if(gv==NULL&&qv==NULL&&loh==NULL&&hih==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 aaCast(s,BP,str);
 v=0;
 isneg=0;
 while(1)
  {
  if(*s=='-')
   {
   if(isneg) { break; }
   isneg=1;
   }
  else
   {
   ch=*s-'0';
   if(ch>9) { break; }
   v=v*(G)10;
   v=v+(G)ch;
   }
  chars--;
  if(chars==0) { break; }
  s++;
  }
 if(isneg) { v=-v; }
 if(gv)  {  *gv=(G)v;  }
 if(qv)  {  *qv=(Q)v;  }
 if(hih)
  {
  if(aa.math_system.four_billion==0.0) oof;
  h=v/(G)aa.math_system.four_billion;
  *hih=(H)h;
  }
 if(loh) { *loh=(H)v; }
 return RET_YES;
 }




 B aaStringHexToNumber                 (VP str,H chars,HP loh,HP hih,GP gv,QP qv)
 {
 BP s;
 G val;
 H ch;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(loh!=NULL) { *loh=0; }
 if(hih!=NULL) { *hih=0; }
 if(gv!=NULL) { *gv=0; }
 if(qv!=NULL) { *qv=0; }

 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 aaCast(s,BP,str);
 if(chars>=3)
  {
  if(s[0]=='0'&&(s[1]=='x'||s[1]=='X')&&aaCharIsHex(s[2]))  { s+=2;   chars-=2;   }
  }
 val=0;
 while(1)
  {
  ch=*s;
  if(ch>='A'&&ch<='F') { ch=ch-'A'; ch=ch+10; }  else
  if(ch>='a'&&ch<='f') { ch=ch-'a'; ch=ch+10; }  else
  if(ch>='0'&&ch<='9') { ch=ch-'0';           }  else { break; }
  val=val*(G)16;
  val=val+(G)ch;
  chars--;
  if(chars==0) { break; }
  s++;
  }
 if(gv)  {  *gv=(G)val;  }
 if(qv)  {  *qv=(Q)val;  }
 if(loh) { *loh=(H)val; }
 val=val>>16;
 if(hih) {  *hih=(H)val;  }
 return RET_YES;
 }


 /*
 aaStringFromBinary(str,0,32,4,1,&em);
 aaDebugf("       0    4    8   12   16   20   24   28   " );
 aaDebugf("       +----+----+----+----+----+----+----+---" );
 aaDebugf("bits:  %s",str);
 */



 CP mystrchr                           (CP string,C ch)
 {
 while(*string&&*string!=ch)  ++string;
 if(*string==ch)  return string;
 return NULL;
 }




 CP mystrtok                           (CP str,CP control)
 {
 static CP s=NULL;
 register CP s1;

 if(str) s=str;
 if(!s)  return NULL;
 while(*s)
  {
  if(mystrchr(control,*s))
   {
   s++;
   }
  else break;
  }
 s1=s;
 while(*s)
  {
  if(mystrchr(control,*s))   {  *s=NULL_CHAR;  return s1; }
  ++s;
  }
 s=NULL;
 if(*s1)  return s1;
 else     return NULL;
 }





 B aaStringComafy                      (VP str,G val)
 {
 Z i;
 CP p;
 CP a[2];
 B txt[_2K];
 B out[_2K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 aaStringCopyf(txt,"%I64d",val);
 a[1]=(CP)txt;
 aaStringNull(out);
    p=mystrtok(a[1],".");
 a[1]=mystrtok(0,   ".");
 if(*p=='-') { aaStringAppendf(out,"%c",*p++); }
 aaStringLen(p,(HP)&i);
 i=i%3;
 if(i==0) i=3;
 while(1)
  {
  while(i-->0)   {   aaStringAppendf(out,"%c",*p++);   }
  if(*p==0) break;
  else           {   aaStringAppendf(out,",");   }
  i=3;
  }
 aaStringCopyf(str,"%s",out);
 return RET_YES;
 }





 B aaStringFromBinary                  (VP str,H from,H nbits,H gbits,B dir,VP mem)
 {
 BP sp,mp;
 H bb,o,by,bi;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 if(str==NULL) { return RET_BADPARM; }
 aaStringNull(str);
 sp=(BP)str;
 mp=(BP)mem;

 for(bb=0;bb<nbits;bb++)
  {
  if(dir==1) { o=(bb); }
  else       { o=nbits-bb-1; }
  o+=from;
  by=o/8;
  bi=o%8;
  if(aaBitGet(mp[by],bi)) { *sp='1'; } else { *sp='0'; }
  sp++;
  if(gbits!=0&&((bb+1)%gbits)==0)   {   *sp=SPACE_CHAR;   sp++;   }
  }
 *sp=NULL_CHAR;
 return RET_YES;
 }








 B aaStringCountChars                  (VP str,H chars,HP count,B ch,B consecutive,B logic)
 {
 H i,c;
 BP s;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(count==NULL) { return RET_BADPARM; }
 *count=0;
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 aaCast(s,BP,str);
 c=0;
 for(i=0;i<chars;i++)
  {
  if((s[i]!=ch&&logic==YES)||(s[i]==ch&&logic==NO))
   {
   if(consecutive==YES) { break; }
   }
  else
   {
   c++;
   }
  }
 *count=c;
 return RET_YES;
 }






 B aaStringFindChar                    (VP str,H chars,HP pos,B ch,B logic,H number,B fwd)
 {
 BP ptr;
 H s,f;
 _parser p;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(pos!=NULL) { *pos=0xffffffff; }
 if(str==NULL) { return RET_BADPARM;  }
 if(chars==0)  { aaStringLen(str,&chars);  }
 if(chars==0)  { return RET_NOTFOUND;  }
 f=0;
 if(fwd==YES)
  {
  aaCast(ptr,BP,str);
  s=0;
  while(1)
   {
   if((*ptr==ch&&logic)||(*ptr!=ch&&!logic))
    {
    if(f==number)     {   if(pos) { *pos=s; }   return RET_YES;     }
    f++;
    }
   chars--;
   if(chars==0) { break; }
   ptr++;
   s++;
   }
  return RET_NOTFOUND;
  }
 else
  {
  aaParserInit(&p,str,chars);
  if(p.length==0) { return RET_NOTFOUND; }
  aaParserSeek(&p,p.length-1);
  while(1)
   {
   if((*p.bp==ch&&logic)||(*p.bp!=ch&&!logic))
    {
    if(f==number) {  if(pos) { *pos=p.offset; } /*(p.length-1)-p.offset; */ return RET_YES;  }
    f++;
    }
   if(p.is_start==YES) { break; }
   aaParserSeek(&p,-1);
   }
  }
 return RET_NOTFOUND;
 }




 B aaStringFindCharList                (VP str,H chars,HP pos,VP chlist,B logic,H number,B fwd)
 {
 BP ptr;
 H s,f,i,sl;
 _parser p;
 B match;
 BP chl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(pos!=NULL) { *pos=0xffffffff; }
 if(chlist==NULL) { return RET_BADPARM; }
 aaStringLen(chlist,&sl);
 if(sl==0) { return RET_BADPARM; }
 if(str==NULL)  {  return RET_BADPARM;  }
 if(chars==0)  {  aaStringLen(str,&chars);  }
 if(chars==0)  {  return RET_NOTFOUND;  }
 f=0;
 aaCast(chl,BP,chlist);
 if(fwd==YES)
  {
  aaCast(ptr,BP,str);
  s=0;
  while(1)
   {
   match=NO;
   if(logic)
    {
    for(i=0;i<sl;i++)     {     if(*ptr==chl[i]) { match=YES; break; }     }
    }
   else
    {
    for(i=0;i<sl;i++)     {     if(*ptr==chl[i]) { break; } }
    if(i==sl) { match=YES;  }
    }
   if(match)
    {
    if(f==number)     {   if(pos) {   *pos=s; }   return RET_YES;     }
    f++;
    }
   chars--;
   if(chars==0) { break; }
   ptr++;
   s++;
   }
  return RET_NOTFOUND;
  }
 else
  {
  aaParserInit(&p,str,chars);
  if(p.length==0) { return RET_NOTFOUND; }
  aaParserSeek(&p,p.length-1);
  while(1)
   {
   match=NO;
   if(logic)
    {
    for(i=0;i<sl;i++)     {     if(*p.bp==chl[i]) { match=YES; break; }     }
    }
   else
    {
    for(i=0;i<sl;i++)     {     if(*p.bp==chl[i]) { break; }}
    if(i==sl) { match=YES;  }
    }
   if(match)
    {
    if(f==number) {  if(pos) { *pos=p.offset; } /*(p.length-1)-p.offset; */ return RET_YES;  }
    f++;
    }
   if(p.is_start==YES) { break; }
   aaParserSeek(&p,-1);
   }
  }
 return RET_NOTFOUND;
 }





 B aaStringFindFirstAlpha              (VP str,H chars,HP pos,B logic)
 {
 BP ptr;
 H s;
 B ascii;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(pos==NULL) { return RET_BADPARM; }
 *pos=0xffffffff;
 if(str==NULL)  {  return RET_BADPARM;  }
 if(chars==0)  {  aaStringLen(str,&chars);  }
 if(chars==0)  {  return RET_NOTFOUND;  }
 aaCast(ptr,BP,str);
 s=0;
 while(1)
  {
  ascii=*ptr;
  if((aaCharIsAlpha(ascii)&&logic)||(((!aaCharIsAlpha(ascii))&&!logic)))
   {
   *pos=s;
   return RET_YES;
   }
  chars--;
  if(chars==0) break;
  ptr++;
  s++;
  }
 return RET_NOTFOUND;
 }




 B aaStringFindFirstNumber             (VP str,H chars,HP pos,B logic)
 {
 BP ptr;
 H s;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(pos==NULL) { return RET_BADPARM; }
 *pos=0xffffffff;
 if(str==NULL)  {  return RET_BADPARM;  }
 if(chars==0)  {  aaStringLen(str,&chars);  }
 if(chars==0)  {  return RET_NOTFOUND;  }
 aaCast(ptr,BP,str);
 s=0;
 while(1)
  {
  if(((*ptr>='0'&&*ptr<='9')&&logic)||((*ptr<'0'||*ptr>'9')&&!logic))
   {
   *pos=s;
   return RET_YES;
   }
  chars--;
  if(chars==0) break;
  ptr++;
  s++;
  }
 return RET_NOTFOUND;
 }




 B aaStringFindCharVisible             (VP str,H chars,HP pos,B logic,H number,B fwd)
 {
 BP ptr;
 H s,f;
 _parser p;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(pos!=NULL) { *pos=0xffffffff; }
 if(str==NULL)  {  return RET_BADPARM;  }
 if(chars==0)  {  aaStringLen(str,&chars);  }
 if(chars==0)  {  return RET_NOTFOUND;  }
 f=0;
 if(fwd==YES)
  {
  aaCast(ptr,BP,str);
  s=0;
  while(1)
   {
   if((aaCharIsVisible(*ptr)&&logic)||(!aaCharIsVisible(*ptr)&&!logic))
    {
    if(f==number)     {   if(pos) {   *pos=s; }   return RET_YES;     }
    f++;
    }
   chars--;
   if(chars==0) { break; }
   ptr++;
   s++;
   }
  return RET_NOTFOUND;
  }
 else
  {
  aaParserInit(&p,str,chars);
  if(p.length==0) { return RET_NOTFOUND; }
  aaParserOffsetSet(&p,p.length-1);
  while(1)
   {
   if((aaCharIsVisible(p.ch)&&logic)||(!aaCharIsVisible(p.ch)&&!logic))
    {
    if(f==number) {  if(pos) { *pos=p.offset; }  return RET_YES;  }
    f++;
    }
   if(p.is_start==YES) { break; }
   aaParserSeek(&p,-1);
   }
  }
 return RET_NOTFOUND;
 }




 B aaStringReplaceChar                 (VP str,H chars,B fromch,B toch)
 {
 BP s;
 H i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 if(fromch==toch) { return RET_YES; }
 aaCast(s,BP,str);
 for(i=0;i<chars;i++)
  {
  if(s[i]==fromch) { s[i]=toch; }
  }
 return RET_YES;
 }





 B aaStringReplaceCharList             (VP str,H chars,VP chlist,B logic,B toch)
 {
 BP ptr;
 H s,c,cl;
 B match;
 BP chl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(chlist==NULL) { return RET_BADPARM; }
 aaStringLen(chlist,&cl);
 if(cl==0)      {  return RET_BADPARM;   }
 if(str==NULL)  {  return RET_BADPARM;  }
 if(chars==0)   {  aaStringLen(str,&chars);  }
 if(chars==0)   {  return RET_NOTFOUND;  }
 aaCast(chl,BP,chlist);
 aaCast(ptr,BP,str);
 match=NO;

 if(logic)
  {
  for(s=0;s<chars;s++)
   {
   for(c=0;c<cl;c++)
    {
    if(ptr[s]==chl[c])
     {
     ptr[s]=toch;
     match=YES;
     }
    }
   }
  }
 else
  {
  for(s=0;s<chars;s++)
   {
   for(c=0;c<cl;c++)
    {
    if(ptr[s]!=chl[c])
     {
     ptr[s]=toch;
     match=YES;
     }
    }
   }
  }
 if(match!=YES) { return RET_NOTFOUND; }
 return RET_YES;
 }










 B aaStringReplaceString               (VP str,H chars,VP fstr,H fchars,VP tstr,H tchars,B iscasesensitive,VP ostr)
 {
 BP ob;
 B buf[_8K];
 _parser pa;
 H ok,o;
 B ib[_8K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(ostr!=NULL&&ostr!=str) { aaStringNull(ostr); }
 ob=(BP)buf;
 if(chars==0)  { aaStringLen(str,&chars); }
 if(chars==0)   {  return RET_NOTFOUND;  }
 if(fstr==NULL) { return RET_BADPARM; }
 if(fchars==0)  {  aaStringLen(fstr,&fchars); }
 if(fchars==0)   { return RET_NOTFOUND;  }
 if(tstr==NULL) { return RET_BADPARM; }
 if(tchars==0)  {  aaStringLen(tstr,&tchars); }
 if(tchars==0)   {  return RET_BADPARM;  }
 aaStringNCopy(ob,str,chars,YES);
 aaStringNCopy(ib,str,chars,YES);
 ok=0;
 aaParserInit(&pa,ob,chars);
 o=pa.offset;
 while(1)
  {
  if(pa.is_end) break;
  if(aaParserSeekToString(&pa,fstr,iscasesensitive,YES,PARSERFLAG_SAFE)!=YES) break;
  if(fchars==tchars)
   {
   aaStringNCopy(&ob[pa.offset],tstr,tchars,NO);
   o=pa.offset+tchars;
   ok=1;
   }
  else
  if(tchars>fchars)
   {
   aaStringInsertChars(ob,0,pa.offset,32,tchars-fchars);
   aaStringNCopy(&ob[pa.offset],tstr,tchars,NO);
   o=pa.offset+(tchars);
   ok=2;
   }
  else
  if(fchars>tchars)
   {
   aaStringDeleteChars(ob,0,pa.offset,fchars-tchars);
   aaStringNCopy(&ob[pa.offset],tstr,tchars,NO);
   o=pa.offset+(tchars);
   ok=3;
   }
  else oof;
  if(ok==0) oof;
  aaStringLen(ob,&chars);
  aaParserInit(&pa,ob,chars);
  aaParserOffsetSet(&pa,o);
  }
 if(ostr==NULL) { aaStringCopyf(str,"%s",ob); }
 else           { aaStringCopyf(ostr,"%s",ob); }
 if(ok) { return RET_YES; }
 return RET_NOTFOUND;
 }








 B aaStringFindFirstString             (VP str,H chars,VP fstr,H fchars,HP pos)
 {
 BP s,d;
 H i,c,p;
 B sch,dch,mch;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(pos) *pos=0xffffffff;
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0)  { aaStringLen(str,&chars); }
 if(fstr==NULL) { return RET_BADPARM; }
 if(fchars==0)  {  aaStringLen(fstr,&fchars); }
 if(fchars==0)   { return RET_NO; }
 if(fchars>chars) { return RET_NO; }
 aaCast(s,BP,str);
 aaCast(d,BP,fstr);
 i=c=0;
 p=0xffffffff;
 mch=d[0];
 while(1)
  {
  sch=s[i];
  dch=d[c];
  if(sch==dch)   {  if(c==0) { p=i; }   c++;   }
  else           {  if(sch==mch) { p=i; c=1;  }  else {  c=0; p=0xffffffff; }  }
  if(c==fchars)  { if(pos) *pos=p; return RET_YES; }
  i++;
  if(i==chars) { break; }
  }
 return RET_NO;
 }





 B aaStringFindFirstIString            (VP str,H chars,VP fstr,H fchars,HP pos)
 {
 BP s,d;
 H i,c,p;
 B sch,dch,mch;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(pos) *pos=0xffffffff;
 if(str==NULL)  { return RET_BADPARM; }
 if(chars==0)     { aaStringLen(str,&chars); }
 if(fstr==NULL)   { return RET_BADPARM; }
 if(fchars==0)    { aaStringLen(fstr,&fchars); }
 if(fchars==0)    { return RET_NO; }
 if(fchars>chars) { return RET_NO; }
 aaCast(s,BP,str);
 aaCast(d,BP,fstr);
 i=c=0;
 p=0xffffffff;
 mch=d[0];
 if(mch>='A'&&mch<='Z') { mch+=(B)32; }
 while(1)
  {
  sch=s[i];
  dch=d[c];
  if(sch>='A'&&sch<='Z') { sch+=(B)32; }
  if(dch>='A'&&dch<='Z') { dch+=(B)32; }
  if(sch==dch)   {  if(c==0) { p=i; }   c++;   }
  else
   {
   if(sch==mch) { p=i; c=1;  }
   else         { c=0; p=0xffffffff; }
   }
  if(c==fchars)  { if(pos) *pos=p; return RET_YES; }
  i++;
  if(i==chars) { break; }
  }
 return RET_NO;
 }




 B aaStringCleanup                     (VP str,H chars,B ignorequoted,HP newlen)
 {
 B ret;
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(newlen) { *newlen=chars; }
 sl=chars;
 while(1)
  {
  if((ret=aaStringRemoveSpaces(str,sl,YES,YES))!=YES) { oops; }
  aaStringLen(str,&sl);
  if(sl==0) { break; }
  ret=aaStringRemoveMultipleSpaces(str,sl,ignorequoted);
  if(ret==RET_YES) { aaStringLen(str,&sl); }
  break;
  }
 if(newlen) {  *newlen=sl; }
 return RET_YES;
 }




 B aaStringRemoveMultipleSpaces        (VP str,H chars,B ignorequoted)
 {
 B ret,prev_char;
 B cur_char;
 BP tmp=NULL_POINTR;
 B in_quote;
 H i,o,done;
 BP sp;
 B temp[_64K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 aaCast(tmp,BP,temp);
 if(aa.is_ready==YES)
  {
  if((ret=aa_MemoryTemp((VP)&tmp,chars+_1K,aa_MEMORYTEMP_StrMultSpaces))!=RET_YES) { return ret; }
  }
 aaStringNull(tmp);
 aaCast(sp,BP,str);
 prev_char=NULL_CHAR;
 in_quote=NO;
 i=o=0;
 done=0;
 while(1)
  {
  if(i>=chars) { break; }
  cur_char=sp[i];
  if(cur_char==NULL_CHAR)       { break; }
  if(cur_char==DQUOTE_CHAR)     { in_quote^=1;  }
  else
  if(cur_char==SPACE_CHAR&&(in_quote==NO||ignorequoted==NO))
   {
   if(prev_char==SPACE_CHAR) { done++; i++; continue; }
   }
  tmp[o++]=cur_char;
  tmp[o]=NULL_CHAR;
  prev_char=cur_char;
  i++;
  }
 aaMemoryCopy(str,o+1,tmp);
 if(done==0) { return RET_NOTFOUND; }
 return RET_YES;
 }





 B aaStringRemoveSpaces                (VP str,H chars,B removeleading,B removetrailing)
 {
 B ch;
 BP bp;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 if(removetrailing==YES)
  {
  while(1)
   {
   if(aaStringLastCharGet(str,chars,&ch)!=RET_YES) { break; }
   if(ch!=SPACE_CHAR) { break; }
   aaStringDeleteChar(str,chars,chars);
   aaStringLen(str,&chars);
   }
  }
 if(removeleading==YES)
  {
  while(1)
   {
   aaCast(bp,BP,str);
   if(bp[0]!=SPACE_CHAR) { break; }
   aaStringDeleteChar(bp,chars,0);
   aaStringLen(str,&chars);
   }
  }
 return RET_YES;
 }




 B aaStringRemoveChars                 (VP str,H chars,B ch)
 {
 BP bp;
 H off;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 aaCast(bp,BP,str);
 off=0;
 while(1)
  {
  if(bp[off]!=ch)   {   off++;   }
  else   {   aaStringDeleteChar(bp,0,off);   chars--;   }
  if(off>=chars) { /* bp[off]=NULL_CHAR;*/ break; }
  }
 return RET_YES;
 }




 B aaStringDespace                     (VP str,H chars)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 aaStringLen(str,&chars);
 if(chars==0) { return RET_YES; }
 aaStringReplaceChar(str,chars,HTAB_CHAR,SPACE_CHAR);
 aaStringRemoveSpaces(str,chars,YES,YES);
 aaStringRemoveMultipleSpaces(str,chars,YES);
 return RET_YES;
 }




 B aaStringFindFirstIStrings           (VP str,H chars,HP pos,HP len,NP which,...)
 {
 va_list ap;
 CP s;
 H ssl,dsl[128];
 H off[128];
 N j,w;
 N smallest_index;
 N smallest_offset;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(which==NULL) { return RET_BADPARM; }
 *which=-1;
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0)  { aaStringLen(str,&chars); }

 va_start(ap,which);
 w=0;
 aaStringLen(str,&ssl);
 while(1)
  {
  s=va_arg(ap,CP);
  if(s==NULL) { break; }
  aaStringLen(s,&dsl[w]);
  if(aaStringFindFirstIString(str,chars,s,dsl[w],&off[w])!=RET_YES) { off[w]=0xffffffff; }
  w++;
  }
 va_end(ap);
 smallest_index=-1;
 smallest_offset=1000000000;
 for(j=0;j<w;j++)
  {
  if(off[j]==0xffffffff) { continue; }
  if(off[j]<(H)smallest_offset) { smallest_index=j; smallest_offset=off[j]; continue; }
  }
 if(smallest_index==-1) { return RET_NO; }
 if(which) { *which=smallest_index; }
 if(pos)   { *pos=off[smallest_index]; }
 if(len)   { *len=dsl[smallest_index]; }
 return RET_YES;
 }




 B aaStringIsQuoted                    (VP str,H chars,BP qchar)
 {
 BP bp;
 B qc;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(qchar) *qchar=0;
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_NO; }
 aaCast(bp,BP,str);
 qc=0;
 if(bp[0]==DQUOTE_CHAR||bp[0]==SQUOTE_CHAR)  { qc=bp[0]; }
 if(qc)   {  if(qchar) *qchar=qc;  }
 if(chars<2) { return RET_NO; }
 if(bp[chars-1]==qc) { return RET_YES; }
 return RET_NO;
 }



 B aaStringIsBraced                    (VP str,H chars)
 {
 BP bp;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_NO; }
 aaCast(bp,BP,str);
 if(bp[0]!='{') { return RET_NO; }
 if(chars<2) { return RET_NO; }
 if(bp[chars-1]=='}') { return RET_YES; }
 return RET_NO;
 }



 B aaStringIsBracketed                 (VP str,H chars)
 {
 BP bp;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_NO; }
 aaCast(bp,BP,str);
 if(bp[0]!='[') { return RET_NO; }
 if(chars<2) { return RET_NO; }
 if(bp[chars-1]==']') { return RET_YES; }
 return RET_NO;
 }


 B aaStringIsParenthesized             (VP str,H chars)
 {
 BP bp;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_NO; }
 aaCast(bp,BP,str);
 if(bp[0]!='(') { return RET_NO; }
 if(chars<2) { return RET_NO; }
 if(bp[chars-1]==')') { return RET_YES; }
 return RET_NO;
 }



 B aaStringUnQuote                     (VP str,H chars,BP qchar)
 {
 B ret,qc;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 ret=aaStringIsQuoted(str,chars,&qc);
 if(qchar) { *qchar=qc; }
 if(ret!=RET_YES) { return ret;  }
 ret=aaStringContract(str,chars,1);
 if(ret!=RET_YES) { return ret;  }
 return RET_YES;
 }




 B aaStringQuotify                     (VP str,H chars,B qchar)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(qchar==0) { return RET_BADPARM; }
 if(chars==0)
  {
  aaStringCopyf(str,"%c%c",qchar,qchar);
  return RET_YES;
  }
 aaStringInsertChar(str,chars,0,qchar);
 aaStringAppendChar(str,qchar);
 return RET_YES;
 }



 B aaStringRandomSet                   (VP str,H chars,B alphalo,B alphahi,B numerical,B appendnull)
 {
 register BP bp;
 register BP vp;
 B val,ch;
 H ra,z;
 BP rp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { return RET_FAILED; }
 if(alphalo!=YES&&alphahi!=YES&&numerical!=YES) { return RET_BADPARM; }
 aaCast(bp,BP,str);
 while(1)
  {
  if(chars==0) { break; }
  if(chars>=4)
   {
   ra=aaMathTwisterInt32(&aa.math_system.twister);
   vp=(BP)&ra;
   for(z=0;z<4;z++)
    {
    ch=vp[z];
    if(alphahi==YES&&ra%3==0)   {    ch%=(B)26;   ch+=(B)'A';   *bp++=ch;      }  else
    if(alphalo==YES&&ra%3==1)   {    ch%=(B)26;   ch+=(B)'a';   *bp++=ch;      }  else
    if(numerical==YES&&ra%3==2) {    ch%=(B)10;   ch+=(B)'0';   *bp++=ch;      }
    else
     {
     if(alphahi==YES)   {    ch%=(B)26;   ch+=(B)'A';   *bp++=ch;      }  else
     if(alphalo==YES)   {    ch%=(B)26;   ch+=(B)'a';   *bp++=ch;      }  else
     if(numerical==YES) {    ch%=(B)10;   ch+=(B)'0';   *bp++=ch;      }  else oof;
     }
    }
   chars-=4;
   continue;
   }
  ra=aaMathTwisterInt32(&aa.math_system.twister);
  rp=(BP)&ra;
  val=rp[0];
  ch=val;
  if(alphahi==YES&&val%3==0)   {    ch%=(B)26;   ch+=(B)'A';   *bp++=ch;     }  else
  if(alphalo==YES&&val%3==1)   {    ch%=(B)26;   ch+=(B)'a';   *bp++=ch;      }  else
  if(numerical==YES&&val%3==2) {    ch%=(B)10;   ch+=(B)'0';   *bp++=ch;     }
  else
   {
   if(alphahi==YES)   {    ch%=(B)26;   ch+=(B)'A';   *bp++=ch;      }  else
   if(alphalo==YES)   {    ch%=(B)26;   ch+=(B)'a';   *bp++=ch;      }  else
   if(numerical==YES) {    ch%=(B)10;   ch+=(B)'0';   *bp++=ch;      }  else oof;
   }
  chars--;
  }
 if(appendnull)
  {
  *bp=NULL_CHAR;
  }
 return RET_YES;
 }






 B aaStringHashGet                     (VP str,H chars,HP hash,B iscasesensitive)
 {
 BP tmp=NULL_POINTR;
 BP ptr;
 B loctmp[_8K];
 B temp[_8K];
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(hash==NULL) { return RET_BADPARM; }
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(iscasesensitive==NO)
  {
  if(chars<sizeof(loctmp))
   {
   aaStringLower(str,chars,loctmp);
   aaCast(ptr,BP,loctmp);
   }
  else
   {
   aaCast(tmp,BP,temp);
   if(aa.is_ready==YES)
    {
    if((ret=aa_MemoryTemp((VP)&tmp,_256K,aa_MEMORYTEMP_StrHash))!=RET_YES) { return ret; }
    }
   else { oof; }
   aaStringLower(str,chars,tmp);
   aaCast(ptr,BP,tmp);
   }
  }
 else
  {
  aaCast(ptr,BP,str);
  }
 return(aaMemoryHashGet(ptr,chars,hash));
 }



 B aaStringHashIsTrue                  (VP str,H chars,H hash,B iscasesensitive)
 {
 B ret;
 H xh;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 xh=0;
 if((ret=aaStringHashGet(str,chars,&xh,iscasesensitive))!=YES) { return ret; }
 if(xh!=hash) { return RET_NO; }
 return RET_YES;
 }



 B aaStringHashBothGet                 (VP str,H chars,HP hash,HP hashi)
 {
 B ret;
 H xh;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(hash)
  {
  xh=0;
  if((ret=aaStringHashGet(str,chars,&xh,YES))!=YES) { return ret; }
  *hash=xh;
  }
 if(hashi)
  {
  xh=0;
  if((ret=aaStringHashGet(str,chars,&xh,NO))!=YES) { return ret; }
  *hashi=xh;
  }
 return RET_YES;
 }



 B aaStringHancock                     (VP str,H id)
 {
 B fn[100];
 B ln[100];
 B px[100];
 H oi,ia,ib,ic;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 id=id%2730;
 oi=id;
 ia=id+(oi%67);
 ia=ia%2;
 ib=id+(oi%21);
 ib=ib%26;
 aaStringCopyf(fn,"%s",aa_common_name[ia][ib]);
 ia=id+(oi%41);
 ia=ia%2;
 ib=id+(oi%13);
 ib=ib%26;
 aaStringCopyf(ln,"%s",aa_common_name[ia][ib]);
 ic=id+(oi%7);
 ic=ic%5;
 if(ic==0) { aaStringCopy(px,"son");   } else
 if(ic==1) { aaStringCopy(px,"smith"); } else
 if(ic==2) { aaStringCopy(px,"ly");    } else
 if(ic==3) { aaStringCopy(px,"child"); } else
 if(ic==4) { aaStringCopy(px,"ton");   }
 aaStringCopyf(str,"%s %s%s",fn,ln,px);
 return RET_YES;
 }




 B aaStringGuid                        (VP str,B appendnull)
 {
 H i,v;
 FILETIME ft;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 aaCast(bp,BP,str);
 GetSystemTimeAsFileTime(&ft);
 aaStringCopyf(bp,"%08lx",ft.dwLowDateTime);
 aaStringRandomSet(&bp[9],27,YES,NO,YES,appendnull);
 bp[8]='-';  bp[13]='-';
 bp[18]='-'; bp[23]='-';
 for(i=0;i<36;i++)
  {
  if(bp[i]>='g'&&bp[i]<='z')
   {
   aaMemoryRandomDwordSet(&v,0,15);
   if(v<10) {         bp[i]=(B)('0'+v); }
   else     {         bp[i]=(B)('a'+(v-10)); }
   }
  }
 return RET_YES;
 }




 B aaStringIsGuid                      (VP str)
 {
 H sl,count;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 aaStringLen(str,&sl);
 if(sl!=36) { return RET_NO; }
 aaCast(bp,BP,str);
 if(bp[8]!='-') { return RET_NO; }
 if(bp[13]!='-') { return RET_NO; }
 if(bp[18]!='-') { return RET_NO; }
 if(bp[23]!='-') { return RET_NO; }
 aaStringCountHex(&bp[0],8,&count,YES);
 if(count!=8) {  return RET_NO; }
 aaStringCountHex(&bp[14],4,&count,YES);
 if(count!=4) {  return RET_NO; }
 aaStringCountHex(&bp[19],4,&count,YES);
 if(count!=4) {  return RET_NO; }
 aaStringCountHex(&bp[24],12,&count,YES);
 if(count!=12) {  return RET_NO; }
 return RET_YES;
 }





 B aaStringFromWideString              (VP str,WCHAR*wstr)
 {
 WCHAR*wp;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 aaCast(bp,BP,str);
 bp[0]=NULL_CHAR;
 if(wstr==NULL) { return RET_BADPARM; }
 aaCast(wp,WCHAR*,wstr);
 while(1)
  {
  *bp=(B)((*wp)&F8);
  if(*bp==0) { break; }
  bp++;
  wp++;
  }
 return RET_YES;
 }




 B aaStringToWideString                (VP str,WCHAR*wstr)
 {
 WCHAR*wp;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(wstr==NULL) { return RET_BADPARM; }
 aaCast(bp,BP,str);
 aaCast(wp,WCHAR*,wstr);
 while(1)
  {
  *wp=(WCHAR)*bp;
  if(*bp==0) { break; }
  bp++;
  wp++;
  }
 return RET_YES;
 }




 B aaStringPathSanitize                 (VP str,H chars,VP ostr)
 {
 register BP s;
 register BP d;
 register H i;
 B last_char;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 aaCast(s,BP,str);
 if(ostr) { aaCast(d,BP,ostr); }
 else     { aaCast(d,BP,str);  }
 last_char=NULL_CHAR;
 for(i=0;i<chars;i++)
  {
  if(s[i]==NULL_CHAR) { break; }
  if(s[i]==BSLASH_CHAR) { d[i]=FSLASH_CHAR; }
  else                  { d[i]=(B)s[i]; }
  last_char=d[i];
  }
 if(last_char==FSLASH_CHAR)  { i--; }
 d[i]=NULL_CHAR;
 return RET_YES;
 }





 B aaStringRot13                       (VP str,H chars,VP ostr)
 {
 B u[]="ABCDEFGHIJKLMNOPQRSTUVWXYZ";
 B l[]="abcdefghijklmnopqrstuvwxyz";
 BP s,d;
 B ch;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 aaCast(s,BP,str);
 if(ostr) { aaCast(d,BP,ostr); }
 else     { aaCast(d,BP,str); }
 while(1)
  {
  ch=*s;
  if(ch>='A'&&ch<='Z') { ch-=(B)'A'; ch+=(B)13; ch%=(B)26; ch=u[ch]; }
  else
  if(ch>='a'&&ch<='z') { ch-=(B)'a'; ch+=(B)13; ch%=(B)26; ch=l[ch]; }
  *d=ch;
  chars--;
  if(chars==0) { d++; *d=NULL_CHAR; break; }
  d++;
  s++;
  }
 return RET_YES;
 }



 B aaStringTranspose                   (VP str,H chars,N amnt,VP ostr)
 {
 BP s,d;
 N ch;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 aaCast(s,BP,str);
 if(ostr) { aaCast(d,BP,ostr); }
 else     { aaCast(d,BP,str); }
 while(1)
  {
  ch=*s;
  ch+=amnt;
  *d=(B)ch;
  chars--;
  if(chars==0) { d++; *d=NULL_CHAR; break; }
  d++;
  s++;
  }
 return RET_YES;
 }





 B aaStringFromDword                   (VP str,H val)
 {
 BP bp;
 BP sp;
 H i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 aaCast(bp,BP,&val);
 aaCast(sp,BP,str);
 sp[0]=bp[0];
 sp[1]=bp[1];
 sp[2]=bp[2];
 sp[3]=bp[3];
 sp[4]=NULL_CHAR;
 for(i=0;i<4;i++)
  {
  if(sp[i]<SPACE_CHAR) { sp[i]=SPACE_CHAR; }
  else
  if(sp[i]>127)        { sp[i]=SPACE_CHAR; }
  }
 return RET_YES;
 }





 B aaStringFromArrayHex                (VP str,H sizet,H count,H cols,B dooffs,B doascii,VP mem)
 {
 H i,j;
 BP dp;
 BP bpi;
 WP wpi;
 HP hpi;
 B ascii;
 B txt[_32K];
 H brk;
 B freshline=YES;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(str==NULL) { return RET_BADPARM; }
 aaStringNull(str);
 if(mem==NULL) { return RET_BADPARM; }
 if(count==0) { return RET_YES; }
 if(sizet!=0&&sizet!=1&&sizet!=2&&sizet!=4&&sizet!=8) { return RET_BADPARM; }

 aaCast(dp,BP,str);
 aaCast(bpi,BP,mem);
 aaCast(wpi,WP,mem);
 aaCast(hpi,HP,mem);
 if(cols<1) { cols=1; }
 else
 if(cols>64) { cols=64; }
 brk=cols;
 j=0;
 if(sizet==0)
  {
  for(i=0;i<count;i++)
   {
   if(aaCharIsVisible(bpi[i])==YES) { aaStringAppendf(dp,"%c  ",bpi[i]); }
   else                             { aaStringAppendf(dp,"_  "); }
   if((i%8)==7) { aaStringAppendf(dp," "); }
   if((i%brk==(brk-1)))     { aaStringAppendf(dp,"\r\n"); }
   }
  }
 else
 if(sizet==1)
  {
  for(i=0;i<count;i++)
   {
   if(freshline)
    {
    if(dooffs) { aaStringAppendf(dp,"%04x: ",i); }
    freshline=NO;
    }
   aaStringAppendf(dp,"%02X ",bpi[i]);
   if((i%8)==7) { aaStringAppendf(dp," "); }
   if(doascii)
    {
    ascii=bpi[i];
    if(aaCharIsVisible(ascii)&&ascii<127) { txt[j]=ascii;  }   else    if(ascii==32)                         { txt[j]=ascii;  }   else    { txt[j]='.'; }
    j++;
    txt[j]=NULL_CHAR;
    }
   if((i%brk==(brk-1)))
    {
    if(doascii)
     {
     aaStringAppendf(dp,"   ");
     aaStringAppendf(dp,"%s",txt);
     j=0;
     }
    aaStringAppendf(dp,"\r\n");
    freshline=YES;
    }
   }
  if(doascii&&j!=0)
   {
   for(i=j;i<(brk);i++)
    {
    aaStringAppendf(dp,"   ");
    if((i%8)==7)
     {
     aaStringAppendf(dp," ");
     }
    }
   aaStringAppendf(dp,"   ");
   aaStringAppendf(dp,"%s",txt);
   }
  }
 else
 if(sizet==2)
  {
  for(i=0;i<count;i++)
   {
   aaStringAppendf(dp,"%04X ",wpi[i]);
   if((i%8)==7) { aaStringAppendf(dp," "); }
   if(doascii)
    {
    ascii=bpi[i];
    if(aaCharIsVisible(ascii)&&ascii<127) { txt[j]=ascii;  }   else    if(ascii==32) { txt[j]=ascii;  }   else    { txt[j]='.'; }  j++; txt[j]=NULL_CHAR;
    }
   if((i%brk==(brk-1)))
    {
    if(doascii) { aaStringAppendf(dp,"%s",txt);  j=0; }
    aaStringAppendf(dp,"\r\n");
    }
   }
  }
 else
 if(sizet==4)
  {
  for(i=0;i<count;i++)
   {
   aaStringAppendf(dp,"%08LX ",hpi[i]);
   if((i%8)==7) { aaStringAppendf(dp," "); }
   if(doascii)
    {
    ascii=bpi[i];
    if(aaCharIsVisible(ascii)&&ascii<127) { txt[j]=ascii;  }   else    if(ascii==32)                         { txt[j]=ascii;  }   else    { txt[j]='.'; }  j++; txt[j]=NULL_CHAR;
    }
   if((i%brk==(brk-1)))
    {
    if(doascii) { aaStringAppendf(dp,"%s",txt);  j=0; }
    aaStringAppendf(dp,"\r\n");
    }
   }
  }
 else
 if(sizet==8)
  {
  for(i=0;i<count;i++)
   {
   if((i%8)==7) { aaStringAppendf(dp," "); }
   if(doascii)
    {
    ascii=bpi[i];
    if(aaCharIsVisible(ascii)&&ascii<127) { txt[j]=ascii;  }   else    if(ascii==32)                         { txt[j]=ascii;  }   else    { txt[j]='.'; }  j++; txt[j]=NULL_CHAR;
    }
   if((i%brk==(brk-1)))
    {
    if(doascii) { aaStringAppendf(dp,"%s",txt);  j=0; }
    aaStringAppendf(dp,"\r\n");
    }
   }
  }
 return RET_YES;
 }






 B aaStringHexDump                     (VP str,H sizet,H count,H cols,B dooffs,B doascii,VP buf,VP fmt,...)
 {
 BP bp;
 H todo,left,off;
 H bound;
 B txt[_16K];
 B spc[_1K];
 //va_list argptr;
 //aaVargsf4K(fmt);
 //B temp[_4K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 //aaFmt(fmt,argptr,temp);
 aaVargsf4K(fmt);
 if(buf==NULL) { return RET_BADPARM; }
 if(str==NULL) { return RET_BADPARM; }
 aaStringNull(str);
 if(count==0) { aaStringLen(buf,&count); }
 if(count>(_32K-32)) { oof; }
 aaCast(bp,BP,buf);
 off=0;
 left=count;
 if(str4k.len!=0) { aaStringAppendf(str,"%s:  ",str4k.buf); aaStringFill(spc,str4k.len,32,YES); }
 //if(aaStringIsNull(temp)==NO) { aaStringAppendf(str,"%s\r\n",temp); }
 aaStringNull(txt);
 while(1)
  {
  if(left==0) { break; }
  bound=aaNumRoof(left,cols);
  todo=aaNumRoof(left,bound);
  aaStringFromArrayHex(txt,sizet,todo,cols,NO,doascii,&bp[off]);
  aaStringLastCharNonVisibleRemove(txt,0);
  if(dooffs)   {   aaStringAppendf(str,"%05u: ",off);   }
  else         {   }
  aaStringAppendf(str,"%s",txt);
  left-=todo;
  if(left!=0)
   {
   aaStringAppendf(str,"\r\n");
   if(str4k.len!=0) { aaStringAppendf(str,"%s:  ",spc); }
   }
  if(sizet==0) { off+=(todo*1); }
  else         { off+=(todo*sizet); }
  }
 return RET_YES;
 }





 B aaStringSplit                       (VP str,H chars,H pos,B incsplit,VP str1,VP str2)
 {
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(str1==NULL&&str2==NULL)
  {
  aaCast(bp,BP,str);
  if(incsplit) {   bp[pos+1]=NULL_CHAR; }
  else         {    bp[pos]=NULL_CHAR; }
  return RET_YES;
  }
 if(str1)
  {
  if(incsplit) {  aaStringNCopy(str1,str,pos+1,YES); }
  else         {  aaStringNCopy(str1,str,pos,YES); }
  }
 if(str2)
  {
  aaCast(bp,BP,str);
  if(incsplit) { aaStringCopy(str2,&bp[pos]); }
  else         { aaStringCopy(str2,&bp[pos+1]);  }
  }
 return RET_YES;
 }



 B aaStringSplitChar                   (VP str,H chars,B ch,B incsplit,B logic,H number,B fwd,VP str1,VP str2)
 {
 B ret;
 H pos;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if((ret=aaStringFindChar(str,chars,&pos,ch,logic,number,fwd))!=YES) { return ret;  }
 return(aaStringSplit(str,chars,pos,incsplit,str1,str2));
 }





 B aaStringExplode                     (VP str,H chars,_stringexplode*explode,B dch)
 {
 B ret;
 H i,count,off,pos,cando,mx;
 BP tmp=NULL_POINTR;
 B temp[_64K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(explode==NULL) { return RET_BADPARM; }
 aaMemoryFill(explode,sizeof(_stringexplode),0);
 if(str==NULL) { return RET_BADPARM; }
 if(dch==0) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 mx=sizeof(explode->off)/sizeof(explode->off[0]);
 aaCast(tmp,BP,temp);
 if(aa.is_ready==YES)
  {
  if((ret=aa_MemoryTemp((VP)&tmp,_256K,aa_MEMORYTEMP_StrExplode))!=RET_YES) { return ret; }
  }
 aaStringNCopy(tmp,str,chars,YES);
 aaStringRemoveSpaces(tmp,0,YES,YES);
 aaStringRemoveMultipleSpaces(tmp,0,NO);
 aaStringLen(tmp,&chars);
 aaStringCountChars(tmp,0,&count,dch,NO,YES);
 count++;
 count=aaNumRoof(count,mx);
 off=0;
 for(i=0;i<count;i++)
  {
  aaStringFindChar(&tmp[off],0,&pos,dch,YES,0,YES);
  explode->off[i]=off;
  if(pos==0xffffffff) { aaStringLen(&tmp[off],&pos); }
  cando=pos;
  explode->len[i]=cando;
  if(explode->len[i]>1&&tmp[off]=='-'&&(tmp[off+1]>='0'&&tmp[off+1]<='9'))
   {
   if(aaStringIsNumerical(&tmp[off+1],0,0,cando-1)==YES)
    {
    aaStringToNumber(&tmp[off+1],cando-1,&explode->value[explode->count],0,0,0);
    explode->type[explode->count]=2;
    }
   }
 else
  if(explode->len[i]>1&&tmp[off]=='+'&&(tmp[off+1]>='0'&&tmp[off+1]<='9'))
   {
   if(aaStringIsNumerical(&tmp[off+1],0,0,cando-1)==YES)
    {
    aaStringToNumber(&tmp[off+1],cando-1,&explode->value[explode->count],0,0,0);
    explode->type[explode->count]=1;
    }
   }
  else
  if(explode->type[explode->count]==0)
   {
   if(aaStringIsNumerical(&tmp[off],0,0,cando)==YES)
    {
    aaStringToNumber(&tmp[off],cando,&explode->value[explode->count],0,0,0);
    explode->type[explode->count]=1;
    }
   }
  explode->count++;
  if(pos==0xffffffff) { break; }
  off+=(pos);  aaStringFindChar(&tmp[off],0,&pos,dch,NO,0,YES);
  off+=(pos);
  }
 explode->off[i]=off+1;
 return RET_YES;
 }





 B aaStringExplodeTokenGet             (VP str,H index,_stringexplode*explode,VP token)
 {
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(token==NULL) { return RET_BADPARM; }
 aaStringNull(token);
 if(explode==NULL) { return RET_BADPARM; }
 if(str==NULL) { return RET_BADPARM; }
 if(index>=explode->count) { return RET_BOUNDS; }
 aaCast(bp,BP,str);
 if((index+1)==explode->count)
  {
  aaStringNCopy(token,&bp[explode->off[index]],explode->len[index]+1,YES);
  }
 else
  {
  aaStringNCopy(token,&bp[explode->off[index]],explode->len[index],YES);
  }
 return RET_YES;
 }






 B aaStringExplodePtrGet               (VP str,H index,_stringexplode*explode,PP token)
 {
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(token==NULL) { return RET_BADPARM; }
 *token=NULL;
 if(explode==NULL) { return RET_BADPARM; }
 if(str==NULL) { return RET_BADPARM; }
 if(index>=explode->count) { return RET_BOUNDS; }
 aaCast(bp,BP,str);
 *token=&bp[explode->off[index]];
 return RET_YES;
 }




 B aaStringEncode                      (VP str,H chars,VP ostr,B appendnull,VP ignorecharlist)
 {
 BP dp;
 BP sp;
 N lo,hi;
 H i,j,k;
 B ch=0;
 B ret;
 BP il;
 BP tmp=NULL_POINTR;
 H icl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if((ret=aa_MemoryTemp((VP)&tmp,_256K,aa_MEMORYTEMP_StrEncode))!=RET_YES) {oops; }
 if(ostr==NULL||ostr==str) { aaCast(dp,BP,tmp); }
 else                      { aaCast(dp,BP,ostr); }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { dp[0]=NULL_CHAR; return RET_YES; }
 aaStringLen(ignorecharlist,&icl);
 il=(BP)ignorecharlist;

 aaCast(sp,BP,str);
 j=0;
 for(i=0;i<chars;i++)
  {
  ch=sp[i];
  if(aaCharIsAlphaNum(ch)==YES||ch=='_')
   {
   dp[j]=ch; j++;
   continue;
   }
  for(k=0;k<icl;k++)
   {
   if(ch==il[k]) {  break;   }
   }
  if(k!=icl&&icl!=0)
   {
   dp[j]=ch; j++;
   continue;
   }
  dp[j]='%'; j++;
  hi=(ch/16);
  lo=(ch%16);
  if(hi<10) { hi='0'+hi; }
  else      { hi='A'+(hi-10); }
  if(lo<10) { lo='0'+lo; }
  else      { lo='A'+(lo-10); }
  dp[j]=(B)hi; j++;
  dp[j]=(B)lo; j++;
  if(ch==NULL_CHAR) { break; }
  }
 if(appendnull&&ch!=NULL_CHAR) { dp[j]=NULL_CHAR; j++; }
 if(dp==tmp)
  {
  if(ostr==NULL) { aaMemoryCopy(str,j,tmp); }
  else           { aaMemoryCopy(ostr,j,tmp); }
  }
 return RET_YES;
 }




 B aa_StringDecode                      (VP str,H chars,VP ostr,B appendnull)
 {
 B ret;
 BP dp;
 BP sp;
 BP tmp;
 N lo,hi;
 H i,j;
 B ch=0;
 B usingtemp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if((ret=aa_MemoryTemp((VP)&tmp,_256K,aa_MEMORYTEMP_StrDecode))!=RET_YES) {oops; }
 if(ostr==NULL||ostr==str) { aaCast(dp,BP,tmp); usingtemp=YES; }
 else                      { aaCast(dp,BP,ostr); usingtemp=NO; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { dp[0]=NULL_CHAR; return RET_YES; }
 aaCast(sp,BP,str);
 j=0;
 for(i=0;i<chars;i++)
  {
  ch=*sp;
  if(ch==0x25)
   {
   if(aaCharIsHex(sp[1])&&aaCharIsHex(sp[2]))
    {
    sp++;
    hi=sp[0];
    lo=sp[1];
    if('0'<=hi&&hi<='9') { hi-='0'; }    else
    if('a'<=hi&&hi<='f') { hi-=('a'-10); }    else
    if('A'<=hi&&hi<='F') { hi-=('A'-10); }
    if('0'<=lo&&lo<='9') { lo-='0'; }    else
    if('a'<=lo&&lo<='f') { lo-=('a'-10); }    else
    if('A'<=lo&&lo<='F') { lo-=('A'-10); }
    *dp=(B)(lo+(16*hi));
    dp++;
    sp+=2;
    j++;
    }
   else
    {
    *dp=ch;
    dp++;
    sp++;
    j++;
    }
   }
  else { *dp=ch; dp++; sp++;  j++; }
  if(ch==NULL_CHAR) { break; }
  }
 if(appendnull&&ch!=NULL_CHAR) { *dp=NULL_CHAR; j++; }
 if(usingtemp==YES)
  {
  if(ostr==NULL) { aaMemoryCopy(str,j,tmp); }
  else           { aaMemoryCopy(ostr,j,tmp); }
  }
 return RET_YES;
 }





 B aaStringDecode                      (VP str,H chars,VP ostr,B fully,B appendnull)
 {
 B ret;
 BP tmpa,tmpb;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 fully&=1;
 if((ret=aa_MemoryTemp((VP)&tmpa,_512K,aa_MEMORYTEMP_StringDecodeA))!=RET_YES) {oops; }
 if((ret=aa_MemoryTemp((VP)&tmpb,_512K,aa_MEMORYTEMP_StringDecodeB))!=RET_YES) {oops; }
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0)
  {
  if(appendnull)
   {
   if(ostr!=NULL)  {    bp=(BP)ostr;    bp[0]=NULL_CHAR;    }
   }
  return RET_YES;
  }
 aaStringNCopy(tmpa,str,chars,YES);
 while(1)
  {
  if((ret=aa_StringDecode(tmpa,chars,tmpb,appendnull))!=RET_YES) { return ret; }
  if(fully!=YES) { break; }
  if(aaStringCompare(tmpa,tmpb,0)==YES) { break; }
  aaStringCopy(tmpa,tmpb);
  }
 if(ostr) { aaStringCopy(ostr,tmpb); }
 else     { aaStringCopy(str,tmpa); }
 return RET_YES;
 }


/*
static const htmlentity_t ent[] =
{
	{ "lt",     "<" },	{ "gt",     ">" },	{ "amp",    "&" },	{ "apos",   "'" },
	{ "quot",   "\"" },	{ "aacute", "" },	{ "eacute", "" },	{ "iacute", "" },
	{ "oacute", "" },	{ "uacute", "" },	{ "agrave", "" },	{ "egrave", "" },
	{ "igrave", "" },	{ "ograve", "" },	{ "ugrave", "" },	{ "acirc",  "" },
	{ "ecirc",  "" },	{ "icirc",  "" },	{ "ocirc",  "" },	{ "ucirc",  "" },
	{ "auml",   "" },	{ "euml",   "" },	{ "iuml",   "" },	{ "ouml",   "" },
	{ "uuml",   "" },	{ "nbsp",   " " },	{ "",        ""  }
};

*/


 B aaStringEntityToPseudoEnglish       (VP str,H chars,VP ostr)
 {
 BP s,d;
 H val,num,i;
 B ok,ascii;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 aaCast(s,BP,str);
 if(ostr) { aaCast(d,BP,ostr); }
 else       { aaCast(d,BP,str);  }
 while(1)
  {
  if(*s==NULL_CHAR)   {   *d=NULL_CHAR;   break;   }
  while(1)
   {
   ok=YES;
   if(chars==0) { break; }
   if(s[0]!='&'||s[1]!='#'||s[2]!='x') { break; }
   if(chars<2) { break; }
   aaStringCountHex(&s[3],chars,&val,YES);
   if(val==0)  {  break; }
   if(s[3+val]!=';') { break; }
   aaStringHexToNumber(&s[3],val,&num,0,NULL,NULL);
     switch(num)
      {
      default:
      ascii=2; break;
      case 1489:   case 1500:   case 1496:   case 1512:   case 1493:    case 1497:     case 1505:      case 1507: ascii=''; break;

      case 37041: case 20896:   case 23431: ascii='i'; break;
      case 65533: ascii='i'; break;
      case 216: ascii='O'; break;
      case 222: ascii='D'; break;
      case 322: ascii='l'; break;
      case 324: ascii='n'; break;
      case 351: ascii='s'; break;
      case 382: ascii='z'; break;
      case 231: ascii='c'; break;
      case 241: ascii='n'; break;
      case 248: ascii='o'; break;
      case 250: ascii='u'; break;
      case 263: ascii='c'; break;
      case 224: case 225:      case 226:      case 227:  case 228:   case 229: ascii='a'; break;
      case 192: case 193:      case 194:      case 195:  case 196: ascii='A'; break;
      case 232: case 233:      case 234:      case 235:  ascii='e'; break;
      case 200: case 201:      case 202:      case 203:  ascii='E'; break;
      case 236: case 237:      case 238:      case 239:  ascii='i'; break;
      case 204: case 205:      case 206:      case 207:  ascii='I'; break;
      case 242: case 243:      case 244:      case 245:  case 246: ascii='o'; break;
      case 210: case 211:      case 212:      case 213:  case 214: ascii='O'; break;
      case 249: case 253:      case 251:      case 252: ascii='u'; break;
      case 217: case 221:      case 219:      case 220: ascii='O'; break;
      case 255: ascii='y'; break;
      case 159: ascii='Y'; break;
      }
   *d=ascii;
   s+=(3+val+1);
   chars-=(3+val+1);
   d++;
   ok=NO;
   break;
   }
  if(ok==YES) { for(i=0;i<1;i++) { *d=*s; s++; d++; chars--; } continue; }
  }
 return RET_YES;
 }



 B aaStringLineCountGet                (VP str,H chars,HP lines)
 {
 H ln,mode,j;
 B cch,nch;
 _parser pa;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(lines) { *lines=0; }
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 aaParserInit(&pa,str,chars);
 ln=0;
 for(;;)
  {
  j=mode=0;
  do
   {
   if((pa.offset+j)>=pa.length) { break; }
   cch=pa.bp[j];
   if(cch<=CR_CHAR)
    {
    if(cch==NULL_CHAR) { mode=0; break; }
    if(cch==CR_CHAR||cch==LF_CHAR)
     {
     nch=pa.bp[j+1];
     mode=2;
     if(cch==CR_CHAR&&nch==LF_CHAR) {   break; }
     if(cch==LF_CHAR&&nch==CR_CHAR) {   break; }
     mode=1;
     break;
     }
    }
   j++;
   }
  while(1);
  ln++;
  if(mode==0) {  break; }
  aaParserSeek(&pa,j+mode);
  }
 if(lines) { *lines=ln; }
 return RET_YES;
 }









 B aaStringLineCountGetToMemory        (VP str,H chars,HP lines,H maxinfolines,PP lineoff,PP linechars)
 {
 B ret;
 H ln,mode,j;
 B cch,nch;
 _parser pa;
 H add,slots,left;
 HP lnof,lnch;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(lines)     { *lines=0; }
 if(lineoff)   { *lineoff=0; }
 if(linechars) { *linechars=0; }
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 aaParserInit(&pa,str,chars);
 add=_8K;
 slots=0;
 lnof=lnch=NULL;
 if(lineoff)    {  if((ret=aaMemoryAllocate((VP)&lnof,(slots+add)*sizeof(H)))!=YES) { oops; }  }
 if(linechars)  {  if((ret=aaMemoryAllocate((VP)&lnch,(slots+add)*sizeof(H)))!=YES) { oops; }  }
 aaMemoryNameSet(lnof,"lnof");
 aaMemoryNameSet(lnch,"lnch");
 slots+=add;
 ln=0;
 for(;;)
  {
  j=mode=0;
  do
   {
   if((pa.offset+j)>=pa.length) { break; }
   cch=pa.bp[j];
   if(cch<=CR_CHAR)
    {
    if(cch==NULL_CHAR) {  mode=0; break; }
    if(cch==CR_CHAR||cch==LF_CHAR)
     {
     nch=pa.bp[j+1];
     mode=2;
     if(cch==CR_CHAR&&nch==LF_CHAR) {   break; }
     if(cch==LF_CHAR&&nch==CR_CHAR) {   break; }
     mode=1;
     break;
     }
    }
   j++;
   }
  while(1);
  if(mode==0) {  break; }
  left=slots-ln;
  if(ln<maxinfolines)
   {
   if(lineoff||linechars)
    {
    if(left<(add/10))
     {
     if(lineoff)     {     if((ret=aaMemoryReAllocate((VP)&lnof,(slots+(add))*sizeof(H)))!=YES) { oops; }     }
     if(linechars)   {     if((ret=aaMemoryReAllocate((VP)&lnch,(slots+(add))*sizeof(H)))!=YES) { oops; }     }
     slots+=(add);
     }
    if(lineoff)   { lnof[ln]=pa.offset; }
    if(linechars) { lnch[ln]=j; }
    }
   }
  ln++;
  aaParserSeek(&pa,j+mode);
  }
 if(lines) { *lines=ln; }
 if(ln!=0)
  {
  if(lineoff) { *lineoff=lnof; }
  if(linechars) { *linechars=lnch; }
  }
 return RET_YES;
 }





 B aaStringLineCountGetToBuffer        (VP str,H chars,HP lines,H maxinfolines,HP lineoff,HP linechars)
 {
 _parser pa;
 H mode,j,l;
 B cch,nch;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(lines) { *lines=0; }
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 aaParserInit(&pa,str,chars);
 l=0;
 for(;;)
  {
  j=mode=0;
  do
   {
   if((pa.offset+j)>=pa.length) { break; }
   cch=pa.bp[j];
   if(cch<=CR_CHAR)
    {
    if(cch==NULL_CHAR) {  mode=0; break; }
    if(cch==CR_CHAR||cch==LF_CHAR)
     {
     nch=pa.bp[j+1];
     mode=2;
     if(cch==CR_CHAR&&nch==LF_CHAR) {   break; }
     if(cch==LF_CHAR&&nch==CR_CHAR) {   break; }
     mode=1;
     break;
     }
    }
   j++;
   }
  while(1);
  //if(mode==0) {  break; }
  if(l<maxinfolines)
   {
   if(lineoff)   { lineoff[l]=pa.offset; }
   if(linechars) { linechars[l]=j; }
   }
  l++;
  if(mode==0) {  break; }
  aaParserSeek(&pa,j+mode);
  }
 if(lines) { *lines=l; }
 return RET_YES;
 }






 B aaStringLineGet                     (VP str,H chars,HP strchars,HP modechars,HP totchars,BP mode)
 {
 B m;
 H mc,i;
 H pos;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(modechars) { *modechars=0; }
 if(strchars) { *strchars=0; }
 if(totchars) { *totchars=0; }
 if(mode) { *mode=0; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 bp=(BP)str;
 for(i=0;i<chars;i++)
  {
  if(bp[i]==CR_CHAR||bp[i]==LF_CHAR) { break; }
  }
 if(i==chars)
  {
  if(mode) { *mode=aa_STRINGMODE_NULL; }
  if(strchars) { *strchars=chars;  }
  if(totchars) { *totchars=chars;  }
  if(modechars) { *modechars=0; }
  return RET_YES;
  }
 pos=i;

 bp=(BP)str;
 m=0;
 mc=0;
 if(bp[pos+0]==CR_CHAR&&bp[pos+1]==LF_CHAR) { m=aa_STRINGMODE_CRLF; }  else
 if(bp[pos+0]==LF_CHAR&&bp[pos+1]==CR_CHAR) { m=aa_STRINGMODE_LFCR; }  else
 if(bp[pos+0]==CR_CHAR)                     { m=aa_STRINGMODE_CR;   }  else
 if(bp[pos+0]==LF_CHAR)                     { m=aa_STRINGMODE_LF;   }
 if(m==aa_STRINGMODE_LFCR||m==aa_STRINGMODE_CRLF) { mc=2; }  else
 if(m==aa_STRINGMODE_CR||m==aa_STRINGMODE_LF)     { mc=1; }
 if(m!=0&&mc!=0)
  {
  if(strchars) { *strchars=pos; }
  if(totchars) { *totchars=pos+mc; }
  }
 if(mode) { *mode=m; }
 if(modechars) { *modechars=mc; }
 return RET_YES;
 }





 B aaStringLineTrim                    (VP str,H chars,VP ostr)
 {
 BP s;
 H pos;
 B overwrite;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 aaCast(s,BP,str);
 //aaCast(tmp,BP,temp);
 if(ostr)  {  overwrite=NO;  }
 else      {  overwrite=YES; }
 aaStringFindCharList(s,chars,&pos,"\r\n",YES,0,YES-1);
 if(pos!=0xffffffff)
  {
  if(s[pos+0]==CR_CHAR&&s[pos+1]==LF_CHAR)  { chars=pos;   } else
  if(s[pos+0]==LF_CHAR)                     { chars=pos;   } else
  if(s[pos+0]==CR_CHAR)                     { chars=pos;   } else { oof; }
  }
 else
  {
  chars=0;
  }
 if(overwrite==YES)  {  s[chars]=NULL_CHAR;  }
 else                {  aaStringNCopy(ostr,str,chars,YES);  }
 return RET_YES;
 }




 B aaStringMatchCount                  (VP str,H chars,VP fstr,H fchars,B iscasesensitive,HP count,B logic)
 {
 BP s,d;
 H c;
 B sch,dch;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(count==NULL) { return RET_BADPARM; }
 *count=0;
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0)  { aaStringLen(str,&chars); }
 if(fstr==NULL) { return RET_BADPARM; }
 if(fchars==0)  {  aaStringLen(fstr,&fchars); }
 aaCast(s,BP,str);
 aaCast(d,BP,fstr);
 c=0;
 while(1)
  {
  if(c>=chars) { break; }
  if(c>=fchars) { break; }
  sch=s[c];
  dch=d[c];
  if(iscasesensitive==NO)
   {
   if(sch>='A'&&sch<='Z') { sch+=(B)32; }
   if(dch>='A'&&dch<='Z') { dch+=(B)32; }
   }
  if((sch!=dch&&logic==YES)||(sch==dch&&logic==NO))   {   break;   }
  c++;
  }
 *count=c;
 return RET_YES;
 }


 B aaStringLengthModeAdjust            (B mode,H chars,B addflag,HP adjustedchars)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(adjustedchars==NULL) { return RET_BADPARM; }
 *adjustedchars=chars;
 if(addflag)
  {
  if(mode==aa_STRINGMODE_CR||mode==aa_STRINGMODE_LF) { chars=chars+1; }
  else
  if(mode==aa_STRINGMODE_CRLF||mode==aa_STRINGMODE_LFCR) { chars=chars+2; }
  else
  if(mode==aa_STRINGMODE_NULL) { chars=chars+0;  }
  else { return RET_FAILED; }
  }
 else
  {
  if(mode==aa_STRINGMODE_CR||mode==aa_STRINGMODE_LF) { chars=chars-1; }
  else
  if(mode==aa_STRINGMODE_CRLF||mode==aa_STRINGMODE_LFCR) { chars=chars-2; }
  else
  if(mode==aa_STRINGMODE_NULL) { chars=chars-0;  }
  else { return RET_FAILED; }
  }
 *adjustedchars=chars;
 return RET_YES;
 }



 B aaStringToker                       (VP str,H chars,_stringtoker*toker,B dohash,B dobuf)
 {
 _parser pa,pb;
 B ascii;
 H i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(toker==NULL) { return RET_BADPARM; }
 toker->count=0;
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_NOTREADY; }
 aaParserInit(&pa,str,chars);
 while(1)
  {
  if(pa.is_end) { break; }
  if(toker->count>=32) { break; }
  if(aaParserSeekToVisibleChar(&pa,YES,YES)!=YES) { break; }
  aaParserCopy(&pb,&pa,NO);
  ascii=pa.ch;
  if(ascii==',')
   {
   aaParserSeek(&pa,1);
   continue;
   }

  if(ascii==SQUOTE_CHAR||ascii==DQUOTE_CHAR)
   {
   aaParserSeek(&pb,1);
   aaParserSeekToChar(&pb,ascii,YES,YES);
   aaParserSeek(&pb,1);
   }
  else
   {
   for(i=0;i<pb.to_end;i++)
    {
    if(aaCharIsVisible(pb.bp[i])==NO) { break; }
    if(pb.bp[i]==',')                 { break; }
    ascii=pa.bp[i];
    if(ascii==SQUOTE_CHAR||ascii==DQUOTE_CHAR)     {     break;     }
    }
   aaParserSeek(&pb,i);
   }
  toker->sl[toker->count]=pb.offset-pa.offset;
  if(toker->sl[toker->count]==0||toker->sl[toker->count]>=_1K) { return RET_CORRUPTED; }
  toker->off[toker->count]=pa.offset;
  toker->ptr[toker->count]=(BP)pa.bp;
  if(dobuf) { aaStringNCopy(toker->buf[toker->count],pa.bp,toker->sl[toker->count],YES); }
  toker->hashs[toker->count]=toker->hashi[toker->count]=0;
  if(aaBitGet(dohash,0)) { aaStringHashGet(toker->buf[toker->count],toker->sl[toker->count],&toker->hashs[toker->count],YES); }
  if(aaBitGet(dohash,1)) { aaStringHashGet(toker->buf[toker->count],toker->sl[toker->count],&toker->hashi[toker->count],NO); }
  toker->count++;
  aaParserCopy(&pa,&pb,NO);
  }
 if(toker->count==0) { return RET_NOTREADY; }
 return RET_YES;
 }




 B aaStringTokerMini                   (VP str,H chars,_stringtokermini*tokermini)
 {
 _parser pa,pb;
 B ascii;
 H i;
 B buf[_64K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(tokermini==NULL) { return RET_BADPARM; }
 tokermini->count=0;
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_NOTREADY; }
 aaParserInit(&pa,str,chars);
 while(1)
  {
  if(pa.is_end) { break; }
  if(tokermini->count>=64) { break; }
  if(aaParserSeekToVisibleChar(&pa,YES,YES)!=YES) { break; }
  aaParserCopy(&pb,&pa,NO);
  ascii=pa.ch;
  if(ascii==SQUOTE_CHAR||ascii==DQUOTE_CHAR)
   {
   aaParserSeek(&pb,1);
   aaParserSeekToChar(&pb,ascii,YES,YES);
   aaParserSeek(&pb,1);
   }
  else
   {
   for(i=0;i<pb.to_end;i++)
    {
    if(aaCharIsVisible(pb.bp[i])==NO) { break; }
    ascii=pa.bp[i];
    if(ascii==SQUOTE_CHAR||ascii==DQUOTE_CHAR)     {     break;     }
    }
   aaParserSeek(&pb,i);
   }
  tokermini->sl[tokermini->count]=pb.offset-pa.offset;
  if(tokermini->sl[tokermini->count]==0||tokermini->sl[tokermini->count]>=_1K) { return RET_CORRUPTED; }
  tokermini->off[tokermini->count]=pa.offset;
  tokermini->ptr[tokermini->count]=(BP)pa.bp;
  tokermini->hashs[tokermini->count]=tokermini->hashi[tokermini->count]=0;
  aaStringNCopy(buf,pa.bp,tokermini->sl[tokermini->count],YES);
  aaStringHashGet(buf,tokermini->sl[tokermini->count],&tokermini->hashs[tokermini->count],YES);
  aaStringHashGet(buf,tokermini->sl[tokermini->count],&tokermini->hashi[tokermini->count],NO);
  tokermini->count++;
  aaParserCopy(&pa,&pb,NO);
  }
 if(tokermini->count==0) { return RET_NOTREADY; }
 return RET_YES;
 }




 B aaStringTokerMiniStringGet          (VP str,H index,H maxchars,_stringtokermini*tokermini)
 {
 H todo;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 aaStringNull(str);
 if(index>=aaElementCount(tokermini->ptr)) { return RET_BOUNDS; }
 if(tokermini==NULL) { return RET_BADPARM; }
 if(index>=tokermini->count) { return RET_BOUNDS; }
 todo=tokermini->sl[index];
 todo=aaNumRoof(todo,maxchars-1);
 if(todo==0) { return RET_YES; }
 aaStringNCopy(str,tokermini->ptr[index],todo,YES);
 return RET_YES;
 }


 B aaStringTokerMaxiStringGet          (VP str,H index,H maxchars,_stringtokermaxi*tokermaxi)
 {
 H todo;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 aaStringNull(str);
 if(index>=aaElementCount(tokermaxi->ptr)) { return RET_BOUNDS; }
 if(tokermaxi==NULL) { return RET_BADPARM; }
 if(index>=tokermaxi->count) { return RET_BOUNDS; }
 todo=tokermaxi->sl[index];
 todo=aaNumRoof(todo,maxchars-1);
 if(todo==0) { return RET_YES; }
 aaStringNCopy(str,tokermaxi->ptr[index],todo,YES);
 return RET_YES;
 }





 B aaStringTokerMaxi                   (VP str,H chars,_stringtokermaxi*tokermaxi)
 {
 _parser pa,pb;
 B ascii;
 H i;
 B buf[_64K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(tokermaxi==NULL) { return RET_BADPARM; }
 tokermaxi->count=0;
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_NOTREADY; }
 aaParserInit(&pa,str,chars);
 while(1)
  {
  if(pa.is_end) { break; }
  if(tokermaxi->count>=256) { break; }
  if(aaParserSeekToVisibleChar(&pa,YES,YES)!=YES) { break; }
  aaParserCopy(&pb,&pa,NO);
  ascii=pa.ch;
  if(ascii==SQUOTE_CHAR||ascii==DQUOTE_CHAR)
   {
   aaParserSeek(&pb,1);
   aaParserSeekToChar(&pb,ascii,YES,YES);
   aaParserSeek(&pb,1);
   }
  else
   {
   for(i=0;i<pb.to_end;i++)
    {
    if(aaCharIsVisible(pb.bp[i])==NO) { break; }
    ascii=pa.bp[i];
    if(ascii==SQUOTE_CHAR||ascii==DQUOTE_CHAR)     {     break;     }
    }
   aaParserSeek(&pb,i);
   }
  tokermaxi->sl[tokermaxi->count]=pb.offset-pa.offset;
  if(tokermaxi->sl[tokermaxi->count]==0||tokermaxi->sl[tokermaxi->count]>=_1K) { return RET_CORRUPTED; }
  tokermaxi->off[tokermaxi->count]=pa.offset;
  tokermaxi->ptr[tokermaxi->count]=(BP)pa.bp;
  tokermaxi->hashs[tokermaxi->count]=tokermaxi->hashi[tokermaxi->count]=0;
  aaStringNCopy(buf,pa.bp,tokermaxi->sl[tokermaxi->count],YES);
  aaStringHashGet(buf,tokermaxi->sl[tokermaxi->count],&tokermaxi->hashs[tokermaxi->count],YES);
  aaStringHashGet(buf,tokermaxi->sl[tokermaxi->count],&tokermaxi->hashi[tokermaxi->count],NO);
  tokermaxi->count++;
  aaParserCopy(&pa,&pb,NO);
  }
 if(tokermaxi->count==0) { return RET_NOTREADY; }
 return RET_YES;
 }



 B aaStringUnicodeToClosestEnglish     (VP str,H chars,VP ostr)
 {
 B output[_64K];
 H off,wro,hex,changes,unknowns,j;
 BP sp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaStringNull(output);
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { if(ostr) aaStringNull(ostr); return RET_YES; }
 sp=(BP)str;
 off=wro=changes=unknowns=0;
 while(1)
  {
  if((chars-off)<6) { for(j=off;j<chars;j++) { output[wro]=sp[j]; wro++;  }  off=j;   }
  if(off>=chars)    { break; }
  if(sp[off]!=BSLASH_CHAR) { output[wro]=sp[off]; wro++; off++; continue; }
  if(sp[off+1]!='u')       { output[wro]=sp[off]; wro++; off++; continue; }
  hex=0;

  if(sp[off+2]>='0'&&sp[off+2]<='9') { hex+=(sp[off+2]-'0')*4096;      }   else
  if(sp[off+2]>='a'&&sp[off+2]<='f') { hex+=((sp[off+2]-'a')+10)*4096; }   else
  if(sp[off+2]>='A'&&sp[off+2]<='F') { hex+=((sp[off+2]-'A')+10)*4096; }   else
                                     { output[wro]=sp[off]; wro++; off++; continue; }

  if(sp[off+3]>='0'&&sp[off+3]<='9') { hex+=(sp[off+3]-'0')*256;      }   else
  if(sp[off+3]>='a'&&sp[off+3]<='f') { hex+=((sp[off+3]-'a')+10)*256; }   else
  if(sp[off+3]>='A'&&sp[off+3]<='F') { hex+=((sp[off+3]-'A')+10)*256; }   else
                                     { output[wro]=sp[off]; wro++; off++; continue; }

  if(sp[off+4]>='0'&&sp[off+4]<='9') { hex+=(sp[off+4]-'0')*16;      }   else
  if(sp[off+4]>='a'&&sp[off+4]<='f') { hex+=((sp[off+4]-'a')+10)*16; }   else
  if(sp[off+4]>='A'&&sp[off+4]<='F') { hex+=((sp[off+4]-'A')+10)*16; }   else
                                     { output[wro]=sp[off]; wro++; off++; continue; }

  if(sp[off+5]>='0'&&sp[off+5]<='9') { hex+=(sp[off+5]-'0');        }   else
  if(sp[off+5]>='a'&&sp[off+5]<='f') { hex+=((sp[off+5]-'a')+10);   }   else
  if(sp[off+5]>='A'&&sp[off+5]<='F') { hex+=((sp[off+5]-'A')+10);   }   else
                                     { output[wro]=sp[off]; wro++; off++; continue; }
  if(hex>=0x391&&hex<=0x03dc)
   {
   if(hex>=0x0391&&hex<=0x0391)                 { output[wro++]='A'; changes++; off+=6; continue; }
   if(hex>=0x0392&&hex<=0x0392)                 { output[wro++]='B'; changes++; off+=6; continue; }
   if(hex>=0x0395&&hex<=0x0395)                 { output[wro++]='E'; changes++; off+=6; continue; }
   if(hex>=0x0397&&hex<=0x0397)                 { output[wro++]='H'; changes++; off+=6; continue; }
   if(hex>=0x0399&&hex<=0x0399)                 { output[wro++]='I'; changes++; off+=6; continue; }
   if(hex>=0x039a&&hex<=0x039a)                 { output[wro++]='K'; changes++; off+=6; continue; }
   if(hex>=0x039c&&hex<=0x039c)                 { output[wro++]='M'; changes++; off+=6; continue; }
   if(hex>=0x039d&&hex<=0x039d)                 { output[wro++]='N'; changes++; off+=6; continue; }
   if(hex>=0x039F&&hex<=0x039F)                 { output[wro++]='O'; changes++; off+=6; continue; }
   if(hex>=0x03a1&&hex<=0x03a1)                 { output[wro++]='P'; changes++; off+=6; continue; }
   if(hex>=0x03a3&&hex<=0x03a3)                 { output[wro++]='E'; changes++; off+=6; continue; }
   if(hex>=0x03a4&&hex<=0x03a4)                 { output[wro++]='T'; changes++; off+=6; continue; }
   if(hex>=0x03a5&&hex<=0x03a5)                 { output[wro++]='Y'; changes++; off+=6; continue; }
   if(hex>=0x03d2&&hex<=0x03d2)                 { output[wro++]='Y'; changes++; off+=6; continue; }
   if(hex>=0x03a7&&hex<=0x03a7)                 { output[wro++]='X'; changes++; off+=6; continue; }
   if(hex>=0x03ad&&hex<=0x03ad)                 { output[wro++]='e'; changes++; off+=6; continue; }
   if(hex>=0x03af&&hex<=0x03af)                 { output[wro++]='c'; changes++; off+=6; continue; }
   if(hex>=0x03b1&&hex<=0x03b1)                 { output[wro++]='a'; changes++; off+=6; continue; }
   if(hex>=0x03b2&&hex<=0x03b2)                 { output[wro++]='b'; changes++; off+=6; continue; }
   if(hex>=0x03b5&&hex<=0x03b5)                 { output[wro++]='e'; changes++; off+=6; continue; }
   if(hex>=0x03b8&&hex<=0x03b8)                 { output[wro++]='o'; changes++; off+=6; continue; }
   if(hex>=0x03b9&&hex<=0x03b9)                 { output[wro++]='i'; changes++; off+=6; continue; }
   if(hex>=0x03ba&&hex<=0x03ba)                 { output[wro++]='k'; changes++; off+=6; continue; }
   if(hex>=0x03bc&&hex<=0x03bc)                 { output[wro++]='u'; changes++; off+=6; continue; }
   if(hex>=0x03bd&&hex<=0x03bd)                 { output[wro++]='v'; changes++; off+=6; continue; }
   if(hex>=0x03bf&&hex<=0x03bf)                 { output[wro++]='o'; changes++; off+=6; continue; }
   if(hex>=0x03c0&&hex<=0x03c0)                 { output[wro++]='n'; changes++; off+=6; continue; }
   if(hex>=0x03c1&&hex<=0x03c1)                 { output[wro++]='p'; changes++; off+=6; continue; }
   if(hex>=0x03c2&&hex<=0x03c2)                 { output[wro++]='c'; changes++; off+=6; continue; }
   if(hex>=0x03c3&&hex<=0x03c3)                 { output[wro++]='o'; changes++; off+=6; continue; }
   if(hex>=0x03c4&&hex<=0x03c4)                 { output[wro++]='t'; changes++; off+=6; continue; }
   if(hex>=0x03c7&&hex<=0x03c7)                 { output[wro++]='x'; changes++; off+=6; continue; }
   if(hex>=0x03c9&&hex<=0x03c9)                 { output[wro++]='w'; changes++; off+=6; continue; }
   if(hex>=0x03cc&&hex<=0x03cc)                 { output[wro++]='o'; changes++; off+=6; continue; }
   if(hex>=0x03cd&&hex<=0x03cd)                 { output[wro++]='v'; changes++; off+=6; continue; }
   }

  if(hex>=0x0061&&hex<=0x02af)
   {
   if(hex>=0x00bf&&hex<=0x00bf)                 { output[wro++]='?'; changes++; off+=6; continue; }
   if(hex>=0x00e0&&hex<=0x00e5)                 { output[wro++]='a'; changes++; off+=6; continue; }
   if(hex>=0x00e8&&hex<=0x00eb)                 { output[wro++]='e'; changes++; off+=6; continue; }
   if(hex>=0x00ec&&hex<=0x00ef)                 { output[wro++]='i'; changes++; off+=6; continue; }
   if(hex>=0x00f2&&hex<=0x00f8)                 { output[wro++]='o'; changes++; off+=6; continue; }
   if(hex>=0x00f9&&hex<=0x00fc)                 { output[wro++]='u'; changes++; off+=6; continue; }
   if(hex==0x0101||hex==0x0103||hex==0x0105)    { output[wro++]='a'; changes++; off+=6; continue; }
   if(hex>=0x015b&&hex<=0x0161)                 { output[wro++]='s'; changes++; off+=6; continue; }
   }
  if(hex>=0x00c0&&hex<=0x00c6)                 { output[wro++]='A'; changes++; off+=6; continue; }
  if(hex==0x0100||hex==0x0102||hex==0x0104)    { output[wro++]='A'; changes++; off+=6; continue; }
  if(hex==0x0410||hex==0x04d0||hex==0x04d2)    { output[wro++]='A'; changes++; off+=6; continue; }
  if(hex==0x01cd||hex==0x01de||hex==0x0200)    { output[wro++]='A'; changes++; off+=6; continue; }
  if(hex==0x0202||hex==0x0226||hex==0x023a)    { output[wro++]='A'; changes++; off+=6; continue; }
  if(hex>=0xC380&&hex<=0xc385)                 { output[wro++]='A'; changes++; off+=6; continue; }




  if(hex>=0x00E0&&hex<=0x00E6)                 { output[wro++]='a'; changes++; off+=6; continue; }
  if(hex==0x0101||hex==0x0104||hex==0x0105)    { output[wro++]='a'; changes++; off+=6; continue; }
  if(hex==0x00aa)                              { output[wro++]='a'; changes++; off+=6; continue; }

  if(hex>=0x00d2&&hex<=0x00d8)                 { output[wro++]='O'; changes++; off+=6; continue; }
  if(hex==0x014c||hex==0x014e||hex==0x0150)    { output[wro++]='O'; changes++; off+=6; continue; }
  if(hex>=0xc392&&hex<=0xc396)                 { output[wro++]='O'; changes++; off+=6; continue; }
  if(hex>=0x00f2&&hex<=0x00f6)                 { output[wro++]='o'; changes++; off+=6; continue; }
  if(hex==0x00f8||hex==0x014d||hex==0x014f)    { output[wro++]='o'; changes++; off+=6; continue; }
  if(hex==0x0151)                              { output[wro++]='o'; changes++; off+=6; continue; }
  if(hex>=0xc3b2&&hex<=0xc3b6)                 { output[wro++]='o'; changes++; off+=6; continue; }

  if(hex>=0x00c8&&hex<=0x00cb)                 { output[wro++]='E'; changes++; off+=6; continue; }
  if(hex==0x0112||hex==0x0114||hex==0x0116)    { output[wro++]='E'; changes++; off+=6; continue; }
  if(hex==0x0118||hex==0x011a||hex==0x04ec)    { output[wro++]='E'; changes++; off+=6; continue; }
  if(hex>=0xC388&&hex<=0xc38b)                 { output[wro++]='E'; changes++; off+=6; continue; }
  if(hex>=0xC3a8&&hex<=0xc3ab)                 { output[wro++]='e'; changes++; off+=6; continue; }
  if(hex>=0x00e8&&hex<=0x00eb)                 { output[wro++]='e'; changes++; off+=6; continue; }
  if(hex==0x0113||hex==0x0115||hex==0x0117)    { output[wro++]='e'; changes++; off+=6; continue; }
  if(hex==0x0119||hex==0x011b||hex==0x04ed)    { output[wro++]='e'; changes++; off+=6; continue; }

  if(hex==0x00c7||hex==0x0106||hex==0x0108)    { output[wro++]='C'; changes++; off+=6; continue; }
  if(hex==0x010a||hex==0x010c)                 { output[wro++]='C'; changes++; off+=6; continue; }
  if(hex==0x00E7||hex==0x0107||hex==0x0109)    { output[wro++]='c'; changes++; off+=6; continue; }
  if(hex==0x010b||hex==0x010d)                 { output[wro++]='c'; changes++; off+=6; continue; }

  if(hex>=0x00cc&&hex<=0x00cf)                 { output[wro++]='I'; changes++; off+=6; continue; }
  if(hex==0x0128||hex==0x012a||hex==0x012c)    { output[wro++]='I'; changes++; off+=6; continue; }
  if(hex==0x012e||hex==0x0130)                 { output[wro++]='I'; changes++; off+=6; continue; }
  if(hex>=0x00ec&&hex<=0x00ef)                 { output[wro++]='i'; changes++; off+=6; continue; }
  if(hex==0x0129||hex==0x012b||hex==0x012d)    { output[wro++]='i'; changes++; off+=6; continue; }
  if(hex==0x012f||hex==0x0131)                 { output[wro++]='i'; changes++; off+=6; continue; }

  if(hex>=0x00d9&&hex<=0x00dc)                 { output[wro++]='U'; changes++; off+=6; continue; }
  if(hex==0x0168||hex==0x016a||hex==0x016c)    { output[wro++]='U'; changes++; off+=6; continue; }
  if(hex==0x016e||hex==0x0170||hex==0x0172)    { output[wro++]='U'; changes++; off+=6; continue; }

  if(hex>=0x00f9&&hex<=0x00fc)                 { output[wro++]='u'; changes++; off+=6; continue; }
  if(hex==0x0169||hex==0x016b||hex==0x016d)    { output[wro++]='u'; changes++; off+=6; continue; }
  if(hex==0x016f||hex==0x0171||hex==0x0173)    { output[wro++]='u'; changes++; off+=6; continue; }

  if(hex>=0x2010&&hex<=0x2015)                 { output[wro++]='-'; changes++; off+=6; continue; }
  if(hex>=0x2018&&hex<=0x201b)                 { output[wro++]=SQUOTE_CHAR; changes++; off+=6; continue; }
  if(hex>=0x201c&&hex<=0x201f)                 { output[wro++]=DQUOTE_CHAR; changes++; off+=6; continue; }

  if(1)
   {
   if(hex==0x00a2) {  output[wro++]='c';  output[wro++]='e'; output[wro++]='n'; output[wro++]='t'; output[wro++]='s'; changes++;  off+=6;  continue;  }
   if(hex==0x00a9) {  output[wro++]='(';  output[wro++]='c'; output[wro++]=')'; changes++;  off+=6;  continue;  }
   if(hex==0x20ac) {  output[wro++]='(';  output[wro++]='$'; output[wro++]='e'; output[wro++]=')';  changes++;  off+=6;  continue;  }
   if(hex==0x2122) {  output[wro++]='(';  output[wro++]='t'; output[wro++]='m'; output[wro++]=')';  changes++;  off+=6;  continue; }
   break;
   }

  if(hex>=0x009d&&hex<=0xff)
   {
   if(hex>=0x00a0)                              { output[wro++]=' '; changes++; off+=6; continue; }
   if(hex>=0x00a1)                              { output[wro++]='!'; changes++; off+=6; continue; }
   if(hex>=0x00a6)                              { output[wro++]='|'; changes++; off+=6; continue; }
   if(hex>=0x00ad)                              { output[wro++]='-'; changes++; off+=6; continue; }
   if(hex>=0x00b4)                              { output[wro++]='`'; changes++; off+=6; continue; }
   if(hex>=0x00b4)                              { output[wro++]='u'; changes++; off+=6; continue; }
   if(hex>=0x00b7)                              { output[wro++]='-'; changes++; off+=6; continue; }
   if(hex>=0x00b8)                              { output[wro++]=','; changes++; off+=6; continue; }
   if(hex>=0x00bf)                              { output[wro++]='?'; changes++; off+=6; continue; }
   }
  aaLog(-1,"BAD u%04x",hex);
  oof;

  output[wro++]='#';
  off+=6;
  changes++;
  unknowns++;
  }
 output[wro]=NULL_CHAR;
 if(changes==0&&ostr==str) { return RET_NOTFOUND; }
 if(changes==0&&ostr!=str&&ostr!=NULL) { aaStringNCopy(ostr,str,chars,YES); return RET_NOTFOUND;   }
 if(changes==0&&ostr==NULL)  {  return RET_NOTFOUND;   }
 if(ostr) { aaStringNCopy(ostr,output,wro,YES); }
 else     { aaStringNCopy(str,output,wro,YES); }
 if(unknowns) { return RET_NOTSUPPORTED; }
 return RET_YES;
 }





 B aaStringContract                    (VP str,H chars,N amnt)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars<2) { return RET_FAILED; }
 if(amnt==0) { return RET_YES; }
 if(amnt<0) { return RET_NOTSUPPORTED; }
 while(1)
  {
  if(chars<2) { break; }
  if(amnt==0) { break; }
  aaStringDeleteChars(str,chars,0,1);
  chars--;
  aaStringLastCharSet(str,chars,0,1);
  chars--;
  amnt--;
  }
 return RET_YES;
 }




///=====================================================



 B aaStringUtfLen                      (VP str,H chars,HP uchars)
 {
 H count=0;
 H done;
 BP s;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(uchars==NULL) { return RET_BADPARM; }
 *uchars=0;
 if(str==NULL) { return RET_BADPARM; }
 done=0;
 aaCast(s,BP,str);
 for(; *s; ++s)
  {
  if(chars==0||chars<done)
   {
   if((*s&0xC0)!=0x80)
    {
    ++count;
    done++;
    }
   }
  }

 if(uchars) { *uchars=count; }
 return RET_YES;
 }


 B aaStringUtfPosGet                   (VP str,H uchrs,H pos,HP off)
 {
 H o=0;
 BP s;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(off==NULL) { return RET_BADPARM; }
 *off=0;
 if(str==NULL) { return RET_BADPARM; }
 if(uchrs==0) { aaStringUtfLen(str,0,&uchrs); }
 if(uchrs==0) { return RET_YES; }
 if(pos==0xffffffff) { pos=uchrs-1; }
 if(pos>=uchrs) { return RET_BOUNDS; }
 aaCast(s,BP,str);
 ++pos;
 while(1)
  {
  if((*s&0xC0)!=0x80) { --pos; }
  if(pos==0) break;
  s++;
  o++;
  }
 *off=o;
 return RET_YES;
 }




 B aaStringUtfTypeGet                  (VP str,H chars,HP type)
 {
 H i,t;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(type) { *type=0; }
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 aaCast(bp,BP,str);
 t=0;
 for(i=0;i<chars;i++)
  {
  if(bp[i]<0x80) { continue; }
  if(bp[i]>=0x80&&bp[i]<=0xbf) { t=1; break; }
  if(bp[i]>=0xc0&&bp[i]<=0xc1) { t=2; break; }
  if(bp[i]>=0xc2&&bp[i]<=0xdf) { t=3; break; }
  if(bp[i]>=0xe0&&bp[i]<=0xef) { t=4; break; }
  if(bp[i]>=0xf0&&bp[i]<=0xf4) { t=5; break; }
  t=0xffffffff;
  break;
  }
 if(type) { *type=t; }
 return RET_YES;
 }



 B aaStringToUtf8                      (VP str,H chars,HP ochars,H maxochars,VP ostr)
 {
 H x,y,len,c,cs;
 BP in,out;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aaStringIsNull(str)!=NO) { return RET_BADPARM; }
 if(str==NULL) { return RET_BADPARM; }
 if(ostr==NULL) { return RET_BADPARM; }
 aaStringNull(ostr);
 if(chars==0) { aaStringLen(str,&chars); }
 if(ochars) { *ochars=0; }
 aaCast(in,BP,str);
 aaCast(out,BP,ostr);
 for(x=len=0;x<chars;x++)
  {
  c=in[x];
  if(c>0x1FFFF)   { return RET_FAILED; }
  if(c<=0x7F)     { cs=1;   } else
  if(c<=0x7FF)    { cs=2;   } else
  if(c<=0xFFFF)   { cs=3;   } else { cs=4; }
  len+=cs;
  }
 if(len<128)        { y=2+len;   } else
 if(len<256)        { y=3+len;   } else
 if(len<65536UL)    { y=4+len;   } else
 if(len<16777216UL) { y=5+len;   } else   {  return RET_FAILED;   }
 if(y>maxochars)    { if(ochars) *ochars=len;  return RET_BOUNDS;   }
 x=0;
 out[x++]=0x0C;
 if(len<128)        { out[x++]=(B)len;                                                    }
 else
 if(len<256)        { out[x++]=0x81;  out[x++]=(B)len;                                    }
 else
 if(len<65536UL)    { out[x++]=0x82;  out[x++]=(B)((len>>8)&255);  out[x++]=(B)(len&255); }
 else
 if(len<16777216UL) { out[x++]=0x83;  out[x++]=(B)((len>>16)&255); out[x++]=(B)((len>>8)&255);   out[x++]=(B)(len&255);  }
 else               { return RET_FAILED;   }
 for(y=0;y<chars;y++)
  {
  c=in[y];
  if(c>0x1FFFF)   { return RET_FAILED; }
  if(c<=0x7F)     { cs=1;   } else
  if(c<=0x7FF)    { cs=2;   } else
  if(c<=0xFFFF)   { cs=3;   } else { cs=4; }
  switch(cs)
   {
   case 1: out[x++]=(B)in[y]; break;
   case 2: out[x++]=0xC0|((in[y]>>6)&0x1F);  out[x++]=0x80|(in[y]&0x3F); break;
   case 3: out[x++]=0xE0|((in[y]>>12)&0x0F); out[x++]=0x80|((in[y]>>6)&0x3F); out[x++]=0x80|(in[y]&0x3F); break;
   case 4: out[x++]=0xF0|((in[y]>>18)&0x07); out[x++]=0x80|((in[y]>>12)&0x3F); out[x++]=0x80|((in[y]>>6)&0x3F); out[x++]=0x80|(in[y]&0x3F); break;
   }
  }
 if(ochars) *ochars=x;
 return RET_YES;
 }




///=====================================================


 B aaStringTokenGet                    (VP str,H chars,B ch,H ti,HP toff,HP tchars,VP tok)
 {
 BP s;
 H i,from,off,pos;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(toff)   { *toff=0xffffffff; }
 if(tchars) { *tchars=0; }
 if(tok)    { aaStringNull(tok); }
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_NOTFOUND; }
 aaCast(s,BP,str);
 i=from=0;
 while(1)
  {
  if(chars==0) { return RET_NOTFOUND; }
  if(aaStringFindChar(&s[from],chars,&off,ch,NO,0,YES)!=RET_YES) { return RET_NOTFOUND; }
  from+=off;
  chars-=off;
  if(aaStringFindChar(&s[from],chars,&pos,ch,YES,0,YES)!=RET_YES)
   {
   if(i==ti) { pos=chars; }
   else      { return RET_NOTFOUND; }
   }
  if(i==ti)
   {
   if(tok) { aaStringNCopy(tok,&s[from],pos,YES); }
   if(toff) { *toff=from; }
   if(tchars) { *tchars=pos; }
   break;
   }
  from+=pos;
  chars-=pos;
  i++;
  }
 return RET_YES;
 }





 B aaStringFix                         (VP str)
 {
 H sl,pos,i,hex;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 aaStringLen(str,&sl);
 aaCast(bp,BP,str);
 while(1)
  {
  if(aaStringFindFirstIString(bp,0,"&amp;",0,&pos)==YES)
   {
   aaStringDeleteChars(bp,0,pos,5);  bp[pos]='&'; continue;
   }
  if(aaStringFindFirstIString(bp,0,"&lt;",0,&pos)==YES)
   {
   aaStringDeleteChars(bp,0,pos,3);  bp[pos]='<'; continue;
   }
  if(aaStringFindFirstIString(bp,0,"&gt;",0,&pos)==YES)
   {
   aaStringDeleteChars(bp,0,pos,3);  bp[pos]='>'; continue;
   }
  if(aaStringFindFirstIString(bp,0,"\\\"",0,&pos)==YES)
   {
   aaStringDeleteChars(bp,0,pos,1);  bp[pos]='\"'; continue;
   }
  break;
  }
 i=0;
 while(1)
  {
  if(aaStringFindChar(bp,0,&pos,'&',YES,i,YES)!=YES) { break; }
  if(aaCharIsHex(bp[pos+1])!=YES) { i++; continue; }
  if(aaCharIsHex(bp[pos+2])!=YES) { i++; continue; }
  if(bp[pos+3]!=';') { i++; continue; }
  if(aaStringToNumber(&bp[pos+1],2,&hex,0,0,0)!=YES) { oof; }
  aaStringDeleteChars(bp,0,pos,3);
  bp[pos]=(B)hex;
  i=0;
  }
 i=0;
 while(1)
  {
  if(aaStringFindChar(bp,0,&pos,'&',YES,i,YES)!=YES) { break; }
  if(bp[pos+1]!='#')              { i++; continue; }
  if(aaCharIsHex(bp[pos+2])!=YES) { i++; continue; }
  if(aaCharIsHex(bp[pos+3])!=YES) { i++; continue; }
  if(bp[pos+4]!=';') { i++; continue; }
  if(aaStringHexToNumber(&bp[pos+2],2,&hex,0,NULL,NULL)!=YES) { oof; }
  aaStringDeleteChars(bp,0,pos,4);
  bp[pos]=(B)hex;
  i=0;
  }
 i=0;
 while(1)
  {
  if(aaStringFindChar(bp,0,&pos,BSLASH_CHAR,YES,i,YES)!=YES) { break; }
  if(bp[pos+1]==SQUOTE_CHAR)  {   aaStringDeleteChars(bp,0,pos,1);   i=0; continue; }
  if(bp[pos+1]==DQUOTE_CHAR)  {   aaStringDeleteChars(bp,0,pos,1);   i=0; continue; }
  if(bp[pos+1]=='n')  {   aaStringDeleteChars(bp,0,pos,1); bp[pos]=' ';  i=0; continue; }
  if(bp[pos+1]=='r')  {   aaStringDeleteChars(bp,0,pos,1); bp[pos]=' '; i=0; continue; }
  i++;
  }
 aaStringCopyf(str,"%s",bp);
 return RET_YES;
 }




 B aaStringWildCompare                 (VP str,H chars,VP wildcard)
 {
 CP cp,mp;
 CP string;
 CP wild;
 H done;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(wildcard==NULL) { return RET_BADPARM; }
 if(chars==0)   { aaStringLen(str,&chars); }
 if(chars==0) { return RET_NO; }
 done=0;
 cp=NULL;
 mp=NULL;
 string=(CP)str;
 wild=(CP)wildcard;
 while((*string)&&(*wild!='*'))
  {
  if((*wild!=*string)&&(*wild!='?')) { return RET_NO; }
  wild++;
  string++;
  }
 while(*string)
  {
  if(*wild=='*')
   {
   if(!*++wild) { return RET_YES; }
   mp=wild;
   cp=string+1;
   }
  else
  if((*wild==*string)||(*wild=='?'))
   {
   wild++;
   string++;
   }
  else
   {
   wild=mp;
   string=cp++;
   }
  }
 while(*wild=='*')
  {
  wild++;
  }
 if(*wild) { return RET_NO; }
 UNUSE(done);
 return RET_YES;
 }



 B aaStringWildICompare                (VP str,H chars,VP wildcard)
 {
 CP cp,mp;
 CP string;
 CP wild;
 H done;
 B w,s;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(wildcard==NULL) { return RET_BADPARM; }
 if(chars==0)   { aaStringLen(str,&chars); }
 if(chars==0) { return RET_NO; }
 done=0;
 cp=NULL;
 mp=NULL;
 string=(CP)str;
 wild=(CP)wildcard;
 while((*string)&&(*wild!='*'))
  {
  w=*wild;
  s=*string;
  if(w>='a'&&w<='z') w-=32;
  if(s>='a'&&s<='z') s-=32;
  if((w!=s)&&(*wild!='?')) { return RET_NO; }
  wild++;
  string++;
  }
 while(*string)
  {
  if(*wild=='*')
   {
   if(!*++wild) { return RET_YES; }
   mp=wild;
   cp=string+1;
   }
  else
   {
   w=*wild;
   s=*string;
   if(w>='a'&&w<='z') w-=32;
   if(s>='a'&&s<='z') s-=32;
   if((w==s)||(*wild=='?'))
    {
    wild++;
    string++;
    }
   else
    {
    wild=mp;
    string=cp++;
    }
   }
  }
 while(*wild=='*')
  {
  wild++;
  }
 if(*wild) { return RET_NO; }
 UNUSE(done);
 return RET_YES;
 }



 B aaStringStartsWithContains          (VP str,H chars,VP sstr,H schars,B isand,VP contains,...)
 {
 B ret;
 BP bp;
 H found,count;
 va_list ap;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 va_start(ap,contains);
 if(str==NULL) {  va_end(ap); return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { va_end(ap); return RET_NO; }
 if(sstr)
  {
  if(aaStringNICompare(str,sstr,schars,0)!=YES) { va_end(ap); return RET_NO; }
  }
 found=0;
 count=0;
 bp=contains;
 while(1)
  {
  if(bp==NULL) { break; }
  ret=aaStringFindFirstIString(str,chars,bp,0,0);
  if(ret==YES) {found++; }
  count++;
  bp=va_arg(ap,BP);
  }
 va_end(ap);
 if(isand)
  {
  if(count==0) { return RET_NO; }
  if(found!=count) { return RET_NO; }
  return RET_YES;
  }
 if(found==0&&count!=0) { return RET_NO; }
 return RET_YES;
 }




 B aaStringHexFromMemory               (VP str,HP chars,H bytes,VP data,B appendnull)
 {
 BP sp;
 BP dp;
 H i,v0,v1;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL)  { return RET_MISSINGPARM; }
 if(chars)      { *chars=0; }
 if(appendnull) { aaStringNull(str); }
 if(data==NULL) { return RET_MISSINGPARM; }
 if(bytes==0)   { return RET_YES; }
 sp=(BP)data;
 dp=(BP)str;
 for(i=0;i<bytes;i++)
  {
  v0=sp[i]/16;
  v1=sp[i]%16;
  if(v0<10) { v0=v0+'0'; } else { v0=(v0-10)+'a'; }
  if(v1<10) { v1=v1+'0'; } else { v1=(v1-10)+'a'; }
  dp[(i*2)+0]=(B)v0;
  dp[(i*2)+1]=(B)v1;
  }
 if(chars)      { *chars=bytes*2; }
 if(appendnull) { dp[(bytes*2)]=NULL_CHAR; }
 return RET_YES;
 }



 B aaStringHexToMemory                 (VP str,H chars,HP bytes,VP data)
 {
 BP sp;
 BP dp;
 H i,v0,v1,v;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL)  { return RET_MISSINGPARM; }
 if(chars==0)   { aaStringLen(str,&chars); }
 if(bytes)      { *bytes=0; }
 if((chars%2)!=0) { return RET_CORRUPTED; }
 if(chars==0)   { return RET_YES; }
 if(data==NULL) { return RET_MISSINGPARM; }
 sp=(BP)str;
 dp=(BP)data;
 chars/=2;
 for(i=0;i<chars;i++)
  {
  v0=sp[(i*2)+0];
  v1=sp[(i*2)+1];
  if(v0>='a'&&v0<='f') { v0=(v0-'a')+10; }   else
  if(v0>='A'&&v0<='F') { v0=(v0-'A')+10; }   else
  if(v0>='0'&&v0<='9') { v0=(v0-'0');    }   else    { return RET_FAILED;  }
  if(v1>='a'&&v1<='f') { v1=(v1-'a')+10; }   else
  if(v1>='A'&&v1<='F') { v1=(v1-'A')+10; }   else
  if(v1>='0'&&v1<='9') { v1=(v1-'0');    }   else    { return RET_FAILED;  }
  v=(v0*16)+v1;
  dp[i]=(B)v;
  }
 if(bytes) { *bytes=i; }
 return RET_YES;
 }




 B aaStringDollars                     (VP str,B adddollar,Q cents)
 {
 B etc[_2K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 aaStringComafy(etc,cents/100LL);
 if(adddollar) { aaStringCopyf(str,"$%s.%02I64d",etc,cents%100LL); }
 else          { aaStringCopyf(str,"%s.%02I64d",etc,cents%100LL);  }
 return RET_YES;
 }




#if 0

 B aaStringDetermine                   (VP str,H chars,BP type)
 {
 B ret;
 BP s,d;
 H i,j;
 H off;
 H stage;
 B ascii;
 B aprev;
 B anext;
 B atype;
 B ntype;
 B lex[_4K];
 B cex[_4K];
 B mex[_4K];
 B ok;
 H t;
 H count[10];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(type)      { *type=0; }
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0)  { aaStringLen(str,&chars); }
 if(chars==0)  { return RET_YES; }

 lex[0]=0;
 off=0;
 stage=0;
 aaCast(s,BP,str);
 while(1)
  {
  if(stage==666) { break; }

  switch(stage)
   {
   case 0:
   if(s[0]==NULL_CHAR)      {  stage=666; break; }
   if(s[0]=='+'||s[0]=='-') {  break; }
   if(s[0]=='.')            {  stage=2000; break; }
   if(aaCharIsNum(s[0]))    {  stage=3000; break; }
   if(aaCharIsAlpha(s[0]))  {  stage=4000; break; }
   stage=5000;
   break;

   case 1000:
   lex[off++]='s';
   s++;
   if(s[0]==NULL_CHAR)      {  stage=666; break; }
   if(s[0]=='.')            {  stage=1100; break; }
   if(aaCharIsNum(s[0]))    {  stage=1200; break; }
   stage=9000;
   break;

   case 1100:
   lex[off++]='d';
   s++;
   if(s[0]==NULL_CHAR)      {  stage=666; break; }
   if(aaCharIsNum(s[0]))    {  stage=1200; break; }
   stage=9000;
   break;

   case 1200:
   lex[off++]='d';
   s++;
   if(s[0]==NULL_CHAR)      {  stage=666; break; }
   if(aaCharIsNum(s[0]))    {  stage=1200; break; }
   stage=9000;
   break;



   stage=9000;
   break;



   if(s[0]=='+'||s[0]=='-') {  stage=100; break; }
   if(s[0]=='.')            {  stage=200; break; }
   if(aaCharIsNum(s[0]))    {  stage=300; break; }
   if(aaCharIsAlpha(s[0]))  {  stage=400; break; }
   stage=500;
   break;












 //if((ret=aaStringCountCharList(str,chars,&count[0],YES,"ghijklmnopqrstuvwxyzGHIJKLMNOPQRSTUVWXYZ"))!=YES) { oops; }
 //if(count


 aaCast(s,BP,str);
 if(s[0]=='+'||s[0]=='-')
  {



  }






 if((ret=aaStringCountCharList(str,chars,&count[0],1,"0123456789"))!=YES) { oops; }
 if((ret=aaStringCountCharList(str,chars,&count[1],0,"0123456789"))!=YES) { oops; }
 if((ret=aaStringCountCharList(str,chars,&count[2],1,"abcdefABCDEF"))!=YES) { oops; }
 if((ret=aaStringCountCharList(str,chars,&count[3],0,"abcdefABCDEF"))!=YES) { oops; }

 if((ret=aaStringCountCharList(str,chars,&count[4],1,"ghijklmnopqrstuvwxyzGHIJKLMNOPQRSTUVWXYZ"))!=YES) { oops; }
 if((ret=aaStringCountCharList(str,chars,&count[5],0,"ghijklmnopqrstuvwxyzGHIJKLMNOPQRSTUVWXYZ"))!=YES) { oops; }

 ok=32;
 while(1)
  {
  if(count[0]==chars)  {  ok='i'; break; }
  if(count[2]==chars)  {  ok='h'; break; }
  if(count[4]!=0)      {  ok='s'; break; }
  if(count[2]!=0)      {  ok='s'; break; }
  break;
  }


 //if((ret=aaStringCountCharList(str,chars,&count[3],0,"abcdefABCDEF"))!=YES) { oops; }

 aaDebugf("%-3i %20s = %c %-2i %-2i  %-2i %-2i  %-2i %-2i",chars,str,ok,count[0],count[1],count[2],count[3],count[4],count[5]);
 return 1;

// if((ret=aaStringCountCharList(str,chars,&count[4],1,"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_"))!=YES) { oops; }
 //if((ret=aaStringCountCharList(str,chars,&count[5],0,"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_"))!=YES) { oops; }
 //if((ret=aaStringCountCharList(str,chars,&count[6],1,"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_"))!=YES) { oops; }
 //if((ret=aaStringCountCharList(str,chars,&count[7],0,"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_"))!=YES) { oops; }

 if(count[4]==chars)
  {
  //if(count[
  }

 aaStringNull(lex);
 if(count[0]) { aaStringAppendf(lex," N=%-2i  ",count[0]); }
 //if(count[1]) { aaStringAppendf(lex,"!N=%-2i  ",count[1]); }
 if(count[2]) { aaStringAppendf(lex," H=%-2i  ",count[2]); }
 //if(count[3]) { aaStringAppendf(lex,"!H=%-2i  ",count[3]); }
 if(count[4]) { aaStringAppendf(lex," A=%-2i  ",count[4]); }
 //if(count[5]) { aaStringAppendf(lex,"!A=%-2i  ",count[5]); }
 if(count[7]) { aaStringAppendf(lex," X=%-2i  ",count[7]); }
 //if(count[7]) { aaStringAppendf(lex,"!X=%-2i  ",count[7]); }


 aaDebugf("%-3i %20s = %s",chars,str,lex);


 /*
 if((ret=aaStringCountCharList(str,chars,&count[1],YES,"0123456789abcdefABCDEF"))!=YES) { oops; }
 if((ret=aaStringCountCharList(str,chars,&count[2],YES,"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"))!=YES) { oops; }
 if((ret=aaStringCountCharList(str,chars,&count[3],YES,"ghijklmnopqrstuvwxyzGHIJKLMNOPQRSTUVWXYZ"))!=YES) { oops; }
 if((ret=aaStringCountCharList(str,chars,&count[4],YES,"01234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_"))!=YES) { oops; }
 if((ret=aaStringCountCharList(str,chars,&count[5],YES,"+-."))!=YES) { oops; }
*/
 //aaDebugf("%-3i %20s = NUM=%-2i !NUM=%-2i   HEX=%-2i !HEX=%-2i   ALP=%-2i !ALP=%-2i   ALL=%-2i !ANY=%-2i",chars,str,count[0],count[1],count[2],count[3],count[4],count[5],count[6],count[7]);
 return 1;

 ok=0;
 while(1)
  {
  // x,0,0 only num
  if(count[0]==chars&&count[1]==0&&count[2]==0)
   {
   ok='n';
   break;
   }
  if(count[2]>count[1]&&count[2]>count[0])
   {
   ok='t';
   break;
   }
  if(count[0]==0&&count[1]==count[2]&&count[1]==chars)
   {
   ok='t';
   break;
   }





  // x,x,0
  if(count[0]==chars&&count[0]==count[1]&&count[2]==0) { ok='i'; break; }
  // 0,x,y no nums, some hex, some alpha, but some alpha not hex, so is string

  //
  if(count[0]==chars&&count[0]==count[1]&&count[2]==0) { ok='i'; break; }

  break;
  }

 if(ok)
  {
  if(type) { *type=ok; }
  //aaDebugf("TYPE=%c %-3i %20s = %i,%i,%i",ok,chars,str,count[0],count[1],count[2]);
  return RET_YES;
  }





 aaDebugf("%-3i %20s = %i,%i,%i",chars,str,count[0],count[1],count[2]);
 return 1;



 lex[0]=cex[0]=mex[0]=NULL_CHAR;

 aaStringCopy(lex,str);

 t=0;

 while(1)
  {
  i=j=0;
  aaCast(s,BP,lex);
  aaCast(d,BP,cex);

  while(1)
   {
   ascii=s[i+0];
   if(ascii==NULL_CHAR) { break; }
   anext=s[i+1];

   if(ascii==NULL_CHAR)       { atype=0;    } else
   if(ascii=='.')             { atype='a';  } else
   if(ascii=='+'||ascii=='-') { atype='b';  } else
   if(aaCharIsNum(ascii))     { atype='c';  } else
   if(aaCharIsHex(ascii))     { atype='d';  } else
   if(aaCharIsAlpha(ascii))   { atype='e';  } else
   if(ascii=='_')             { atype='f';  } else
   if(ascii==32)              { atype='g';  } else
   if(ascii<32)               { atype='h';  } else
   if(ascii>127)              { atype='i';  } else { oof; }

   if(anext==NULL_CHAR)       { ntype=0;    } else
   if(anext=='.')             { ntype='a';  } else
   if(anext=='+'||anext=='-') { ntype='b';  } else
   if(aaCharIsNum(anext))     { ntype='c';  } else
   if(aaCharIsHex(anext))     { ntype='d';  } else
   if(aaCharIsAlpha(anext))   { ntype='e';  } else
   if(anext=='_')             { ntype='f';  } else
   if(anext==32)              { ntype='g';  } else
   if(anext<32)               { ntype='h';  } else
   if(anext>127)              { ntype='i';  } else { oof; }

   if(atype=='d'&&ntype=='e') { d[j++]='e'; d[j]=0; i++; continue; }
   if(atype=='e'&&ntype=='f') { d[j++]='e'; d[j]=0; i++; continue; }

   /*
   if(atype=='c'&&ntype=='c') { d[j++]='c'; d[j]=0; i++; continue; }
   if(atype=='d'&&ntype=='d') { d[j++]='d'; d[j]=0; i++; continue; }
   if(atype=='e'&&ntype=='e') { d[j++]='e'; d[j]=0; i++; continue; }
   if(atype=='f'&&ntype=='f') { d[j++]='f'; d[j]=0; i++; continue; }
   if(atype=='c'&&ntype=='f') { d[j++]='f'; d[j]=0; i++; continue; }
   if(atype=='d'&&ntype=='f') { d[j++]='e'; d[j]=0; i++; continue; }
   if(atype=='e'&&ntype=='f') { d[j++]='e'; d[j]=0; i++; continue; }
   */


   d[j++]=atype;
   d[j++]=ntype;
   d[j]=NULL_CHAR;
   i++;
   }

  aaCast(s,BP,cex);
  aaCast(d,BP,mex);


  i=j=0;
  aprev=0;
  ok=1;
  while(1)
   {
   ascii=s[i];
   if(ascii==NULL_CHAR) { break; }
   if(ascii==aprev)     { ok=0; i++; continue; }
   d[j++]=ascii;
   d[j]=NULL_CHAR;
   aprev=ascii;
   i++;
   }
  aaDebugf("A%i) str=%-20s  lex=%-20s  cex=%-20s  mex=%-20s",t++,str,lex,cex,mex);
  if(ok) { break; }

  aaStringCopy(lex,mex);
  }

  //aaCast(s,BP,str);



 return 1;



 for(i=0;i<chars;i++)
  {
  ascii=s[i+0];

  if(ascii=='.')             { lex[i]='a'; continue; }
  if(ascii=='+'||ascii=='-') { lex[i]='b'; continue; }
  if(aaCharIsNum(ascii))     { lex[i]='c'; continue; }
  if(aaCharIsHex(ascii))     { lex[i]='d'; continue; }
  if(aaCharIsAlpha(ascii))   { lex[i]='e'; continue; }
  if(ascii=='_')             { lex[i]='f'; continue; }
  if(ascii==32)              { lex[i]='g'; continue; }
  if(ascii<32)               { lex[i]='h'; continue; }
  if(ascii>127)              { lex[i]='i'; continue; }
  lex[i]='j';
  }
 lex[i+0]=lex[i+1]=lex[i+2]=NULL_CHAR;
 cex[  0]=NULL_CHAR;
 mex[  0]=NULL_CHAR;

 aaDebugf("A) str=%-20s  lex=%-20s",str,lex);

 i=j=0;
 aprev=0;
 while(1)
  {
  ascii=lex[i];
  if(ascii==NULL_CHAR) { break; }
  if(ascii==aprev)     { i++; continue; }
  cex[j++]=ascii;
  cex[j]=NULL_CHAR;
  aprev=ascii;
  i++;
  }

 aaDebugf("B) str=%-20s  lex=%-20s  cex=%-20s",str,lex,cex);


 i=1;
 j=0;
 while(1)
  {
  aprev=cex[i-1];
  ascii=cex[i  ];
  if(ascii==NULL_CHAR) { break; }
  if(aprev=='d'&&ascii=='e')
   {
   mex[j++]='e';
   }
  else
  if(aprev=='e'&&ascii=='f')
   {
   mex[j++]='e';
   }
  else
  if(aprev=='e'&&ascii=='d')
   {
   mex[j++]='e';
   }
  else
  if(aprev=='f'&&ascii=='d')
   {
   mex[j++]='e';
   }
  else
  if(aprev=='f'&&ascii=='e')
   {
   mex[j++]='e';
   }

  else
   {
   mex[j++]=ascii;
   }
  mex[j]=NULL_CHAR;
  i++;
  }
 if(mex[0]==NULL_CHAR)
  {
  mex[0]=cex[0];
  mex[1]=NULL_CHAR;
  if(cex[1]!=0) oof;
  }


 aaDebugf("C) str=%-20s  lex=%-20s  cex=%-20s  mex=%-20s",str,lex,cex,mex);

 return YES;



#if 0

 i=1;
 while(1)
  {
  aprev=cex[i-1];
  ascii=cex[i  ];
  if(ascii==NULL_CHAR) { break; }
  if(aprev=='e'&&ascii=='f') { cex[i]='e'; }
  else
  if(aprev=='d'&&ascii=='e') { cex[i]='e'; }
  i++;
  }

 i=j=0;
 aprev=0;
 while(1)
  {
  ascii=lex[i];
  if(ascii==NULL_CHAR) { break; }
  if(ascii==aprev)     { i++; continue; }
  cex[j++]=ascii;
  cex[j]=NULL_CHAR;
  aprev=ascii;
  i++;
  }

#endif

  #if 0
 i=1;
 while(1)
  {
  aprev=cex[i-1];
  ascii=cex[i  ];
  if(aprev=='d'&&ascii=='e') { cex[i-1]='e'; }
  }
  #endif

#if 0

 for(i=1;i<j;i++)
  {
  aprev=cex[i-1];
  ascii=cex[i  ];
  if(aprev=='d'&&ascii=='e') { cex[i-1]='e'; }
  }



 i=j=0;
 aprev=0;
 while(1)
  {
  ascii=lex[i];
  if(ascii==NULL_CHAR) { break; }
  if(ascii==aprev)     { i++; continue; }
  cex[j]=aprev;
  j++;
  cex[j]=NULL_CHAR;
  aprev=ascii;
  i++;
  }



 for(i=1;i<j;i++)
  {
  aprev=cex[i-1];
  ascii=cex[i  ];
  if(aprev=='e'&&ascii=='f') { cex[i-1]='e'; }
  }




 i=j=0;
 aprev=0;
 while(1)
  {
  ascii=lex[i];
  if(ascii==NULL_CHAR) { break; }
  if(ascii==aprev)     { i++; continue; }
  cex[j]=aprev;
  j++;
  cex[j]=NULL_CHAR;
  aprev=ascii;
  i++;
  }
#endif


 aaDebugf("B) str=%-20s  lex=%-20s  cex=%-20s j=%i",str,lex,cex,j);


 if(j==1)
  {
  ok=0;
  if(cex[0]=='e') { ok='s'; }  else
  if(cex[0]=='c') { ok='i'; }  else
  if(cex[0]=='d') { ok='t'; }
  if(ok)
   {
   if(type) { *type=ok; }
   aaDebugf("str=%-20s  lex=%-20s  cex=%-20s j=%i type=0x%02x %c",str,lex,cex,j,ok,ok);
   return RET_YES;
   }
  }
 if(j==2)
  {
  ok=0;
  if(cex[0]=='a'&&cex[1]=='c') { ok='f'; } else
  if(cex[0]=='d'&&cex[1]=='e') { ok='s'; } else
  if(cex[0]=='b'&&cex[1]=='c') { ok='n'; }
  if(ok)
   {
   if(type) { *type=ok; }
   aaDebugf("str=%-20s  lex=%-20s  cex=%-20s j=%i type=0x%02x %c",str,lex,cex,j,ok,ok);
   return RET_YES;
   }
  }
 if(j==3)
  {
  ok=0;
  if(cex[0]=='b'&&cex[1]=='a'&&cex[2]=='c') { ok='f'; } else
  if(cex[0]=='c'&&cex[1]=='a'&&cex[2]=='c') { ok='f'; } else
  if(cex[0]=='e'&&cex[1]=='d'&&cex[2]=='e') { ok='s'; } else
  if(cex[0]=='c'&&cex[1]=='e'&&cex[2]=='c') { ok='h'; }
  if(ok)
   {
   if(type) { *type=ok; }
   aaDebugf("str=%-20s  lex=%-20s  cex=%-20s j=%i type=0x%02x %c",str,lex,cex,j,ok,ok);
   return RET_YES;
   }
  }
 if(j==4)
  {
  ok=0;
  if(cex[0]=='b'&&cex[1]=='c'&&cex[2]=='a'&&cex[3]=='c') { ok='f'; } else
  if(cex[0]=='b'&&cex[1]=='c'&&cex[2]=='e'&&cex[3]=='c') { ok='h'; } else
  if(cex[0]=='c'&&cex[1]=='e'&&cex[2]=='d'&&cex[3]=='e') { ok='s'; }
  if(ok)
   {
   if(type) { *type=ok; }
   aaDebugf("str=%-20s  lex=%-20s  cex=%-20s j=%i type=0x%02x %c",str,lex,cex,j,ok,ok);
   return RET_YES;
   }
  }
 if(j>=4)
  {
  if(cex[0]=='e') { ok='s'; }
  if(ok)
   {
   if(type) { *type=ok; }
   aaDebugf("str=%-20s  lex=%-20s  cex=%-20s j=%i type=0x%02x %c",str,lex,cex,j,ok,ok);
   return RET_YES;
   }
  }


 return RET_YES;
 }



#endif



/*-----------------------------------------------------------------------*/


 VP aaf                                (VP buf,H off,VP fmt,...)
 {
 B ret;
 BP tmp;
 BP bp;
 va_list argptr;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(fmt==NULL) { return NULL; }
 bp=(BP)buf;
 if(buf==NULL)
  {
  if((ret=aa_MemoryTemp((VP)&tmp,_256K,aa_MEMORYTEMP_aaf))!=RET_YES)
   {
   oops;
   return NULL;
   }
  bp=(BP)tmp;
  }
 aaFmt(fmt,argptr,&bp[off]);
 return &bp[off];
 }



/*-----------------------------------------------------------------------*/

/*-----------------------------------------------------------------------*/


 B aaBase64Encode                      (VP mem,H bytes,VP str,HP chars)
 {
 B ret;
 BP sp,mp;
 H i,soff,moff;
 B input[3];
 B output[4];
 BP tmp=NULL_POINTR;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(mem==NULL) { return RET_BADPARM; }
 if(chars) { *chars=0; }
 if(bytes==0) { aaStringLen(mem,&bytes); }
 if(str==mem)
  {
  if((ret=aa_MemoryTemp((VP)&tmp,bytes+_32K,aa_MEMORYTEMP_Base64))!=RET_YES) {oops; }
  aaCast(sp,BP,tmp);
  aaCast(mp,BP,mem);
  }
 else
  {
  aaCast(sp,BP,str);
  aaCast(mp,BP,mem);
  }
 soff=moff=0;
 while(2<bytes)
  {
  input[0]=mp[moff]; moff++;
  input[1]=mp[moff]; moff++;
  input[2]=mp[moff]; moff++;
  bytes-=3;
  output[0]=(B)(input[0]>>2);
  output[1]=(B)(((input[0]&0x03)<<4)+(input[1]>>4));
  output[2]=(B)(((input[1]&0x0f)<<2)+(input[2]>>6));
  output[3]=(B)(input[2]&0x3f);
  sp[soff]=aa_Base64Char[output[0]]; soff++;
  sp[soff]=aa_Base64Char[output[1]]; soff++;
  sp[soff]=aa_Base64Char[output[2]]; soff++;
  sp[soff]=aa_Base64Char[output[3]]; soff++;
  }
 if(bytes!=0)
  {
  input[0]=input[1]=input[2]=NULL_CHAR;
  for(i=0;i<bytes;i++)  {  input[i]=mp[moff]; moff++;  }
  output[0]=(B)(input[0]>>2);
  output[1]=(B)(((input[0]&0x03)<<4)+(input[1]>>4));
  output[2]=(B)(((input[1]&0x0f)<<2)+(input[2]>>6));
  sp[soff]=aa_Base64Char[output[0]]; soff++;
  sp[soff]=aa_Base64Char[output[1]]; soff++;
  if(bytes==1) { sp[soff]=EQUAL_CHAR; soff++; }
  else         { sp[soff]=aa_Base64Char[output[2]]; soff++; }
  sp[soff]=EQUAL_CHAR; soff++;
  }
 sp[soff]=NULL_CHAR;
 if(chars) { *chars=soff; }
 if(str==mem)
  {
  aaMemoryCopy(str,soff,tmp);
  aaCast(sp,BP,str);
  sp[soff]=NULL_CHAR;
  }
 return RET_YES;
 }






 B aaBase64Decode                      (VP str,H chars,VP mem,HP bytes)
 {
 B ret;
 BP sp,mp,tmp=NULL_POINTR;
 B ch=0,bb;
 H i,stage,soff,moff;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(mem==NULL) { return RET_BADPARM; }
 if(bytes) { *bytes=0; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(str==mem)
  {
  if((ret=aa_MemoryTemp((VP)&tmp,chars+_32K,aa_MEMORYTEMP_Base64))!=RET_YES) {oops; }
  aaCast(sp,BP,str);
  aaCast(mp,BP,tmp);
  }
 else
  {
  aaCast(sp,BP,str);
  aaCast(mp,BP,mem);
  }
soff=moff=stage=0;
 while(soff!=chars)
  {
  ch=sp[soff];
  soff++;
  if(ch==NULL_CHAR)  { break; }
  if(ch==SPACE_CHAR) { continue; }
  if(ch==LF_CHAR) { continue; }
  if(ch==CR_CHAR) { continue; }
  if(ch==EQUAL_CHAR) { break; }
  if(aaStringFindChar(aa_Base64Char,64,&i,ch,YES,0,YES)!=YES) { aaNote(0,"b7a %i %c",ch,ch); return RET_CORRUPTED; }
  bb=(B)(i);
  switch(stage)
   {
   case 0:  mp[moff]=(B)(bb<<2);   stage=1;   break;
   case 1:  mp[moff]|=(B)(bb>>4);  mp[moff+1]=(B)(((bb)&0x0f)<<4); moff++;   stage=2;   break;
   case 2:  mp[moff]|=(B)(bb>>2);  mp[moff+1]=(B)(((bb)&0x03)<<6); moff++;   stage=3;   break;
   case 3:  mp[moff]|=(B)(bb);     moff++;   stage=0;   break;
   default: break;
   }
  }
 if(stage!=0&&ch!=EQUAL_CHAR) { oof; return RET_CORRUPTED; }
 mp[moff]=NULL_CHAR;
 if(bytes) { *bytes=moff; }
 if(str==mem)
  {
  aaMemoryCopy(mem,moff,tmp);
  aaCast(sp,BP,mem);
  sp[moff]=NULL_CHAR;
  }
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/



 B aaVarintDecode                      (VP buf,HP len,QP val)
 {
 BP bp;
 H length;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(buf==NULL) { return RET_MISSINGPARM; }
 bp=(BP)buf;
 if(bp[0]<=0xFC) { length=1; }
 else
 if(bp[0]==0xFD) { length=3; }
 else
 if(bp[0]==0xFE) { length=5; }
 else            { length=9; }
 if(len)         { *len=length; }
 if(val)
  {
  if(length==1) { *val=*(BP)&bp[1]; }
  else
  if(length==3) { *val=*(WP)&bp[1]; }
  else
  if(length==5) { *val=*(HP)&bp[1]; }
  else          { *val=*(QP)&bp[1]; }
  }
 return RET_YES;
 }





 B aaVarintEncode                      (VP buf,HP len,Q val)
 {
 BP bp;
 H length;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(buf==NULL&&len==NULL) { return RET_MISSINGPARM; }
 if(val<=0xFCLL)        {  length=1;  }
 else
 if(val<=0xFFFFLL)      {  length=3;  }
 else
 if(val<=0xFFFFFFFFLL)  {  length=5;  }
 else                   {  length=9;  }
 if(buf)
  {
  bp=(BP)buf;
  if(length==1)   {   bp[0]=(B)val;   }
  else
  if(length==3)   {   bp[0]=0xFD;   *(WP)&bp[1]=(W)val;   }
  else
  if(length==5)   {   bp[0]=0xFE;   *(HP)&bp[1]=(H)val;   }
  else            {   bp[0]=0xFF;   *(QP)&bp[1]=(Q)val;   }
  }
 if(len)          {  *len=length; }
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/


 B aaU29Encode                         (VP buf,HP len,Z val)
 {
 CP buffer;
 Z length;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(buf==NULL) { return RET_MISSINGPARM; }
 if(len)       { *len=0; }
 if(val<-268435456) { return RET_BOUNDS; }
 if(val>268435455)  { return RET_BOUNDS; }
 buffer=(CP)buf;
 val&=0x1fffffff;
 if(val<=0x7f)     {  buffer[0]=val;  length=1;  }
 else
 if(val<=0x3fff)   {  buffer[0]=(val>>7)|0x80;   buffer[1]=val&0x7f;  length=2;  }
 else
 if(val<=0x1fffff) {  buffer[0]=(val>>14)|0x80;  buffer[1]=(val>>7)|0x80;   buffer[2]=val&0x7f;       length=3;         }
 else              {  buffer[0]=(val>>22)|0x80;  buffer[1]=(val>>15)|0x80;  buffer[2]=(val>>8)|0x80;  buffer[3]=val;  length=4;  }
 if(len) { *len=length; }
 return RET_YES;
 }





 B aaU29Decode                         (VP buf,HP len,ZP val)
 {
 Z n,ofs;
 B b;
 CP bf;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(buf==NULL) { return RET_MISSINGPARM; }
 n=0;
 ofs=0;
 bf=(CP)buf;
 do
  {
  b=bf[ofs++];
  if(ofs==4) { n<<=8;  n|=b;  break;   }
  n<<=7;
  n|=b&0x7f;
  }
 while(b&0x80);
 if(ofs<0) { oof; }
 if(n&0x10000000) n-=0x20000000;
 if(len) { *len=ofs; }
 if(val) { *val=n;   }
 return RET_YES;
 }

/*-----------------------------------------------------------------------*/



 B aaGuidInit                          (_guid*guid,VP node)
 {
 B ret;
 B nod[6];
 ULARGE_INTEGER time;
 S W seq=0;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(guid==NULL) { return RET_BADPARM; }
 GetSystemTimeAsFileTime((FILETIME *)&time);
 time.QuadPart+=(Q)(1000*1000*10)*(Q)(60*60*24)*(Q)(17+30+31+365*18+5);
 if(node) { aaMemoryCopy(nod,6,node); }
 else     { aaMemoryRandomSet(nod,6); }
 ret=aaGuidSet(guid,seq,time.QuadPart,nod);
 seq++;
 return ret;
 }




 B aaGuidSet                           (_guid*guid,W cseq,Q tstamp,VP node)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(guid==NULL) { return RET_BADPARM; }
 guid->time_low=(H)(tstamp&0xFFFFFFFF);
 guid->time_mid=(W)((tstamp>>32)&0xFFFF);
 guid->time_hi_and_version=(W)((tstamp>>48)&0x0FFF);
 guid->time_hi_and_version|=(1<<12);
 guid->clock_seq_low=cseq&0xFF;
 guid->clock_seq_hi_and_reserved=(cseq&0x3F00)>>8;
 guid->clock_seq_hi_and_reserved|=0x80;
 if(node) { aaMemoryCopy(guid->node,6,node); }
 else     { aaMemoryRandomSet(guid->node,6); }
 return RET_YES;
 }




 B aaGuidToString                      (_guid*guid,VP str)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 aaStringCopyf(str,"%8.8x-%4.4x-%4.4x-%2.2x%2.2x-%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x",guid->time_low,guid->time_mid,
    guid->time_hi_and_version,guid->clock_seq_hi_and_reserved,guid->clock_seq_low,
    guid->node[0],guid->node[1],guid->node[2],guid->node[3],guid->node[4],guid->node[5]);
 return RET_YES;
 }








/*-----------------------------------------------------------------------*/



 B aaParserInit                        (_parser*parser,VP string,H chars)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(parser==NULL) { return RET_BADPARM; }
 if(string==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(string,&chars); }
 aaMemoryFill(parser,sizeof(_parser),0);
 parser->string=string;
 parser->magic=aa_PARSE_MAGIC;
 parser->length=chars;
 parser->to_end=parser->length;
 aaCast(parser->bp,BP,parser->string);
 parser->ch=parser->bp[0];
 parser->is_start=YES;
 if(parser->length==0) { parser->is_end=YES; }
 else                  { parser->is_end=NO; }
 return RET_YES;
 }




 B aaParserCopy                        (_parser*parser,_parser*sparser,B reset)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(parser==NULL) { return RET_BADPARM; }
 if(sparser==NULL) { return RET_BADPARM; }
 if(sparser->magic!=aa_PARSE_MAGIC) { return RET_NOTSTARTED; }
 if(sparser->string==NULL) { return RET_BADPARM; }
 if(sparser->offset>sparser->length) { return RET_FAILED; }
 if(sparser->to_end>sparser->length) { return RET_FAILED; }
 if(reset) { if((ret=aaParserInit(parser,sparser->bp,sparser->to_end))!=RET_YES) { return ret; } return RET_YES; }
 aaMemoryCopy(parser,sizeof(_parser),sparser);
 return RET_YES;
 }




 B aaParserSeek                        (_parser*parser,N amnt)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(parser==NULL) { return RET_BADPARM; }
 if(parser->magic!=aa_PARSE_MAGIC) { return RET_NOTSTARTED; }
 if(parser->string==NULL) { return RET_BADPARM; }
 if(parser->offset>parser->length) { return RET_FAILED; }
 if(parser->to_end>parser->length) { return RET_FAILED; }
 if(amnt==0) { return RET_YES; }
 if(amnt<0)
  {
  amnt=aaNumAbs(amnt);
  if((H)amnt>parser->offset) { amnt=parser->offset; }
  parser->bp-=amnt;
  parser->offset-=amnt;
  parser->to_end+=amnt;
  }
 else
 if(amnt>0)
  {
  if((H)amnt>parser->to_end) { amnt=parser->to_end; }
  parser->bp+=amnt;
  parser->offset+=amnt;
  parser->to_end-=amnt;
  }
 if(parser->offset==0) { parser->is_start=YES; }
 else                    { parser->is_start=NO; }
 if(parser->to_end==0) { parser->is_end=YES; }
 else                  { parser->is_end=NO; }
 parser->ch=parser->bp[0];
 return RET_YES;
 }





 B aaParserOffsetSet                   (_parser*parser,H offset)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(parser==NULL) { return RET_BADPARM; }
 if(parser->magic!=aa_PARSE_MAGIC) { return RET_NOTSTARTED; }
 if(parser->string==NULL) { return RET_BADPARM; }
 if(parser->offset>parser->length) { return RET_FAILED; }
 if(offset==0xffffffff)
  {
  parser->bp+=parser->to_end;
  parser->offset+=parser->to_end;
  parser->to_end=0;
  parser->ch=parser->bp[0];
  if(parser->offset==0) { parser->is_start=YES; } else { parser->is_start=NO; }
  if(parser->to_end==0) { parser->is_end=YES; } else { parser->is_end=NO; }
  return RET_YES;
  }
 parser->offset=offset;
 parser->to_end=parser->length-parser->offset;
 aaCast(parser->bp,BP,parser->string);
 parser->bp+=offset;
 parser->ch=parser->bp[0];
 if(parser->offset==0) { parser->is_start=YES; } else { parser->is_start=NO; }
 if(parser->to_end==0) { parser->is_end=YES; } else { parser->is_end=NO; }
 return RET_YES;
 }






 B aaParserDeleteChars                 (_parser*parser,H amnt)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(parser==NULL) { return RET_BADPARM; }
 if(parser->magic!=aa_PARSE_MAGIC) { return RET_NOTSTARTED; }
 if(parser->string==NULL) { return RET_BADPARM; }
 if(parser->offset>parser->length) { return RET_FAILED; }
 if(parser->to_end>parser->length) { return RET_FAILED; }
 if(amnt>parser->to_end) { return RET_BOUNDS; }
 if(amnt==0) { return RET_YES; }
 aaStringDeleteChars(parser->bp,parser->to_end,0,amnt);
 parser->to_end-=amnt;
 parser->length-=amnt;
 if(parser->offset==0) { parser->is_start=YES; }
 else                  { parser->is_start=NO; }
 if(parser->to_end==0) { parser->is_end=YES; }
 else                  { parser->is_end=NO; }
 parser->ch=parser->bp[0];
 return RET_YES;
 }





 B aaParserReset                       (_parser*parser)
 {
 B ret;
 _parser p;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(parser==NULL) { return RET_BADPARM; }
 if(parser->magic!=aa_PARSE_MAGIC) { return RET_NOTSTARTED; }
 if((ret=aaParserInit(&p,parser->string,parser->length))!=RET_YES) { return ret; }
 return(aaParserCopy(parser,&p,NO));
 }





 B aaParserSeekToChar                  (_parser*parser,B ch,B logic,B fwd)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(parser==NULL) { return RET_BADPARM; }
 if(parser->magic!=aa_PARSE_MAGIC) { return RET_NOTSTARTED; }
 if(parser->string==NULL) { return RET_BADPARM; }
 if(parser->offset>parser->length) { return RET_FAILED; }
 if(parser->to_end>parser->length) { return RET_FAILED; }
 if(fwd)
  {
  while(1)
   {
   if(parser->is_end) { break; }
   if(logic==YES&&parser->ch==ch) { return RET_YES; }
   if(logic!=YES&&parser->ch!=ch) { return RET_YES; }
   aaParserSeek(parser,1);
   }
  }
 else
  {
  while(1)
   {
   if(logic==YES&&parser->ch==ch) { return RET_YES; }
   if(logic!=YES&&parser->ch!=ch) { return RET_YES; }
   if(parser->is_start) { break; }
   aaParserSeek(parser,-1);
   }
  }
 return RET_NOTFOUND;
 }




 B aaParserSeekToCharList              (_parser*parser,VP chlist,B logic,B fwd)
 {
 H i,sl;
 BP bp;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(parser==NULL) { return RET_BADPARM; }
 if(parser->magic!=aa_PARSE_MAGIC) { return RET_NOTSTARTED; }
 if(chlist==NULL) { return RET_BADPARM; }
 aaStringLen(chlist,&sl);
 if(parser->offset>parser->length) { return RET_FAILED; }
 if(parser->to_end>parser->length) { return RET_FAILED; }
 aaCast(bp,BP,chlist);
 if(fwd)
  {
  while(1)
   {
   if(parser->is_end) { break; }
   if(logic==YES)   {   for(i=0;i<sl;i++) {   if(parser->ch==bp[i]) { return RET_YES; }    }   }
   else
    {
    for(i=0;i<sl;i++)  {    if(parser->ch==bp[i]) { break; }      }
    if(i==sl) { return RET_YES; }
    }
   aaParserSeek(parser,1);
   }
  }
 else
  {
  aaParserStackPush(parser);
  while(1)
   {
   aaParserSeek(parser,parser->to_end-1);
   //if(parser->is_end) { break; }
   if(logic==YES)   {   for(i=0;i<sl;i++) {   if(parser->ch==bp[i]) { return RET_YES; }    }   }
   else
    {
    for(i=0;i<sl;i++)  {    if(parser->ch==bp[i]) { break; }      }
    if(i==sl) { return RET_YES; }
    }
   aaParserSeek(parser,-1);
   }
  aaParserStackPop(parser);
  }
 return RET_NOTFOUND;
 }




 B aaParserSeekToQuoteEnd              (_parser*parser,B ch)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(parser==NULL) { return RET_BADPARM; }
 if(parser->magic!=aa_PARSE_MAGIC) { return RET_NOTSTARTED; }
 if(ch!=SQUOTE_CHAR&&ch!=DQUOTE_CHAR) { return RET_BADPARM; }
 while(1)
  {
  if(parser->is_end) { break; }
  if(parser->ch==BSLASH_CHAR)  { aaParserSeek(parser,2);   continue;   }
  if(parser->ch!=ch)           { aaParserSeek(parser,1);   continue;   }
  return RET_YES;
  }
 return RET_FAILED;
 }







 B aaParserSeekToNumber                (_parser*parser,B logic)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(parser==NULL) { return RET_BADPARM; }
 if(parser->magic!=aa_PARSE_MAGIC) { return RET_NOTSTARTED; }
 if(parser->string==NULL) { return RET_BADPARM; }
 if(parser->offset>parser->length) { return RET_FAILED; }
 if(parser->to_end>parser->length) { return RET_FAILED; }
 while(1)
  {
  if(parser->is_end) { break; }
  if(logic==YES&&aaCharIsNum(parser->ch)==YES) { return RET_YES; }
  if(logic!=YES&&aaCharIsNum(parser->ch)!=YES) { return RET_YES; }
  if(parser->is_end) { break; }
  aaParserSeek(parser,1);
  }
 return RET_NOTFOUND;
 }






 B aaParserSeekToVisibleChar           (_parser*parser,B logic,B fwd)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(parser==NULL) { return RET_BADPARM; }
 if(parser->magic!=aa_PARSE_MAGIC) { return RET_NOTSTARTED; }
 if(parser->string==NULL) { return RET_BADPARM; }
 if(parser->offset>parser->length) { return RET_FAILED; }
 if(parser->to_end>parser->length) { return RET_FAILED; }
 if(fwd)
  {
  while(1)
   {
   if(parser->is_end) { break; }
   if(logic==YES&&aaCharIsVisible(parser->ch)==YES) { return RET_YES; }
   if(logic!=YES&&aaCharIsVisible(parser->ch)!=YES) { return RET_YES; }
   aaParserSeek(parser,1);
   }
  }
 else
  {
  while(1)
   {
   if(logic==YES&&aaCharIsVisible(parser->ch)==YES) { return RET_YES; }
   if(logic!=YES&&aaCharIsVisible(parser->ch)!=YES) { return RET_YES; }
   if(parser->is_start) { break; }
   aaParserSeek(parser,-1);
   }
  }
 return RET_NOTFOUND;
 }





 B aaParserSeekToString                (_parser*parser,VP string,B cs,B logic,B flags)
 {
 H i,sl,oldoff;
 BP bp;
 B as,bs;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(parser==NULL) { return RET_BADPARM; }
 if(parser->magic!=aa_PARSE_MAGIC) { return RET_NOTSTARTED; }
 if(string==NULL) { return RET_BADPARM; }
 aaStringLen(string,&sl);
 if(parser->offset>parser->length) { return RET_FAILED; }
 if(parser->to_end>parser->length) { return RET_FAILED; }
 if((parser->offset+sl)>parser->length) { return RET_NOTFOUND; }
 if(sl>parser->to_end) {  return RET_NOTFOUND; }
 if(aaBitGet(flags,2))
  {
  if(parser->stack_len>=aaElementCount(parser->stack_buf)) { return RET_BOUNDS; }
  }
 oldoff=parser->offset;
 aaCast(bp,BP,string);
 while(1)
  {
  if(parser->is_end) { break; }
  if(sl>parser->to_end) { break; }
  if(logic==YES)
   {
   for(i=0;i<sl;i++)
    {
    as=bp[i];
    bs=parser->bp[i];
    if(!cs) { if(as>='A'&&as<='Z') { as+=32; } if(bs>='A'&&bs<='Z') { bs+=32; } }
    if(as!=bs)
     {
     parser->bp+=(i+1);
     parser->offset+=(i+1);
     parser->to_end-=(i+1);
     if(parser->offset==0) { parser->is_start=YES; } else   { parser->is_start=NO; }
     if(parser->to_end==0) { parser->is_end=YES; } else  { parser->is_end=NO; }
     parser->ch=parser->bp[0];
     break;
     }
    }
   if(i!=sl) { continue; }
   if(aaBitGet(flags,1))  {   aaParserSeek(parser,sl);   }
   if(aaBitGet(flags,2))  {   aaParserStackPush(parser);   }
   return RET_YES;
   }
  else
   {
   for(i=0;i<sl;i++)
    {
    as=bp[i];
    bs=parser->bp[i];
    if(!cs) { if(as>='A'&&as<='Z') { as+=32; } if(bs>='A'&&bs<='Z') { bs+=32; } }
    if(as==bs)     {     aaParserSeek(parser,i+1);   break;     }
    }
   if(i!=sl) { continue; }
   if(aaBitGet(flags,1))  { aaParserSeek(parser,sl);    }
   if(aaBitGet(flags,2))  {   aaParserStackPush(parser);   }
   return RET_YES;
   }
  parser->bp+=1;
  parser->offset+=1;
  parser->to_end-=1;
  if(parser->offset==0) { parser->is_start=YES; }
  else                  { parser->is_start=NO; }
  if(parser->to_end==0) { parser->is_end=YES; }
  else                  { parser->is_end=NO; }
  parser->ch=parser->bp[0];
  }
 if(aaBitGet(flags,0)) { aaParserOffsetSet(parser,oldoff);  }
 return RET_NOTFOUND;
 }



 B aaParserSeekToStringf               (_parser*parser,B cs,B logic,B flags,VP fmt,...)
 {
 va_list argptr;
 B str[_4K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,str);
 return(aaParserSeekToString(parser,str,cs,logic,flags));
 }




 B aaParserStringCopy                  (_parser*parser,VP buf,H chars,B appendnull)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(parser==NULL) { return RET_BADPARM; }
 if(parser->magic!=aa_PARSE_MAGIC) { return RET_NOTSTARTED; }
 if(buf==NULL) { return RET_BADPARM; }
 if(chars>parser->to_end) { return RET_BOUNDS; }
 if(chars==0)
  {
  if(appendnull) { aaStringNull(buf); }
  }
 else
  {
  aaStringNCopy(buf,parser->bp,chars,appendnull);
  }
 return RET_YES;
 }




 B aaParserStackPush                   (_parser*parser)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(parser==NULL) { return RET_BADPARM; }
 if(parser->magic!=aa_PARSE_MAGIC) { return RET_NOTSTARTED; }
 if(parser->stack_len>=aaElementCount(parser->stack_buf)) { return RET_BOUNDS; }
 parser->stack_buf[parser->stack_len]=parser->offset;
 parser->stack_len++;
 return RET_YES;
 }



 B aaParserStackPop                    (_parser*parser)
 {
 H off;
 B ret;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(parser==NULL) { return RET_BADPARM; }
 if(parser->magic!=aa_PARSE_MAGIC) { return RET_NOTSTARTED; }
 if(parser->stack_len==0) { return RET_BOUNDS; }
 off=parser->stack_buf[parser->stack_len-1];
 if((ret=aaParserOffsetSet(parser,off))!=YES) { return ret; }
 parser->stack_len--;
 return RET_YES;
 }




 B aaParserStackPeek                   (_parser*parser,H index,HP offset)
 {
 H off;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(parser==NULL) { return RET_BADPARM; }
 if(parser->magic!=aa_PARSE_MAGIC) { return RET_NOTSTARTED; }
 if(parser->stack_len==0) { return RET_BOUNDS; }
 if(index>=parser->stack_len) { return RET_BOUNDS; }
 off=parser->stack_buf[index];
 if(offset) { *offset=off; }
 return RET_YES;
 }



 B aaParserStackDiscard                (_parser*parser)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(parser==NULL) { return RET_BADPARM; }
 if(parser->magic!=aa_PARSE_MAGIC) { return RET_NOTSTARTED; }
 if(parser->stack_len==0) { return RET_BOUNDS; }
 parser->stack_len--;
 return RET_YES;
 }



 B aaParserStackString                 (_parser*parser,HP chars,H maxchars,VP buf,B appendnull)
 {
 B ret;
 H coff,poff,sl;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(parser==NULL) { return RET_BADPARM; }
 if(parser->magic!=aa_PARSE_MAGIC) { return RET_NOTSTARTED; }
 if(parser->stack_len==0) { return RET_BOUNDS; }
 coff=parser->offset;
 if((ret=aaParserStackPeek(parser,parser->stack_len-1,&poff))!=YES) { return ret; }
 sl=coff-poff;
 if(chars) { *chars=sl; }
 if(buf==NULL) { return RET_BADPARM; }
 if(appendnull) { aaStringNull(buf); }

 if(sl>maxchars)
  {
  if(sl>0) { aaStringNCopy(buf,&parser->string[poff],sl,appendnull); }
  return RET_BOUNDS;
  }
 if(sl>0) { aaStringNCopy(buf,&parser->string[poff],sl,appendnull); }
 aaParserStackDiscard(parser);
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/



/*-----------------------------------------------------------------------*/


 B aaCordNull                          (_cord*cord)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(cord==NULL)  { return RET_BADPARM; }
 cord->x=0;
 cord->y=0;
 return RET_YES;
 }



 B aaCordSet                           (_cord*cord,N x,N y)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(cord==NULL)  { return RET_BADPARM; }
 cord->x=x;
 cord->y=y;
 return RET_YES;
 }



 B aaCordGet                           (_cord*cord,NP x,NP y)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(cord==NULL) { return RET_BADPARM; }
 if(x) { *x=cord->x; }
 if(y) { *y=cord->y; }
 return RET_YES;
 }




 B aaCordCopy                          (_cord*cord,_cord*scord)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(cord==NULL)  { return RET_BADPARM; }
 if(scord==NULL)  { return RET_BADPARM; }
 cord->x=scord->x;
 cord->y=scord->y;
 return RET_YES;
 }





 B aaCordAdjust                        (_cord*cord,N xa,N ya)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(cord==NULL)    { return RET_BADPARM; }
 cord->x+=xa;
 cord->y+=ya;
 return RET_YES;
 }





 B aaCordsAdjust                       (_cord*cord1,_cord*cord2,N x1a,N y1a,N x2a,N y2a)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(cord1==NULL&&cord2==NULL) { return RET_BADPARM; }
 if(cord1!=NULL) { aaCordAdjust(cord1,x1a,y1a); }
 if(cord2!=NULL) { aaCordAdjust(cord2,x2a,y2a); }
 return RET_YES;
 }




 B aaCordEqualsCord                    (_cord*cord,_cord*cord2)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(cord==NULL)    { return RET_BADPARM; }
 if(cord2==NULL)   { return RET_BADPARM; }
 if(cord->x!=cord2->x) return RET_NO;
 if(cord->y!=cord2->y) return RET_NO;
 return RET_YES;
 }





 B aaCordSubtract                      (_cord*cord,_cord*cord2,_cord*rescord)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(cord==NULL)    { return RET_BADPARM; }
 if(cord2==NULL)   { return RET_BADPARM; }
 return(aaCordSet(rescord,(cord->x-cord2->x),(cord->y-cord2->y)));
 }





 B aaCordAdd                           (_cord*cord,_cord*cord2,_cord*rescord)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(cord==NULL)    { return RET_BADPARM; }
 if(cord2==NULL)   { return RET_BADPARM; }
 return(aaCordSet(rescord,(cord->x+cord2->x),(cord->y+cord2->y)));
 }




 B aaCordIsWithinRect                  (_cord*cord,_rect*rect)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(cord==NULL) { return RET_BADPARM; }
 if(rect==NULL) { return RET_BADPARM; }
 if(rect->w==0) { return RET_FAILED; }
 if(rect->h==0) { return RET_FAILED; }
 if(cord->x<rect->x) return RET_NO;
 if(cord->y<rect->y) return RET_NO;
 if(cord->x>=(N)(rect->x+rect->w)) return RET_NO;
 if(cord->y>=(N)(rect->y+rect->h)) return RET_NO;
 return RET_YES;
 }






 B aaCordIsWithinRects                 (_cord*cord,_rect*rect,H count,HP which)
 {
 H i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(cord==NULL) { return RET_BADPARM; }
 if(rect==NULL) { return RET_BADPARM; }
 if(which==NULL) { return RET_BADPARM; }
 *which=0xffffffff;
 if(count==0) { return RET_BADPARM; }
 for(i=0;i<count;i++)
  {
  if(rect[i].w==0) { return RET_FAILED; }
  if(rect[i].h==0) { return RET_FAILED; }
  if(cord->x<rect[i].x) continue;
  if(cord->y<rect[i].y) continue;
  if(cord->x>=(N)(rect[i].x+rect[i].w)) continue;
  if(cord->y>=(N)(rect[i].y+rect[i].h)) continue;
  *which=i;
  return RET_YES;
  }
 return RET_NO;
 }





 B aaCordsSet                          (_cord*cord1,_cord*cord2,N x1,N y1,N x2,N y2)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(cord1==NULL) { return RET_BADPARM; }
 if(cord2==NULL) { return RET_BADPARM; }
 aaCordSet(cord1,x1,y1);
 return(aaCordSet(cord2,x2,y2));
 }




 B aaCordsToRect                       (_cord*cord1,_cord*cord2,_rect*rect)
 {
 N n;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(cord1==NULL) { return RET_BADPARM; }
 if(cord2==NULL) { return RET_BADPARM; }
 if(rect!=NULL)
  {
  n=cord2->x-cord1->x;
  if(n>=0) { rect->x=cord1->x; rect->w=n; }
  else     { rect->x=cord2->x; rect->w=cord1->x-cord2->x; }
  n=cord2->y-cord1->y;
  if(n>=0) { rect->y=cord1->y; rect->h=n; }
  else     { rect->y=cord2->y; rect->h=cord1->y-cord2->y; }
  rect->w++;
  rect->h++;
  }
 return RET_YES;
 }




 B aaCordIsZero                        (_cord*cord)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(cord==NULL) { return RET_BADPARM; }
 if(cord->x==0&&cord->y==0) { return RET_YES; }
 return RET_NO;
 }



 B aaCordCopyFromRect                  (_cord*cord,_rect*srect)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(cord==NULL) { return RET_BADPARM; }
 if(srect==NULL)  { return RET_BADPARM; }
 cord->x=srect->x;
 cord->y=srect->y;
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/


 B aaSizeNull                          (_size*size)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(size==NULL)   { return RET_BADPARM; }
 size->w=0;
 size->h=0;
 return RET_YES;
 }


 B aaSizeSet                           (_size*size,H w,H h)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(size==NULL)   { return RET_BADPARM; }
 size->w=w;
 size->h=h;
 return RET_YES;
 }



 B aaSizeGet                           (_size*size,HP wid,HP hit)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(size==NULL) { return RET_BADPARM; }
 if(wid) { *wid=size->w; }
 if(hit) { *hit=size->h; }
 return RET_YES;
 }


 B aaSizeCopy                          (_size*size,_size*ssize)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(size==NULL)  { return RET_BADPARM; }
 if(ssize==NULL)  { return RET_BADPARM; }
 size->w=ssize->w;
 size->h=ssize->h;
 return RET_YES;
 }




 B aaSizeAdjust                        (_size*size,N wa,N ha)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(size==NULL) { return RET_BADPARM; }
 size->w+=wa;
 size->h+=ha;
 return RET_YES;
 }




 B aaSizeEqualsSize                    (_size*size,_size*size2)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(size==NULL)    { return RET_BADPARM; }
 if(size2==NULL)   { return RET_BADPARM; }
 if(size->w!=size2->w) return RET_NO;
 if(size->h!=size2->h) return RET_NO;
 return RET_YES;
 }




 B aaSizeToRect                        (_size*size,_rect*rect)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(size==NULL) { return RET_BADPARM; }
 return(aaRectSet(rect,0,0,size->w,size->h));
 }



 B aaSizeIsValid                       (_size*size)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(size==NULL) { return RET_BADPARM; }
 if((N)size->w<=0) { return RET_NO; }
 if((N)size->h<=0) { return RET_NO; }
 return RET_YES;
 }



 B aaSizeCordCenterGet                 (_size*size,_cord*cord)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(size==NULL) { return RET_BADPARM; }
 if(cord==NULL) { return RET_BADPARM; }
 cord->x=size->w/2;
 cord->y=size->h/2;
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/

 B aaRectNull                          (_rect*rect)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 rect->x=0;
 rect->y=0;
 rect->w=0;
 rect->h=0;
 return RET_YES;
 }




 B aaRectIsEmpty                       (_rect*rect)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 if(rect->w==0&&rect->h==0) { return RET_YES; }
 return RET_NO;
 }




 B aaRectSet                           (_rect*rect,N x,N y,H w,H h)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 rect->x=x;
 rect->y=y;
 rect->w=w;
 rect->h=h;
 return RET_YES;
 }




 B aaRectGet                           (_rect*rect,NP x,NP y,HP wid,HP hit)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 if(x) { *x=rect->x; }
 if(y) { *y=rect->y; }
 if(wid) { *wid=rect->w; }
 if(hit) { *hit=rect->h; }
 return RET_YES;
 }



 B aaRectCopy                          (_rect*rect,_rect*srect)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 if(srect==NULL) { return RET_BADPARM; }
 rect->x=srect->x;
 rect->y=srect->y;
 rect->w=srect->w;
 rect->h=srect->h;
 return RET_YES;
 }



 B aaRectSwap                          (_rect*rect,_rect*rect2)
 {
 _rect tmp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 if(rect2==NULL) { return RET_BADPARM; }
 if(rect==rect2) { return RET_YES; }
 aaRectCopy(&tmp,rect);
 aaRectCopy(rect,rect2);
 aaRectCopy(rect2,&tmp);
 return RET_YES;
 }




 B aaRectAdjust                        (_rect*rect,N xa,N ya,N wa,N ha)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 rect->x+=xa;
 rect->y+=ya;
 rect->w+=wa;
 rect->h+=ha;
 return RET_YES;
 }




 B aaRectCordSet                       (_rect*rect,N x,N y)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 rect->x=x;
 rect->y=y;
 return RET_YES;
 }





 B aaRectSizeSet                       (_rect*rect,H w,H h)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 rect->w=w;
 rect->h=h;
 return RET_YES;
 }



 B aaRectEqualsRect                    (_rect*rect,_rect*rect2)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL)    { return RET_BADPARM; }
 if(rect2==NULL)   { return RET_BADPARM; }
 if(rect->x!=rect2->x) return RET_NO;
 if(rect->y!=rect2->y) return RET_NO;
 if(rect->w!=rect2->w) return RET_NO;
 if(rect->h!=rect2->h) return RET_NO;
 return RET_YES;
 }





 B aaRectIntersect                     (_rect*rect,_rect*rect2,_rect*resrect)
 {
 BOOL bl;
 RECT rr1,rr2,rr3;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 if(rect2==NULL) { return RET_BADPARM; }
 if(resrect==NULL) { return RET_BADPARM; }
 WinRectFromRect(&rr1,rect);
 WinRectFromRect(&rr2,rect2);
 bl=IntersectRect(&rr3,&rr1,&rr2);
 resrect->x=rr3.left;
 resrect->y=rr3.top;
 resrect->w=rr3.right-rr3.left;
 resrect->h=rr3.bottom-rr3.top;
 if(bl==0) { return RET_NO; }
 return RET_YES;
 }



 B aaRectIsInsideRect                  (_rect*rect,_rect*rect2)
 {
 N r1x1,r1y1,r1y2,r1x2;
 N r2x1,r2y1,r2y2,r2x2;

 r1x1=(rect->x);             r1y1=(rect->y);
 r1x2=(rect->x+rect->w)-1;   r1y2=(rect->y+rect->h)-1;
 r2x1=(rect2->x);            r2y1=(rect2->y);
 r2x2=(rect2->x+rect2->w)-1; r2y2=(rect2->y+rect2->h)-1;
 if((r1x1>=r2x1)&&(r1x2<=r2x2))
  {
  if((r1y1>=r2y1)&&(r1y2<=r2y2))  {   return RET_YES;   }
  }
 return RET_NO;
 }




 B aaRectIsOutsideRect                 (_rect*rect,_rect*rect2)
 {
 N r1x1,r1y1,r1y2,r1x2;
 N r2x1,r2y1,r2y2,r2x2;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 r1x1=(rect->x);             r1y1=(rect->y);
 r1x2=(rect->x+rect->w)-1;   r1y2=(rect->y+rect->h)-1;
 r2x1=(rect2->x);            r2y1=(rect2->y);
 r2x2=(rect2->x+rect2->w)-1; r2y2=(rect2->y+rect2->h)-1;

 while(1)
  {
  if(r1x1<r2x1&&r1x2<r2x1) { break; }
  if(r1x1>r2x2&&r1x2>r2x2) { break; }
  if(r1y1<r2y1&&r1y2<r2y1) { break; }
  if(r1y1>r2y2&&r1y2>r2y2) { break; }
  return RET_NO;
  }
 return RET_YES;
 }




 B aaRectIsOverlappingRect             (_rect*rect,_rect*rect2)
 {
 N r1x1,r1y1,r1y2,r1x2;
 N r2x1,r2y1,r2y2,r2x2;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 r1x1=(rect->x);             r1y1=(rect->y);
 r1x2=(rect->x+rect->w)-1;   r1y2=(rect->y+rect->h)-1;
 r2x1=(rect2->x);            r2y1=(rect2->y);
 r2x2=(rect2->x+rect2->w)-1; r2y2=(rect2->y+rect2->h)-1;
 while(1)
  {
  if(r1x1<r2x1&&r1x2<r2x1) { break; }
  if(r1x1>r2x2&&r1x2>r2x2) { break; }
  if(r1y1<r2y1&&r1y2<r2y1) { break; }
  if(r1y1>r2y2&&r1y2>r2y2) { break; }
  return RET_YES;
  }
 return RET_NO;
 }





 B aaRectAdd                           (_rect*rect,_rect*rect2,_rect*resrect)
 {
 RECT rr1,rr2,rr3;
 _rect ro;
 _cord ca1,ca2;
 _cord cb1,cb2;
 _cord cd1,cd2;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 if(rect2==NULL) { return RET_BADPARM; }
 if(resrect==NULL) { return RET_BADPARM; }
 WinRectFromRect(&rr1,rect);
 WinRectFromRect(&rr2,rect2);

 aaRectToCords(rect,&ca1,&ca2);
 aaRectToCords(rect2,&cb1,&cb2);
 cd1.x=aaNumMin(ca1.x,cb1.x);
 cd2.x=aaNumMax(ca2.x,cb2.x);
 cd1.y=aaNumMin(ca1.y,cb1.y);
 cd2.y=aaNumMax(ca2.y,cb2.y);
 aaRectSet(resrect,cd1.x,cd1.y,(cd2.x-cd1.x)+1,(cd2.y-cd1.y)+1);
 UnionRect(&rr3,&rr1,&rr2);
 ro.x=rr3.left;
 ro.y=rr3.top;
 ro.w=rr3.right-rr3.left;
 ro.h=rr3.bottom-rr3.top;
 if(ro.x!=resrect->x||ro.y!=resrect->y||ro.w!=resrect->w||ro.h!=resrect->h)
  {
  aaRectCopy(resrect,rect2);
  }
 return RET_YES;
 }




 B aaRectSubtract                      (_rect*rect,_rect*rect2,_rect*resrect)
 {
 RECT rr1,rr2,rr3;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 if(rect2==NULL) { return RET_BADPARM; }
 if(resrect==NULL) { return RET_BADPARM; }
 WinRectFromRect(&rr1,rect);
 WinRectFromRect(&rr2,rect2);
 SubtractRect(&rr3,&rr1,&rr2);
 resrect->x=rr3.left;
 resrect->y=rr3.top;
 resrect->w=rr3.right-rr3.left;
 resrect->h=rr3.bottom-rr3.top;
 return RET_YES;
 }



 B aaRectToCords                       (_rect*rect,_cord*cord1,_cord*cord2)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 if(cord1!=NULL) { aaCordSet(cord1,rect->x,rect->y); }
 if(cord2!=NULL) { aaCordSet(cord2,(rect->x+rect->w)-1,(rect->y+rect->h)-1); }
 return RET_YES;
 }



 B aaRectToSize                        (_rect*rect,_size*size)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 return(aaSizeSet(size,rect->w,rect->h));
 }




 B aaRectIsValid                       (_rect*rect)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 if((N)rect->w<=0) { return RET_NO; }
 if((N)rect->h<=0) { return RET_NO; }
 return RET_YES;
 }





 B aaRectCordCenterGet                 (_rect*rect,_cord*cord)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 return(aaCordSet(cord,rect->x+(rect->w/2),rect->y+(rect->h/2)));
 }



 B aaRectExpand                        (_rect*rect,N wamnt,N hamnt)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 if(wamnt!=0)  {  rect->x=rect->x-wamnt;  rect->w=rect->w+(wamnt*2);  }
 if(hamnt!=0)  {  rect->y=rect->y-hamnt;  rect->h=rect->h+(hamnt*2);  }
 return RET_YES;
 }



 B aaRectToCornerCords                 (_rect*rect,_cord*cord1,_cord*cord2,_cord*cord3,_cord*cord4)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 if(cord1) { cord1->x=rect->x; cord1->y=rect->y; }
 if(cord2) { cord2->x=(rect->x+rect->w)-1; cord2->y=rect->y; }
 if(cord3) { cord3->x=(rect->x+rect->w)-1; cord3->y=(rect->y+rect->h)-1; }
 if(cord4) { cord4->x=rect->x; cord4->y=(rect->y+rect->h)-1; }
 return RET_YES;
 }



 B aaRectToSideCords                   (_rect*rect,_cord*cord1,_cord*cord2,_cord*cord3,_cord*cord4)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 if(cord1) { cord1->x=(rect->x+(rect->w/2))-1; cord1->y=rect->y; }
 if(cord2) { cord2->x=(rect->x+rect->w)-1; cord2->y=(rect->y+(rect->h/2))-1; }
 if(cord3) { cord3->x=(rect->x+(rect->w/2))-1; cord3->y=(rect->y+rect->h)-1; }
 if(cord4) { cord4->x=(rect->x); cord4->y=(rect->y+(rect->h/2))-1; }
 return RET_YES;
 }



 B aaRectAlignRect                     (_rect*rect,_rect*rect2,B ha,B va,_rect*resrect)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect2==NULL) { return RET_BADPARM; }
 if(rect==NULL) { return RET_BADPARM; }
 if(resrect==NULL) { return RET_BADPARM; }
 resrect->w=rect->w;
 resrect->h=rect->h;
 switch(ha)
  {
  default:
  case aa_ALIGN_NONE:   resrect->x=rect->x;  break;
  case aa_ALIGN_LEFT:   resrect->x=rect2->x+rect->x;  break;
  case aa_ALIGN_MIDDLE: resrect->x=(rect2->w/2)-(rect->w/2);  break;
  case aa_ALIGN_RIGHT:  resrect->x=(rect2->x+rect2->w)-(rect->w)-(rect->x);  break;
  }
 switch(va)
  {
  default:
  case aa_ALIGN_NONE:   resrect->y=rect->y;  break;
  case aa_ALIGN_TOP:   resrect->y=rect2->y+rect->y;  break;
  case aa_ALIGN_MIDDLE: resrect->y=(rect2->h/2)-(rect->h/2);  break;
  case aa_ALIGN_BOTTOM:  resrect->y=(rect2->y+rect2->h)-(rect->h)-(rect->y);  break;
  }
 return RET_YES;
 }




 B aaRectFromWinRect                   (_rect*rect,RECT*winrect)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(WinRectToRect(winrect,rect));
 }




 B aaRectMakeValid                     (_rect*rect)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 if(rect->w==0) { rect->w=1;  }
 if(rect->h==0) { rect->h=1;  }
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/


 B aaGridToCord                        (_rect*rect,_cord*g1,_cord*c1)
 {
 D xs,ys;
 _cord cd1;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 xs=rect->w/10000.0; ys=rect->h/10000.0;
 if(g1==NULL) { return RET_BADPARM; }
 if(c1==NULL) { return RET_BADPARM; }
 cd1.x=(g1->x*xs);
 cd1.y=(g1->y*ys);
 cd1.x+=rect->x;
 cd1.y+=rect->y;
 aaCordCopy(c1,&cd1);
 return RET_YES;
 }



 B aaGridToCords                       (_rect*rect,_cord*g1,_cord*g2,_cord*c1,_cord*c2)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(g1==NULL&&c1==NULL) { return RET_BADPARM; }
 if(g2!=NULL&&c2==NULL) { return RET_BADPARM; }
 if(g1==NULL&&c1!=NULL) { return RET_BADPARM; }
 if(g2==NULL&&c2!=NULL) { return RET_BADPARM; }
 if(g1&&c1) { aaGridToCord(rect,g1,c1); }
 if(g2&&c2) { aaGridToCord(rect,g2,c2); }
 return RET_YES;
 }


 B aaGridToRect                        (_rect*rect,_cord*g1,_cord*g2,_rect*r1)
 {
 D xs,ys;
 _cord cd1,cd2;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 xs=rect->w/10000.0; ys=rect->h/10000.0;
 if(g1==NULL&&g2==NULL) { return RET_BADPARM; }
 if(g1==NULL) { aaCordSet(&cd1,rect->x,rect->y); }
 else
  {
  cd1.x=(g1->x*xs);
  cd1.y=(g1->y*ys);
  cd1.x+=rect->x;
  cd1.y+=rect->y;
  }
 if(g2==NULL) { aaCordSet(&cd2,(rect->x+rect->w)-1,(rect->y+rect->h)-1); }
 else
  {
  cd2.x=(g2->x*xs);
  cd2.y=(g2->y*ys);
  cd2.x+=rect->x;
  cd2.y+=rect->y;
  }
 if(r1)
  {
  aaRectSet(r1,cd1.x,cd1.y,(cd2.x-cd1.x)+1,(cd2.y-cd1.y)+1);
  }
 return RET_YES;
 }





 B aaGridRectToCord                    (_rect*rect,_rect*r1,_cord*c1)
 {
 _rect rc1;
 _cord gc1,gc2;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(r1==NULL) { aaRectCopy(&rc1,rect); }
 else         { aaRectCopy(&rc1,r1); }
 aaRectToCords(&rc1,&gc1,&gc2);
 aaGridToCord(rect,&gc1,c1);
 return RET_YES;
 }






 B aaGridRectToCords                   (_rect*rect,_rect*r1,_cord*c1,_cord*c2)
 {
 _rect rc1;
 _cord gc1,gc2;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(r1==NULL) { aaRectCopy(&rc1,rect); }
 else         { aaRectCopy(&rc1,r1); }
 aaRectToCords(&rc1,&gc1,&gc2);
 aaGridToCords(rect,&gc1,&gc2,c1,c2);
 return RET_YES;
 }




 B aaGridRectToRect                    (_rect*rect,_rect*r1,_rect*r2)
 {
 _rect rc1;
 _cord gc1,gc2;
 _cord cd1,cd2;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(r1==NULL) { aaRectCopy(&rc1,rect); }
 else         { aaRectCopy(&rc1,r1); }
 aaRectToCords(&rc1,&gc1,&gc2);
 aaGridToCords(rect,&gc1,&gc2,&cd1,&cd2);
 aaCordsToRect(&cd1,&cd2,r2);
 return RET_YES;
 }






 B aaCordToGrid                        (_rect*rect,_cord*c1,_cord*g1)
 {
 D xs,ys;
 _cord cd1;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 xs=rect->w/10000.0; ys=rect->h/10000.0;
 if(c1==NULL) { aaCordSet(&cd1,rect->x,rect->y); }
 else
  {
  cd1.x=c1->x/xs;
  cd1.y=c1->y/ys;
  }
 if(g1)
  {
  aaCordCopy(g1,&cd1);
  }
 return RET_YES;
 }





 B aaCordToGrids                       (_rect*rect,_cord*c1,_cord*c2,_cord*g1,_cord*g2)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(g1!=NULL&&c1==NULL) { return RET_BADPARM; }
 if(g2!=NULL&&c2==NULL) { return RET_BADPARM; }
 if(g1==NULL&&c1!=NULL) { return RET_BADPARM; }
 if(g2==NULL&&c2!=NULL) { return RET_BADPARM; }
 if(g1&&c1) { aaCordToGrid(rect,c1,g1); }
 if(g2&&c2) { aaCordToGrid(rect,c2,g2); }
 return RET_YES;
 }




 B aaRectToGrid                        (_rect*rect,_rect*r1,_cord*g1,_cord*g2)
 {
 D xs,ys;
 _rect rc1;
 _cord cd1,cd2;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 xs=rect->w/10000.0; ys=rect->h/10000.0;
 if(r1==NULL) { aaRectSet(&rc1,rect->x,rect->y,rect->w,rect->h); }
 else         { aaRectCopy(&rc1,r1);  }
 cd1.x=(rc1.x)/xs;
 cd1.y=(rc1.y)/ys;
 cd2.x=(((rc1.x+rc1.w)-1)/xs);
 cd2.y=(((rc1.y+rc1.h)-1)/ys);
 if(g1)  {  aaCordCopy(g1,&cd1); }
 if(g2)  {  aaCordCopy(g2,&cd2); }
 return RET_YES;
 }



 B aaGridFromFloats                    (_cord*cord1,_cord*cord2,D x1,D y1,D x2,D y2)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(cord1==NULL&&cord2==NULL) { return RET_BADPARM; }
 if(cord1)
  {
  x1=x1*100.0;
  y1=y1*100.0;
  x1=aaNumClamp(x1,0.0,10000.0);
  y1=aaNumClamp(y1,0.0,10000.0);
  cord1->x=x1;
  cord1->y=y1;
  }
 if(cord2)
  {
  x2=x2*100.0;
  y2=y2*100.0;
  x2=aaNumClamp(x2,0.0,10000.0);
  y2=aaNumClamp(y2,0.0,10000.0);
  cord2->x=x2;
  cord2->y=y2;
  }
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/





 B aaRgbaSet                           (_rgba*rgba,B r,B g,B b,B a)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rgba==NULL)  { return RET_BADPARM; }
 rgba->r=r;
 rgba->g=g;
 rgba->b=b;
 rgba->a=a;
 return RET_YES;
 }





 B aaRgbaCopy                          (_rgba*rgba,_rgba*srgba)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rgba==NULL)   { return RET_BADPARM; }
 if(srgba==NULL)  { return RET_BADPARM; }
 rgba->r=srgba->r;
 rgba->g=srgba->g;
 rgba->b=srgba->b;
 rgba->a=srgba->a;
 return RET_YES;
 }




 B aaRgbaCopyWithAlpha                 (_rgba*rgba,_rgba*srgba,B a)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rgba==NULL)   { return RET_BADPARM; }
 if(srgba==NULL)  { return RET_BADPARM; }
 rgba->r=srgba->r;
 rgba->g=srgba->g;
 rgba->b=srgba->b;
 rgba->a=a;
 return RET_YES;
 }



 B aaRgbaAdjust                        (_rgba*rgba,N ramnt,N gamnt,N bamnt,N aamnt)
 {
 N r,g,b,a;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rgba==NULL) { return RET_BADPARM; }
 r=rgba->r+ramnt;
 g=rgba->g+gamnt;
 b=rgba->b+bamnt;
 a=rgba->a+aamnt;
 r=aaNumClamp(r,0,255);
 g=aaNumClamp(g,0,255);
 b=aaNumClamp(b,0,255);
 a=aaNumClamp(a,0,255);
 rgba->r=(B)r;
 rgba->g=(B)g;
 rgba->b=(B)b;
 rgba->a=(B)a;
 return RET_YES;
 }







 B aaRgbaEqualsRgba                    (_rgba*rgba,_rgba*rgba2)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rgba==NULL)    { return RET_BADPARM; }
 if(rgba2==NULL)   { return RET_BADPARM; }
 if(rgba->r!=rgba2->r) return RET_NO;
 if(rgba->g!=rgba2->g) return RET_NO;
 if(rgba->b!=rgba2->b) return RET_NO;
 if(rgba->a!=rgba2->a) return RET_NO;
 return RET_YES;
 }





 B aaRgbaGradientArray                 (_rgba*rgba1,_rgba*rgba2,H count,_rgba*rgbaarray)
 {
 F rx,gx,bx,ax;
 F rs,gs,bs,as,d;
 H i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rgba1==NULL) { return RET_BADPARM; }
 if(rgba2==NULL) { return RET_BADPARM; }
 if(rgbaarray==NULL) { return RET_BADPARM; }
 if(count==0) { return RET_BADPARM; }
 rs=(F)rgba1->r; d=rgba2->r-rgba1->r; rx=d/(F)count;
 gs=(F)rgba1->g; d=rgba2->g-rgba1->g; gx=d/(F)count;
 bs=(F)rgba1->b; d=rgba2->b-rgba1->b; bx=d/(F)count;
 as=(F)rgba1->a; d=rgba2->a-rgba1->a; ax=d/(F)count;
 for(i=0;i<count;i++)
  {
  rgbaarray[i].r=(B)rs;
  rgbaarray[i].g=(B)gs;
  rgbaarray[i].b=(B)bs;
  rgbaarray[i].a=(B)as;
  rs+=rx; gs+=gx; bs+=bx; as+=ax;
  aaNumDoClamp(rs,0.0,255.0);
  aaNumDoClamp(gs,0.0,255.0);
  aaNumDoClamp(bs,0.0,255.0);
  aaNumDoClamp(as,0.0,255.0);
  }
 if(rgba1->a==255&&rgba2->a==255)
  {
  for(i=0;i<count;i++) { if(rgbaarray[i].a!=255) { oof; }}
  }
 return RET_YES;
 }





 B aaRgbaDwordSet                      (_rgba*rgba,H dword)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rgba==NULL) { return RET_BADPARM; }
 rgba->a=(B)((dword>>0)&F8);
 rgba->r=(B)((dword>>24)&F8);
 rgba->g=(B)((dword>>16)&F8);
 rgba->b=(B)((dword>>8)&F8);
 return RET_YES;
 }





 B aaRgbaYuvaSet                       (_rgba*rgba,B y,B u,B v,B a)
 {
 F yy,uu,vv;
 N r,g,b;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rgba==NULL)  {  return RET_BADPARM;  }
 yy=(F)y;
 uu=(F)u;
 vv=(F)v;
 r=(yy+1.402*(vv-128.0));
 g=(yy-0.34414*(uu-128.0)-0.71414*(vv-128.0));
 b=(yy+1.772*(uu-128.0));
 rgba->r=(B)aaNumClamp(r,0,255);
 rgba->g=(B)aaNumClamp(g,0,255);
 rgba->b=(B)aaNumClamp(b,0,255);
 rgba->a=a;
 return RET_YES;
 }






 B aaRgbaSetUsingHsla                  (_rgba*rgba,B h,B s,B l,B a)
 {
 _hsla hh;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rgba==NULL) { return RET_BADPARM; }
 aaHslaSet(&hh,h,s,l,a);
 aaHslaToRgba(&hh,rgba);
 return RET_YES;
 }





 B aaRgbaShadeSet                      (_rgba*p1,_rgba*p2,F amnt)
 {
 D l,s;
 _hsla hh;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(p1==NULL) { return RET_BADPARM; }
 if(amnt<0.0) { return RET_BOUNDS; }
 aaHslaFromRgba(&hh,p1);
 l=hh.l;
 l=l*amnt;
 l=aaNumClamp(l,0.0,255.0);
 s=hh.s;
 s=s*amnt;
 s=aaNumClamp(s,0.0,255.0);
 hh.l=(B)l;
 hh.s=(B)s;
 if(p2==NULL) {  aaHslaToRgba(&hh,p1); }
 else         {  aaHslaToRgba(&hh,p2); }
 return RET_YES;
 }






 B aaRgbaSwap                          (_rgba*p1,_rgba*p2)
 {
 _rgba pn;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(p1==NULL) { return RET_BADPARM; }
 if(p2==NULL) { return RET_BADPARM; }
 if(p1==p2) { oof; return RET_YES; }
 aaRgbaCopy(&pn,p1);
 aaRgbaCopy(p1,p2);
 aaRgbaCopy(p2,&pn);
 return RET_YES;
 }





 B aaRgbaMix                           (_rgba*p1,_rgba*p2,_rgba*p3)
 {
 N a1;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(p1==NULL||p2==NULL||p3==NULL) { return RET_BADPARM; }
 a1=(p1->r+p2->r)>>1;  p3->r=(B)(a1);
 a1=(p1->g+p2->g)>>1;  p3->g=(B)(a1);
 a1=(p1->b+p2->b)>>1;  p3->b=(B)(a1);
 a1=(p1->a+p2->a)>>1;  p3->a=(B)(a1);
 return RET_YES;
 }






 B aaRgbaAdjustUsingHsla               (_rgba*p1,N hamnt,N samnt,N lamnt,N aamnt,_rgba*p2)
 {
 _hsla hh;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(p1==NULL) { return RET_BADPARM; }
 aaHslaFromRgba(&hh,p1);
 aaHslaAdjust(&hh,hamnt,samnt,lamnt,aamnt);
 if(p2) { aaHslaToRgba(&hh,p2); }
 else   { aaHslaToRgba(&hh,p1); }
 return RET_YES;
 }


 B aaRgbaDistanceCompare               (_rgba*p1,_rgba*p2,DP res)
 {
 N r,g,b,rmean;
 D result;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(res==NULL)  { return RET_BADPARM; }
 if(p1==NULL)   { return RET_BADPARM; }
 if(p2==NULL)   { return RET_BADPARM; }
 rmean=(p1->r+p2->r)/2;
 r=(N)p1->r-(N)p2->r;
 g=(N)p1->g-(N)p2->g;
 b=(N)p1->b-(N)p2->b;
 result=sqrt((((512+rmean)*r*r)>>8)+4*g*g+(((767-rmean)*b*b)>>8));
 result=result/764.0;
 result=result*100.0;
 if(result>100.0) { result=100.0; }
 *res=result;
 return RET_YES;
 }

 B aaRgbabfSet                         (_rgbabf*rgbabf,B rb,B gb,B bb,B ab,B rf,B gf,B bf,B af)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rgbabf==NULL) { return RET_BADPARM; }
 aaRgbaSet(&rgbabf->bg,rb,gb,bb,ab);
 aaRgbaSet(&rgbabf->fg,rf,gf,bf,af);
 return RET_YES;
 }


 B aaRgbabfCopy                        (_rgbabf*rgbabf,_rgba*rgbab,_rgba*rgbaf)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rgbabf==NULL) { return RET_BADPARM; }
 if(rgbab!=NULL) { aaRgbaCopy(&rgbabf->bg,rgbab); }
 if(rgbaf!=NULL) { aaRgbaCopy(&rgbabf->fg,rgbaf); }
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/

 B aaYuvaSet                           (_yuva*yuva,B y,B u,B v,B a)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(yuva==NULL) { return RET_BADPARM; }
 yuva->y=y;
 yuva->u=u;
 yuva->v=v;
 yuva->a=a;
 return RET_YES;
 }



 B aaYuvaCopy                          (_yuva*yuva,_yuva*syuva)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(yuva==NULL) { return RET_BADPARM; }
 if(syuva==NULL) { return RET_BADPARM; }
 yuva->y=syuva->y;
 yuva->u=syuva->u;
 yuva->v=syuva->v;
 yuva->a=syuva->a;
 return RET_YES;
 }



 B aaYuvaAdjust                        (_yuva*yuva,N yamnt,N uamnt,N vamnt,N aamnt)
 {
 N y,u,v,a;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(yuva==NULL) { return RET_BADPARM; }
 y=yuva->y+yamnt;
 u=yuva->u+uamnt;
 v=yuva->v+vamnt;
 a=yuva->a+aamnt;
 y=aaNumClamp(y,0,255);
 u=aaNumClamp(u,0,255);
 v=aaNumClamp(v,0,255);
 a=aaNumClamp(a,0,255);
 yuva->y=(B)y;
 yuva->u=(B)u;
 yuva->v=(B)v;
 yuva->a=(B)a;
 return RET_YES;
 }



 B aaYuvaToRgba                        (_yuva*yuva,_rgba*rgba)
 {
 F yy,uu,vv;
 N r,g,b;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(yuva==NULL) { return RET_BADPARM; }
 if(rgba==NULL) { return RET_BADPARM; }
 yy=(F)yuva->y;
 uu=(F)yuva->u;
 vv=(F)yuva->v;
 r=(yy+1.402*(vv-128.0));
 g=(yy-0.34414*(uu-128.0)-0.71414*(vv-128.0));
 b=(yy+1.772*(uu-128.0));
 rgba->r=(B)aaNumClamp(r,0,255);
 rgba->g=(B)aaNumClamp(g,0,255);
 rgba->b=(B)aaNumClamp(b,0,255);
 rgba->a=yuva->a;
 return RET_YES;
 }



 B aaYuvaFromRgba                      (_yuva*yuva,_rgba*rgba)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(yuva==NULL) { return RET_BADPARM; }
 if(rgba==NULL) { return RET_BADPARM; }
 yuva->y=rgba->r*.299000+rgba->g*.587000+rgba->b*.114000;
 yuva->u=rgba->r*-.168736+rgba->g*-.331264+rgba->b*.500000+128;
 yuva->v=rgba->r*.500000+rgba->g*-.418688+rgba->b*-.081312+128;
 yuva->a=rgba->a;
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/


 B aaHslaSet                           (_hsla*hsla,B h,B s,B l,B a)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(hsla==NULL) { return RET_BADPARM; }
 hsla->h=h;
 hsla->s=s;
 hsla->l=l;
 hsla->a=a;
 return RET_YES;
 }



 B aaHslaCopy                          (_hsla*hsla,_hsla*shsla)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(shsla==NULL) { return RET_BADPARM; }
 return(aaHslaSet(hsla,shsla->h,shsla->s,shsla->l,shsla->a));
 }




 B aaHslaAdjust                        (_hsla*hsla,N hamnt,N samnt,N lamnt,N aamnt)
 {
 N h,l,s,a;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(hsla==NULL) { return RET_BADPARM; }
 h=(N)hsla->h+hamnt;
 s=(N)hsla->s+samnt;
 l=(N)hsla->l+lamnt;
 a=(N)hsla->a+aamnt;
 if(h<0)   { h=0;   }
 if(h>255) { h=255; }
 if(s<0)   { s=0;   }
 if(s>255) { s=255; }
 if(l<0)   { l=0;   }
 if(l>255) { l=255; }
 if(a<0)   { a=0;   }
 if(a>255) { a=255; }

 ///h=aaNumClamp(h,0,255);
 ///l=aaNumClamp(l,0,255);
 //s=aaNumClamp(s,0,255);
 //a=aaNumClamp(a,0,255);
 hsla->h=(B)h;
 hsla->s=(B)s;
 hsla->l=(B)l;
 hsla->a=(B)a;
 return RET_YES;
 }






 B aaHslaToRgba                        (_hsla*hsla,_rgba*rgba)
 {
 F hue,lum,sat;
 F rm1,rm2;
 F trm1,trm2,th;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(hsla==NULL) { return RET_BADPARM; }
 if(rgba==NULL) { return RET_BADPARM; }
 hue=((F)hsla->h/255.0)*360.0;
 lum=(F)hsla->l/255.0;
 sat=(F)hsla->s/255.0;

 if(sat==0.0)
  {
  rgba->r=rgba->g=rgba->b=(B)(lum*255.0);
  }
 else
  {
  if(lum<=0.5f) { rm2=lum+lum*sat; }  else { rm2=lum+sat-lum*sat; }
  rm1=2.0f*lum-rm2;
  trm1=rm1; trm2=rm2; th=hue+120.f;
  if      (th>360.0f) th-=360.0f;  else
  if      (th<0.0f)   th+=360.0f;

  if      (th<60.0f)  trm1=trm1+(trm2-trm1)*th/60.0f;  else
  if      (th<180.0f) trm1=trm2;  else
  if      (th<240.0f) trm1=trm1+(trm2-trm1)*(240.0f-th)/60.0f;
  rgba->r=(B)(trm1*255);

  trm1=rm1; trm2=rm2; th=hue;
  if      (th>360.0f) th-=360.0f;  else
  if      (th<0.0f)   th+=360.0f;

  if      (th<60.0f)  trm1=trm1+(trm2-trm1)*th/60.0f;  else
  if      (th<180.0f) trm1=trm2;  else
  if      (th<240.0f) trm1=trm1+(trm2-trm1)*(240.0f-th)/60.0f;
  rgba->g=(B)(trm1*255);

  trm1=rm1; trm2=rm2; th=hue-120.0f;
  if      (th>360.0f) th-=360.0f;  else
  if      (th<0.0f)   th+=360.0f;

  if      (th<60.0f)  trm1=trm1+(trm2-trm1)*th/60.0f;  else
  if      (th<180.0f) trm1=trm2;  else
  if      (th<240.0f) trm1=trm1+(trm2-trm1)*(240.0f-th)/60.0f;
  rgba->b=(B)(trm1*255);
  }
 rgba->a=hsla->a;
 return RET_YES;
 }





 B aaHslaFromRgba                      (_hsla*hsla,_rgba*rgba)
 {
 B minval,maxval;
 F mdiff,msum;
 F rnorm,gnorm,bnorm;
 F lum,sat,hue;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(hsla==NULL) { return RET_BADPARM; }
 if(rgba==NULL) { return RET_BADPARM; }
 minval=aaNumMin(rgba->r,aaNumMin(rgba->g,rgba->b));
 maxval=aaNumMax(rgba->r,aaNumMax(rgba->g,rgba->b));
 mdiff=(F)(maxval)-(F)(minval);
 msum=(F)(maxval)+(F)(minval);
 lum=msum/510.0f;
 sat=0.0f;
 hue=0.0f;
 if(maxval!=minval)
  {
  rnorm=(maxval-rgba->r)/mdiff;
  gnorm=(maxval-rgba->g)/mdiff;
  bnorm=(maxval-rgba->b)/mdiff;
  sat=(lum<=0.5f)?(mdiff/msum):(mdiff/(510.0f-msum));
  if(rgba->r==maxval) hue=60.0f*(6.0f+bnorm-gnorm);
  if(rgba->g==maxval) hue=60.0f*(2.0f+rnorm-bnorm);
  if(rgba->b==maxval) hue=60.0f*(4.0f+gnorm-rnorm);
  if(hue>360.0f)      hue=hue-360.0f;
  }
 hsla->h=(B)((hue/360.0)*255.0);
 hsla->s=(B)(sat*255.0);
 hsla->l=(B)(lum*255.0);
 hsla->a=rgba->a;
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/


 _cord*aaCord                          (_cord*cd,N x,N y)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(cd==NULL) { return NULL; }
 cd->x=x;
 cd->y=y;
 return cd;
 }




 _size*aaSize                          (_size*sz,H w,H h)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(sz==NULL) { return NULL; }
 sz->w=w;
 sz->h=h;
 return sz;
 }





 _rect*aaRect                          (_rect*rc,N x,N y,H w,H h)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rc==NULL) { return NULL; }
 rc->x=x;
 rc->y=y;
 rc->w=w;
 rc->h=h;
 return rc;
 }





 _rgba*aaRgba                          (_rgba*pn,B r,B g,B b,B a)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(pn==NULL) { return NULL; }
 pn->r=r;
 pn->g=g;
 pn->b=b;
 pn->a=a;
 return pn;
 }





 _yuva*aaYuva                          (_yuva*yu,B y,B u,B v,B a)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(yu==NULL) { return NULL; }
 yu->y=y;
 yu->u=u;
 yu->v=v;
 yu->a=a;
 return yu;
 }






 _hsla*aaHsla                          (_hsla*hl,B h,B s,B l,B a)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(hl==NULL) { return NULL; }
 hl->h=h;
 hl->s=s;
 hl->l=l;
 hl->a=a;
 return hl;
 }





/*-----------------------------------------------------------------------*/




 B aaPoolCreate                        (HP handle,H bytesperblock,H blocksperpage,H maxpages)
 {
 B ret;
 _aa_poolobject*poop;
 H add;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==NULL) { return RET_BADPARM; }
 *handle=0;
 if((ret=aa_ObjectCreate(aa.pool_system.object_id,handle,(VP)&poop))!=RET_YES) { oops; return ret; }
 poop->self_handle=*handle;
 ret=RET_YES;
 while(1)
  {
  if(bytesperblock==0||bytesperblock>_1GIG) { ret=RET_BOUNDS; break; }
  if(blocksperpage==0||blocksperpage>_1GIG) { ret=RET_BOUNDS; break; }
  if(maxpages==0||maxpages>_1GIG) { ret=RET_BOUNDS; break; }
  poop->status.max_possible_blocks=(Q)blocksperpage*(Q)maxpages;
  poop->status.max_possible_memory=poop->status.max_possible_blocks*(Q)bytesperblock;
  if(poop->status.max_possible_blocks>_2GIG) { ret=RET_BOUNDS; break; }
  poop->status.blocks_per_page=blocksperpage;
  poop->status.bytes_per_block=bytesperblock;
  poop->status.max_pages=maxpages;
  poop->id_counter=1;
  add=poop->status.blocks_per_page;
  add=add/10;
  add=aaNumFloor(add,10);
  add=aaNumRoof(add,100);
  poop->pages_topup_amount=add;
  poop->pages_topup_threshold=poop->pages_topup_amount/10;
  if((poop->pages_topup_amount-poop->pages_topup_threshold)<10) { poop->pages_topup_amount+=10; }
  if((ret=aa_PoolSystemAddPages((VP)&poop,poop->pages_topup_amount))!=YES) { break; }
  break;
  }
 if(ret!=RET_YES)
  {
  aaPoolDestroy(*handle);
  *handle=0;
  return ret;
  }
 return RET_YES;
 }





 B aaPoolDestroy                       (H handle)
 {
 B ret;
 _aa_poolobject*poop;
 B isprot;
 H page_index;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.pool_system.object_id,handle,(VP)&poop,&isprot))!=RET_YES) { return ret; }
 if(isprot) { return RET_FORBIDDEN; }
 for(page_index=0;page_index<poop->pages_allocated;page_index++)
  {
  if(poop->page[page_index].blocks_allocated==0) { continue; }
  if((ret=aaMemoryRelease(poop->page[page_index].block_memory))!=YES) { oops; break; }
  if((ret=aaMemoryRelease(poop->page[page_index].block_state))!=YES) { oops; break; }
  }
 if(page_index!=0)
  {
  aaMemoryRelease(poop->page);
  }
 aa_ObjectDestroy(aa.pool_system.object_id,handle);
 return RET_YES;
 }



 B aaPoolStatus                        (H handle,_poolstatus*poolstatus)
 {
 B ret;
 _aa_poolobject*poop;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.pool_system.object_id,handle,(VP)&poop,NULL))!=RET_YES) { return ret; }
 if(poolstatus) { aaMemoryCopy(poolstatus,sizeof(_poolstatus),&poop->status); }
 return RET_YES;
 }




 B aaPoolStatusToString                (H handle,_poolstatus*poolstatus,VP str)
 {
 B ret;
 _aa_poolobject*poop;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.pool_system.object_id,handle,(VP)&poop,NULL))!=RET_YES) { return ret; }
 if(poolstatus) { aaMemoryCopy(poolstatus,sizeof(_poolstatus),&poop->status); }
 if(str)
  {
  aaStringNull(str);
  aaStringAppendf(str,"bytes_per_block=%u     \n",poop->status.bytes_per_block);
  aaStringAppendf(str,"blocks_per_page=%u  \n",poop->status.blocks_per_page);
  aaStringAppendf(str,"max_Pages=%u\n\n",poop->status.max_pages);
  aaStringAppendf(str,"block_count=%u  \n",poop->status.block_count);
  aaStringAppendf(str,"max_possible_blocks=%I64u  \n",poop->status.max_possible_blocks);
  aaStringAppendf(str,"max_possible_memory=%I64u  \n",poop->status.max_possible_memory);
  aaStringAppendf(str,"-----------------\n");
  }
 return RET_YES;
 }




 B aaPoolBlockNew                      (H handle,_poolblock*poolblock)
 {
 B ret;
 _aa_poolobject*poop;
 H b,p,x=0,y=0;
 H page_index;
 H blok_index;
 H left,bytes;
 BP bp;
 _aa_poolblockstub*blockstub;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.pool_system.object_id,handle,(VP)&poop,NULL))!=RET_YES) { return ret; }
 if(poolblock==NULL) { return RET_BADPARM; }
 aaMemoryFill(poolblock,sizeof(_poolblock),0);
 page_index=0xffffffff;
 blok_index=0xffffffff;
 for(p=0;p<poop->pages_allocated;p++)
  {
  y=poop->page_pf;
  left=poop->page[y].blocks_allocated-poop->page[y].blocks_inuse;
  if(left==0)
   {
   left=poop->pages_allocated-poop->pages_full;
   if(left<poop->pages_topup_threshold)
    {
    if((ret=aa_PoolSystemAddPages((VP)&poop,poop->pages_topup_amount))!=YES) { oops; }
    }
   left=poop->page[y].blocks_allocated-poop->page[y].blocks_inuse;
   poop->page_pf=poop->pages_full;
   y=poop->page_pf;
   bytes=sizeof(_aa_poolblockstub)+poop->status.bytes_per_block;
   if((ret=aaMemoryAllocate((VP)&poop->page[y].block_memory,bytes*poop->status.blocks_per_page))!=YES) { oops; }
   aaMemoryNameSet(poop->page[y].block_memory,"poolblock");
   if((ret=aaMemoryAllocate((VP)&poop->page[y].block_state,poop->status.blocks_per_page))!=YES) { oops; }
   aaMemoryNameSet(poop->page[y].block_state,"poolblocksta");
   poop->page[y].blocks_allocated=poop->status.blocks_per_page;
   poop->page[y].blocks_inuse=0;
   poop->page[y].block_pf=0;
   }
  for(b=0;b<poop->page[y].blocks_allocated;b++)
   {
   x=poop->page[y].block_pf;
   poop->page[y].block_pf++;
   poop->page[y].block_pf%=poop->page[y].blocks_allocated;
   if(poop->page[y].block_state[x]!=0) { continue; }
   page_index=y;
   blok_index=x;
   break;
   }
  if(page_index!=0xffffffff&&blok_index!=0xffffffff) break;
  }
 if(page_index==0xffffffff||blok_index==0xffffffff)
  {
  aaNote(0,"page_index=%i blok_index=%i pgpf=%i pa=%i pul=%i x=%i y=%i",
            page_index,blok_index,poop->page_pf,poop->pages_allocated,
            poop->pages_full,x,y);
  }
 bytes=sizeof(_aa_poolblockstub)+poop->status.bytes_per_block;
 bp=&poop->page[page_index].block_memory[(blok_index*bytes)];
 blockstub=(_aa_poolblockstub*)bp;
 blockstub->magic=(H)(PP)aaPoolBlockNew;
 blockstub->state=1;
 blockstub->page_index=page_index;
 blockstub->block_index=blok_index;
 blockstub->id=poop->id_counter;
 poop->id_counter++;
 bp+=sizeof(_aa_poolblockstub);
 poop->page[page_index].block_state[blok_index]=1;
 poop->page[page_index].blocks_inuse++;
 poop->status.block_count++;
 if(poop->page[page_index].blocks_inuse==poop->page[page_index].blocks_allocated)
  {
  poop->pages_full++;
  }
 poolblock->id=blockstub->id;
 poolblock->index= (blockstub->page_index*poop->status.blocks_per_page)+blockstub->block_index;
 poolblock->state=blockstub->state;
 poolblock->mem=bp;
 return RET_YES;
 }






 B aaPoolBlockDelete                   (H handle,VP block)
 {
 B ret;
 _aa_poolobject*poop;
 BP bp;
 _aa_poolblockstub*blockstub;
 H page_index,blok_index;
 B was_full;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.pool_system.object_id,handle,(VP)&poop,NULL))!=RET_YES) { return ret; }
 if(block==NULL) { return RET_BADPARM; }
 bp=(BP)block;
 bp-=sizeof(_aa_poolblockstub);
 blockstub=(_aa_poolblockstub*)bp;
 if(blockstub->magic!=(H)(PP)aaPoolBlockNew) { oof; }
 bp=(BP)block;
 page_index=blockstub->page_index;
 blok_index=blockstub->block_index;
 if(poop->page[page_index].block_state[blockstub->block_index]==0) { return RET_YES; }
 was_full=NO;
 if(poop->page[page_index].blocks_inuse==poop->page[page_index].blocks_allocated) { was_full=YES; }
 poop->page[page_index].block_state[blockstub->block_index]=0;
 poop->page[page_index].blocks_inuse--;
 poop->status.block_count--;
 if(was_full) {  poop->pages_full--;  }
 poop->page[page_index].block_pf=blok_index;
 poop->page_pf=page_index;
 blockstub->state=0;
 return RET_YES;
 }





 B aaPoolBlockDeleteByIndex            (H handle,H bindex)
 {
 B ret;
 _aa_poolobject*poop;
 BP bp;
 _aa_poolblockstub*blockstub;
 H bytes;
 H page_index,blok_index;
 B was_full;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.pool_system.object_id,handle,(VP)&poop,NULL))!=RET_YES) { return ret; }
 page_index=bindex/poop->status.blocks_per_page;
 blok_index=bindex%poop->status.blocks_per_page;
 if(page_index>=poop->pages_allocated) { return RET_BOUNDS; }
 bytes=sizeof(_aa_poolblockstub)+poop->status.bytes_per_block;
 bp=&poop->page[page_index].block_memory[(blok_index*bytes)];
 blockstub=(_aa_poolblockstub*)bp;
 if(poop->page[page_index].block_state[blok_index]!=1) { return RET_BADHANDLE; }
 if(blockstub->magic!=(H)(PP)aaPoolBlockNew) { oof; }
 bp=&poop->page[page_index].block_memory[(blok_index*bytes)];
 was_full=NO;
 if(poop->page[page_index].blocks_inuse==poop->page[page_index].blocks_allocated) { was_full=YES; }
 poop->page[page_index].block_state[blockstub->block_index]=0;
 poop->page[page_index].blocks_inuse--;
 poop->status.block_count--;
 if(was_full) {  poop->pages_full--;  }
 poop->page[page_index].block_pf=blok_index;
 poop->page_pf=page_index;
 blockstub->state=0;
 return RET_YES;
 }





 B aaPoolBlockInfoGet                  (H handle,VP block,_poolblock*poolblock)
 {
 B ret;
 _aa_poolobject*poop;
 _aa_poolblockstub*blockstub;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.pool_system.object_id,handle,(VP)&poop,NULL))!=RET_YES) { return ret; }
 if(poolblock) { aaMemoryFill(poolblock,sizeof(_poolblock),0); }
 bp=(BP)block;
 bp-=sizeof(_aa_poolblockstub);
 blockstub=(_aa_poolblockstub*)bp;
 if(blockstub->magic!=(H)(PP)aaPoolBlockNew) { oof; }
 bp=(BP)block;
 if(poolblock)
  {
  poolblock->id=blockstub->id;
  poolblock->index= (blockstub->page_index*poop->status.blocks_per_page)+blockstub->block_index;
  poolblock->state=blockstub->state;
  poolblock->mem=bp;
  }
 return RET_YES;
 }






 B aaPoolBlockGetByIndex               (H handle,H bindex,_poolblock*poolblock)
 {
 B ret;
 _aa_poolobject*poop;
 _aa_poolblockstub*blockstub;
 BP bp;
 H page_index;
 H blok_index;
 H bytes;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.pool_system.object_id,handle,(VP)&poop,NULL))!=RET_YES) { return ret; }
 if(poolblock) { aaMemoryFill(poolblock,sizeof(_poolblock),0); }
 page_index=bindex/poop->status.blocks_per_page;
 blok_index=bindex%poop->status.blocks_per_page;
 if(page_index>=poop->pages_allocated) { return RET_BOUNDS; }
 bytes=sizeof(_aa_poolblockstub)+poop->status.bytes_per_block;
 bp=&poop->page[page_index].block_memory[(blok_index*bytes)];
 blockstub=(_aa_poolblockstub*)bp;
 if(poop->page[page_index].block_state[blok_index]!=1) { return RET_BADHANDLE; }
 if(blockstub->magic!=(H)(PP)aaPoolBlockNew) { oof; }
 if(blockstub->id==0||blockstub->id>=poop->id_counter) { oof; return RET_FAILED; }
 bp+=sizeof(_aa_poolblockstub);
 if(poolblock)
  {
  poolblock->id=blockstub->id;
  poolblock->index= (blockstub->page_index*poop->status.blocks_per_page)+blockstub->block_index;
  poolblock->state=blockstub->state;
  poolblock->mem=bp;
  }
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/




 B aa_EventDefine                      (_aa_event*event,B manualreset,B startsignaled,VP fmt,...)
 {
 va_list argptr;
 B txt[_4K];
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,txt);
 if(event==NULL) { return RET_BADPARM; }
 aaMemoryFill(event,sizeof(_aa_event),0);
 if(fmt==NULL) { return RET_BADPARM; }
 aaStringLen(txt,&sl);
 if(sl==0) { return RET_BADPARM; }
 if(manualreset==YES) event->is_manual_reset=YES;
 if(startsignaled==YES) event->is_signaled=YES;
 event->handle=CreateEvent(NULL,event->is_manual_reset,event->is_signaled,(CP)txt);
 if(event->handle==NULL) { event->handle=NULL; return RET_FAILED; }
 logg("Event %s created",txt);
 return RET_YES;
 }




 B aa_EventUndefine                    (_aa_event*event)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(event==NULL)  { return RET_BADPARM; }
 if(event->handle==NULL) { return RET_NOTOPEN; }
 if(CloseHandle(event->handle)==FALSE) { return RET_FAILED; }
 aaMemoryFill(event,sizeof(_aa_event),0);
 return RET_YES;
 }





 B aa_EventSignal                      (_aa_event*event)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(event==NULL)  { return RET_BADPARM; }
 if(event->handle==NULL) { return RET_NOTOPEN; }
 if(event->is_signaled==YES) { return RET_YES; }
 if(SetEvent(event->handle)==FALSE) { oof; oow; Boop; }
 event->is_signaled=YES;
 return RET_YES;
 }



 B aa_EventIsSignaled                  (_aa_event*event)
 {
 H w;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(event==NULL)  { return RET_BADPARM; }
 if(event->handle==NULL) { return RET_NOTOPEN; }
 if(event->is_signaled==YES) { return RET_YES; }
 w=WaitForSingleObject(event->handle,0);
 if(w==WAIT_FAILED||w==WAIT_ABANDONED) { return RET_FAILED; }
 if(w==WAIT_OBJECT_0) { event->is_signaled=YES; return RET_YES; }
 return RET_NO;
 }





 B aa_EventReset                       (_aa_event*event)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(event==NULL)  { return RET_BADPARM; }
 if(event->handle==NULL) { return RET_NOTOPEN; }
 if(event->is_signaled==NO) { return RET_YES; }
 if(ResetEvent(event->handle)==0) { return RET_FAILED; }
 event->is_signaled=NO;
 return RET_NO;
 }



/*-----------------------------------------------------------------------*/


/*
 B aaThreadProc                        (H handle)
 {
 B ret;
 _threadunit tu;

 tu.handle=handle;
 while(1)
  {
  if((ret=aaThreadStatus(tu.handle,&tu.status))!=YES) { oops; return ret; }
  if(is_aa_quit_posted)    { break; }
  if(tu.status.is_exiting) { break; }
  aaSleep(1);
  }
 return RET_YES;
 }

*/



 H aa_ThreadRelay                      (VP parm)
 {
 B ret;
 _aa_threadobject*thrp;
 H th;
 B(*function)(H);

 th=(H)(HP)parm;
 if((ret=aa_ObjectCheck(aa.thread_system.object_id,th,(VP)&thrp,NULL))!=RET_YES) { oops; }
 function=thrp->status.proc;
 ret=function(th);
 aaThreadQuit(th,ret);
 }





 B aaThreadCreate                      (HP handle,H(*proc)(VP),H data,H bytes,VP udata,B startpaused)
 {
 B ret;
 _aa_threadobject*thrp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(proc==NULL) { return RET_BADPARM; }
 if(bytes>=sizeof(thrp->status.user_data)) { return RET_BOUNDS; }
 if(bytes!=0&&udata==NULL) { return RET_BADPARM; }
 if((ret=aa_ObjectCreate(aa.thread_system.object_id,handle,(VP)&thrp))!=RET_YES) { oops; return ret; }
 thrp->self_handle=*handle;
 if(bytes)
  {
  aaMemoryCopy(&thrp->status.user_data[0],bytes,udata);
  }
 InitializeCriticalSection(&thrp->mutex);
 aa_EventDefine(&thrp->event,YES,NO,"aa.thread.event.%lu.%lu",aa.core_system.launch_tik,*handle);
 thrp->status.is_paused=YES;
 thrp->status.data=data;
 thrp->handle=CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)proc,(VP)*handle,CREATE_SUSPENDED,&thrp->id);
 logg("thread created");
 if(startpaused!=YES)
  {
  logg("Initializing thread to Unpause");
  if((ret=aaThreadPause(*handle,NO))!=YES)
   {
   logg("holy crap %i",ret);
   }
  }
 logg("ThreadCreate success");
 return RET_YES;
 }





 B aaThreadCreateRelayed               (HP handle,B(*proc)(H),H data,H bytes,VP udata,B startpaused)
 {
 B ret;
 _aa_threadobject*thrp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(proc==NULL) { return RET_BADPARM; }
 if(bytes>=sizeof(thrp->status.user_data)) { return RET_BOUNDS; }
 if(bytes!=0&&udata==NULL) { return RET_BADPARM; }
 if((ret=aa_ObjectCreate(aa.thread_system.object_id,handle,(VP)&thrp))!=RET_YES) { oops; return ret; }
 thrp->self_handle=*handle;
 if(bytes)  {  aaMemoryCopy(&thrp->status.user_data[0],bytes,udata);  }
 thrp->status.proc=proc;
 InitializeCriticalSection(&thrp->mutex);
 aa_EventDefine(&thrp->event,YES,NO,"aa.thread.event.%lu.%lu",aa.core_system.launch_tik,*handle);
 thrp->status.is_paused=YES;
 thrp->status.data=data;
 thrp->handle=CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)aa_ThreadRelay,(VP)*handle,CREATE_SUSPENDED,&thrp->id);
 if(startpaused!=YES)
  {
  if((ret=aaThreadPause(*handle,NO))!=YES)   { oops; }
  }
 return RET_YES;
 }





 B aaThreadDestroy                     (H handle)
 {
 B ret;
 _aa_threadobject*thrp;
 B isprot;
 H elapsed;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.thread_system.object_id,handle,(VP)&thrp,&isprot))!=RET_YES) { return ret; }
 if(isprot==YES) { oof; return RET_FORBIDDEN; }
 if(thrp->status.is_exited!=YES)
  {
  if(is_aa_started_by_winmain==YES)
   {
   if(thrp->status.is_exiting==NO)
    {
    if(aaThreadExit(handle)!=RET_YES) {}
    }
   elapsed=0;
   while(1)
    {
    if(thrp->status.is_exited==YES)   {  break; }
    if((ret=aaThreadStatus(handle,&thrp->status))!=RET_YES)  { break; } //oops; }
   aaSleep(1);
    if(aa_is_quit_called)
     {
     if((elapsed++)>10)    {  break;  }
     }
    else
     {
     if((elapsed++)>100)    {  break;  }
     }
    }
   }
  }
 CloseHandle(thrp->handle);
 if(aa_EventUndefine(&thrp->event)!=RET_YES) {}
 DeleteCriticalSection(&thrp->mutex);
 aa_ObjectDestroy(aa.thread_system.object_id,handle);
 return RET_YES;
 }







 B aaThreadExit                        (H handle)
 {
 B ret;
 _aa_threadobject*thrp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.thread_system.object_id,handle,(VP)&thrp,NULL))!=RET_YES) { return ret; }
 if(thrp->status.is_exiting==YES) { return RET_YES; }
 if(aa_EventSignal(&thrp->event)!=RET_YES) { oof; Boop; return RET_FAILED; }
 thrp->status.is_exiting=YES;
 return RET_YES;
 }






 B aaThreadStatus                      (H handle,_threadstatus*threadstatus)
 {
 B ret;
 _aa_threadobject*thrp;
 H ec;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.thread_system.object_id,handle,(VP)&thrp,NULL))!=RET_YES) { return ret; }
 if(thrp->status.is_exiting==NO&&thrp->status.is_exited==NO)
  {
  ret=aa_EventIsSignaled(&thrp->event);
  if(ret==RET_YES)
   {
   }
  else
   {
   }

  if(ret==RET_YES)
   {
   thrp->status.is_exiting=YES;
   }
  else
  if(ret!=RET_NO)  { Boop; oof; return RET_FAILED; }
  }
 else
 if(thrp->status.is_exiting==YES&&thrp->status.is_exited==NO)
  {
  if(GetExitCodeThread((HANDLE)thrp->handle,&ec)!=0)
   {
   if(ec!=STILL_ACTIVE)
    {
    thrp->status.is_exited=YES;
    thrp->status.is_exiting=YES;
    thrp->status.exit_code=ec;
    }
   }
  }
 if(threadstatus)
  {
  aaMemoryCopy(threadstatus,sizeof(_threadstatus),&thrp->status);
  #if 0
  HP sp,dp;
  aaCast(sp,HP,&thrp->status);
  aaCast(dp,HP,threadstatus);
  dp[0]=sp[0];
  dp[1]=sp[1];
  #endif
  }
 return RET_YES;
 }



 B aaThreadSpinWaitSet                 (H handle,H count,HP prevcount)
 {
 B ret;
 _aa_threadobject*thrp;
 H prev;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.thread_system.object_id,handle,(VP)&thrp,NULL))!=RET_YES) { return ret; }
 prev=SetCriticalSectionSpinCount(&thrp->mutex,count);
 if(prevcount) { *prevcount=prev; }
 thrp->status.spin_wait=count;
 if((ret=aaThreadStatus(handle,&thrp->status))!=YES) { return ret; }
 return RET_YES;
 }


 B aaThreadWait                        (H handle,B waitexit)
 {
 B ret;
 _aa_threadobject*thrp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.thread_system.object_id,handle,(VP)&thrp,NULL))!=RET_YES) { return ret; }
 if((ret=aaThreadStatus(handle,&thrp->status))!=YES) { return ret; }
 if(thrp->status.is_exited==YES) { return RET_YES; }
 if(thrp->status.is_exiting==NO) { return RET_NOTREADY; }
 if(waitexit==YES) { return RET_NOTREADY; }
 return RET_YES;
 }





 B aaThreadPause                       (H handle,B state)
 {
 B ret;
 _aa_threadobject*thrp;
 H e;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.thread_system.object_id,handle,(VP)&thrp,NULL))!=RET_YES) { return ret; }
 if(thrp->status.is_exiting==YES)
  {
  logg("failed to set threadpause to %s, as we are exiting",aaBoolString(state));
  return RET_FAILED;
  }
 if(state==YES)
  {
  if(thrp->status.is_paused==YES) { return RET_YES; }
  if(thrp->status.is_locked==YES) { return RET_FAILED; }
  thrp->status.is_paused=YES;
  e=SuspendThread(thrp->handle);
  if(e==0xffffffff)
   {
   thrp->status.is_paused=NO;
   logg("suspend thread failed");
   return RET_FAILED;
   }
  }
 else
  {
  if(thrp->status.is_paused==NO) { return RET_YES; }
  if(thrp->status.is_locked==YES) { return RET_FAILED; }
  e=ResumeThread(thrp->handle);
  if(e==0xffffffff)
   {
   logg("Resume thread failed");
   return RET_FAILED;
   }
  else
  if(e<=1) { thrp->status.is_paused=NO; }
  else
   {
   }
  }
 logg("Thread has been set to %s",aaBoolString(thrp->status.is_paused));
 return RET_YES;
 }





 B aaThreadLock                        (H handle,B wait)
 {
 B ret;
 _aa_threadobject*thrp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.thread_system.object_id,handle,(VP)&thrp,NULL))!=RET_YES) { return ret; }
 if(wait)  { thrp->status.is_locked=YES; EnterCriticalSection(&thrp->mutex);  }
 else      {  if(aa.core_system.TryEnterCriticalSection(&thrp->mutex)==0) { return RET_NOTREADY; }  }
 thrp->status.is_locked=YES;
 return RET_YES;
 }




 B aaThreadUnLock                      (H handle)
 {
 B ret;
 _aa_threadobject*thrp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.thread_system.object_id,handle,(VP)&thrp,NULL))!=RET_YES) { return ret; }
 LeaveCriticalSection(&thrp->mutex);
 thrp->status.is_locked=NO;
 return RET_YES;
 }






/*-----------------------------------------------------------------------*/




 H aa_ProcessCrashTester               (VP parm)
 {
 B ret;
 _aa_threadobject*thrp;
 HP hp;
 H handle;
 _aa_processobject*prop;
 DWORD res;
 LRESULT lr;
 _threadunit tu;

 #if aa_USE_GLOBAL_MUTEX == 1
 EnterCriticalSection(&global_mutex);
 #endif
 hp=(HP)parm;
 tu.handle=(H)&hp[0];
 if((ret=aa_ObjectCheck(aa.thread_system.object_id,tu.handle,(VP)&thrp,NULL))!=YES) { oops; }
 if((ret=aaThreadStatus(tu.handle,&tu.status))!=RET_YES) { oops; }
 handle=tu.status.data;
 if((ret=aa_ObjectCheck(aa.process_system.object_id,handle,(VP)&prop,NULL))!=RET_YES)  { oops;  }
 else
  {
  #if aa_USE_GLOBAL_MUTEX == 1
  LeaveCriticalSection(&global_mutex);
  #endif
  while(1)
   {
   #if aa_USE_GLOBAL_MUTEX == 1
   EnterCriticalSection(&global_mutex);
   #endif
   if(prop->status.crash_thread.handle==0) { break; }
   if(is_aa_quit_posted)                   { break; }
   aaThreadStatus(prop->status.crash_thread.handle,&prop->status.crash_thread.status);
   if(prop->status.unresponsive_count>5) { prop->status.is_unresponsive=YES; }
   if(prop->status.crash_thread.status.is_exited==YES)  { break; }
   if(prop->status.crash_thread.status.is_exiting==YES) { break; }
   if(prop->status.is_ready==YES)
    {
    aaTimerUpdate(&prop->crash_tm,1);
    if(prop->crash_tm.elapsed>prop->status.unresponsive_timeout)
     {
     lr=SendMessageTimeout(prop->status.hwnd,WM_NULL,0,0,SMTO_NORMAL|SMTO_ABORTIFHUNG,prop->status.unresponsive_timeout,&res);
     if(lr==0)      {      prop->status.unresponsive_count++;      }
     else           {      prop->status.unresponsive_count=0;      }
     aaTimerInit(&prop->crash_tm,1);
     }
    }
   #if aa_USE_GLOBAL_MUTEX == 1
   LeaveCriticalSection(&global_mutex);
   #endif
   aaSleep(2);
   }
  }
 #if aa_USE_GLOBAL_MUTEX == 1
 LeaveCriticalSection(&global_mutex);
 #endif
 aaThreadQuit(prop->status.crash_thread.handle,RET_YES);
 }



 B aaProcessCreate                     (HP handle,VP fname,VP cmdline,B clmode,B inherit,B startpaused,B detach,B newroot,W showcmd,B isconsole,VP desktop)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 ret=aa_ProcessSystemCreate(handle,fname,cmdline,clmode,inherit,startpaused,detach,newroot,showcmd,isconsole,desktop);
 if(ret==RET_YES)
  {
  if((ret=aaProcessUnresponsiveTimeoutSet(*handle,500))!=YES) { oops; }
  return RET_YES;
  }
 return ret;
 }






 B aaProcessCreateWithLogin            (HP handle,VP fname,VP cmdline,VP user,VP pass,B detach,B newroot)
 {
 B ret;
 _aa_processobject*prop;
 BOOL bl;
 USER_INFO_1 ui1;
 H sl,flags;
 wchar_t user_name[256];
 wchar_t pass_word[256];
 wchar_t file_name[1513];
 wchar_t cmnd_line[1513];
 B txt[_3K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(fname==NULL) { return RET_BADPARM; }
 if(user==NULL)  { return RET_BADPARM; }
 if(aaFileExists(fname)!=YES) { return RET_NOTFOUND; }
 detach&=1;
 newroot&=1;
 if((ret=aa_ObjectCreate(aa.process_system.object_id,handle,(VP)&prop))!=RET_YES) { oops; return ret; }
 prop->self_handle=*handle;
 aaMemoryFill(&ui1,sizeof(ui1),0);
 aaMemoryFill(user_name,sizeof(user_name),0);
 aaMemoryFill(pass_word,sizeof(pass_word),0);
 aaMemoryFill(file_name,sizeof(file_name),0);
 aaMemoryFill(cmnd_line,sizeof(cmnd_line),0);
 if(user)  { aaStringLen(user,&sl);  MultiByteToWideChar(CP_ACP,0,user,sl,user_name,sizeof(user_name));  }
 if(pass)  { aaStringLen(pass,&sl);  MultiByteToWideChar(CP_ACP,0,pass,sl,pass_word,sizeof(pass_word)); }
 aaStringLen(fname,&sl);
 MultiByteToWideChar(CP_ACP,0,fname,sl,file_name,sizeof(file_name));
 if(cmdline)
  {
  aaStringLen(cmdline,&sl);
  MultiByteToWideChar(CP_ACP,0,cmdline,sl,cmnd_line,sizeof(cmnd_line));
  }
 if(NetUserGetInfo(NULL,user_name,1,(LPBYTE*)&prop->user_info)!=NERR_Success)
  {
  ui1.usri1_name=user_name;
  if(pass) ui1.usri1_password=pass_word;
  ui1.usri1_password_age=0;
  ui1.usri1_priv=USER_PRIV_USER;
  ui1.usri1_home_dir=NULL;
  ui1.usri1_comment=NULL;
  ui1.usri1_flags=UF_NORMAL_ACCOUNT|UF_SCRIPT|UF_PASSWD_CANT_CHANGE|UF_DONT_EXPIRE_PASSWD|UF_PASSWD_NOTREQD;
  ui1.usri1_script_path=NULL;
  if(NetUserAdd(NULL,1,(LPBYTE)&ui1,NULL)!=NERR_Success)
   { oof;
   aa_ObjectDestroy(aa.process_system.object_id,*handle);
   *handle=0;
   return RET_FAILED;
   }
  if(NetUserGetInfo(NULL,user_name,1,(LPBYTE *)&prop->user_info)!=NERR_Success)
   {
   aa_ObjectDestroy(aa.process_system.object_id,*handle);
   *handle=0;
   return RET_FAILED;
   }
  }

 prop->siw.cb=sizeof(prop->siw);
 if(newroot==YES) {  flags=0x200;  }
 else             {  flags=0x000; }
 if(cmdline)
  {
  aaStringCopyf(txt,"\"%s\"  %s",fname,cmdline);
  aaStringToWideString(txt,cmnd_line);
  bl=aa.core_system.CreateProcWithLogin(user_name,L".",(pass)?pass_word:0,0x00000001,0,cmnd_line,flags,NULL,NULL,&prop->siw,&prop->pi);
  }
 else
  {
  bl=aa.core_system.CreateProcWithLogin(user_name,L".",(pass)?pass_word:0,0x00000001,0,file_name,flags,NULL,NULL,&prop->siw,&prop->pi);
  }
 if(bl==0)
  {
  oow;
  if(prop->user_info) { NetApiBufferFree(prop->user_info); }
  aa_ObjectDestroy(aa.process_system.object_id,*handle);
  *handle=0;
  return RET_FAILED;
  }
 prop->status.is_login=YES;
 aaTimerTikGet(&prop->ms_root);
 if(detach==YES) { prop->status.is_detached=YES; }
 prop->status.tid=prop->pi.dwThreadId;
 prop->status.pid=prop->pi.dwProcessId;
 prop->status.thread_handle=prop->pi.hThread;
 prop->status.process_handle=prop->pi.hProcess;
 if(newroot) { prop->status.is_newroot=YES; }
 aaStringCopy(prop->status.user,user);
 aaStringCopy(prop->status.pass,pass);
 return RET_YES;
 }






 B aaProcessDestroy                    (H handle)
 {
 B ret;
 _aa_processobject*prop;
 B isprot;
 H elapsed,sl,cnt;
 wchar_t user_name[256];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.process_system.object_id,handle,(VP)&prop,&isprot))!=RET_YES) { return ret; }
 if(isprot==YES) { return RET_FORBIDDEN; }

 if(prop->status.crash_thread.handle!=0)
  {
  if((ret=aaThreadExit(prop->status.crash_thread.handle))!=YES) { oops; }
  cnt=0;
  while(1)
   {
   aaThreadStatus(prop->status.crash_thread.handle,&prop->status.crash_thread.status);
   if(prop->status.crash_thread.status.is_exited) { break; }
   cnt++;
   aaSleep(1);
   if(cnt>10) { break; }
   }
  if((ret=aaThreadDestroy(prop->status.crash_thread.handle))!=YES) { oops; }
  prop->status.crash_thread.handle=0;
  }
 if(prop->status.is_login==YES)
  {
  if(prop->status.is_detached==NO)
   {
   if(prop->pi.dwThreadId) { PostThreadMessage(prop->pi.dwThreadId,WM_QUIT,0,0); }
   if(prop->pi.hProcess) { CloseHandle(prop->pi.hProcess);  }
   if(prop->pi.hThread) { CloseHandle(prop->pi.hThread);    }
   aaMemoryFill(user_name,sizeof(user_name),0);
   aaStringLen(prop->status.user,&sl);
   MultiByteToWideChar(CP_ACP,0,(LPCSTR)prop->status.user,sl,user_name,sizeof(user_name));
   if(prop->user_info) { NetApiBufferFree(prop->user_info); }
   }
  aa_ObjectDestroy(aa.process_system.object_id,handle);
  return RET_YES;
  }
 if(prop->status.is_newroot==YES||prop->status.is_detached==YES)
  {
  if(prop->status.is_paused==NO&&prop->status.is_unresponsive==NO&&prop->status.is_ready==YES)
   {
   aa_ObjectDestroy(aa.process_system.object_id,handle);
   return RET_YES;
   }
  }
 if(prop->status.is_exited==YES) {}
 else
 if(prop->status.is_detached!=YES)
  {
  if(prop->status.is_exiting==NO)
   {
   if(aaProcessExit(handle)!=RET_YES) {}
   logg("process quited");
   }
  elapsed=0;
  while(1)
   {
   if(aaProcessStatus(handle,NULL)!=RET_YES)    {        }
   if(prop->status.is_exited==YES)              { break; }
   if(prop->status.is_unresponsive==YES)        { break; }
   aaSleep(1);
   elapsed+=3;
   if(elapsed>1000) { break; }
   }
  if(prop->status.is_exited==NO)
   {
   if(TerminateProcess((HANDLE)prop->pi.hProcess,(UINT)123)==FALSE) {}
   }
  }
 if(prop->pi.hThread)  { CloseHandle(prop->pi.hThread);  prop->pi.hThread=0; }
 if(prop->pi.hProcess) { CloseHandle(prop->pi.hProcess); prop->pi.hProcess=0; }
 aa_ObjectDestroy(aa.process_system.object_id,handle);
 return RET_YES;
 }





 B aaProcessExit                       (H handle)
 {
 B ret;
 _aa_processobject*prop;
 H go,cnt;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.process_system.object_id,handle,(VP)&prop,NULL))!=RET_YES) { return ret; }

 if(prop->status.is_exiting==YES) { return RET_YES;  }
 aaProcessStatus(handle,0);

 if(prop->status.crash_thread.handle!=0)
  {
  if((ret=aaThreadExit(prop->status.crash_thread.handle))!=YES) { oops; }
  cnt=0;
  while(1)
   {
   aaThreadStatus(prop->status.crash_thread.handle,&prop->status.crash_thread.status);
   if(prop->status.crash_thread.status.is_exited) { break; }
   cnt++;
   aaSleep(1);
   if(cnt>10) { break; }
   }
  if(cnt>5) { aaNote(0,"xzcn %i",cnt); }
  if((ret=aaThreadDestroy(prop->status.crash_thread.handle))!=YES) { oops; }
  prop->status.crash_thread.handle=0;
  }
 if(prop->status.is_exited==NO&&prop->status.is_ready==YES)
  {
  go=0;
  while(1)
   {
   if(prop->status.is_exiting) { break; }
   if(PostThreadMessage(prop->pi.dwThreadId,WM_QUIT,0,0)!=0) {  break; }
   if(GetLastError()==ERROR_INVALID_THREAD_ID) {  break; }
   go++;
   aaSleep(4);
   if(go<10) { continue; }
   TerminateProcess(prop->pi.hProcess,(UINT)123);
   prop->status.is_exiting=YES;
   break;
   }
  }
 else
 if(prop->status.is_exited==NO&&prop->status.is_ready==NO)
  {
  if(TerminateProcess(prop->pi.hProcess,(UINT)123)==0)   { oof;  oow; oof; return RET_FAILED; }
  }
 prop->status.is_exiting=YES;
 return RET_YES;
 }






 B aaProcessPause                      (H handle,B state)
 {
 B ret;
 _aa_processobject*prop;
 H e;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.process_system.object_id,handle,(VP)&prop,NULL))!=RET_YES) { return ret; }
 if(prop->status.is_exiting==YES)
  {
  logg("failed to set processpause to %s, as we are exiting",aaBoolString(state));
  return RET_FAILED;
  }
 if(state==YES)
  {
  if(prop->status.is_paused==YES) { return RET_YES; }
  e=SuspendThread(prop->pi.hThread);
  if(e==0xffffffff) { return RET_FAILED; }
  prop->status.is_paused=YES;
  }
 else
  {
  if(prop->status.is_paused==NO) { return RET_YES; }
  e=ResumeThread(prop->pi.hThread);
  if(e==0xffffffff) { return RET_FAILED; }
  else
  if(e<=1) { prop->status.is_paused=NO; }
  }
 logg("Process has been set to %s",aaBoolString(prop->status.is_paused));
 return RET_YES;
 }






 B aaProcessStatus                     (H handle,_processstatus*processstatus)
 {
 B ret;
 _aa_processobject*prop;
 H rc,ec;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.process_system.object_id,handle,(VP)&prop,NULL))!=RET_YES) { return ret; }
 aaTimerTikElapsed(prop->ms_root,&prop->status.ms);

  if(prop->status.is_ready!=YES)
   {
   rc=WaitForInputIdle(prop->pi.hProcess,0);
   if(rc==0)
    {
    EnumThreadWindows(prop->status.tid,aa_ProcessSystemEnum,(LPARAM)prop);
    if(prop->status.hwnd==0) { EnumThreadWindows(GetCurrentThreadId(),aa_ProcessSystemEnum,(LPARAM)prop);     }
    if(prop->status.hwnd==0)
     {
     }
    prop->status.is_ready=YES;
    }
   else
    {
    if(prop->status.ms>500)
     {
     EnumThreadWindows(prop->status.tid,aa_ProcessSystemEnum,(LPARAM)prop);
     if(prop->status.hwnd==0) { EnumThreadWindows(GetCurrentThreadId(),aa_ProcessSystemEnum,(LPARAM)prop);     }
     if(prop->status.hwnd==0)
      {
      }
     prop->status.is_ready=YES;
     }
    }
   }
 else
  {
  if(prop->status.crash_thread.status.is_exited&&prop->status.crash_thread.status.is_exiting)
   {
   if(prop->status.is_exiting&&prop->status.is_exited==NO)
    {
    if((rc=GetExitCodeThread((HANDLE)prop->pi.hThread,&ec))!=0)
     {
     if(ec!=STILL_ACTIVE)
      {
      prop->status.is_exited=YES;
      prop->status.exit_code=ec;
      }
     }
    }
   }

  if(prop->status.crash_thread.handle==0)
   {
   if(prop->crash_tm.magic==0)
    {
    aaTimerInit(&prop->crash_tm,1);
    if((ret=aaThreadCreate(&prop->status.crash_thread.handle,aa_ProcessCrashTester,handle,0,NULL,NO))!=YES) { oops; }
    aaThreadStatus(prop->status.crash_thread.handle,&prop->status.crash_thread.status);
    }
   }
  else
   {
   prop->crash_tm_counter++;
   if(aaNumIsMod(prop->crash_tm_counter,5))
    {
    ret=aaThreadStatus(prop->status.crash_thread.handle,&prop->status.crash_thread.status);
    if(ret!=YES) oops;
    if(prop->status.crash_thread.status.is_exiting||prop->status.crash_thread.status.is_exited)
     {
     }
    if(prop->status.is_exiting||prop->status.is_exited)
     {
     }
    if((rc=GetExitCodeThread((HANDLE)prop->pi.hThread,&ec))!=0)
     {
     if(ec!=STILL_ACTIVE)
      {
      prop->status.is_exited=YES;
      prop->status.exit_code=ec;
      }
     }
    else
     {
     }
    }
   }
  }
 if(processstatus) { aaMemoryCopy(processstatus,sizeof(_processstatus),&prop->status); }
 return RET_YES;
 }




 B aaProcessStatusToString             (H handle,_processstatus*processstatus,VP str)
 {
 B ret;
 _processstatus ps;
 _processstatus*psp;
 B buf[_4K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str) { aaStringNull(str); }
 if(processstatus==NULL) psp=(_processstatus*)&ps;
 else             psp=(_processstatus*)processstatus;
 if((ret=aaProcessStatus(handle,psp))!=YES) {  return ret; }
 if(str)
  {
  aaStringNull(buf);
  aaStringAppendf(buf,"is_paused=%i   ",psp->is_paused);
  aaStringAppendf(buf,"is_exiting=%i ",psp->is_exiting);
  aaStringAppendf(buf,"is_exited=%i  ",psp->is_exited);
  aaStringAppendf(buf,"is_ready=%i ",psp->is_ready);
  aaStringAppendf(buf,"is_inherit=%i ",psp->is_inherit);
  aaStringAppendf(str,"%s\n",buf);
  aaStringNull(buf);
  aaStringAppendf(buf,"is_detached=%i ",psp->is_detached);
  aaStringAppendf(buf,"is_newroot=%i ",psp->is_newroot);
  aaStringAppendf(buf,"is_console=%i ",psp->is_console);
  aaStringAppendf(buf,"is_login=%i ",psp->is_login);
  aaStringAppendf(buf,"is_unresponsive=%i ",psp->is_unresponsive);
  aaStringAppendf(buf,"unresponsive_count=%i ",psp->unresponsive_count);
  aaStringAppendf(str,"%s\n",buf);
  aaStringNull(buf);
  aaStringAppendf(buf,"exit_code=%i  ",psp->exit_code);
  aaStringAppendf(buf,"ms=%i ",psp->ms);
  aaStringAppendf(buf,"tid=%-8u  ",psp->tid);
  aaStringAppendf(buf,"pid=%-u     ",psp->pid);
  aaStringAppendf(buf,"thread_han=0x%08x   ",psp->thread_handle);
  aaStringAppendf(buf,"process_han=0x%08x ",psp->process_handle);
  aaStringAppendf(str,"%s\n",buf);
  aaStringNull(buf);
  aaStringAppendf(buf,"hwnd=0x%08x ",psp->hwnd);
  aaStringAppendf(str,"%s\n",buf);
  }
 return RET_YES;
 }




 B aaProcessUnresponsiveTimeoutSet     (H handle,H ms)
 {
 B ret;
 _aa_processobject*prop;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.process_system.object_id,handle,(VP)&prop,NULL))!=RET_YES) { return ret; }
 if(ms<100||ms>5000) { oops; return RET_BOUNDS; }
 prop->status.unresponsive_timeout=ms;
 return RET_YES;
 }





 B aaProcessRetry                      (H handle)
 {
 B ret;
 _aa_processobject*prop;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.process_system.object_id,handle,(VP)&prop,NULL))!=RET_YES) { return ret; }
 if(prop->status.crash_thread.handle==0) { return RET_FAILED; }
 if(is_aa_quit_posted) {  return RET_FAILED; }
 if(prop->status.is_unresponsive!=YES) { return RET_YES; }
 prop->status.is_unresponsive=NO;
 prop->status.unresponsive_count=0;
 aaTimerInit(&prop->crash_tm,1);
 return RET_YES;
 }




 B aaProcessSpawn                      (VP fname,VP cmdline,W showcmd,HP prochan,HP procid)
 {
 B txt[_1K];
 SHELLEXECUTEINFO execinfo;
 BOOL bl;
 HANDLE ss;
 HANDLE hh;
 PROCENTRY32 entry;
 H num;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMemoryFill(&execinfo,sizeof(execinfo),0);
 if(prochan) { *prochan=0; }
 if(procid)  { *procid=0;  }
 if(fname==NULL&&cmdline==NULL) { return RET_BADPARM; }
 aaStringNull(txt);
 execinfo.cbSize=sizeof (execinfo);
 execinfo.fMask=SEE_MASK_NOCLOSEPROCESS|SEE_MASK_FLAG_NO_UI;
 execinfo.hwnd=NULL;
 execinfo.lpVerb="open";
 if(fname)   execinfo.lpFile=fname;
 if(cmdline) execinfo.lpParameters=cmdline;
 execinfo.nShow=showcmd;
 bl=ShellExecuteEx(&execinfo);
 if(bl==FALSE) { oow; return RET_FAILED; }
 if(prochan)
  {
  *prochan=(H)execinfo.hProcess;
  }
 if(procid)
  {
  if((ss=aa.core_system.Create32Snapshot(0x00000002,0))==INVALID_HANDLE_VALUE) {  oof; }
  num=0;
  while(1)
   {
   entry.dwSize=sizeof(PROCENTRY32);
   if(num==0) { bl=aa.core_system.Process32First(ss,&entry); }
   else       { bl=aa.core_system.Process32Next(ss,&entry); }
   if(bl==FALSE) { break; }
   num++;
   if(aaStringICompare(entry.szExeFile,fname,0)!=YES) { continue; }
   if((hh=OpenProcess(PROCESS_QUERY_INFORMATION,FALSE,entry.th32ProcessID))==NULL) { oof; }
   CloseHandle(hh);
   *procid=entry.th32ProcessID;
   break;
   }
  CloseHandle(ss);
  }
 return RET_YES;
 }





 B aaProcessLaunch                     (VP exefile,VP exeargs,VP workdir,W showcmd,HP prochan,HP procid)
 {
 PROCESS_INFORMATION processInfo;
 STARTUPINFO startupInfo;
 H flags;
 B txt[_4K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMemoryFill(&startupInfo,sizeof(startupInfo),0);
 if(prochan) { *prochan=0; }
 if(procid)  { *procid=0; }
 startupInfo.cb=sizeof(startupInfo);
 startupInfo.dwFlags=STARTF_USESHOWWINDOW;
 startupInfo.wShowWindow=showcmd;
 flags=0;
 if(1) { flags|=CREATE_NEW_PROCESS_GROUP; }
 if(0) { flags|=CREATE_NEW_CONSOLE; }
 if(showcmd==SW_HIDE) { flags|=CREATE_NO_WINDOW; }
 if(0) { flags|=DETACHED_PROCESS; }
 if(exeargs)  {  aaStringCopyf(txt,"\"%s\" %s",exefile,exeargs);  }
 else         {  aaStringCopyf(txt,"\"%s\"",exefile);  }
 if(CreateProcess(0,(LPTSTR)txt,NULL,NULL,FALSE,flags,NULL,workdir,&startupInfo,&processInfo)==0)
  {
  oow;
  return RET_FAILED;
  }
 if(prochan) { *prochan=(H)processInfo.hProcess; }
 if(procid)  { *procid=(H)processInfo.dwProcessId; }
 return RET_YES;
 }






 B aaProcessIsRunning                  (VP exename,HP count)
 {
 H num,c;
 HANDLE ss;
 PROCENTRY32 entry;
 BOOL bl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 c=0;
 if(count) { *count=0; }
 if(exename==NULL) { return RET_BADPARM; }
 if(aaStringIsEmpty(exename,YES)!=NO) { return RET_BADPARM; }
 if((ss=aa.core_system.Create32Snapshot(0x00000002,0))==INVALID_HANDLE_VALUE) {  return RET_FAILED; }
 num=0;
 while(1)
  {
  entry.dwSize=sizeof(PROCENTRY32);
  if(num==0) { bl=aa.core_system.Process32First(ss,&entry); }
  else       { bl=aa.core_system.Process32Next(ss,&entry); }
  if(bl==FALSE)
   {
   break;
   }
  num++;
  if(aaStringICompare(entry.szExeFile,exename,0)==YES) { c++;   }
  }
 CloseHandle(ss);
 if(count) { *count=c; }
 if(c!=0) { return RET_YES; }
 return RET_NO;
 }








 B aaProcessListGather                 (_processlist*processlist,VP wildcard)
 {
 H slots,left;
 B ret;
 H index,ok;
 _processentry*processentry;
 PROCENTRY32 entry;
 B space[_1K];
 BOOL bl;
 HANDLE tmp;
 H sl,han;
 PROCESS_BASIC_INFORMATION pbi;
 VP pebAddress,rtlUserProcParamsAddress;
 UNICODE_STRING commandLine;
 BP tmpmem;
 B buf[_1K];
 UNUSE(space);
 FILETIME cc_time,ee_time,kk_time,uu_time;
 _systime cc_sys;
 G cc_secs;
 H pi;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 aaMissingParm(processlist);
 aaMemoryFill(processlist,sizeof(_processlist),0);
 processlist->magic=aaHPP(aaProcessListGather);

 if(wildcard) { slots=8; }
 else         { slots=32; }
 if((ret=aaMemoryAllocate((VP)&processlist->entry,slots*sizeof(_processentry)))!=YES) { oops; }
 aaMemoryNameSet(processlist->entry,"plistent");
 //han=(H)aa.core_system.Create32Snapshot(1|8|2|4,0);
 han=(H)aa.core_system.Create32Snapshot(2,0);
 if(((H)han)==(H)INVALID_HANDLE_VALUE)
  {
  aaMemoryRelease(&processlist->entry);
  aaMemoryFill(processlist,sizeof(_processlist),0);
  return RET_FAILED;
  }
 index=0;
 while(1)
  {
  pi=processlist->entries;
  processentry=(_processentry*)&processlist->entry[pi];
  left=slots-processlist->entries;
  if(left<2)
   {
   slots=slots+(slots/4)+50;
   if((ret=aaMemoryReAllocate((VP)&processlist->entry,slots*sizeof(_processentry)))!=YES) { oops; }
   left=slots-processlist->entries;
   }
  processentry=(_processentry*)&processlist->entry[pi];
  processentry->exe_path[0]=0;
  processentry->dev_path[0]=0;
  processentry->cmd_line[0]=0;
  processentry->exe_file[0]=0;
  //aaMemoryFill(&entry,sizeof(entry),0);
  entry.dwSize=0;
  entry.cntUsage=0;
  entry.th32ProcessID=0;
  entry.th32DefaultHeapID=0;
 entry.th32ModuleID=0;
 entry.cntThreads=0;
 entry.th32ParentProcessID=0;
 entry.pcPriClassBase=0;
 entry.dwFlags=0;
 entry.szExeFile[0]=entry.szExeFile[1]=0;
  ///
  entry.dwSize=sizeof(PROCENTRY32);
  if(index==0) { bl=aa.core_system.Process32First((HANDLE)han,&entry); }
  else         { bl=aa.core_system.Process32Next((HANDLE)han,&entry);  }
  if(bl==FALSE)
   {
   if(GetLastError()==ERROR_NO_MORE_FILES) { }
   break;
   }
  ok=YES;
  if(wildcard)
   {
   ret=aaStringWildICompare(entry.szExeFile,0,wildcard);
   if(ret!=RET_YES) { ok=NO; }
   }
  if(ok)
   {
   if((tmp=OpenProcess(PROCESS_ALL_ACCESS,FALSE,entry.th32ProcessID))!=NULL)
    {
    processentry->process_handle=tmp;
    if(aa.core_system.GetProcessTimes(processentry->process_handle,&cc_time,&ee_time,&kk_time,&uu_time)==0) { oow; }
    if((ret=WinFileTimeToSysTime(&cc_time,&cc_sys))!=YES) { oops; }
    if((ret=aaTimeCompare(&cc_sys,0,&cc_secs))!=YES) { oops; }
    processentry->ms_running=cc_secs*1000LL;
     aa.core_system.ntQueryInformationProcess(tmp,0,&pbi,sizeof(pbi),NULL);
     pebAddress=pbi.PebBaseAddress;
     if(ReadProcessMemory(tmp,(PCHAR)pebAddress+0x10,&rtlUserProcParamsAddress,sizeof(PVOID),NULL)!=0)
      {
      if(ReadProcessMemory(tmp,(PCHAR)rtlUserProcParamsAddress+0x40,&commandLine,sizeof(commandLine),NULL)!=0)
       {
       if((ret=aa_MemoryTemp((VP)&tmpmem,_256K,aa_MEMORYTEMP_ProcessList))==RET_YES)
        {
        if(ReadProcessMemory(tmp,commandLine.Buffer,tmpmem,commandLine.Length,NULL)!=0)
         {
         aaStringFromWideString(processentry->cmd_line,(WCHAR*)tmpmem);
         processentry->cmd_line[commandLine.Length/2]=0;
         }
        }
       }
      }
    if(aa.core_system.GetProcessFileName(tmp,(CP)processentry->exe_path,sizeof(processentry->exe_path))!=0)
     {
     aaStringCopyf(processentry->dev_path,"%s",processentry->exe_path);
     aaStringCopyLen(buf,&sl,"\\Device\\Harddisk");
     if(aaStringNICompare(processentry->exe_path,buf,sl,0)==YES)    {     aaStringDeleteChars(processentry->exe_path,0,0,sl);      }
     }
    CloseHandle(tmp);
    }
   processentry->process_id=entry.th32ProcessID;
   processentry->module_id=entry.th32ModuleID;
   processentry->thread_count=entry.cntThreads;
   processentry->parent_process_id=entry.th32ParentProcessID;
   aaStringCopy(processentry->exe_file,entry.szExeFile);
   processlist->entries++;
   }
  index++;
  }
 CloseHandle((HANDLE)han);
 return RET_YES;
 }




 B aaProcessListRelease                (_processlist*processlist)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMissingParm(processlist);
 if(processlist->magic!=aaHPP(aaProcessListGather)) { return RET_NOTINITIALIZED; }
 if(processlist->entry!=NULL)
  {
  if((ret=aaMemoryRelease(processlist->entry))!=YES) { oops; }
  }
 aaMemoryFill(processlist,sizeof(_processlist),0);
 return RET_YES;
 }







 B aaProcessList                       (HP handle,H index,_processentry*processentry)
 {
 B ret;
 H han;
 PROCENTRY32 entry;
 BOOL bl;
 HANDLE tmp;
 B ok;
 B drive;
 B path[_1K];
 B buf[_1K];
 H pos,sl;
 BP tmpmem;
// HMODULE mod;
 VP pebAddress,rtlUserProcParamsAddress;
 UNICODE_STRING commandLine;
 PROCESS_BASIC_INFORMATION pbi;
 //ntQueryInformationProcess NtQueryInformationProcess;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==NULL) { return RET_BADPARM; }
 if(processentry==NULL) { return RET_BADPARM; }
 aaMemoryFill(processentry,sizeof(_processentry),0);
 if(index==0)  {  *handle=0;  }
 else          {  if(*handle==0) { return RET_BADHANDLE; }  }
 if(index==0)
  {
  han=(H)aa.core_system.Create32Snapshot(0x00000002,0);
  if(((H)han)==(H)INVALID_HANDLE_VALUE) {  return RET_FAILED; }
  *handle=han;
  }
 han=*handle;
 while(1)
  {
  processentry->exe_path[0]=0;
  processentry->dev_path[0]=0;
  processentry->cmd_line[0]=0;
  processentry->exe_file[0]=0;
  entry.dwSize=sizeof(PROCENTRY32);
  if(index==0xffffffff) {  CloseHandle((HANDLE)han);   *handle=0;   return RET_FINISHED;   }
  if(index==0) { bl=aa.core_system.Process32First((HANDLE)han,&entry); }
  else         { bl=aa.core_system.Process32Next((HANDLE)han,&entry); }
  if(bl==FALSE)
   {
   if(GetLastError()==ERROR_NO_MORE_FILES) { break; }
   CloseHandle((HANDLE)han);
   *handle=0;
   return RET_FAILED;
   }
  ok=NO;
  if((tmp=OpenProcess(PROCESS_ALL_ACCESS,FALSE,entry.th32ProcessID))!=NULL)
   {
   processentry->process_handle=tmp;
   ///mod=GetModuleHandleA("ntdll.dll");
   //if((NtQueryInformationProcess=(VP)GetProcAddress(mod,"NtQueryInformationProcess"))!=NULL)
    //{
    aa.core_system.ntQueryInformationProcess(tmp,0,&pbi,sizeof(pbi),NULL);
    pebAddress=pbi.PebBaseAddress;
    if(ReadProcessMemory(tmp,(PCHAR)pebAddress+0x10,&rtlUserProcParamsAddress,sizeof(PVOID),NULL)!=0)
     {
     if(ReadProcessMemory(tmp,(PCHAR)rtlUserProcParamsAddress+0x40,&commandLine,sizeof(commandLine),NULL)!=0)
      {
      if((ret=aa_MemoryTemp((VP)&tmpmem,_256K,aa_MEMORYTEMP_ProcessList))==RET_YES)
       {
       if(ReadProcessMemory(tmp,commandLine.Buffer,tmpmem,commandLine.Length,NULL)!=0)
        {
        aaStringFromWideString(processentry->cmd_line,(WCHAR*)tmpmem);
        processentry->cmd_line[commandLine.Length/2]=0;
        }
       }
      }
     }
    //}
   if(aa.core_system.GetProcessFileName(tmp,(CP)processentry->exe_path,sizeof(processentry->exe_path))!=0)
    {
    ok=YES;
    aaStringCopyf(processentry->dev_path,"%s",processentry->exe_path);
    aaStringCopy(buf,"\\Device\\Harddisk");
    aaStringLen(buf,&sl);
    if(aaStringNICompare(processentry->exe_path,buf,sl,0)==YES)
     {
     aaStringDeleteChars(processentry->exe_path,0,0,sl);
     aaStringFindChar(processentry->exe_path,0,&pos,'\\',YES,0,YES);
     if(pos!=0xffffffff)
      {
      aaStringDeleteChars(processentry->exe_path,0,0,pos+1);
      for(drive='c';drive<('z'+1);drive++)
       {
       aaStringCopyf(path,"%c:\\%s",drive,processentry->exe_path);
       if(aaFileExists(path)==YES) { break; }
       }
      if(drive!=('z'+1))
       {
       aaStringCopyf(processentry->exe_path,"%s",path);
       aaStringFindChar(processentry->exe_path,0,&pos,'\\',YES,0,NO);
       if(pos!=0xffffffff) { processentry->exe_path[pos+1]=NULL_CHAR;  }
       }
      }
     }
    }
   CloseHandle(tmp);
   }
  if(ok==NO)
   {
   aaStringNull(processentry->exe_path);
   }
  processentry->process_id=entry.th32ProcessID;
  processentry->module_id=entry.th32ModuleID;
  processentry->thread_count=entry.cntThreads;
  processentry->parent_process_id=entry.th32ParentProcessID;
  aaStringCopy(processentry->exe_file,entry.szExeFile);
  return RET_YES;
  }
 CloseHandle((HANDLE)han);
 *handle=0;
 return RET_FINISHED;
 }





 B aaProcessListDestroy                (H handle)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(CloseHandle((HANDLE)handle)==0) { return RET_BADHANDLE; }
 return RET_YES;
 }





 B aaProcessThreadList                 (HP handle,H index,_processthreadentry*processthreadentry)
 {
 H han;
 THREADENTRY32 entry;
 BOOL bl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==NULL) { return RET_BADPARM; }
 if(processthreadentry==NULL) { return RET_BADPARM; }
 if(index==0)  {  *handle=0;  }
 else          {  if(*handle==0) { return RET_BADHANDLE; }  }
 aaMemoryFill(processthreadentry,sizeof(_processthreadentry),0);

 if(index==0)
  {
  han=(H)aa.core_system.Create32Snapshot(0x00000004,0);
  if(((H)han)==(H)INVALID_HANDLE_VALUE) {  return RET_FAILED; }
  *handle=han;
  }
 han=*handle;
 while(1)
  {
  aaMemoryFill(&entry,sizeof(entry),0);
  entry.dwSize=sizeof(THREADENTRY32);
  if(index==0xffffffff)   {   CloseHandle((HANDLE)han);   *handle=0;   return RET_FINISHED;   }
  if(index==0) { bl=aa.core_system.Thread32First((HANDLE)han,&entry); }
  else         { bl=aa.core_system.Thread32Next((HANDLE)han,&entry); }
  if(bl==FALSE)
   {
   if(GetLastError()==ERROR_NO_MORE_FILES) { break; }
   CloseHandle((HANDLE)han);
   *handle=0;
   return RET_FAILED;
   }
  processthreadentry->thread_id=entry.th32ThreadID;
  processthreadentry->owner_process_id=entry.th32OwnerProcessID;
  return RET_YES;
  }
 CloseHandle((HANDLE)han);
 *handle=0;
 return RET_FINISHED;
 }




 B aaProcessThreadListDestroy          (H handle)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(CloseHandle((HANDLE)handle)==0) { return RET_BADHANDLE; }
 return RET_YES;
 }



// https://msdn.microsoft.com/en-us/library/windows/desktop/ms683189%28v=vs.85%29.aspx

/*Important  The GetExitCodeProcess function returns a valid error
  code defined by the application only after the thread terminates.
  Therefore, an application should not use STILL_ACTIVE (259) as an error code.
  If a thread returns STILL_ACTIVE (259) as an error code,
  applications that test for this value could interpret it to mean
  that the thread is still running and continue to test for the
  completion of the thread after the thread has terminated,
  which could put the application into an infinite loop.
  */

 BOOL SafeTerminateProcess             (HANDLE hProcess,UINT uExitCode)
 {
 DWORD dwTID,dwCode,dwErr;
 HANDLE hProcessDup=INVALID_HANDLE_VALUE;
 HANDLE hRT=NULL;
 HINSTANCE hKernel=GetModuleHandle("Kernel32");
 FARPROC pfnExitProc;
 BOOL bSuccess=FALSE;
 BOOL bDup;

 if((dwErr=TerminateProcess(hProcess,uExitCode))==0)  {   return FALSE;  }
 if((bDup=DuplicateHandle(GetCurrentProcess(),hProcess,GetCurrentProcess(),&hProcessDup,PROCESS_ALL_ACCESS,FALSE,0))==0)   {   return FALSE; }
 dwErr=GetExitCodeProcess((bDup)?hProcessDup:hProcess,&dwCode);
 if(dwErr!=0&&(dwCode==STILL_ACTIVE))
  {
  pfnExitProc=GetProcAddress(hKernel,"ExitProcess");
  hRT=CreateRemoteThread((bDup)?hProcessDup:hProcess,NULL,0,(LPTHREAD_START_ROUTINE)pfnExitProc,(PVOID)uExitCode,0,&dwTID);
  if(hRT==NULL) { dwErr=GetLastError(); }
  else          { bSuccess=TRUE; }
  }
 else
  {
  dwErr=ERROR_PROCESS_ABORTED;
  bSuccess=TRUE;
  }
 if(hRT)
  {
  WaitForSingleObject((bDup)?hProcessDup:hProcess,INFINITE);
  CloseHandle(hRT);
  bSuccess=TRUE;
  }
 if(bDup)      { CloseHandle(hProcessDup);  }
 if(!bSuccess) { SetLastError(dwErr);  }
 return TRUE;
 }






 B aaProcessTerminateByHandle          (HANDLE handle,W ecode)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(SafeTerminateProcess(handle,ecode)==0) { return RET_FAILED; }
 return RET_YES;
 }




 B aaProcessTerminateByPid             (H pid,W ecode)
 {
 B ret;
 HANDLE han;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if((han=OpenProcess(PROCESS_TERMINATE,FALSE,pid))==NULL) { return RET_FAILED; }
 ret=aaProcessTerminateByHandle(han,ecode);
 CloseHandle(han);
 return ret;
 }




 B aaProcessIsRunningByPid             (H pid)
 {
 HANDLE pro;
 H res;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 pro=OpenProcess(SYNCHRONIZE,FALSE,pid);
 res=WaitForSingleObject(pro,0);
 CloseHandle(pro);
 if(res!=WAIT_TIMEOUT) { return RET_NO; }
 return RET_YES;
 }






 B aaProcessRestart                    (VP exename,VP cmdline,HP prochan,HP procid)
 {
 _processentry pe;
 H i,han;
 B ret,flag;
 B txt[_1K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(prochan) { *prochan=0; }
 if(procid) { *procid=0; }
 if(exename==NULL) { return RET_BADPARM; }
 if(aaStringIsEmpty(exename,YES)!=NO) { return RET_BADPARM; }
 flag=0;
 han=0;
 for(i=0;i<0xffffffff;i++)
  {
  if((ret=aaProcessList(&han,i,&pe))!=YES) {  break; }
  if(flag==0)
   {
   if(aaStringICompare(pe.exe_file,exename,0)!=YES) { continue; }
   aaStringCopyf(txt,"%s\\%s",pe.exe_path,pe.exe_file);
   aaProcessTerminateByPid(pe.process_id,0);
   if((ret=aaProcessSpawn(txt,cmdline,0,prochan,procid))!=RET_YES) { return ret; }
   flag=1;
   }
  }
 if(han!=0) { aaProcessListDestroy(han); }
 if(flag==1) { return RET_YES; }
 return RET_NOTFOUND;
 }



/*-----------------------------------------------------------------------*/



 BOOL CALLBACK aa_WinEnumProc          (HWND hwnd,LPARAM lparm)
 {
 B ret;
 _aa_winenumobject*wenp;
 H mom,left,add;
 _winenumentry*wnt;

 mom=(H)lparm;
 if((ret=aa_ObjectCheck(aa.winenum_system.object_id,mom,(VP)&wenp,NULL))!=RET_YES) { oops;  }
 left=wenp->slots-wenp->status.total_entries;
 add=64;
 if(left<(add/2))
  {
  if((ret=aaMemoryReAllocate((VP)&wenp->mem,(wenp->slots+add)*sizeof(_winenumentry)))!=YES) { oops; }
  wenp->slots+=add;
  }
 aaCast(wnt,_winenumentry*,&wenp->mem[wenp->status.total_entries*sizeof(_winenumentry)]);
 if(IsWindow(hwnd)!=0)
  {
  wnt->hwnd=hwnd;
  if(aaHwndInfoGet(wnt->hwnd,NULL,NULL,NULL,wnt->c_txt,wnt->t_txt)!=YES) { return TRUE; }
  wnt->tid=GetWindowThreadProcessId(wnt->hwnd,&wnt->pid);
  if(IsWindowVisible(wnt->hwnd)!=0) { wenp->status.total_visible++; wnt->is_visible=YES; } else { wnt->is_visible=NO; }
  wnt->is_child=NO;
  wnt->is_visible=NO;

  switch(wenp->status.mode)
   {
   case aa_WINENUM_STANDARD:
   wnt->parent_hwnd=GetParent(hwnd);
   wnt->owner_hwnd=GetWindow(hwnd,GW_OWNER);
   wenp->status.total_entries++;
   if(wnt->is_child) { wenp->status.total_children++; }
   else              {  wenp->status.total_windows++; }
   break;

   case aa_WINENUM_THREADID:
   wnt->parent_hwnd=GetParent(wnt->hwnd);
   wnt->owner_hwnd=GetWindow(hwnd,GW_OWNER);
   wenp->status.total_entries++;
   if(wnt->is_child) { wenp->status.total_children++; }
   else              {  wenp->status.total_windows++; }
   break;

   case aa_WINENUM_CHILDREN:
   if(IsChild((HWND)wenp->status.hanhwn,wnt->hwnd)!=0) { wnt->is_child=YES; } else { wnt->is_child=NO; }
   wnt->parent_hwnd=GetParent(hwnd);
   wnt->owner_hwnd=GetWindow(hwnd,GW_OWNER);
   wenp->status.total_entries++;
   if(wnt->is_child) { wenp->status.total_children++; }
   else              {  wenp->status.total_windows++; }

   break;
   }

  }
 return TRUE;
 }




 H aa_WinEnumThread                    (VP parm)
 {
 B ret;
 _aa_threadobject*thrp;
 H handle;
 HP hp;
 _threadunit tu;
 _aa_winenumobject*wenp;

 #if aa_USE_GLOBAL_MUTEX == 1
 EnterCriticalSection(&global_mutex);
 #endif
 hp=(HP)parm;
 tu.handle=(H)&hp[0];
 if((ret=aa_ObjectCheck(aa.thread_system.object_id,tu.handle,(VP)&thrp,NULL))!=YES) { oops; }
 if((ret=aaThreadStatus(tu.handle,&tu.status))!=RET_YES) { oops; }
 handle=tu.status.data;
 if(aa_ObjectCheck(aa.winenum_system.object_id,handle,(VP)&wenp,NULL)!=RET_YES) oof;
 ret=RET_YES;
 #if aa_USE_GLOBAL_MUTEX == 1
 LeaveCriticalSection(&global_mutex);
 #endif
 while(1)
  {
  #if aa_USE_GLOBAL_MUTEX == 1
  EnterCriticalSection(&global_mutex);
  #endif
  if(is_aa_quit_posted) {  break; }
  aaThreadStatus(tu.handle,&tu.status);
  if(tu.status.is_exiting==YES)    {     break;   }
  ret=RET_YES;
  switch(wenp->status.mode)
   {
   case aa_WINENUM_STANDARD:
   if(EnumWindows(aa_WinEnumProc,(LPARAM)handle)==0) { ret=RET_FAILED;   }
   break;
   case aa_WINENUM_THREADID:
   if(EnumThreadWindows(wenp->status.hanhwn,aa_WinEnumProc,(LPARAM)handle)==0) {  ret=RET_FAILED; }
   break;
   case aa_WINENUM_CHILDREN:
   if(EnumChildWindows((HWND)wenp->status.hanhwn,aa_WinEnumProc,(LPARAM)handle)==0) {  ret=RET_FAILED; }
   break;
   default: oof;
   break;
   }
  wenp->status.in_progress=NO;
  wenp->status.is_completed=YES;
  wenp->status.is_success=YES;
  wenp->sleep_cycle++;
  #if aa_USE_GLOBAL_MUTEX == 1
  LeaveCriticalSection(&global_mutex);
  #endif
  if(aaNumIsMod(wenp->sleep_cycle,10)) { aaSleep(1); }
  else                                 { aaSleep(0); }
  break;
  }
 #if aa_USE_GLOBAL_MUTEX == 1
 LeaveCriticalSection(&global_mutex);
 #endif
 aaThreadQuit(tu.handle,ret);
 }




 B aaWinEnumCreate                     (HP handle,B mode,H hanhwn)
 {
 B ret;
 _aa_winenumobject*wenp;
 H c;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==NULL) { return RET_BADPARM; }
 *handle=0;
 switch(mode)
  {
  case aa_WINENUM_STANDARD:
  break;
  case aa_WINENUM_THREADID:
  if(hanhwn==0) { return RET_BADPARM; }
  break;
  case aa_WINENUM_CHILDREN:
  if(hanhwn==0)   {   hanhwn=(H)GetDesktopWindow();   }
  if(hanhwn==0) return RET_BADPARM;
  break;
  default:
  return RET_FAILED;
  }
 if((ret=aa_ObjectCreate(aa.winenum_system.object_id,handle,(VP)&wenp))!=RET_YES) { oops;  return ret; }
 wenp->self_handle=*handle;
 c=10;
 if((ret=aaMemoryAllocate((VP)&wenp->mem,c*sizeof(_winenumentry)))!=YES) { oops; }
 aaMemoryNameSet(wenp->mem,"wenpme");
 aaCast(wenp->status.entry,_winenumentry*,wenp->mem);
 wenp->slots=c;
 wenp->status.mode=mode;
 wenp->status.hanhwn=hanhwn;
 wenp->status.in_progress=YES;
 if((ret=aaThreadCreate(&wenp->thread_handle,aa_WinEnumThread,*handle,0,NULL,NO))!=YES) { oops; }
 return ret;
 }






 B aaWinEnumDestroy                    (H handle)
 {
 B ret;
 _aa_winenumobject*wenp;
 B isprot;
 H cnt;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.winenum_system.object_id,handle,(VP)&wenp,&isprot))!=RET_YES) { return ret; }
 if(isprot==YES) { oof; Boop; return RET_FORBIDDEN; }
 if(wenp->thread_handle!=0)
  {
  if((ret=aaThreadExit(wenp->thread_handle))!=YES) { oops; }
  cnt=0;
  while(1)
   {
   aaThreadStatus(wenp->thread_handle,&wenp->thread_status);
   if(wenp->thread_status.is_exited) { break; }
   cnt++;
   aaSleep(1);
   if(cnt>10) { break; }
   }
  if((ret=aaThreadDestroy(wenp->thread_handle))!=YES) { oops; }
  wenp->thread_handle=0;
  }
 if(wenp->slots!=0)
  {
  aaMemoryRelease(wenp->mem);
  wenp->mem=NULL;
  }
 if((ret=aa_ObjectDestroy(aa.winenum_system.object_id,handle))!=YES) { oops;  }
 return RET_YES;
 }




 B aaWinEnumStatus                     (H handle,_winenumstatus*winenumstatus)
 {
 B ret;
 _aa_winenumobject*wenp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.winenum_system.object_id,handle,(VP)&wenp,NULL))!=RET_YES) { return ret; }
 aaYieldRaw();
 aaCast(wenp->status.entry,_winenumentry*,wenp->mem);
 if(winenumstatus)  {  aaMemoryCopy(winenumstatus,sizeof(_winenumstatus),&wenp->status); }
 return RET_YES;
 }


/*-----------------------------------------------------------------------*/

 #define aa_MATH_DCT_ACCURATE_ROUNDING
 #define aa_MATH_DCT_RIGHT_SHIFT(x,s)  ((x)>>(s))

 #ifdef  aa_MATH_DCT_ACCURATE_ROUNDING
 #define aa_MATH_DCT_ONE               ((N) 1)
 #define aa_MATH_DCT_DESCALE(x,n)      aa_MATH_DCT_RIGHT_SHIFT((x)+(aa_MATH_DCT_ONE<<((n)-1)),n)
 #else
 #define aa_MATH_DCT_DESCALE(x,n)      aa_MATH_DCT_RIGHT_SHIFT(x,n)
 #endif

 #define aa_MATH_DCT_CONST_BITS        13
 #define aa_MATH_DCT_PASS1_BITS        2

 #define aa_MATH_DCT_FIX_0_298631336   ((N)2446)
 #define aa_MATH_DCT_FIX_0_390180644   ((N)3196)
 #define aa_MATH_DCT_FIX_0_541196100   ((N)4433)
 #define aa_MATH_DCT_FIX_0_765366865   ((N)6270)
 #define aa_MATH_DCT_FIX_0_899976223   ((N)7373)
 #define aa_MATH_DCT_FIX_1_175875602   ((N)9633)
 #define aa_MATH_DCT_FIX_1_501321110   ((N)12299)
 #define aa_MATH_DCT_FIX_1_847759065   ((N)15137)
 #define aa_MATH_DCT_FIX_1_961570560   ((N)16069)
 #define aa_MATH_DCT_FIX_2_053119869   ((N)16819)
 #define aa_MATH_DCT_FIX_2_562915447   ((N)20995)
 #define aa_MATH_DCT_FIX_3_072711026   ((N)25172)

 #define aa_MATH_DCT_W1                2841
 #define aa_MATH_DCT_W2                2676
 #define aa_MATH_DCT_W3                2408
 #define aa_MATH_DCT_W5                1609
 #define aa_MATH_DCT_W6                1108
 #define aa_MATH_DCT_W7                565



 B aa_MathSystemStart                  (V)
 {
 N i;
 B txt[_1K];
 H key[8];
 B ret;
 POINT pnt;
 D f1;

 logg("aa_MathSystemStart()");
 aa.math_system.four_billion=65536.0*65536.0;
 aa.math_system.one_million=(D)1000000;
 aa.math_system.ten_million=(D)10000000;
 aa.math_system.dct_iclip_ptr=aa.math_system.dct_iclip+512;
 for(i=-512;i<512; i++) { aa.math_system.dct_iclip_ptr[i]=(I)aaNumClamp(i,-256,255); }
 aaStringCopyf(txt,"%s","pmmzech");
 key[0]=(H)&txt;
 #ifdef IS_A_DLL
 key[0]+=(H)(PP)DllMain;
 #else
 key[0]+=(H)(PP)WinMain;
 #endif
 key[0]+=(H)aa_avgcpuload;
 aa_CoreSystemCpuLoadGet();
 f1=aa_avgcpuload;
 f1=f1*31230000.0;
 key[0]+=(H)f1;
 key[0]+=aa_launchtik;
 key[0]+=aa.core_system.process_id;
 for(i=0;i<7;i++) txt[i]--;
 GetCursorPos(&pnt);
 for(i=0;i<48*6;i++)
  {
  if(i==0) {  txt[7]='.'; }
  }
 key[1]=(H)aaMicrosecsRunning();
 txt[8]='e';
 for(i=0;i<572;i++)
  {
  if(i==10) {  key[4]=(H)aa.core_system.this_instance+(pnt.x); txt[9]='x'; }
  }
 key[2]=aa.core_system.process_id;
 for(i=0;i<48*6; i++)
  {
  if(i==5)  { txt[10]='e';  key[3]=aa.core_system.thread_id; }
  if(i==20) { key[5]=(H)aa.core_system.process_handle; txt[11]=0;  }
  }
 key[6]=(H)aa.core_system.thread_handle+(pnt.y);
 key[7]=aa_launchtik;
 if((ret=aaMathTwisterInit(&aa.math_system.twister,8,key))!=YES) oops;
 if(aaProcessIsRunning(txt,0)==((txt[0]-'o')+1))  { aaQuit(); }
 logg("");
 return RET_YES;
 }




 V aa_MathSystemStop                   (V)
 {
 logg("aa_MathSystemStop()");
 logg("");
 }




 B aa_MathRandomGet                    (VP buf,H bytes)
 {
 BP bp,tp;
 HP hp;
 H val,b;
 S H woff=0;
 S H roff=0;
 S H have=0;
 S H hlen=256;
 S B hold[256];
 H thresh=128;
 N left,edge;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(buf==NULL) { return RET_BADPARM;  }
 aaCast(bp,BP,buf);
 while(1)
  {
  while(1)
   {
   if(have==0) { break; }
   if(bytes==0) { break; }
   bp[0]=hold[roff];
   bp++;
   roff++;
   roff%=hlen;
   have--;
   bytes--;
   }
  if(bytes==0) break;
  while(1)
   {
   if(have>=thresh) { break; }
   left=(N)hlen-(N)have;
   edge=(N)hlen-(N)woff;
   if(left>=4&&edge>=4)
    {
    aaCast(hp,HP,&hold[woff]);
    *hp=aaMathTwisterInt32(&aa.math_system.twister);
    woff+=4;
    have+=4;
    continue;
    }
   val=aaMathTwisterInt32(&aa.math_system.twister);
   aaCast(tp,BP,&val);
   for(b=0;b<4;b++) {  hold[woff]=tp[b];   woff++;   woff%=hlen; have++;   }
   }
  }
 return RET_YES;
 }

/*-----------------------------------------------------------------------*/


/*
inline double to_degrees(double radians) {    return radians*(180.0/M_PI);}
// Converts degrees to radians.
#define degreesToRadians(angleDegrees) (angleDegrees*M_PI/180.0)
// Converts radians to degrees.
#define radiansToDegrees(angleRadians) (angleRadians*180.0/M_PI)
//
private static double calculateDirection(double x, double y){    return Math.toDegrees(Math.atan2(y, x));}
*/


 B aaMathDct                           (IP block,B fwd,B descale)
 {
 N tmp0,tmp1,tmp2,tmp3,tmp4,tmp5,tmp6,tmp7;
 N tmp10,tmp11,tmp12,tmp13;
 N X0,X1,X2,X3,X4,X5,X6,X7,X8;
 N z1,z2,z3,z4,z5;
 IP blkptr;
 NP dataptr;
 N data[64];
 register N i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(fwd==YES)
  {
  aaCast(dataptr,NP,data);
  aaCast(blkptr,IP,block);
  for(i=0;i<8; i++)
   {
  tmp0=blkptr[0]+blkptr[7];
  tmp7=blkptr[0]-blkptr[7];
  tmp1=blkptr[1]+blkptr[6];
  tmp6=blkptr[1]-blkptr[6];
  tmp2=blkptr[2]+blkptr[5];
  tmp5=blkptr[2]-blkptr[5];
  tmp3=blkptr[3]+blkptr[4];
  tmp4=blkptr[3]-blkptr[4];
  tmp10=tmp0+tmp3;
  tmp13=tmp0-tmp3;
  tmp11=tmp1+tmp2;
  tmp12=tmp1-tmp2;
  dataptr[0]=(tmp10+tmp11)<<aa_MATH_DCT_PASS1_BITS;
  dataptr[4]=(tmp10-tmp11)<<aa_MATH_DCT_PASS1_BITS;
  z1=(tmp12+tmp13)*aa_MATH_DCT_FIX_0_541196100;
  dataptr[2]=aa_MATH_DCT_DESCALE(z1+tmp13*aa_MATH_DCT_FIX_0_765366865,aa_MATH_DCT_CONST_BITS-aa_MATH_DCT_PASS1_BITS);
  dataptr[6]=aa_MATH_DCT_DESCALE(z1+tmp12*(-aa_MATH_DCT_FIX_1_847759065),aa_MATH_DCT_CONST_BITS-aa_MATH_DCT_PASS1_BITS);
  z1=tmp4+tmp7;
  z2=tmp5+tmp6;
  z3=tmp4+tmp6;
  z4=tmp5+tmp7;
  z5=(z3+z4)*aa_MATH_DCT_FIX_1_175875602;
  tmp4*=aa_MATH_DCT_FIX_0_298631336;
  tmp5*=aa_MATH_DCT_FIX_2_053119869;
  tmp6*=aa_MATH_DCT_FIX_3_072711026;
  tmp7*=aa_MATH_DCT_FIX_1_501321110;
  z1*=-aa_MATH_DCT_FIX_0_899976223;
  z2*=-aa_MATH_DCT_FIX_2_562915447;
  z3*=-aa_MATH_DCT_FIX_1_961570560;
  z4*=-aa_MATH_DCT_FIX_0_390180644;
  z3+=z5;
  z4+=z5;
  dataptr[7]=aa_MATH_DCT_DESCALE(tmp4+z1+z3,aa_MATH_DCT_CONST_BITS-aa_MATH_DCT_PASS1_BITS);
  dataptr[5]=aa_MATH_DCT_DESCALE(tmp5+z2+z4,aa_MATH_DCT_CONST_BITS-aa_MATH_DCT_PASS1_BITS);
  dataptr[3]=aa_MATH_DCT_DESCALE(tmp6+z2+z3,aa_MATH_DCT_CONST_BITS-aa_MATH_DCT_PASS1_BITS);
  dataptr[1]=aa_MATH_DCT_DESCALE(tmp7+z1+z4,aa_MATH_DCT_CONST_BITS-aa_MATH_DCT_PASS1_BITS);
  dataptr+=8;
  blkptr+=8;
  }
  // Pass 2: process columns.
 dataptr=data;
 for(i=0;i<8;i++)
  {
  tmp0=dataptr[0]+dataptr[56];
  tmp7=dataptr[0]-dataptr[56];
  tmp1=dataptr[8]+dataptr[48];
  tmp6=dataptr[8]-dataptr[48];
  tmp2=dataptr[16]+dataptr[40];
  tmp5=dataptr[16]-dataptr[40];
  tmp3=dataptr[24]+dataptr[32];
  tmp4=dataptr[24]-dataptr[32];
  tmp10=tmp0+tmp3;
  tmp13=tmp0-tmp3;
  tmp11=tmp1+tmp2;
  tmp12=tmp1-tmp2;
  dataptr[0]=aa_MATH_DCT_DESCALE(tmp10+tmp11,aa_MATH_DCT_PASS1_BITS);
  dataptr[32]=aa_MATH_DCT_DESCALE(tmp10-tmp11,aa_MATH_DCT_PASS1_BITS);
  z1=(tmp12+tmp13)*aa_MATH_DCT_FIX_0_541196100;
  dataptr[16]=aa_MATH_DCT_DESCALE(z1+tmp13*aa_MATH_DCT_FIX_0_765366865,aa_MATH_DCT_CONST_BITS+aa_MATH_DCT_PASS1_BITS);
  dataptr[48]=aa_MATH_DCT_DESCALE(z1+tmp12*(-aa_MATH_DCT_FIX_1_847759065),aa_MATH_DCT_CONST_BITS+aa_MATH_DCT_PASS1_BITS);
  z1=tmp4+tmp7;
  z2=tmp5+tmp6;
  z3=tmp4+tmp6;
  z4=tmp5+tmp7;
  z5=(z3+z4)*aa_MATH_DCT_FIX_1_175875602;
  tmp4*=aa_MATH_DCT_FIX_0_298631336;
  tmp5*=aa_MATH_DCT_FIX_2_053119869;
  tmp6*=aa_MATH_DCT_FIX_3_072711026;
  tmp7*=aa_MATH_DCT_FIX_1_501321110;
  z1*=-aa_MATH_DCT_FIX_0_899976223;
  z2*=-aa_MATH_DCT_FIX_2_562915447;
  z3*=-aa_MATH_DCT_FIX_1_961570560;
  z4*=-aa_MATH_DCT_FIX_0_390180644;
  z3+=z5;
  z4+=z5;
  dataptr[56]=aa_MATH_DCT_DESCALE(tmp4+z1+z3,aa_MATH_DCT_CONST_BITS+aa_MATH_DCT_PASS1_BITS);
  dataptr[40]=aa_MATH_DCT_DESCALE(tmp5+z2+z4,aa_MATH_DCT_CONST_BITS+aa_MATH_DCT_PASS1_BITS);
  dataptr[24]=aa_MATH_DCT_DESCALE(tmp6+z2+z3,aa_MATH_DCT_CONST_BITS+aa_MATH_DCT_PASS1_BITS);
  dataptr[8]=aa_MATH_DCT_DESCALE(tmp7+z1+z4,aa_MATH_DCT_CONST_BITS+aa_MATH_DCT_PASS1_BITS);
  dataptr++;
  }
 if(descale==YES) {   for(i=0;i<64;i++) { block[i]=(short int)aa_MATH_DCT_DESCALE(data[i],3); } }
 else             {   for(i=0;i<64;i++) { block[i]=(short int)data[i]; } }
 }
 else ////////// REVERSE
  {
  for(i=0;i<8;i++)
  {
  blkptr=block+(i<<3);
  if(!((X1=blkptr[4]<<11)|(X2=blkptr[6])|(X3=blkptr[2])|(X4=blkptr[1])|(X5=blkptr[7])|(X6=blkptr[5])|(X7=blkptr[3])))
      {
      blkptr[0]=blkptr[1]=blkptr[2]=blkptr[3]=blkptr[4]=blkptr[5]=blkptr[6]=blkptr[7]=(I)(blkptr[0]<<3);
      continue;
      }
  X0=(blkptr[0]<<11)+128;
  // first stage
  X8=aa_MATH_DCT_W7*(X4+X5);
  X4=X8+(aa_MATH_DCT_W1-aa_MATH_DCT_W7)*X4;
  X5=X8-(aa_MATH_DCT_W1+aa_MATH_DCT_W7)*X5;
  X8=aa_MATH_DCT_W3*(X6+X7);
  X6=X8-(aa_MATH_DCT_W3-aa_MATH_DCT_W5)*X6;
  X7=X8-(aa_MATH_DCT_W3+aa_MATH_DCT_W5)*X7;
  // second stage
  X8=X0+X1;
  X0-=X1;
  X1=aa_MATH_DCT_W6*(X3+X2);
  X2=X1-(aa_MATH_DCT_W2+aa_MATH_DCT_W6)*X2;
  X3=X1+(aa_MATH_DCT_W2-aa_MATH_DCT_W6)*X3;
  X1=X4+X6;
  X4-=X6;
  X6=X5+X7;
  X5-=X7;
  // third stage
  X7=X8+X3;
  X8-=X3;
  X3=X0+X2;
  X0-=X2;
  X2=(181*(X4+X5)+128)>>8;
  X4=(181*(X4-X5)+128)>>8;
  // fourth stage
  blkptr[0]=(short)((X7+X1)>>8);
  blkptr[1]=(short)((X3+X2)>>8);
  blkptr[2]=(short)((X0+X4)>>8);
  blkptr[3]=(short)((X8+X6)>>8);
  blkptr[4]=(short)((X8-X6)>>8);
  blkptr[5]=(short)((X0-X4)>>8);
  blkptr[6]=(short)((X3-X2)>>8);
  blkptr[7]=(short)((X7-X1)>>8);
  }
 for(i=0;i<8;i++)
  {
  blkptr=block+i;
  if(!((X1=(blkptr[8*4]<<8))|(X2=blkptr[8*6])|(X3=blkptr[8*2])|(X4=blkptr[8*1])|(X5=blkptr[8*7])|(X6=blkptr[8*5])|(X7=blkptr[8*3])))
   {
   blkptr[8*0]=blkptr[8*1]=blkptr[8*2]=blkptr[8*3]=blkptr[8*4]=blkptr[8*5]=blkptr[8*6]=blkptr[8*7]=aa.math_system.dct_iclip_ptr[(blkptr[8*0]+32)>>6];
   continue;
   }
  X0=(blkptr[8*0]<<8)+8192;
  // first stage
  X8=aa_MATH_DCT_W7*(X4+X5)+4;
  X4=(X8+(aa_MATH_DCT_W1-aa_MATH_DCT_W7)*X4)>>3;
  X5=(X8-(aa_MATH_DCT_W1+aa_MATH_DCT_W7)*X5)>>3;
  X8=aa_MATH_DCT_W3*(X6+X7)+4;
  X6=(X8-(aa_MATH_DCT_W3-aa_MATH_DCT_W5)*X6)>>3;
  X7=(X8-(aa_MATH_DCT_W3+aa_MATH_DCT_W5)*X7)>>3;
  // second stage
  X8=X0+X1;
  X0-=X1;
  X1=aa_MATH_DCT_W6*(X3+X2)+4;
  X2=(X1-(aa_MATH_DCT_W2+aa_MATH_DCT_W6)*X2)>>3;
  X3=(X1+(aa_MATH_DCT_W2-aa_MATH_DCT_W6)*X3)>>3;
  X1=X4+X6;
  X4-=X6;
  X6=X5+X7;
  X5-=X7;
  // third stage
  X7=X8+X3;
  X8-=X3;
  X3=X0+X2;
  X0-=X2;
  X2=(181*(X4+X5)+128)>>8;
  X4=(181*(X4-X5)+128)>>8;
  // fourth stage
  blkptr[8*0]=aa.math_system.dct_iclip_ptr[(X7+X1)>>14];
  blkptr[8*1]=aa.math_system.dct_iclip_ptr[(X3+X2)>>14];
  blkptr[8*2]=aa.math_system.dct_iclip_ptr[(X0+X4)>>14];
  blkptr[8*3]=aa.math_system.dct_iclip_ptr[(X8+X6)>>14];
  blkptr[8*4]=aa.math_system.dct_iclip_ptr[(X8-X6)>>14];
  blkptr[8*5]=aa.math_system.dct_iclip_ptr[(X0-X4)>>14];
  blkptr[8*6]=aa.math_system.dct_iclip_ptr[(X3-X2)>>14];
  blkptr[8*7]=aa.math_system.dct_iclip_ptr[(X7-X1)>>14];
  }
  }
 return RET_YES;
 }





 B aaMathSinTableCreate                (FP*table)
 {
 F the,rad,a;
 D s;
 W z;
 FP ptr;
 BP mem;
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(table==NULL) return RET_BADPARM;
 if((ret=aaMemoryAllocate((VP)&mem,3600*sizeof(F)))!=RET_YES) { return ret; }
 aaMemoryNameSet(mem,"sintable");
 aaCast(ptr,FP,mem);
 a=0;
 for(z=0;z<3600;z++)
  {
  the=(F)a;
  rad=(the*aaPi)/180.0;
  s=sin(rad);
  ptr[z]=(F)s;
  a+=0.1;
  }
 *table=ptr;
 return RET_YES;
 }







 B aaMathCosTableCreate                (FP*table)
 {
 F the,rad,a;
 D s;
 W z;
 FP ptr;
 BP mem;
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(table==NULL) return RET_BADPARM;
 if((ret=aaMemoryAllocate((VP)&mem,3600*sizeof(F)))!=RET_YES) { return ret; }
 aaMemoryNameSet(mem,"costable");
 aaCast(ptr,FP,mem);
 a=0;
 for(z=0;z<3600;z++)
  {
  the=(F)a;
  rad=(the*aaPi)/180.0;
  s=cos(rad);
  ptr[z]=(F)s;
  a+=0.1;
  }
 *table=ptr;
 return RET_YES;
 }




 B aaMathDtmfSet                       (H samples,_audiomode*audiomode,N amp,B code,VP buf)
 {
 S N dtmf_tone[17][2]=
 {
 {941,1336}, // 0
 {697,1209}, // 1
 {697,1336}, // 2
 {697,1477}, // 3
 {770,1209}, // 4
 {770,1336}, // 5
 {770,1477}, // 6
 {852,1209}, // 7
 {852,1336}, // 8
 {852,1477}, // 9
 {697,1633}, // a
 {770,1633}, // b
 {852,1633}, // c
 {941,1633}, // d
 {941,1209}, // *
 {941,1447}, // #
 };

 N srate,j;
 D t1,t2,t,v,tonelen;
 C q[2];
 CP cp;
 IP ip;
 H cnt;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(buf==NULL)  { return RET_BADPARM; }
 if(audiomode==NULL) { return RET_BADPARM; }
 if(samples==0) { return RET_BADPARM; }

 srate=audiomode->frequency;
 cp=(CP)buf;
 ip=(IP)buf;
 tonelen=(D)samples/(D)audiomode->frequency;
 cnt=0;
 for(t=0;t<tonelen*2;t+=1.0/srate)
  {
  t1=sin(2.0*aaPi*dtmf_tone[code][0]*t);
  t2=sin(2.0*aaPi*dtmf_tone[code][1]*t);
  v=amp*(t1+t2);
  j=(Z)v;
  q[0]=(C)(j&F8);
  q[1]=(C)((j>>8)&F8);
  j=*(NP)q;
  if(audiomode->channels==1)
   {
   if(audiomode->bits==16) { ip[0]=j*128;       ip+=1;    }
   else
   if(audiomode->bits==8)  { cp[0]=q[0]-128;    cp+=1;    }
   }
  else
   {
   if(audiomode->bits==16) { ip[0]=j*128;      ip[1]=j*128;     ip+=2;   }
   else
   if(audiomode->bits==8)  { cp[0]=q[0]-128;   cp[1]=q[1]-128;  cp+=2;   }
   }
  cnt++;
  if(cnt>=samples) { break; }
  }
 return RET_YES;
 }



/*

<<< http://gis.stackexchange.com/questions/8650/how-to-measure-the-accuracy-of-latitude-and-longitude
http://www.longitudestore.com/how-big-is-one-gps-degree.html
http://msi.nga.mil/MSISiteContent/StaticFiles/Calculators/degree.html
https://www.maptools.com/tutorials/lat_lon/formats
https://knowledge.safe.com/articles/725/calculating-accurate-length-in-meters-for-lat-long.html
http://stackoverflow.com/questions/639695/how-to-convert-latitude-or-longitude-to-meters


function measure(lat1, lon1, lat2, lon2){  // generally used geo measurement function
    var R=6378.137; // Radius of earth in KM
    var dLat=(lat2 - lat1)*Math.PI/180;
    var dLon=(lon2 - lon1)*Math.PI/180;
    var a=Math.sin(dLat/2)*Math.sin(dLat/2) +
    Math.cos(lat1*Math.PI/180)*Math.cos(lat2*Math.PI/180) *
    Math.sin(dLon/2)*Math.sin(dLon/2);
    var c=2*Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    var d=R*c;
    return d*1000; // meters
}
*/


 /*
 (((acos(sin(($lat*pi()/180))*sin((latitude*pi()/180)) cos(($lat*pi()/180))*cos((latitude*pi()/180))*cos((($lng - longitude)*pi()/180))))*180/pi())*60*1.1515)
 */


 // lat=-90/+90  lon=-180/+180


 B aaMathLatLongDistanceGet            (D lat1,D lon1,D lat2,D lon2,DP distance)
 {
 D th,di;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(distance==NULL) { return RET_BADPARM; }
 *distance=0;
 if(lon1<-180||lon1>+180) { return RET_BOUNDS; }
 if(lat1<-90||lat1>+90) { return RET_BOUNDS; }
 if(lon2<-180||lon2>+180) { return RET_BOUNDS; }
 if(lat2<-90||lat2>+90) { return RET_BOUNDS; }
 th=lon1-lon2;
 di=sin((lat1*aaPi/180.0))*sin((lat2*aaPi/180.0))+cos((lat1*aaPi/180.0))*cos((lat2*aaPi/180.0))*cos((th*aaPi/180.0));
 di=acos(di);
 di=(di*180.0/aaPi);
 di=di*60*1.1515;
 di=di*1.609344;
 // default is miles
 // to covert to k's di=di*1.609344
 // to conver to nautical milex di=di*0.8684
 *distance=di;
 return RET_YES;
 }



 B aaMathLatLongCordGet                (D lat,D lon,_size*size,_cord*cord)
 {
 D minlat=-90.0;
 D maxlat=+90.0;
 D minlon=-180;
 D maxlon=+180;
 D x,y;
 D rad,mer;

 //minlat=-85.05112878;
 //maxlat=+85.05112878;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(cord==NULL) { return RET_BADPARM; }
 cord->x=cord->y=0;
 if(size==NULL) { return RET_BADPARM; }
 if(size->w==0||size->h==0) { return RET_BADPARM; }
 lat=aaNumClamp(lat,minlat,maxlat);
 lon=aaNumClamp(lon,minlon,maxlon);
 x=(lon+180.0)*(size->w/360.0);
 rad=lat*aaPi/180.0;
 mer=log(tan((aaPi/4.0)+(rad/2.0)));
 y=(size->h/2.0)-(size->w*mer/(2.0*aaPi));
 //x=((lon+180.0)*(size->w/360.0));
 //y=(((lat*-1.0)+90.0)*(size->h/180.0));
 cord->x=aaNumClamp((N)x,0,(N)(size->w-1));
 cord->y=aaNumClamp((N)y,0,(N)(size->h-1));
 return RET_YES;
 }

/*
 B aaMathLatLongCordGet                (D lat,D lon,_size*size,_cord*cord)
 {
 D mw,mh;
 D mlonl,mlonr,mlond;
 D mlatb,mlatbd;
 D wmw,moy;
 D x,y;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(cord==NULL) { return RET_BADPARM; }
 cord->x=cord->y=0;
 if(size==NULL) { return RET_BADPARM; }
 if(size->w==0||size->h==0) { return RET_BADPARM; }
 mw=(D)size->w;
 mh=(D)size->h;
 mlonl=-180.0;
 mlonr=+180.0;
 mlond=mlonr-mlonl;
 mlatb=40.1700;
 mlatbd=mlatb*aaPi/180.0;
 x=(lon-mlonl)*(mw/mlond);
 lat=lat*aaPi/180.0;
 wmw=((mw/mlond)*360.0)/(2.0*aaPi);
 moy=(wmw/2.0*log((1.0+sin(mlatbd))/(1.0-sin(mlatbd))));
 y=mh-((wmw/2.0*log((1.0+sin(lat))/(1.0-sin(lat))))-moy);
 cord->x=aaNumClamp((N)x,0,(N)(size->w-1));
 cord->y=aaNumClamp((N)y,0,(N)(size->h-1));
 return RET_YES;
 }
*/





 D aaMathDoubleRound                   (D val,N numer,N denom)
 {
 D y;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 y=floor(val*(D)denom+(D)numer/2.0);
 return((D)((y-(N)y%numer)/(D)denom));
 }



 B aaMathRandomGet                     (HP val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(val==NULL) { return RET_BADPARM; }
 *val=aaMathTwisterInt32(&aa.math_system.twister);
 return RET_YES;
 }



 H aaMathRand32                        (H lo,H hi)
 {
 H rn,val;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(lo>hi) { val=lo; lo=hi; hi=val;   }
 rn=(hi-lo)+1;
 val=aaMathTwisterInt32(&aa.math_system.twister);
 if(rn!=0&&rn!=0xffffffff) {  val%=(rn); }
 val=lo+val;
 return(val);
 }



 Q aaMathRand64                        (Q lo,Q hi)
 {
 Q val,rn;
 HP hp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(lo>hi) { val=lo; lo=hi; hi=val;   }
 rn=(hi-lo)+1;
 hp=(HP)&val;
 hp[0]=aaMathTwisterInt32(&aa.math_system.twister);
 hp[1]=aaMathTwisterInt32(&aa.math_system.twister);
 if(rn!=0&&rn!=F64) {  val%=(rn); }
 val=lo+val;
 return(val);
 }



 D aaMathRandDouble                    (D lo,D hi)
 {
 D v;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(lo>hi) { v=lo; lo=hi; hi=v;   }
 v=((hi-lo)*((D)aaMathRand32(0,0xffffffff)/4294967296.0))+lo;
 return v;
 }



 B aaMathTwisterInit                   (_twister*twister,H seed,HP key)
 {
 H kylen;
 Z i,j,k;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(twister==NULL) { return RET_BADPARM; }
 if(key==NULL&&seed==0) { seed=5489UL; }
 aaMemoryFill(twister,sizeof(_twister),0);
 twister->magic=(H)(PP)aaMathTwisterInit;
 twister->mag01[0]=0x0UL;
 twister->mag01[1]=aa_MathTwister_MATRIX_A;
 twister->mti=624+1;
 kylen=0;
 if(key!=NULL)  {  kylen=seed;  seed=19650218UL;  }
 twister->mt[0]=seed&0xffffffffUL;
 for(twister->mti=1;twister->mti<624;twister->mti++)
  {
  twister->mt[twister->mti]=(1812433253UL*(twister->mt[twister->mti-1]^(twister->mt[twister->mti-1]>>30))+twister->mti);
  twister->mt[twister->mti]&=0xffffffffUL;
  }
 if(kylen>0)
  {
  i=1;
  j=0;
  k=(624>kylen?624:kylen);
  for(;k;k--)
   {
   twister->mt[i]=(twister->mt[i]^((twister->mt[i-1]^(twister->mt[i-1]>>30))*1664525UL))+key[j]+j;
   twister->mt[i]&=0xffffffffUL;
   i++; j++;
   if(i>=624)   { twister->mt[0]=twister->mt[624-1];i=1;}
   if((H)j>=kylen) { j=0; }
   }
  for(k=624-1;k;k--)
   {
   twister->mt[i]=(twister->mt[i]^((twister->mt[i-1]^(twister->mt[i-1]>>30))*1566083941UL))-i;
   twister->mt[i]&=0xffffffffUL;
   i++;
   if(i>=624) { twister->mt[0]=twister->mt[624-1]; i=1; }
   }
  twister->mt[0]=0x80000000UL;
  }
 twister->ret=RET_YES;
 return RET_YES;
 }




 H aaMathTwisterInt32                  (_twister*twister)
 {
 register H y;
 register Z kk;
 _twister*twt;
 S H counter=0;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(twister==NULL) { twt=&aa.math_system.twister; }
 else              { twt=twister; }
 if(twt->magic!=(H)(PP)aaMathTwisterInit) { twt->ret=RET_NOTINITIALIZED; return RET_NOTINITIALIZED; }
 if(twt->mti>=624)
  {
  if(twt->mti==624+1) { twt->mti=0; }
  for(kk=0;kk<624-aa_MathTwister_MM;kk++)
   {
   y=(twt->mt[kk]&aa_MathTwister_UPPER_MASK)|(twt->mt[kk+1]&aa_MathTwister_LOWER_MASK);
   twt->mt[kk]=twt->mt[kk+aa_MathTwister_MM]^(y>>1)^twt->mag01[y&0x1UL];
   }
  for(;kk<624-1;kk++)
   {
   y=(twt->mt[kk]&aa_MathTwister_UPPER_MASK)|(twt->mt[kk+1]&aa_MathTwister_LOWER_MASK);
   twt->mt[kk]=twt->mt[kk+(aa_MathTwister_MM-624)]^(y>>1)^twt->mag01[y&0x1UL];
   }
  y=(twt->mt[624-1]&aa_MathTwister_UPPER_MASK)|(twt->mt[0]&aa_MathTwister_LOWER_MASK);
  twt->mt[624-1]=twt->mt[aa_MathTwister_MM-1]^(y>>1)^twt->mag01[y&0x1UL];
  twt->mti=0;
  }
 y=twt->mt[twt->mti++];
 y^=(y>>11);
 y^=(y<<7)&0x9d2c5680UL;
 y^=(y<<15)&0xefc60000UL;
 y^=(y>>18);
 if((counter%12768)==(y%1911)) { y+=rand()%371; }
 counter++;
 twt->ret=RET_YES;
 return y;
 }




 N aaMathTwisterInt31                  (_twister*twister)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return (N)(aaMathTwisterInt32(twister)>>1);
 }


 D aaMathTwisterReal1                  (_twister*twister)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return aaMathTwisterInt32(twister)*(1.0/4294967295.0);
 }


 D aaMathTwisterReal2                  (_twister*twister)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return aaMathTwisterInt32(twister)*(1.0/4294967296.0);
 }


 D aaMathTwisterReal3                  (_twister*twister)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return (((D)aaMathTwisterInt32(twister))+0.5)*(1.0/4294967296.0);
 }



 D aaMathTwisterRes53                  (_twister*twister)
 {
 H a,b;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 a=aaMathTwisterInt32(twister)>>5;
 b=aaMathTwisterInt32(twister)>>6;
 return(a*67108864.0+b)*(1.0/9007199254740992.0);
 }




 B aaMathAngleToCord                   (D angle,_rect*rect,_cord*cord)
 {
 D a,radius1,radius2;
 D x_tmp,y_tmp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 if(aaRectIsValid(rect)!=YES) { return RET_BADPARM; }
 radius1=rect->w/2.0;
 radius2=rect->h/2.0;
 a=angle*(aaPi/180.0)-(aaPi/2.0);
 x_tmp=cos(a)*radius1;
 y_tmp=sin(a)*radius2;
 if(cord)
  {
  x_tmp=x_tmp+radius1+rect->x;
  y_tmp=y_tmp+radius2+rect->y;
  cord->x=x_tmp;
  cord->y=y_tmp;
  }
 return RET_YES;
 }



/**
   aaRectSet(&r1,200,200,300,300);
   aaSurfaceFill(app.splash.handle,&r1,&col_red[1]);
   aaRectExpand(&r1,-10,-10);
   aaRectCordCenterGet(&r1,&c1);

   gettimeofday(&tv,0);
   t=localtime(&tv.tv_sec);

   s=t->tm_hour%12;
   aaRectExpand(&r1,-30,-30);
   aaMathAngleToCord((D)s*30.0,&r1,&c2);
   aaSurfaceArrow(app.splash.handle,&c2,&c1,0,5,20,45,&col_cyan[20],&col_green[30]);
   aaRectExpand(&r1,+30,+30);

   s=t->tm_min;
   aaRectExpand(&r1,-5,-5);
   aaMathAngleToCord((D)s*6.0,&r1,&c2);
   aaSurfaceArrow(app.splash.handle,&c2,&c1,0,5,20,45,&col_red[30],&col_yellow[30]);
   aaRectExpand(&r1,+5,+5);

   s=t->tm_sec;
   aaRectExpand(&r1,-10,-10);
   aaMathAngleToCord((D)s*6.0,&r1,&c2);
   aaSurfaceArrow(app.splash.handle,&c2,&c1,0,2,20,45,&col_red[30],&col_red[25]);
   aaRectExpand(&r1,+10,+10);

   s=(aa_msrunning%1000);
   aaRectExpand(&r1,-15,-15);
   aaMathAngleToCord((D)s*0.36,&r1,&c2);
   aaSurfaceArrow(app.splash.handle,&c2,&c1,0,1,20,45,&col_blue[30],&col_purple[30]);
   aaRectExpand(&r1,+15,+15);

   aaSurfaceUpdateAreaAdd(app.splash.handle,0,0);
   aaSurfaceStatus(app.splash.handle,&app.splash.status);
*/

 B aaMathCirclesToVectorCords          (_rect*srect,_rect*trect,_cord*cord1,_cord*cord2)
 {
 D ahl,nrw,nrh;
 D sangle,tangle;
 D x1,y1,x2,y2;
 D sx,sy,tx,ty;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(srect==NULL) { return RET_MISSINGPARM; }
 if(trect==NULL) { return RET_MISSINGPARM; }
 if(cord1==NULL) { return RET_MISSINGPARM; }
 if(cord2==NULL) { return RET_MISSINGPARM; }
 ahl=0;//15;
 nrw=srect->w/2;
 nrh=srect->h/2;
 //nrw+=10; nrh+=10;
 x1=srect->x;
 y1=srect->y;
 x2=trect->x;
 y2=trect->y;
 sangle=atan2(y2-y1,x2-x1);
 sx=x2-cos(sangle)*(nrw+ahl);
 sy=y2-sin(sangle)*(nrh+ahl);
 sx+=nrw;
 sy+=nrh;
 ahl=0;
 nrw=trect->w/2;
 nrh=trect->h/2;
 //nrw+=10; nrh+=10;

 x1=trect->x;
 y1=trect->y;
 x2=srect->x;
 y2=srect->y;
 tangle=atan2(y2-y1,x2-x1);
 tx=x2-cos(tangle)*(nrw+ahl);
 ty=y2-sin(tangle)*(nrh+ahl);
 tx+=nrw;
 ty+=nrh;
 aaCordSet(cord2,(N)sx,(N)sy);
 aaCordSet(cord1,(N)tx,(N)ty);
 return RET_YES;
 }





 B aaMathLog2                          (Y val,YP res)
 {
 Y ans;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(res==NULL) { return RET_BADPARM; }
 ans=0;
 while(val>>=1) ans++;
 *res=ans;
 return RET_YES;
 }


 B aaMathLog2D                         (D val,DP res)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(res==NULL) { return RET_BADPARM; }
 *res=log(val)/log(2.0);
 return RET_YES;
 }



 B aaMathIsPowerOfTwo                  (Q val)
 {
 Q res;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 res=((val!=0LL)&&((val&(~val+1LL))==val));
 if(res) { return RET_YES; }
 return RET_NO;
 }




 B aaMathMulDiv                        (Z numa,Z numb,Z numc,ZP result)
 {
 G res;
 G halfnumc;
 G multiplied;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(result)  { *result=-1; }
 if(numc==0) { return RET_BOUNDS;  }
 if(numc<0)  { numa=aaNumNeg(numa); numc=aaNumNeg(numc);  }
 halfnumc=(G)(numc/2);
 multiplied=(G)(numa*numb);
 if(((numa<0)&&(numb<0))||((numa>=0)&&(numb>=0))) { res=(multiplied+halfnumc);  }
 else                                             { res=(multiplied-halfnumc); }
 res=res/numc;
 if((res>INT_MAX)||(res<-INT_MAX)) { res=-1; }
 if(result) { *result=(Z)res; }
 return RET_YES;
 }





 B aaMathLineToCords                   (_cord*c1,_cord*c2,HP cordcount,H maxcords,_cord*cords)
 {
 _cord df;
 N numpixels,i,x,y;
 N d,dinc1,dinc2;
 N xinc1,xinc2;
 N yinc1,yinc2;
 H cc;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(c1==NULL)  { return RET_BADPARM; }
 if(c2==NULL)  { return RET_BADPARM; }
 if(cordcount) { *cordcount=0; }
 if(maxcords>0&&cords==NULL) { return RET_MISSINGPARM; }
 aaCordSubtract(c1,c2,&df);
 df.x=aaNumAbs(df.x);
 df.y=aaNumAbs(df.y);

 if(df.x==0&&df.y==0)
  {
  if(cordcount) { *cordcount=1; }
  if(cords!=NULL&&maxcords>0) { cords[0].x=c1->x; cords[0].y=c1->y; }
  return RET_YES;
  }
 if(df.x>=df.y)
  {
  numpixels=df.x;
  d=2*df.y-df.x;
  dinc1=df.y*2;
  dinc2=(df.y-df.x)*2;
  xinc1=xinc2=yinc2=1;
  yinc1=0;
  }
 else
  {
  numpixels=df.y;
  d=2*df.x-df.y;
  dinc1=df.x*2;
  dinc2=(df.x-df.y)*2;
  xinc1=0;
  xinc2=yinc1=yinc2=1;
  }
 numpixels++;
 if(c1->x>c2->x)  {  xinc1=-xinc1;  xinc2=-xinc2;  }
 if(c1->y>c2->y)  {  yinc1=-yinc1;  yinc2=-yinc2;  }
 x=c1->x;
 y=c1->y;
 cc=0;
 for(i=0;i<numpixels;i++)
  {
  if(cords!=NULL&&maxcords>cc)
   {
   cords[cc].x=x;
   cords[cc].y=y;
   }
  cc++;
  if(d<0)   {   d+=dinc1;   x+=xinc1;   y+=yinc1;   }
  else      {   d+=dinc2;   x+=xinc2;   y+=yinc2;   }
  }
 if(cordcount) { *cordcount=cc; }
 return RET_YES;
 }




 B aaMathMidPoint                      (_cord*cord1,_cord*cord2,_cord*midcord)
 {
 _cord c3;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(cord1==NULL) { return RET_MISSINGPARM; }
 if(cord2==NULL) { return RET_MISSINGPARM; }
 if(midcord==NULL) { return RET_MISSINGPARM; }
 c3.x=aaNumAbs((cord1->x-cord2->x)/2);
 c3.y=aaNumAbs((cord1->y-cord2->y)/2);
 if(cord1->x<=cord2->x) { c3.x+=cord1->x; } else { c3.x+=cord2->x; }
 if(cord1->y<=cord2->y) { c3.y+=cord1->y; } else { c3.y+=cord2->y; }
 aaCordSet(midcord,c3.x,c3.y);
 return RET_YES;
 }







/*-----------------------------------------------------------------------*/


 B aaDynbufCreate                      (HP handle)
 {
 B ret;
 _aa_dynbufobject*dynp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCreate(aa.dynbuf_system.object_id,handle,(VP)&dynp))!=RET_YES) { oops; return ret; }
 dynp->self_handle=*handle;
 return RET_YES;
 }




 B aaDynbufDestroy                     (H handle)
 {
 B ret;
 _aa_dynbufobject*dynp;
 B isprot;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.dynbuf_system.object_id,handle,(VP)&dynp,&isprot))!=RET_YES) { return ret; }
 if(isprot==YES) { return RET_FORBIDDEN; }
 if(dynp->status.bytes_allocated!=0)
  {
  if((ret=aa_MemoryProtect(dynp->status.mem,NO))!=YES) { oops; }
  if((ret=aa_MemoryRelease(dynp->status.mem))!=YES) { oops; }
  }
 if((ret=aa_ObjectDestroy(aa.dynbuf_system.object_id,handle))!=YES) {oops; }
 return RET_YES;
 }





 B aaDynbufStatus                      (H handle,_dynbufstatus*dynbufstatus)
 {
 B ret;
 _aa_dynbufobject*dynp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.dynbuf_system.object_id,handle,(VP)&dynp,NULL))!=RET_YES) { return ret; }
 if(dynbufstatus!=NULL) { aaMemoryCopy(dynbufstatus,sizeof(_dynbufstatus),&dynp->status); }
 return RET_YES;
 }





 B aaDynbufReset                       (H handle)
 {
 B ret;
 _aa_dynbufobject*dynp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.dynbuf_system.object_id,handle,(VP)&dynp,NULL))!=RET_YES) { return ret; }
 if(dynp->status.bytes_allocated>0)   {   dynp->status.mem[0]=NULL_CHAR;  }
 dynp->status.bytes_used=0;
 dynp->status.bytes_left=dynp->status.bytes_allocated-dynp->status.bytes_used;
 dynp->read_bit_pos=0;
 dynp->write_bit_pos=0;
 dynp->status.bits_used=0;
 return RET_YES;
 }




 B aaDynbufSeek                        (H handle,H offset)
 {
 B ret;
 _aa_dynbufobject*dynp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.dynbuf_system.object_id,handle,(VP)&dynp,NULL))!=RET_YES) { return ret; }
 if(offset==0xffffffff) { offset=dynp->status.bytes_used; }
 if((offset+_1K)>=dynp->status.bytes_allocated)
  {
  if((ret=aa_DynbufSystemExtend((VP)&dynp,((offset+_4K)-dynp->status.bytes_allocated)))!=YES) { oops; }
  }
 dynp->status.bytes_used=(offset+1);
 dynp->status.bytes_left=dynp->status.bytes_allocated-dynp->status.bytes_used;
 return RET_YES;
 }




 B aaDynbufAppendByte                  (H handle,B val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaDynbufAppend(handle,1,&val));
 }

 B aaDynbufAppendWord                  (H handle,W val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaDynbufAppend(handle,2,&val));
 }

 B aaDynbufAppendDword                 (H handle,H val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaDynbufAppend(handle,4,&val));
 }



 B aaDynbufAppend                      (H handle,H bytes,VP data)
 {
 B ret;
 _aa_dynbufobject*dynp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.dynbuf_system.object_id,handle,(VP)&dynp,NULL))!=RET_YES) { return ret; }
 if(bytes==0) { return RET_YES; }
 if((bytes+_1K)>=dynp->status.bytes_left)
  {
  if((ret=aa_DynbufSystemExtend((VP)&dynp,bytes+_4K+(dynp->status.bytes_allocated/10)))!=YES) {oops; }
  }
 aaMemoryCopy(&dynp->status.mem[dynp->status.bytes_used],bytes,data);
 dynp->status.bytes_used+=bytes;
 dynp->status.bytes_left=dynp->status.bytes_allocated-dynp->status.bytes_used;
 dynp->status.mem[dynp->status.bytes_used]=NULL_CHAR;
 return RET_YES;
 }





 B aaDynbufAppendf                     (H handle,VP fmt,...)
 {
 B ret;
 _aa_dynbufobject*dynp;
 va_list argptr;
 BP tmp=NULL_POINTR;
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aa.is_ready==YES)
  {
  if((ret=aa_MemoryTemp((VP)&tmp,_128K,aa_MEMORYTEMP_DynAppendf))!=RET_YES) { return ret; }
  }
 else oof;
 aaFmt(fmt,argptr,tmp);
 if((ret=aa_ObjectCheck(aa.dynbuf_system.object_id,handle,(VP)&dynp,NULL))!=RET_YES) { return ret; }
 aaStringLen(tmp,&sl);
 return(aaDynbufAppend(handle,sl,tmp));
 }



 B aaDynbufAppendBits                  (H handle,H bits,N data,B issigned)
 {
 B ret;
 _aa_dynbufobject*dynp;
 H bpos;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.dynbuf_system.object_id,handle,(VP)&dynp,NULL))!=RET_YES) { return ret; }
 if(issigned)
  {
  if(data<0) {   data=(1<<bits)+data; }
  }
 bpos=dynp->write_bit_pos;
 if(dynp->status.bytes_left<_1K)
  {
  if((ret=aa_DynbufSystemExtend((VP)&dynp,_4K+(dynp->status.bytes_allocated/16)))!=YES) {oops; }
  }
 while(bits>0)
  {
  if(bits+bpos>=8)
   {
   dynp->status.mem[dynp->status.bytes_used]+=(B)((data>>(bits+bpos-8))&F8);
   bits-=8-bpos;
   ++dynp->status.bytes_used;
   --dynp->status.bytes_left;
   dynp->status.bits_used+=(8-bpos);
   dynp->status.mem[dynp->status.bytes_used]=0;
   bpos=0;
   }
  else
   {
   dynp->status.mem[dynp->status.bytes_used]+=(B)((data<<(8-bits-bpos))&F8);
   dynp->status.bits_used+=bits;
   bpos+=bits;
   bits=0;
   }
  }
 dynp->write_bit_pos=bpos;
 dynp->status.bytes_used=dynp->status.bits_used/8;
 if(dynp->write_bit_pos!=0) { dynp->status.bytes_used++; }
 dynp->status.bytes_left=dynp->status.bytes_allocated-dynp->status.bytes_used;
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/



 B aaQueCreate                         (HP handle)
 {
 B ret;
 _aa_queobject*quep;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aa_last_line_executed=__LINE__;
 if((ret=aa_ObjectCreate(aa.que_system.object_id,handle,(VP)&quep))!=RET_YES) { oops; return ret; }
 aa_last_line_executed=__LINE__;
 if(aa_QueSystemExtendPageSlots((VP)&quep,128)!=RET_YES)
  {
  aa_last_line_executed=__LINE__;
  aaQueDestroy(*handle);
  *handle=0;
  return RET_FAILED;
  }
 aa_last_line_executed=__LINE__;
 quep->self_handle=*handle;
 //aaLog(-555,"Que Created: handle=%lu",*handle);
 return RET_YES;
 }






 B aaQueDestroy                        (H handle)
 {
 B ret;
 _aa_queobject*quep;
 B isprot;
 H p;
 H release_count;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.que_system.object_id,handle,(VP)&quep,&isprot))!=RET_YES) { return ret; }
 if(isprot==YES) { return RET_FORBIDDEN; }
 release_count=0;
 for(p=0;p<quep->slots_allocated;p++)
  {
  if(quep->pages_allocated==0)  { break; }
  if(quep->pge_slot[p]!=0)
   {
   aa_PageRelease(quep->pge_slot[p]);
   quep->pge_slot[p]=0;
   quep->pages_allocated--;
   release_count++;
   }
  }
 if(quep->pages_allocated!=0)
  {
  aaLog(-1,"Pge leak: pages allocated = %i slots allocated = %i releasecount=%i",quep->pages_allocated,quep->slots_allocated,release_count);
  Boop;
  }
 if(quep->slots_allocated!=0)
  {
  if((ret=aa_MemoryRelease(quep->pge_slot))!=YES) { oops; }
  quep->slots_allocated=0;
  quep->pge_slot=NULL;
  }
 aa_ObjectDestroy(aa.que_system.object_id,handle);
 return RET_YES;
 }





 B aaQueStatus                         (H handle,_questatus*questatus)
 {
 B ret;
 _aa_queobject*quep;
 H mx;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.que_system.object_id,handle,(VP)&quep,NULL))!=RET_YES) { return ret; }
 if(questatus)
  {
  mx=sizeof(_questatus);
  if(mx==4) {  questatus->bytes=quep->status.bytes;   }
  else      {  aaMemoryCopy(questatus,sizeof(_questatus),&quep->status);   }
  }
 return RET_YES;
 }





 B aaQueWrite                          (H handle,H bytes,VP data)
 {
 B ret;
 _aa_queobject*quep;
 H pages_required;
 H pages_available;
 H bytes_available;
 H extra_bytes_required;
 H extra_pages_required;
 H p;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.que_system.object_id,handle,(VP)&quep,NULL))!=RET_YES) { return ret; }
 if(bytes==0) { return RET_YES; }
 if(data==NULL) { return RET_BADPARM; }

 bytes_available=(quep->pages_allocated*aa.page_system.bytes_per_page)-quep->head;
 pages_required=bytes/aa.page_system.bytes_per_page;
 if((bytes%aa.page_system.bytes_per_page)!=0) pages_required++;
 pages_available=quep->slots_allocated-quep->pages_allocated;
 if(pages_available<=(pages_required+2))
  {
  if((ret=aa_QueSystemExtendPageSlots((VP)&quep,pages_required+8))!=RET_YES) { oops; }
  bytes_available=(quep->pages_allocated*aa.page_system.bytes_per_page)-quep->head;
  pages_required=bytes/aa.page_system.bytes_per_page;
  if((bytes%aa.page_system.bytes_per_page)!=0) pages_required++;
  pages_available=quep->slots_allocated-quep->pages_allocated;
  if(pages_available<=(pages_required+2)) { oof; }
  }
 if(bytes_available>=bytes)
  {
  if((ret=aa_PageArrayIo(quep->pge_slot,quep->pages_allocated,quep->head,bytes,data,YES))!=RET_YES) { oof; Boop; }
  quep->status.bytes+=bytes;
  quep->head+=bytes;
  quep->status.total_bytes_written+=(Q)bytes;
  return RET_YES;
  }

 extra_bytes_required=bytes-bytes_available;
 extra_pages_required=extra_bytes_required/aa.page_system.bytes_per_page;
 if((extra_bytes_required%aa.page_system.bytes_per_page)!=0) { extra_pages_required++; }

 if(extra_pages_required)
  {
  logg("Que handle %i, requires %i more pages",handle,extra_pages_required);
  }
 for(p=0;p<extra_pages_required;p++)
  {
  if((ret=aa_PageAllocate(&quep->pge_slot[quep->pages_allocated+p],0,"QuePage"))!=RET_YES) { oops; }
  }
 quep->pages_allocated+=extra_pages_required;
 if(extra_pages_required)
  {
  logg("Que handle %i, addiotional page allocation success",handle);
  }
 bytes_available=(quep->pages_allocated*aa.page_system.bytes_per_page)-quep->head;
 if(bytes_available<bytes) { oof; Boop; }
 if((ret=aa_PageArrayIo(quep->pge_slot,quep->pages_allocated,quep->head,bytes,data,YES))!=RET_YES)
  {
  oops;
  aaNote(0,"pages_allocated=%i head=%i bytes=%i bavail=%i",quep->pages_allocated,quep->head,bytes,bytes_available);
  }
 if(extra_pages_required)
  {
  logg("Que handle %i, has completed the pageIO",handle);
  }
 quep->status.bytes+=bytes;
 quep->head+=bytes;
 quep->status.total_bytes_written+=(Q)bytes;
 return RET_YES;
 }






 B aaQueWritef                         (H handle,VP fmt,...)
 {
 va_list argptr;
 B txt[_8K];
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,txt);
 aaStringLen(txt,&sl);
 if(sl==0) { return RET_YES; }
 return(aaQueWrite(handle,sl,txt));
 }

 B aaQueWriteByte                      (H handle,B val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaQueWrite(handle,1,&val));
 }


 B aaQueWriteWord                      (H handle,W val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaQueWrite(handle,2,&val));
 }

 B aaQueWriteDword                     (H handle,H val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaQueWrite(handle,4,&val));
 }

 B aaQueWriteQuad                      (H handle,Q val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaQueWrite(handle,8,&val));
 }


 B aaQueRead                           (H handle,H bytes,VP data)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaQuePeek(handle,0,bytes,data))!=RET_YES) {  return ret; }
 if((ret=aaQueDiscard(handle,bytes))!=RET_YES) { return ret; }
 return RET_YES;
 }


 B aaQueReadByte                       (H handle,BP val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaQueRead(handle,1,val));
 }


 B aaQueReadWord                       (H handle,WP val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaQueRead(handle,2,val));
 }

 B aaQueReadDword                      (H handle,HP val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaQueRead(handle,4,val));
 }

 B aaQueReadQuad                       (H handle,QP val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaQueRead(handle,8,val));
 }



 B aaQuePeek                           (H handle,H offset,H bytes,VP data)
 {
 B ret;
 _aa_queobject*quep;
 H avail;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.que_system.object_id,handle,(VP)&quep,NULL))!=RET_YES) { return ret; }
 if(bytes==0) { return RET_YES; }
 if(data==NULL) { return RET_BADPARM; }
 if(bytes>quep->status.bytes) { return RET_BOUNDS; }
 if(offset>=quep->status.bytes) { return RET_BOUNDS; }
 avail=quep->status.bytes-offset;
 if(bytes>avail) { return RET_BOUNDS; }
 if((ret=aa_PageArrayIo(quep->pge_slot,quep->pages_allocated,quep->tail+offset,bytes,data,NO))!=RET_YES)
  {
  aaNote(0,"PLEASE TAKE A SCREEN SHOT OF THIS MESSAGE\n\nLINE=%i\n\nRET = %s\nquep->pages_allocated=%i\nquep->tail=%i,quep->head=%i\noffset=%i,bytes=%i\nquep->status.bytes=%i",__LINE__,ret_string[ret],quep->pages_allocated,quep->tail,quep->head,offset,bytes,quep->status.bytes);
  return ret;
  }
 return RET_YES;
 }


 B aaQuePeekByte                       (H handle,H offset,BP val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaQuePeek(handle,offset,1,val));
 }

 B aaQuePeekWord                       (H handle,H offset,WP val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaQuePeek(handle,offset,2,val));
 }

 B aaQuePeekDword                      (H handle,H offset,HP val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaQuePeek(handle,offset,4,val));
 }

 B aaQuePeekQuad                       (H handle,H offset,QP val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaQuePeek(handle,offset,8,val));
 }



 B aaQueFindByte                       (H handle,H offset,H bytes,HP pos,B val,B logic,H number)
 {
 B ret;
 _aa_queobject*quep;
 BP tmp;
 H cando,have,todo,i,c;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.que_system.object_id,handle,(VP)&quep,NULL))!=RET_YES) { return ret; }
 if((ret=aa_MemoryTemp((VP)&tmp,_4K+quep->status.bytes,aa_MEMORYTEMP_QueFind))!=RET_YES) { oops; return ret; }
 if(pos) { *pos=0xffffffff; }
 have=quep->status.bytes;
 if(offset>=have) { return RET_BOUNDS; }
 cando=have-offset;
 if(cando==0) { return RET_BOUNDS; }
 if(bytes==0xffffffff) { bytes=cando; }
 if(bytes>cando) { return RET_BOUNDS; }
 todo=bytes;
 if(todo==0) { return RET_NOTFOUND; }
 if((ret=aaQuePeek(handle,offset,todo,tmp))!=RET_YES) { oops; return ret; }
 c=0;
 for(i=0;i<todo;i++)
  {
  if(tmp[i]==val&&logic==YES)
   {
   if(number==c)
    {
    if(pos) { *pos=i; }
    return RET_YES;
    }
   c++;
   continue;
   }
  if(tmp[i]!=val&&logic!=YES)
   {
   if(number==c)
    {
    if(pos) { *pos=i; }
    return RET_YES;
    }
   c++;
   continue;
   }
  }
 return RET_NOTFOUND;
 }




 B aaQueDiscard                        (H handle,H bytes)
 {
 B ret;
 _aa_queobject*quep;
 H avail,todo;
 H t_page,t_offset;
 H bytes_to_next;
 H slot_index;
 H z;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.que_system.object_id,handle,(VP)&quep,NULL))!=RET_YES) { return ret; }
 if(bytes==0) { return RET_YES; }
 avail=quep->status.bytes;
 if(bytes==0xffffffff) { bytes=avail; }
 if(bytes>avail) { return RET_BOUNDS; }
 while(bytes)
  {
  todo=bytes;
  t_page=quep->tail/aa.page_system.bytes_per_page;
  t_offset=quep->tail%aa.page_system.bytes_per_page;
  bytes_to_next=aa.page_system.bytes_per_page-t_offset;
  todo=aaNumRoof(todo,bytes_to_next);
  quep->tail+=todo;
  quep->status.bytes-=todo;
  quep->status.total_bytes_read+=(Q)todo;
  slot_index=quep->tail/aa.page_system.bytes_per_page;
  if(slot_index==t_page&&((bytes-todo)!=0)) { oof;  Boop; }
  if(slot_index>t_page)
   {
   if((slot_index-t_page)>1)
    {
    aaNote(0,"slot_ndx=%i, t_page=%i delta=%i",slot_index,t_page,slot_index-t_page);
    logg("aaa");
    Boop;
    }
   if(quep->slots_allocated==0)
    {
    aaNote(0,"slots_alocatd=0");
    logg("ggg");
    Boop;
    }
   if(quep->pages_allocated==0)
    {
    aaNote(0,"pges_alocatd=0");
    logg("seg");
    Boop;
    }
   if(t_page!=0)
    {
    logg("tp=%i",t_page);
    }
   if((ret=aa_PageRelease(quep->pge_slot[t_page]))!=RET_YES)
    {
    logg("rl=%i",ret);
    }
   if(quep->slots_allocated>1)
    {
    for(z=0;z<(quep->slots_allocated-1);z++) {   quep->pge_slot[z]=quep->pge_slot[z+1]; }
    }
   quep->pages_allocated--;
   quep->pge_slot[quep->pages_allocated]=0;
   quep->tail-=aa.page_system.bytes_per_page;
   quep->head-=aa.page_system.bytes_per_page;
   }
  bytes-=todo;
  }
 if(quep->status.bytes==0)
  {
  quep->tail=quep->head=0;
  }
 quep->crlf_state=0;
 return RET_YES;
 }



 B aaQueStringLen                      (H handle,HP chars,BP stringmode)
 {
 B ret;
 _aa_queobject*quep;
 H i,cando;
 H atatime;
 B block[_4K];
 C ch;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.que_system.object_id,handle,(VP)&quep,NULL))!=RET_YES) {return ret; }
 if(chars==NULL)  {  return RET_BADPARM;  }
 *chars=0;
 if(stringmode) { *stringmode=0; }
 if((ret=aaQueStatus(handle,0))!=RET_YES) {  return ret; }
 atatime=_1K;
 switch(quep->crlf_state)
  {
  case 0:
  quep->line_chars=0;
  quep->line_peek_offset=0;
  quep->crlf_state=1;
  case 1:
  case 2:
  if((cando=aaNumRoof((quep->status.bytes-quep->line_peek_offset),atatime))!=0)
   {
   if((ret=aaQuePeek(handle,quep->line_peek_offset,cando,block))!=RET_YES) { oops; }
   for(i=0;i<cando;i++)
    {
    ch=block[i];
    quep->line_peek_offset++;
    quep->line_chars++;
    if(ch==CR_CHAR)
     {
     if(quep->crlf_state!=1) { quep->crlf_state=4; break; }
     quep->crlf_state=2;
     break;
     }
    if(ch==LF_CHAR)
     {
     if(quep->crlf_state==1) { quep->crlf_state=5; }
     else
     if(quep->crlf_state==2) { quep->crlf_state=6; }
     break;
     }
    if(quep->crlf_state==2)
     {
     quep->line_chars--;
     quep->line_peek_offset--;
     quep->crlf_state=4;
     break;
     }
    quep->crlf_state=1;
    }
   }
  break;

  default:
  break;
  }
 if(quep->crlf_state>=4)
  {
  if(stringmode) {  *stringmode=(B)(quep->crlf_state-3); }
  *chars=quep->line_chars;
  return RET_YES;
  }
 return RET_NOTREADY;
 }



 B aaQueStringRead                     (H handle,HP chars,BP stringmode,H maxchars,VP buf)
 {
 B ret;
 H ch,len;
 B mo;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(buf) { aaStringNull(buf); }
 if(stringmode) { *stringmode=0; }
 if(chars==NULL) { return RET_BADPARM; }
 *chars=0;
 if(maxchars==0) { return RET_BADPARM; }
 if(buf==NULL) { return RET_BADPARM; }
 aaStringNull(buf);
 ret=aaQueStringLen(handle,&len,&mo);
 if(stringmode) { *stringmode=mo; }
 if(chars) { *chars=len; }
 if(ret!=RET_NOTREADY&&ret!=RET_YES) { return ret; }
 if(ret==RET_YES)
  {
  ch=len;
  if(mo==aa_STRINGMODE_LF||mo==aa_STRINGMODE_CR) { ch=len-1; }  else
  if(mo==aa_STRINGMODE_CRLF)                     { ch=len-2; }  else { oof; }
  *chars=ch;
  if(ch>maxchars) {  return RET_BOUNDS; }
  if((ret=aaQueRead(handle,len,buf))!=RET_YES) { oops; }
  aaCast(bp,BP,buf);
  bp[ch]=NULL_CHAR;
  return RET_YES;
  }
 return RET_NOTREADY;
 }





 B aaQueReturn                         (H handle,H bytes)
 {
 B ret;
 _aa_queobject*quep;
 B block[_4K];
 H todo;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.que_system.object_id,handle,(VP)&quep,NULL))!=RET_YES) { return ret; }
 if(bytes>quep->status.bytes) { return RET_BOUNDS; }
 if(bytes==quep->status.bytes) { return RET_YES; }
 while(1)
  {
  if(bytes==0) { break; }
  todo=aaNumRoof(bytes,_4K);
  if((ret=aaQueRead(handle,todo,block))!=RET_YES) { oops; }
  if((ret=aaQueWrite(handle,todo,block))!=RET_YES) { oops; }
  bytes-=todo;
  }
 return RET_YES;
 }



 B aaQueTrim                           (H handle,H bytes)
 {
 B ret;
 _aa_queobject*quep;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.que_system.object_id,handle,(VP)&quep,NULL))!=RET_YES) { return ret; }
 if(bytes==0) { return RET_YES; }
 if(bytes==0xffffffff||bytes==quep->status.bytes)
  {
  if(quep->status.bytes==0) { return RET_YES; }
  if((ret=aaQueDiscard(handle,0xffffffff))!=RET_YES) { return ret; }
  }
 if(bytes>quep->status.bytes) { return RET_BOUNDS; }
 quep->head-=bytes;
 quep->status.bytes-=bytes;
 return RET_YES;
 }





 B aaQueStrap                          (H handle,H bytes,VP data)
 {
 B ret;
 BP tmp;
 BP bp;
 H have;
 _aa_queobject*quep;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.que_system.object_id,handle,(VP)&quep,NULL))!=RET_YES) { return ret; }
 if(bytes==0) { return RET_YES; }
 if(data==NULL) { return RET_BADPARM; }
 aaQueStatus(handle,0);
 have=quep->status.bytes;
 if((ret=aa_MemoryTemp((VP)&tmp,have+_8K,aa_MEMORYTEMP_QueStrap))!=RET_YES) { oops; return ret; }
 bp=(BP)tmp;
 if(have)  {  aaQueRead(handle,have,bp);     }
 if(bytes) {  aaQueWrite(handle,bytes,data); }
 if(have)  {  aaQueWrite(handle,have,bp);    }
 aaQueStatus(handle,0);
 return RET_YES;
 }



 B aaQueStrapf                         (H handle,VP fmt,...)
 {
 va_list argptr;
 B txt[_8K];
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,txt);
 aaStringLen(txt,&sl);
 if(sl==0) { return RET_YES; }
 return(aaQueStrap(handle,sl,txt));
 }

/*-----------------------------------------------------------------------*/


 B aaHuffNew                           (_aahuff*aahuff)
 {
 B ret;
 H bytes;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aahuff==NULL) { return RET_BADPARM; }
 aaMemoryFill(aahuff,sizeof(_aahuff),0);
 aahuff->magic=(H)(PP)aaHuffNew;
 aahuff->is_initialized=YES;
 bytes=aa_HUFF_HEAP_SIZE;
 if(bytes<_64K) { bytes=_64K; }
 if((ret=aaMemoryUnitAllocate(&aahuff->heap_buf,bytes))!=YES) oops;
 return RET_YES;
 }




 B aaHuffDelete                        (_aahuff*aahuff)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aahuff==NULL) { return RET_BADPARM; }
 if(aahuff->magic!=(H)(PP)aaHuffNew) { return RET_NOTINITIALIZED; }
 if(aahuff->is_initialized!=YES)  { return RET_NOTINITIALIZED; }
 if(aahuff->heap_buf.bytes) aaMemoryUnitRelease(&aahuff->heap_buf);
 aaMemoryFill(aahuff,sizeof(_aahuff),0);
 return RET_YES;
 }




 B aaHuffEncode                        (_aahuff*aahuff,H ibytes,VP ibuf,HP obytes,H obufmax,VP obuf)
 {
 H rr;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aahuff==NULL) { return RET_BADPARM; }
 if(aahuff->magic!=(H)(PP)aaHuffNew) { return RET_NOTINITIALIZED; }
 if(aahuff->is_initialized!=YES)  { return RET_NOTINITIALIZED; }
 if(obytes==NULL) { return RET_BADPARM; }
 *obytes=0;
 if(ibuf==NULL) { return RET_BADPARM; }
 if(obuf==NULL) { return RET_BADPARM; }
 if(ibytes==0) { aaStringLen(ibuf,&ibytes); }
 rr=aa_huffmanCompress(ibuf,ibytes,obuf,obufmax,aahuff->heap_buf.mem);
 if(rr==(0xffffffff-1)) { return RET_BOUNDS; }
 if(rr==0xffffffff) { return RET_FAILED; }
 *obytes=rr;
 return RET_YES;
 }




 B aaHuffDecode                        (_aahuff*aahuff,H ibytes,VP ibuf,HP obytes,H obufmax,VP obuf)
 {
 H rr;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aahuff==NULL) { return RET_BADPARM; }
 if(aahuff->magic!=(H)(PP)aaHuffNew) { return RET_NOTINITIALIZED; }
 if(aahuff->is_initialized!=YES)  { return RET_NOTINITIALIZED; }
 if(obytes==NULL) { return RET_BADPARM; }
 *obytes=0;
 if(ibuf==NULL) { return RET_BADPARM; }
 if(obuf==NULL) { return RET_BADPARM; }
 rr=aa_huffmanDecompress(ibuf,ibytes,obuf,obufmax,aahuff->heap_buf.mem,aahuff->heap_buf.bytes);
 if(rr==(0xffffffff-1)) { return RET_BOUNDS; }
 if(rr==0xffffffff) { return RET_FAILED; }
 *obytes=rr;
 return RET_YES;
 }


/*-----------------------------------------------------------------------*/


 B aaLz4Encode                         (VP source,H sbytes,VP dest,HP dbytes)
 {
 Z r;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(sbytes<(Z)aa_LZ4_64KLIMIT)
  {
  r=aa_LZ4_compress64kCtx(NULL,source,dest,sbytes,aa_LZ4_compressBound(sbytes));
  }
 else
  {
  r=aa_LZ4_compressCtx(NULL,source,dest,sbytes,aa_LZ4_compressBound(sbytes));
  }
 if(r<0) { return RET_FAILED; }
 if(dbytes) { *dbytes=r; }
 return RET_YES;
 }





 B aaLz4Decode                         (VP source,H sbytes,VP dest,HP dbytes,H maxdbytes)
 {
 BP ip=(BP)source;
 BP iend=ip+sbytes;
 BP op=(BP)dest;
 BP oend=op+maxdbytes;
 BP cpy,ref;
 BP src,dst;
 Z dec2,length,s,r;
 B token;
 size_t dec[]={0,3,2,3,0,0,0,0};

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 src=(BP)source;
 dst=(BP)dest;
 while(ip<iend)
  {
  token=*ip++;
  if((length=(token>>aa_LZ4_ML_BITS))==aa_LZ4_RUN_MASK) { s=255; while((ip<iend)&&(s==255)) { s=*ip++; length+=s; } }
  cpy=op+length;
  if((cpy>oend-aa_LZ4_COPYLENGTH)||(ip+length>iend-aa_LZ4_COPYLENGTH))
   {
   if(cpy>oend)       {  goto _output_error; }
   if(ip+length>iend) {  goto _output_error; }
   aaMemoryCopy(op,length,ip);
   op+=length; ip+=length;
   if(ip<iend) { goto _output_error; }
   break;
   }
  aa_LZ4_WILDCOPY(ip,op,cpy); ip-=(op-cpy); op=cpy;
  aa_LZ4_READ_LE_16(ref,cpy,ip); ip+=2;
  if(ref<(BP)dst) { goto _output_error; }
  if((length=(token&aa_LZ4_ML_MASK))==aa_LZ4_ML_MASK) { while(ip<iend) { Z s=*ip++; length+=s; if(s==255) continue; break; } }
  if unlikely(op-ref<aa_LZ4_STEPSIZE)
   {
   dec2=0;
   *op++=*ref++; *op++=*ref++; *op++=*ref++; *op++=*ref++;
   ref-=dec[op-ref];
   aa_LZ4_A32(op)=aa_LZ4_A32(ref); op+=aa_LZ4_STEPSIZE-4;
   ref-=dec2;
   }
  else
   {
   aa_LZ4_COPYSTEP(ref,op);
   }
  cpy=op+length-(aa_LZ4_STEPSIZE-4);
  if(cpy>oend-aa_LZ4_COPYLENGTH)
   {
   if(cpy>oend) {  goto _output_error; }
   aa_LZ4_SECURECOPY(ref,op,(oend-aa_LZ4_COPYLENGTH));
   while(op<cpy) *op++=*ref++;
   op=cpy;
   if(op==oend) break;
   continue;
   }
  aa_LZ4_SECURECOPY(ref,op,cpy);
  op=cpy;
  }

 r=(Z)(((BP)op)-dst);
 if(dbytes) { *dbytes=r; }
 return RET_YES;
 _output_error:
 r=(Z)(-(((BP)ip)-src));
 if(dbytes) { *dbytes=r; }
 return RET_FAILED;
 }




/*-----------------------------------------------------------------------*/




 B aaMiniQueInit                       (_minique*minique)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(minique==NULL) { return RET_BADPARM; }
 minique->magic=aa_MINIQUE_MAGIC;
 minique->head=minique->tail=minique->bytes=0;
 minique->left=sizeof(minique->buf)-minique->bytes;
 return RET_YES;
 }




 B aaMiniQueWrite                      (_minique*minique,H bytes,VP data)
 {
 BP bp;
 H off;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(minique==NULL) { return RET_BADPARM; }
 if(minique->magic!=aa_MINIQUE_MAGIC) { oof; return RET_NOTSTARTED; }
 if(bytes==0) { return RET_YES; }
 if(bytes>minique->left) { return RET_BOUNDS; }
 aaCast(bp,BP,data);
 for(off=0;off<bytes;off++)
  {
  minique->buf[minique->head]=bp[off];
  minique->head++;
  minique->head%=sizeof(minique->buf);
  minique->bytes++;
  minique->left--;
  }
 return RET_YES;
 }




 B aaMiniQueRead                       (_minique*minique,H bytes,VP data)
 {
 BP bp;
 H off;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(minique==NULL) { return RET_BADPARM; }
 if(minique->magic!=aa_MINIQUE_MAGIC) {  return RET_NOTSTARTED; }
 if(bytes==0) { return RET_YES; }
 if(bytes>minique->bytes) { return RET_BOUNDS; }
 aaCast(bp,BP,data);
 for(off=0;off<bytes;off++)
  {
  bp[off]=minique->buf[minique->tail];
  minique->tail++;
  minique->tail%=sizeof(minique->buf);
  minique->bytes--;
  minique->left++;
  }
 return RET_YES;
 }




 B aaMiniQuePeek                       (_minique*minique,H offset,H bytes,VP data)
 {
 H off,allow,tt;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(minique==NULL) { return RET_BADPARM; }
 if(minique->magic!=aa_MINIQUE_MAGIC) { aaNote(0,"fl;as %i %i",minique->magic,aa_MINIQUE_MAGIC);    return RET_NOTSTARTED; }
 if(bytes==0) { return RET_YES; }
 if(offset>=minique->bytes) { return RET_BOUNDS; }
 allow=minique->bytes-offset;
 if(bytes==0xffffffff) { bytes=allow; }
 if(bytes>allow) { return RET_BOUNDS; }
 if(bytes==0xffffffff) { bytes=allow; }
 if(bytes>allow) { return RET_BOUNDS; }
 tt=minique->tail+offset;
 tt=tt%sizeof(minique->buf);
 aaCast(bp,BP,data);
 for(off=0;off<bytes;off++)
  {
  bp[off]=minique->buf[tt];
  tt++;
  tt%=sizeof(minique->buf);
  }
 return RET_YES;
 }





 B aaMiniQueDiscard                    (_minique*minique,H bytes)
 {
 H off;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(minique==NULL) { return RET_BADPARM; }
 if(minique->magic!=aa_MINIQUE_MAGIC) { oof; return RET_NOTSTARTED; }
 if(bytes==0) { return RET_YES; }
 if(bytes==0xffffffff) { bytes=minique->bytes; }
 if(bytes>minique->bytes) { return RET_BOUNDS; }
 for(off=0;off<bytes;off++)
  {
  minique->tail++;
  minique->tail%=sizeof(minique->buf);
  minique->bytes--;
  minique->left++;
  }
 return RET_YES;
 }





 B aaMiniQueReturn                     (_minique*minique,H bytes)
 {
 B ret;
 B tmp[_2K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(minique==NULL) { return RET_BADPARM; }
 if(minique->magic!=aa_MINIQUE_MAGIC) { oof; return RET_NOTSTARTED; }
 if(bytes==0) { return RET_YES; }
 if(bytes==0xffffffff) { bytes=minique->bytes; }
 if(bytes>minique->bytes) { return RET_BOUNDS; }
 if((ret=aaMiniQueRead(minique,bytes,tmp))!=RET_YES) { oops; }
 if((ret=aaMiniQueWrite(minique,bytes,tmp))!=RET_YES) { oops; }
 return RET_YES;
 }


/*-----------------------------------------------------------------------*/




 B aaMiniStackNew                      (_ministack*ministack)
 {
 H len;

 #ifdef aa_VERSION
//// aa_ZIAG(__FUNCTION__);
 #endif
 if(ministack==NULL) { return RET_BADPARM; }
 aaMemoryFill(ministack,sizeof(_ministack),0);
 ministack->magic=aa_MINISTACK_MAGIC;
 ministack->bytes=0;
 ministack->height=0;
 len=sizeof(ministack->buf);
 ministack->left=len;
 return RET_YES;
 }



 B aaMiniStackDelete                   (_ministack*ministack)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(ministack==NULL) { return RET_BADPARM; }
 if(ministack->magic!=aa_MINISTACK_MAGIC) { return RET_NOTINITIALIZED; }
 aaMemoryFill(ministack,sizeof(_ministack),0);
 return RET_YES;
 }



 B aaMiniStackPush                     (_ministack*ministack,H bytes,VP data)
 {
 H len;
 BP bp;

 #ifdef aa_VERSION
 ///aa_ZIAG(__FUNCTION__);
 #endif
 if(ministack==NULL) { return RET_BADPARM; }
 if(ministack->magic!=aa_MINISTACK_MAGIC) { return RET_NOTSTARTED; }
 len=sizeof(ministack->buf);
 ministack->left=len-ministack->bytes;
 if((bytes)>ministack->left) {  return RET_BOUNDS; }
 if(data==NULL) { return RET_BADPARM; }
 aaCast(bp,BP,data);
 aaMemoryCopy(&ministack->buf[ministack->bytes],bytes,bp);
 ministack->bytes+=bytes;
 ministack->left-=(bytes);
 ministack->height++;
 return RET_YES;
 }



 B aaMiniStackPushByte                 (_ministack*ministack,B val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaMiniStackPush(ministack,1,&val));
 }


 B aaMiniStackPushWord                 (_ministack*ministack,W val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaMiniStackPush(ministack,2,&val));
 }

 B aaMiniStackPushDword                (_ministack*ministack,H val)
 {
 #ifdef aa_VERSION
// aa_ZIAG(__FUNCTION__);
 #endif
 return(aaMiniStackPush(ministack,4,&val));
 }

 B aaMiniStackPushQuad                 (_ministack*ministack,Q val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaMiniStackPush(ministack,8,&val));
 }


 B aaMiniStackPushStringf              (_ministack*ministack,VP fmt,...)
 {
 B ret;
 va_list argptr;
 B str[_64K+_16K];
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,str);
 aaStringLen(str,&sl);
 if((sl+4+1)>=ministack->left) { return RET_BOUNDS; }
 if((ret=aaMiniStackPush(ministack,sl+1,str))!=RET_YES) { oops; }
 if((ret=aaMiniStackPushDword(ministack,sl+4+1))!=RET_YES) { oops; }
 return RET_YES;
 }



 B aaMiniStackPushMulti                (_ministack*ministack,VP fmt,...)
 {
 B ret;
 va_list ap;
 BP bp;
 H off;
 B ch;
 B var_b;
 W var_w;
 H var_h;
 Q var_q;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(ministack==NULL) { return RET_BADPARM; }
 if(ministack->magic!=aa_MINISTACK_MAGIC) { return RET_NOTSTARTED; }
 if(fmt==NULL) { return RET_BADPARM; }
 aaCast(bp,BP,fmt);
 va_start(ap,fmt);
 off=0;
 while(1)
  {
  ch=bp[off];
  ret=RET_YES;
  if(ch==NULL_CHAR) { break; }
  switch(ch)
   {
   case 'b': case 'B':
   var_b=(B)va_arg(ap,u32);
   ret=aaMiniStackPushByte(ministack,var_b);
   break;
   case 'w': case 'W':
   var_w=(W)va_arg(ap,u32);
   ret=aaMiniStackPushWord(ministack,var_w);
   break;
   case 'h': case 'H':
   var_h=(H)va_arg(ap,u32);
   ret=aaMiniStackPushDword(ministack,var_h);
   break;
   case 'q': case 'Q':
   var_q=(Q)va_arg(ap,u64);
   ret=aaMiniStackPushQuad(ministack,var_q);
   break;
   default:
   ret=RET_BADPARM;
   break;
   }
  if(ret!=RET_YES) { break; }
  off++;
  }
 va_end(ap);
 return ret;
 }




 B aaMiniStackPop                      (_ministack*ministack,H bytes,VP data)
 {
 H off;

 #ifdef aa_VERSION
// aa_ZIAG(__FUNCTION__);
 #endif
 if(ministack==NULL) { return RET_BADPARM; }
 if(ministack->magic!=aa_MINISTACK_MAGIC) { return RET_NOTSTARTED; }
 if(bytes==0) { return RET_YES; }
 if(data==NULL) {  return RET_BADPARM; }
 if(bytes==0xffffffff) { bytes=ministack->bytes; }
 if(bytes>ministack->bytes) {  return RET_BOUNDS; }
 off=ministack->bytes-(bytes);
 aaMemoryCopy(data,bytes,&ministack->buf[off]);
 ministack->bytes-=bytes;
 ministack->left+=bytes;
 ministack->height--;
 return RET_YES;
 }



 B aaMiniStackPopByte                  (_ministack*ministack,BP val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaMiniStackPop(ministack,1,val));
 }


 B aaMiniStackPopWord                  (_ministack*ministack,WP val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaMiniStackPop(ministack,2,val));
 }

 B aaMiniStackPopDword                 (_ministack*ministack,HP val)
 {
 #ifdef aa_VERSION
 //aa_ZIAG(__FUNCTION__);
 #endif
 return(aaMiniStackPop(ministack,4,val));
 }

 B aaMiniStackPopQuad                  (_ministack*ministack,QP val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaMiniStackPop(ministack,8,val));
 }


 B aaMiniStackPopString                (_ministack*ministack,HP chars,H maxchars,VP str)
 {
 B ret;
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(chars)  { *chars=0; }
 if(str) { aaStringNull(str); }
 if(ministack->height<2) { return RET_NOTFOUND; }
 if((ret=aaMiniStackPeekDword(ministack,0,&sl))!=RET_YES) { return ret; }
 if((sl+4+1)>=ministack->left) { return RET_BOUNDS; }
 sl-=4;
 if(sl>ministack->bytes) { return RET_NOTFOUND; }
 if(chars) *chars=sl-1;
 if(str==NULL) { return RET_YES; }
 if((sl-1)>maxchars) { return RET_BOUNDS; }
 if((ret=aaMiniStackDiscard(ministack,4))!=RET_YES) { oops; return ret; }
 if((ret=aaMiniStackPop(ministack,sl,str))!=RET_YES) { oops; return ret; }
 return RET_YES;
 }



 B aaMiniStackPopMulti                 (_ministack*ministack,VP fmt,...)
 {
 B ret;
 va_list ap;
 BP bp;
 H off,sl;
 B ch;
 B var_b;
 W var_w;
 H var_h;
 Q var_q;
 PP var_ptr_b;
 PP var_ptr_w;
 PP var_ptr_h;
 PP var_ptr_q;
 PP var_ptrptr[32];
 Q var_temp[32];
 H argindex,a;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(ministack==NULL) { return RET_BADPARM; }
 if(fmt==NULL) { return RET_BADPARM; }
 aaCast(bp,BP,fmt);
 va_start(ap,fmt);
 aaStringLen(fmt,&sl);
 off=0;
 argindex=0;
 while(1)
  {
  ch=bp[sl-off-1];
  ret=RET_YES;
  if(ch==NULL_CHAR) { break; }
  switch(ch)
   {
   case 'b': case 'B':
   var_ptrptr[argindex]=va_arg(ap,PP);
   if((ret=aaMiniStackPopByte(ministack,&var_b))!=YES) { oops; break; }
   var_temp[argindex++]=(Q)var_b;
   break;
   case 'w': case 'W':
   var_ptrptr[argindex]=va_arg(ap,PP);
   if((ret=aaMiniStackPopWord(ministack,&var_w))!=YES)  { oops; break; }
   var_temp[argindex++]=(Q)var_w;
   break;
   case 'h': case 'H':
   var_ptrptr[argindex]=va_arg(ap,PP);
   if((ret=aaMiniStackPopDword(ministack,&var_h))!=YES) { break; }
   var_temp[argindex++]=(Q)var_h;
   break;
   case 'q': case 'Q':
   var_ptrptr[argindex]=va_arg(ap,PP);
   if((ret=aaMiniStackPopQuad(ministack,&var_q))!=YES) { break; }
   var_temp[argindex++]=(Q)var_q;
   break;
   default:
   ret=RET_BADPARM;
   break;
   }
  if(ret!=RET_YES) { oops; break; }
  off++;
  }
 va_end(ap);
 if(ret==RET_YES)
  {
  for(a=0;a<argindex;a++)
   {
   ch=bp[a];
   switch(ch)
    {
    case 'b': case 'B':
    var_ptr_b=var_ptrptr[a];
    *(BP)var_ptr_b=var_temp[argindex-a-1];
    break;
    case 'w': case 'W':
    var_ptr_w=var_ptrptr[a];
    *(WP)var_ptr_w=(W)var_temp[argindex-a-1];
    break;
    case 'h': case 'H':
    var_ptr_h=var_ptrptr[a];
    *(HP)var_ptr_h=(H)var_temp[argindex-a-1];
    break;
    case 'q': case 'Q':
    var_ptr_q=var_ptrptr[a];
    *(QP)var_ptr_q=(Q)var_temp[argindex-a-1];
    break;
    default:
    ret=RET_BADPARM;
    break;
    }
   }
  }
 return ret;
 }



 B aaMiniStackPeek                     (_ministack*ministack,H offset,H bytes,VP data)
 {
 H off;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(ministack==NULL) { return RET_BADPARM; }
 if(ministack->magic!=aa_MINISTACK_MAGIC) { return RET_NOTSTARTED; }
 if(bytes==0) { return RET_YES; }
 if(bytes==0xffffffff) { bytes=ministack->bytes; }
 if(bytes>ministack->bytes) {  return RET_BOUNDS; }
 if((offset+bytes)>ministack->bytes) {  return RET_BOUNDS; }
 off=ministack->bytes-(offset+bytes);
 if(data)  { aaMemoryCopy(data,bytes,&ministack->buf[off]);   }
 return RET_YES;
 }


 B aaMiniStackPeekByte                 (_ministack*ministack,H offset,BP val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaMiniStackPeek(ministack,offset,1,val));
 }

 B aaMiniStackPeekWord                 (_ministack*ministack,H offset,WP val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaMiniStackPeek(ministack,offset,2,val));
 }
 B aaMiniStackPeekDword                (_ministack*ministack,H offset,HP val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaMiniStackPeek(ministack,offset,4,val));
 }
 B aaMiniStackPeekQuad                 (_ministack*ministack,H offset,QP val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaMiniStackPeek(ministack,offset,8,val));
 }


 B aaMiniStackPeekString               (_ministack*ministack,H index,HP chars,H maxchars,VP str)
 {
 B ret;
 H asl,sl,i,off;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(chars)  { *chars=0; }
 if(str) { aaStringNull(str); }
 if(ministack->height<(N)((index+1)*2)) { return RET_NOTFOUND; }
 off=0;
 asl=0;
 for(i=0;i<(index+1);i++)
  {
  if((ret=aaMiniStackPeekDword(ministack,off,&sl))!=RET_YES) { return ret; }
  asl+=sl;
  if(asl>=ministack->left) { return RET_BOUNDS; }
  if(i>=index) { break; }
  off=asl;
  }
 sl-=4;
 if(sl>ministack->bytes) { return RET_NOTFOUND; }
 if(chars) *chars=sl-1;
 if(str==NULL) { return RET_YES; }
 if((sl-1)>maxchars) { return RET_BOUNDS; }
 if((ret=aaMiniStackPeek(ministack,off+4,sl,str))!=RET_YES) { oops; return ret; }
 return RET_YES;
 }



 B aaMiniStackDiscard                  (_ministack*ministack,H bytes)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(ministack==NULL) { return RET_BADPARM; }
 if(ministack->magic!=aa_MINISTACK_MAGIC) { return RET_NOTSTARTED; }
 if(bytes==0) { return RET_YES; }
 if(bytes==0xffffffff) { bytes=ministack->bytes; }
 if(bytes>ministack->bytes) { return RET_BOUNDS; }
 ministack->bytes-=bytes;
 ministack->left+=bytes;
 ministack->height--;
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/





 B aaNetStatus                         (_netstatus*netstatus)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(netstatus) { aaMemoryCopy(netstatus,sizeof(_netstatus),&aa.net_system.net_status);  }
 return RET_YES;
 }


 B aaNetSnapshotTcpCalls               (_list*list)
 {
 B ret;
 H x;
 H i_calls,i_calls_connected;
 H o_calls,o_calls_connected;
 _netstatus ns;
 //B txt[_1K];
 _tcpcallunit call;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(list==NULL) { return RET_MISSINGPARM; }
 if(list->magic==aaHPP(aaListNew))
  {
  aaListDelete(list);
  }
 if((ret=aaListNew(list,0,_64K,0,0))!=YES) { oops; }
 i_calls=o_calls=0;
 i_calls_connected=o_calls_connected=0;
 if((ret=aaNetStatus(&ns))!=YES) { oops; }
 for(x=0;x<F24;x++)
  {
  if(i_calls>=ns.current_incoming_tcp_call_count&&o_calls>=ns.current_outgoing_tcp_call_count)
   {
   if((i_calls_connected+o_calls_connected)>=ns.current_tcp_calls_connected)   {   break;     }
   }
  if((ret=aaNetTcpCallByIndex(&call.handle,x,&call.status))!=YES) {   continue;   }
  //aaStringCopyf(txt,"%u",call.handle);
  if((ret=aaListAppend(list,NULL,NULL,sizeof(_tcpcallunit),&call))!=RET_YES) { oops; }
  if(call.status.is_incoming)  {  i_calls++; if(call.status.is_connected) { i_calls_connected++; }   }
  else                         {  o_calls++; if(call.status.is_connected) { o_calls_connected++; }   }
  }
 return RET_YES;
 }




 B aaNetLocalIpGet                     (_localip*localip,B getmac,B getbcast)
 {
 B ret;
 H i,cnt,j,k;
 HP iptr;
 _netsubnet net_subnet[32];
 _netinfo ni;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(localip==NULL)  { return RET_BADPARM; }
 aaMemoryFill(localip,sizeof(_localip),0);
 aaCast(iptr,HP,localip->ip);

 if((ret=aa_NetSystemLocalHostGet(iptr,31))!=RET_YES) { oops; }
 cnt=0;
 for(i=0;i<32;i++)  {   if(iptr[i]!=0) { cnt++; }  }
 for(i=0;i<32;i++)   {   if((ret=aaNetIpTypeGet(iptr[i],&localip->type[i]))!=RET_YES) { oops; }   }
 for(i=0;i<32;i++)   {   aaNetIpToString(iptr[i],&localip->dot[i]);   }
 if(getmac)
  {
  for(i=0;i<32;i++)
   {
   if(localip->ip[i]!=0)
    {
    ret=aaNetMacGet(localip->mac[i],localip->ip[i],localip->mac_dot[i]);
    if(ret!=YES)
     {
     localip->mac[i][0]=localip->mac[i][1]=localip->mac[i][2]=
     localip->mac[i][3]=localip->mac[i][4]=localip->mac[i][5]=0;
     aaStringCopyf(localip->mac_dot[i],"%02X:%02X:%02X:%02X:%02X:%02X",0,0,0,0,0,0);
     }
    }
   }
  }
 localip->count=(B)cnt;
 if(getbcast)
  {
  if((ret=aaNetInfoGet(&ni))!=RET_YES) { oops; }
  for(k=0;k<aaElementCount(localip->ip);k++)
   {
   for(i=0;i<ni.adapter_count;i++)
     {
     for(j=0;j<ni.adapter[i].address_count;j++)
      {
      if(ni.adapter[i].address[j].ip==localip->ip[k])
       {
       if(localip->ip[k]!=0)
        {
        aaNetSubnetFromIp(&net_subnet[k],localip->ip[k],ni.adapter[i].address[j].subnet);
        localip->bcast_ip[k]=net_subnet[k].broadcast_ip;
        aaNetIpToString(localip->bcast_ip[k],localip->bcast_dot[k]);
        }
       }
      }
     }
    }
   }
 return RET_YES;
 }






 B aaNetInfoGet                        (_netinfo*netinfo)
 {
 HMODULE mod;
 T DWORD (WINAPI*getAdaptersInfo)(PIP_ADAPTER_INFO,PULONG);
 T DWORD (WINAPI*getNetworkParams)(PFIXED_INFO,PULONG);
 getAdaptersInfo myGetAdaptersInfo;
 getNetworkParams myGetNetworkParams;
 PIP_ADAPTER_INFO adapt_ptr;
 PIP_ADDR_STRING  addr_str_ptr;
 ULONG outbuf_len;
 DWORD err,res,adapter_info_size;
 IP_ADDR_STRING*ip_addr_ptr;
 FIXED_INFO*fixed_info_ptr;
 B fixed_info_buf[_1K+sizeof(FIXED_INFO)];
 B fixed_info_was_allocated;
 B adapter_info_buf[_4K];
 B adapter_info_was_allocated;
 PIP_ADAPTER_INFO adapter_info_ptr;
 B fail,first;
 B txt[_1K];
 B str[_1K];
 H sl,j,dapi,adri;
 _netinfoadapter*nidap_ptr;
 _netinfoadapteraddress*nidapadr_ptr;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(netinfo==NULL) { return RET_BADPARM; }
 aaMemoryFill(netinfo,sizeof(_netinfo),0);
 adapter_info_size=0;
 if((mod=LoadLibrary("Iphlpapi.dll"))==NULL) { return RET_FAILED;  }
 myGetAdaptersInfo=(getAdaptersInfo)GetProcAddress(mod,"GetAdaptersInfo");
 myGetNetworkParams=(getNetworkParams)GetProcAddress(mod,"GetNetworkParams");
 if(myGetNetworkParams==NULL||myGetAdaptersInfo==NULL) { FreeLibrary(mod);  return RET_FAILED;  }
  fixed_info_was_allocated=NO;
  fixed_info_ptr=(FIXED_INFO *)fixed_info_buf;
  outbuf_len=sizeof(fixed_info_buf);
  if(myGetNetworkParams(fixed_info_ptr,&outbuf_len)==ERROR_BUFFER_OVERFLOW)
   {
   if(aaMemoryAllocate((VP)&fixed_info_ptr,outbuf_len)!=YES)
    {
    FreeLibrary(mod);
    return RET_FAILED;
    }
   aaMemoryNameSet(fixed_info_ptr,"neifo");
   fixed_info_was_allocated=YES;
   }
  fail=YES;
  if((res=myGetNetworkParams(fixed_info_ptr,&outbuf_len))==NO_ERROR)
   {
   fail=NO;
   aaStringCopyf(netinfo->host_name,"%s",fixed_info_ptr->HostName);
   aaStringCopyf(netinfo->domain_name,"%s",fixed_info_ptr->DomainName);
   aaStringCopyfLen(txt,&sl,"%s",fixed_info_ptr->DnsServerList.IpAddress.String);
   first=YES;
   while(1)
    {
    if(sl>=7&&sl<=15)
     {
     if(aaNetIpFromString(txt,&netinfo->dns_server_ip[netinfo->dns_server_count])==YES)
      {
      aaStringCopyf(netinfo->dns_server_dot[netinfo->dns_server_count],"%s",txt);
      netinfo->dns_server_count++;
      if(netinfo->dns_server_count>=aaElementCount(netinfo->dns_server_ip)) { break; }
      }
     }
    if(first==YES) {  ip_addr_ptr=fixed_info_ptr->DnsServerList.Next;    }
    else           {  ip_addr_ptr=ip_addr_ptr->Next;   }
    if(!ip_addr_ptr) { break; }
    aaStringCopyfLen(txt,&sl,"%s",ip_addr_ptr->IpAddress.String);
    first=NO;
    }
   switch (fixed_info_ptr->NodeType)
    {
    case BROADCAST_NODETYPE:    netinfo->is_broadcast_node=YES;  break;
    case PEER_TO_PEER_NODETYPE: netinfo->is_ppp_node=YES;        break;
    case MIXED_NODETYPE:        netinfo->is_mixed_node=YES;      break;
    case HYBRID_NODETYPE:       netinfo->is_hybrid_node=YES;     break;
    default:                    netinfo->is_unknown_node=YES;    break;
    }
   aaStringCopyf(netinfo->dhcp_scope_name,"%s",fixed_info_ptr->ScopeId);
   if(fixed_info_ptr->EnableRouting) netinfo->is_routing_enabled=YES;
   if(fixed_info_ptr->EnableProxy)   netinfo->is_arpproxy_enabled=YES;
   if(fixed_info_ptr->EnableDns)     netinfo->is_dns_enabled=YES;
   }
  if(fixed_info_was_allocated)  {  aaMemoryRelease(fixed_info_ptr);   fixed_info_ptr=NULL;   }
  if(fail)  { FreeLibrary(mod); return RET_FAILED; }

  adapter_info_was_allocated=NO;
  adapter_info_size=sizeof(adapter_info_buf);
  adapter_info_ptr=(PIP_ADAPTER_INFO)adapter_info_buf;
  if((err=myGetAdaptersInfo(adapter_info_ptr,&adapter_info_size))!= 0)
   {
   if(err==ERROR_BUFFER_OVERFLOW)
    {
    if((adapter_info_ptr=(PIP_ADAPTER_INFO)GlobalAlloc(GPTR,adapter_info_size))==NULL)
     {
     FreeLibrary(mod);
     return RET_FAILED;
     }
    adapter_info_was_allocated=YES;
    if((err=myGetAdaptersInfo(adapter_info_ptr,&adapter_info_size))!= 0)
     {
     GlobalFree(adapter_info_ptr);
     FreeLibrary(mod);
     return RET_FAILED;
     }
    }
   else
    {
    FreeLibrary(mod);
    return RET_FAILED;
    }
   }
  adapt_ptr=adapter_info_ptr;
  while(adapt_ptr)
   {
   addr_str_ptr=&(adapt_ptr->IpAddressList);
   dapi=netinfo->adapter_count;
   nidap_ptr=(_netinfoadapter*)&netinfo->adapter[dapi];
   while(addr_str_ptr)
    {
    adri=netinfo->adapter[dapi].address_count;
    nidapadr_ptr=(_netinfoadapteraddress*)&nidap_ptr->address[adri];
    if(nidap_ptr->address_count<aaElementCount(nidap_ptr->address))
     {
     aaStringCopyf(nidapadr_ptr->ip_dot,"%s",addr_str_ptr->IpAddress.String);
     aaNetIpFromString(nidapadr_ptr->ip_dot,&nidapadr_ptr->ip);
     aaStringCopyf(nidapadr_ptr->subnet_dot,"%s",addr_str_ptr->IpMask.String);
     aaNetIpFromString(nidapadr_ptr->subnet_dot,&nidapadr_ptr->subnet);
     nidap_ptr->address_count++;
     }
    addr_str_ptr=addr_str_ptr->Next;
    }
   aaStringCopyf(nidap_ptr->description,"%s",adapt_ptr->Description);
   aaStringNull(str);
   for(j=0;j<adapt_ptr->AddressLength;j++)
    {
    if(j==(adapt_ptr->AddressLength-1)) aaStringAppendf(str,"%.2X",(Z)adapt_ptr->Address[j]);
    else                                aaStringAppendf(str,"%.2X-",(Z)adapt_ptr->Address[j]);
    }
   aaStringCopyf(nidap_ptr->physical_address,"%s",str);
   switch(adapt_ptr->Type)
    {
    case MIB_IF_TYPE_OTHER:     nidap_ptr->is_type_other=YES;     break;
    case MIB_IF_TYPE_ETHERNET:  nidap_ptr->is_type_ethernet=YES;  break;
    case MIB_IF_TYPE_TOKENRING: nidap_ptr->is_type_tokenring=YES; break;
    case MIB_IF_TYPE_FDDI:      nidap_ptr->is_type_fddi=YES;      break;
    case MIB_IF_TYPE_PPP:       nidap_ptr->is_type_ppp=YES;       break;
    case MIB_IF_TYPE_LOOPBACK:  nidap_ptr->is_type_loopback=YES;  break;
    case MIB_IF_TYPE_SLIP:      nidap_ptr->is_type_slip=YES;      break;
    default:                    nidap_ptr->is_type_unknown=YES;   break;
    }
   aaStringCopyf(nidap_ptr->gateway_dot,"%s",adapt_ptr->GatewayList.IpAddress.String);
   aaNetIpFromString(nidap_ptr->gateway_dot,&nidap_ptr->gateway);
   addr_str_ptr=adapt_ptr->GatewayList.Next;
   while(addr_str_ptr)    {    addr_str_ptr=addr_str_ptr->Next;    }
   aaStringCopyf(nidap_ptr->dhcp_dot,"%s",adapt_ptr->DhcpServer.IpAddress.String);
   aaNetIpFromString(nidap_ptr->dhcp_dot,&nidap_ptr->dhcp);
   aaStringCopyf(nidap_ptr->primary_wins_dot,"%s",adapt_ptr->PrimaryWinsServer.IpAddress.String);
   aaNetIpFromString(nidap_ptr->primary_wins_dot,&nidap_ptr->primary_wins);
   aaStringCopyf(nidap_ptr->secondary_wins_dot,"%s",adapt_ptr->SecondaryWinsServer.IpAddress.String);
   aaNetIpFromString(nidap_ptr->secondary_wins_dot,&nidap_ptr->secondary_wins);
   netinfo->adapter_count++;
   if(netinfo->adapter_count>=aaElementCount(netinfo->adapter)) { break; }
   adapt_ptr=adapt_ptr->Next;
   }
  if(adapter_info_was_allocated==YES)
   {
   GlobalFree(adapter_info_ptr);
   }
 FreeLibrary(mod);
 return RET_YES;
 }







 B aaNetInfoToString                   (_netinfo*netinfo,H maxchars,VP str)
 {
 B txt[_32K];
 H i,c,a,ac,sl;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(netinfo==NULL) { return RET_BADPARM; }
 if(str) { aaStringNull(str); }
 if(maxchars==0) { return RET_BADPARM; }
 aaStringNull(txt);
 if(netinfo->host_name[0]) { aaStringAppendf(txt,"host_name=%s\n",netinfo->host_name); }
 if(netinfo->domain_name[0]) { aaStringAppendf(txt,"domain_name=%s\n",netinfo->domain_name); }
 c=netinfo->dns_server_count;
 for(i=0;i<c;i++)
  {
  aaStringAppendf(txt,"dns_server[%i/%i] %s (%u)\n",i,c,netinfo->dns_server_dot[i],netinfo->dns_server_ip[i]);
  }
 aaStringAppendf(txt,"is_broadcast_node=%i\n",netinfo->is_broadcast_node);
 aaStringAppendf(txt,"is_ppp_node=%i\n",netinfo->is_ppp_node);
 aaStringAppendf(txt,"is_mixed_node=%i\n",netinfo->is_mixed_node);
 aaStringAppendf(txt,"is_hybrid_node=%i\n",netinfo->is_hybrid_node);
 aaStringAppendf(txt,"is_unknown_node=%i\n",netinfo->is_unknown_node);
 if(netinfo->dhcp_scope_name[0]) { aaStringAppendf(txt,"dhcp_scope_name=%s\n",netinfo->dhcp_scope_name); }
 aaStringAppendf(txt,"is_routing_enabled=%i\n",netinfo->is_routing_enabled);
 aaStringAppendf(txt,"is_arpproxy_enabled=%i\n",netinfo->is_arpproxy_enabled);
 aaStringAppendf(txt,"is_dns_enabled=%i\n",netinfo->is_dns_enabled);
 c=netinfo->adapter_count;
 for(i=0;i<c;i++)
  {
  aaStringAppendf(txt,"adapter[%i/%i]\n",i,c);
  if(netinfo->adapter[i].description[0]) { aaStringAppendf(txt,"description=%s\n",netinfo->adapter[i].description); }
  if(netinfo->adapter[i].physical_address[0]) { aaStringAppendf(txt,"physical_address=%s\n",netinfo->adapter[i].physical_address); }
  aaStringAppendf(txt,"is_type_other=%i\n",netinfo->adapter[i].is_type_other);
  aaStringAppendf(txt,"is_type_ethernet=%i\n",netinfo->adapter[i].is_type_ethernet);
  aaStringAppendf(txt,"is_type_tokenring=%i\n",netinfo->adapter[i].is_type_tokenring);
  aaStringAppendf(txt,"is_type_fddi=%i\n",netinfo->adapter[i].is_type_fddi);
  aaStringAppendf(txt,"is_type_ppp=%i\n",netinfo->adapter[i].is_type_ppp);
  aaStringAppendf(txt,"is_type_loopback=%i\n",netinfo->adapter[i].is_type_loopback);
  aaStringAppendf(txt,"is_type_slip=%i\n",netinfo->adapter[i].is_type_slip);
  aaStringAppendf(txt,"is_type_unknown=%i\n",netinfo->adapter[i].is_type_unknown);
  ac=netinfo->adapter[i].address_count;
  for(a=0;a<ac;a++)
   {
   aaStringAppendf(txt,"address[%i/%i]\n",a,ac);
   aaStringAppendf(txt,"ip=%s (%u)\n",netinfo->adapter[i].address[a].ip_dot,netinfo->adapter[i].address[a].ip);
   aaStringAppendf(txt,"subnet=%s (%u)\n",netinfo->adapter[i].address[a].subnet_dot,netinfo->adapter[i].address[a].subnet);
   }
  aaStringAppendf(txt,"gateway=%s (%u)\n",netinfo->adapter[i].gateway_dot,netinfo->adapter[i].gateway);
  if(netinfo->adapter[i].dhcp) { aaStringAppendf(txt,"dhcp=%s (%u)\n",netinfo->adapter[i].dhcp_dot,netinfo->adapter[i].dhcp); }
  if(netinfo->adapter[i].primary_wins) { aaStringAppendf(txt,"primary_wins=%s (%u)\n",netinfo->adapter[i].primary_wins_dot,netinfo->adapter[i].primary_wins); }
  if(netinfo->adapter[i].secondary_wins) { aaStringAppendf(txt,"secondary_wins=%s (%u)\n",netinfo->adapter[i].secondary_wins_dot,netinfo->adapter[i].secondary_wins); }
  }
 aaStringLen(txt,&sl);
 if(sl>maxchars)  { txt[maxchars]=NULL_CHAR; sl=maxchars; }
 aaStringNCopy(str,txt,sl,YES);
 return RET_YES;
 }






 B aaNetOnlineStateGet                 (BP state)
 {
 HINSTANCE lib;
 H flags;
 T BOOL(WINAPI*deffunc)(HP,H);
 deffunc func;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(state==NULL) { return RET_BADPARM; }
 *state=NO;
 lib=LoadLibrary("wininet.dll");
 if(lib==NULL||lib==INVALID_HANDLE_VALUE) { return RET_FAILED; }
 func=(deffunc)GetProcAddress(lib,"InternetGetConnectedState");
 if(func==NULL)  { FreeLibrary(lib);  return RET_FAILED;  }
 flags=0;
 if(func(&flags,0)!=0) { *state=YES; }
 FreeLibrary(lib);
 return RET_YES;
 }





 B aaNetMacGet                         (VP mac,H ip,VP txt)
 {
 B ret;
 H dwBufLen;
 B dot[33];
 B str[_1K];
 HMODULE mod;
 T BOOL (*_gai) (PIP_ADAPTER_INFO,PULONG);
 _gai gai;
 PIP_ADAPTER_INFO pAdapterInfo=NULL;
 PIP_ADAPTER_INFO pAdapter=NULL;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mac==NULL&&txt==NULL) { return RET_BADPARM; }
 if(mac) { aaMemoryFill(mac,6,0); }
 if(txt) { aaStringNull(txt); }
 aaNetIpToString(ip,dot);
 if((mod=LoadLibrary("iphlpapi.dll"))==NULL) { oof; return RET_FAILED; }
 if((gai=(_gai)GetProcAddress(mod,"GetAdaptersInfo"))==NULL)  { oof; FreeLibrary(mod);   return RET_FAILED; }
 dwBufLen=sizeof(IP_ADAPTER_INFO);
 if(aaMemoryAllocate((VP)&pAdapterInfo,dwBufLen)!=YES) { oof; FreeLibrary(mod);   return RET_FAILED; }
 if(gai(pAdapterInfo,&dwBufLen)==ERROR_BUFFER_OVERFLOW)
  {
  aaMemoryRelease(pAdapterInfo);
  pAdapterInfo=NULL;
  if(aaMemoryAllocate((VP)&pAdapterInfo,dwBufLen)!=YES) { oof; }
  }

 if(gai(pAdapterInfo,&dwBufLen)==NO_ERROR)
  {
  ret=RET_YES;
  pAdapter=pAdapterInfo;
  while(pAdapter)
   {
   aaLog(-777,"li=%i",__LINE__);
   aaLog(-777,"li=%i ip=%u",__LINE__,ip);
   aaLog(-777,"li=%i dot=%s",__LINE__,dot);
   aaLog(-777,"li=%i ipa=%s",__LINE__,pAdapter->IpAddressList.IpAddress);
   aaLog(-777,"li=%i gwa=%s",__LINE__,pAdapter->GatewayList.IpAddress);
   aaLog(-777,"li=%i %s",__LINE__,pAdapter->AdapterName);
   aaLog(-777,"li=%i %s",__LINE__,pAdapter->Description);
   aaLog(-777,"li=%i al=%i",__LINE__,pAdapter->AddressLength);
   aaStringCopyf(str,"%02X:%02X:%02X:%02X:%02X:%02X:%02x:%02x",
   pAdapterInfo->Address[0],pAdapterInfo->Address[1],pAdapterInfo->Address[2],
   pAdapterInfo->Address[3],pAdapterInfo->Address[4],pAdapterInfo->Address[5],
   pAdapterInfo->Address[6],pAdapterInfo->Address[7]);
   str[(pAdapter->AddressLength*3)-1]=NULL_CHAR;
   if(pAdapter->HaveWins)
    {
    }
   pAdapter=pAdapterInfo->Next;
   }
  }
 else
  {
  ret=RET_FAILED;
  }
 aaLog(-777,"li=%i",__LINE__);
 if(pAdapterInfo) {  aaMemoryRelease(pAdapterInfo); pAdapterInfo=NULL; }
 FreeLibrary(mod);
 return ret;
 }








 B aaNetIpPublicNext                   (HP ip,HP iterator)
 {
 H h,i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(ip) { *ip=0; }
 if(iterator==NULL)  {  h=aa.net_system.next_public_ip_counter; }
 else                {  h=*iterator; }
 for(i=0;i<aa.net_system.net_status.public_ip_count;i++)
  {
  h++;
  if(h>=aa.net_system.net_status.public_ip_count) { h=0; }
  if(aa.net_system.net_status.public_ip[h]!=0)
   {
   if(ip) { *ip=aa.net_system.net_status.public_ip[h]; }
   if(iterator==NULL)  {  aa.net_system.next_public_ip_counter=h; }
   else                {  *iterator=h; }
   return RET_YES;
   }
  }
 if(iterator==NULL)  {  aa.net_system.next_public_ip_counter=h; }
 else                {  *iterator=h; }
 return RET_NOTFOUND;
 }




 B aaNetIpFromString                   (VP dot,HP bin)
 {
 H addr;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bin==NULL)  {  return RET_BADPARM;  }
 *bin=0;
 if(dot==NULL)  {  return RET_BADPARM;  }
 if(aaNetIpIsValid(dot)!=RET_YES) {  return RET_FAILED; }
 if((addr=inet_addr(dot))==INADDR_NONE)  {  return RET_FAILED;  }
 *bin=addr;
 return RET_YES;
 }





 B aaNetIpToString                     (H bin,VP dot)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(dot==NULL)  {  return RET_BADPARM;  }
 aaStringNull(dot);
 aaStringCopy(dot,inet_ntoa(*(struct in_addr *)&bin));
 return RET_YES;
 }







 B aaNetIpIsValid                      (VP dot)
 {
 H sl,i,dots,nums,val;
 BP bp;
 B tmp[_1K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(dot==NULL)  {  return RET_BADPARM;  }
 aaStringLen(dot,&sl);
 if(sl<7) { return RET_FAILED; }
 if(sl>15) { return RET_FAILED; }
 aaCast(bp,BP,dot);
 dots=0;
 for(i=0;i<sl;i++)
  {
  if(bp[i]=='.') { dots++; }
  }
 if(dots!=3) { return RET_FAILED; }
 for(i=1;i<sl;i++)
  {
  if(bp[i]=='.'&&bp[i-1]=='.') { return RET_FAILED; }
  }
 if(bp[0]=='.') { return RET_FAILED; }
 if(bp[sl-1]=='.') { return RET_FAILED; }
 nums=0;
 for(i=0;i<sl;i++)
  {
  if(bp[i]>='0'&&bp[i]<='9') { nums++; }
  else             { nums=0; }
  if(nums>3) { return RET_FAILED; }
  }
 nums=0;
 tmp[0]=NULL_CHAR;
 for(i=0;i<sl;i++)
  {
  if(bp[i]=='.')
   {
   if(tmp[0]==NULL_CHAR) { return RET_FAILED; }
   if(aaStringToNumber(tmp,nums,&val,NULL,0,0)!=YES) { return RET_FAILED; }
   if(val>255) { return RET_FAILED; }
   nums=0;
   tmp[0]=NULL_CHAR;
   continue;
   }
  tmp[nums]=bp[i];
  nums++;
  tmp[nums]=NULL_CHAR;
  }
 if(tmp[0]==NULL_CHAR) { return RET_FAILED; }
 if(aaStringToNumber(tmp,nums,&val,NULL,0,0)!=YES) { return RET_FAILED; }
 if(val>255) { return RET_FAILED; }
 return RET_YES;
 }




 B aaNetIpIsLoopBack                   (H bin)
 {
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaCast(bp,BP,&bin);
 if(bp[0]==127) { return RET_YES; }
 return RET_NO;
 }





 B aaNetIpIsInternal                   (H bin)
 {
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaCast(bp,BP,&bin);
 if(bp[0]==10) { return RET_YES; }
 if(bp[0]==172&&(bp[1]>=16&&bp[1]<=31)) { return RET_YES; }
 if(bp[0]==192&&bp[1]==168) { return RET_YES; }
 if(bp[0]==169&&bp[1]==254) { return RET_YES; }
 return RET_NO;
 }




 B aaNetIpIsReserved                   (H bin)
 {
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaCast(bp,BP,&bin);
 if(bp[0]==0) { return RET_YES; }
 if(bp[0]==127) { return RET_YES; }
 if(bp[0]==192&&(bp[1]==0&&bp[2]==2)) { return RET_YES; }
 if(bp[0]>=224) { return RET_YES; }
 return RET_NO;
 }



 B aaNetIpIsPublic                     (H bin)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aaNetIpIsReserved(bin)==YES) { return RET_NO; }
 if(aaNetIpIsInternal(bin)==YES) { return RET_NO; }
 if(aaNetIpIsLoopBack(bin)==YES) { return RET_NO; }
 return RET_YES;
 }




 B aaNetIpTypeGet                      (H bin,BP type)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(type==NULL) { return RET_BADPARM; }
 *type=NULL_CHAR;
 if(aaNetIpIsLoopBack(bin)==YES) { *type='L'; return RET_YES; }
 if(aaNetIpIsInternal(bin)==YES) { *type='I'; return RET_YES; }
 if(aaNetIpIsReserved(bin)==YES) { *type='R'; return RET_YES; }
 *type='P';
 return RET_YES;
 }




 B aaNetIpToDword                      (H ip,HP val)
 {
 H v;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(val==NULL) { return RET_BADPARM; }
 v=LOBYTE(LOWORD(ip))<<24;
 v+=HIBYTE(LOWORD(ip))<<16;
 v+=LOBYTE(HIWORD(ip))<<8;
 v+=HIBYTE(HIWORD(ip));
 *val=v;
 return RET_YES;
 }




 B aaNetIpClassGet                     (H ip,BP cls)
 {
 B c=0;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(((H)(ip)&0x80000000)==0) { c='A'; } else
 if((((H)(ip)&0xc0000000)==0x80000000)) { c='B'; } else
 if((((H)(ip)&0xe0000000)==0xc0000000)) { c='C'; } else
 if((((H)(ip)&0xf0000000)==0xe0000000)) { c='D'; } else { c='E'; }
 if(cls) { *cls=c; }
 return RET_YES;
 }




 B aaNetIp6FromIp4                     (_ip6*ip6,H ip4)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(ip6==NULL) { return RET_MISSINGPARM; }
 ip6->dw[0]=0;
 ip6->dw[1]=1;
 ip6->dw[2]=0xffffffff;
 ip6->dw[3]=ip4;
 return RET_YES;
 }



 B aaNetIp6ToIp4                       (_ip6*ip6,HP ip4)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(ip6==NULL) { return RET_MISSINGPARM; }
 if(ip4==NULL) { return RET_MISSINGPARM; }
 *ip4=0;
 if(ip6->dw[0]!=0)   { return RET_FAILED; }
 if(ip6->dw[1]!=0)   { return RET_FAILED; }
 if(ip6->dw[2]!=0xffffffff) { return RET_FAILED; }
 *ip4=ip6->dw[3];
 return RET_YES;
 }





 B aaNetEmailIsValid                   (VP email)
 {
 _parser p;
 H cnt,state,i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(email==NULL) { return RET_BADPARM; }
 aaParserInit(&p,email,0);
 if(p.length<6) { return RET_NO; }
 if(aaStringCountChars(p.bp,p.to_end,&cnt,'@',NO,YES)!=RET_YES) { return RET_NO; }
 if(cnt!=1) { return RET_NO; }
 if(aaStringCountChars(p.bp,p.to_end,&cnt,'.',NO,YES)!=RET_YES) { return RET_NO; }
 if(cnt<1) { return RET_NO; }
 for(i=0;i<p.length;i++)
  {
  if(aaCharIsAlphaNum(p.bp[i])==YES) { continue; }
  if(aaCharIsNum(p.bp[i])==YES) { continue; }
  if(p.bp[i]=='_'||p.bp[i]=='.'||p.bp[i]=='@'||p.bp[i]=='-') { continue; }
  return RET_NO;
  }
 if(aaCharIsAlphaNum(p.bp[0])!=YES&&p.bp[0]!='_') { return RET_NO; }
 if(aaCharIsAlpha(p.bp[p.length-1])!=YES) { return RET_NO; }
 state=0;
 while(1)
  {
  if(p.is_end) break;
  switch(state)
   {
   case 0:
   if(p.ch=='@') { aaParserSeek(&p,1);  state=10; break; }
   if(p.ch=='.') { aaParserSeek(&p,1);  state=10; break; }
   aaParserSeek(&p,1);
   break;

   case 10:
   if(p.ch=='@') {  return RET_NO; }
   if(p.ch=='.') {  return RET_NO; }
   aaParserSeek(&p,1);
   state=0;
   break;
   }
  }
 return RET_YES;
 }







 B aaNetHostToDomain                   (VP host,VP domain)
 {
 B dom[257];
 H cnt,pos,ip;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(domain==NULL) { return RET_BADPARM; }
 aaStringNull(domain);
 if(host==NULL) { return RET_BADPARM; }
 aaCast(bp,BP,host);
 aaStringCopyf(dom,"%s",bp);
 if(aaNetIpFromString(dom,&ip)==YES&&ip!=0)
  {
  aaStringCopyf(dom,".%s",bp);
  }
 else
  {
  aaStringCountChars(dom,0,&cnt,'.',NO,YES);
  if(cnt>1) { aaStringFindChar(bp,0,&pos,'.',YES,0,YES);  aaStringCopyf(dom,"%s",&bp[pos]);  }
  else      { aaStringCopyf(dom,".%s",bp);  }
  }
 aaStringCopy(domain,dom);
 return RET_YES;
 }





 B aaNetHostIsValid                    (VP host,H chars)
 {
 B ret;
 H pos,i;
 B ch;
 _parser pa;
 H len[2];
 B str[2][_2K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(host==NULL) { return RET_MISSINGPARM; }
 if(chars==0) { aaStringLen(host,&chars); }
 if(chars>253) { return RET_NO; }
 if(chars==0)  { return RET_NO; }
 aaParserInit(&pa,host,chars);
 while(1)
  {
  if(aaStringFindChar(pa.bp,pa.to_end,&pos,'.',YES,0,YES)!=YES) { break; }
  ret=aaStringSplit(pa.bp,pa.to_end,pos,NO,str[0],NULL);
  if(ret!=YES) { break; oops; }
  aaStringLen(str[0],&len[0]);
  aaStringLen(str[1],&len[1]);
  if(len[0]==0||len[0]>63) {  return RET_NO; }
  for(i=0;i<len[0];i++)
   {
   ch=str[0][i];
   if(ch=='-') { continue; }
   if(aaCharIsAlphaNum(ch)) { continue; }
   break;
   }
  if(i!=len[0]) { return RET_NO; }
  if(str[0][0]=='-') { return RET_NO; }
  if(str[0][len[0]-1]=='-') { return RET_NO; }
  aaParserSeek(&pa,pos+1);
  }
 return RET_YES;
 }




 B aaNetRfcCrcGet                      (VP mem,H bytes,WP crc)
 {
 H left =bytes;
 WP wp;
 W answer,u;
 N sum;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaCast(wp,WP,mem);
 sum=0;
 while(left>1)
  {
  sum+=*wp++;
  left-=2;
  }
 if(left==1)
  {
  u=0;
  *(BP)(&u)=*(BP)wp;
  sum+=u;
  }
 sum=(sum>>16)+(sum&F16);
 sum+=(sum>>16);
 answer=(W)(~sum);
 *crc=answer;
 return RET_YES;
 }





 B aaNetBrowserWritef                  (HP hinst,VP fmt,...)
 {
 HINSTANCE h;
 va_list argptr;
 B txt[_4K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,txt);
 if(hinst) *hinst=0;
 if(fmt==NULL)  {  return RET_BADPARM;  }
 h=ShellExecute(NULL,NULL,(CP)txt,NULL,NULL,SW_SHOWNORMAL);
 if(hinst) *hinst=(H)h;
 if((H)h<=32)
  {
  return RET_FAILED;
  }
 return RET_YES;
 }




 B aaNetMimeToExtension                (VP mime,VP extension)
 {
 BP mm;
 H i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(extension==NULL) { return RET_BADPARM; }
 aaStringNull(extension);
 if(mime==NULL) { return RET_BADPARM; }
 aaCast(mm,BP,mime);
 if(*mm==NULL_CHAR) {  return RET_FAILED; }
 for(i=0;;i++)
  {
  if(aa_mime_type[i][0][0]==NULL_CHAR) { break; }
  if(aaStringICompare(mm,aa_mime_type[i][1],NULL)!=YES) { continue; }
  aaStringCopy(extension,aa_mime_type[i][0]);
  return RET_YES;
  }
 return RET_NOTFOUND;
 }




 B aaNetExtensionToMime                (VP extension,VP mime)
 {
 BP fe;
 H i,sl,off;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mime==NULL) { return RET_BADPARM; }
 aaStringNull(mime);
 if(extension==NULL) { return RET_BADPARM; }
 aaStringLen(extension,&sl);
 if(sl==0) { return RET_FAILED; }
 off=sl-1;
 aaCast(fe,BP,extension);
 while(1)
  {
  if(fe[off]=='.') { off++; break; }
  if(off==0) { break; }
  off--;
  }
 aaCast(fe,BP,extension);
 fe+=off;
 for(i=0;;i++)
  {
  if(aa_mime_type[i][0][0]==NULL_CHAR) { break; }
  if(aaStringICompare(fe,aa_mime_type[i][0],NULL)!=YES) { continue; }
  aaStringCopy(mime,aa_mime_type[i][1]);
  return RET_YES;
  }
 aaStringCopy(mime,"application/octet-stream");
 return RET_YES;
 }




 B aaNetHostsFileEntryGet              (H index,VP domain,VP dotted,HP ip,BP iscmnt)
 {
 B ret;
 B path[_1K];
 B txt[_4K];
 B tok[_1K];
 H pos,flag;
 _parser pa;
 _textreader tr;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(domain) { aaStringNull(domain); }
 if(iscmnt) { *iscmnt=NO; }
 if(dotted) { aaStringNull(dotted);  }
 if(ip)     { *ip=0; }
 if(GetSystemDirectory((CP)path,sizeof(path))==0) { return RET_FAILED; }
 aaStringAppendf(path,"\\drivers\\etc\\hosts");
 if((ret=aaTextReaderOpen(&tr,path,0,0))!=YES) { return ret; }
 if((ret=aaTextReaderLineGet(&tr,index,NULL,txt))!=YES) {  aaTextReaderDelete(&tr);  return ret;  }

 aaStringReplaceChar(txt,0,HTAB_CHAR,SPACE_CHAR);
 aaStringRemoveSpaces(txt,0,1,1);
 aaStringRemoveMultipleSpaces(txt,0,0);
 aaParserInit(&pa,txt,0);
 ret=RET_NOTFOUND;
 if(aaParserSeekToVisibleChar(&pa,YES,YES)==YES)
  {
  if(pa.ch=='#')    {      if(iscmnt) *iscmnt=YES;       }
  flag=0;
  while(1)
   {
   if(pa.is_end||pa.to_end<7) { break; }
   if(aaParserSeekToNumber(&pa,YES)==YES)
    {
    aaStringFindChar(pa.bp,pa.to_end,&pos,SPACE_CHAR,YES,0,YES);
    if(pos==0xffffffff) {  pos=pa.to_end; break; }
    if(pos>=7&&pos<=15)
     {
     aaStringNCopy(tok,pa.bp,pos,YES);
     if(aaNetIpIsValid(tok)==YES)
      {
      flag=aaBitSet(flag,0);
      if(dotted) { aaStringCopy(dotted,tok); }
      if(ip)     { aaNetIpFromString(tok,ip); }
      }
     }
    aaParserSeek(&pa,pos);
    if(aaParserSeekToVisibleChar(&pa,YES,YES)==YES)
     {
   //  off=pa.offset;
     aaStringFindChar(pa.bp,pa.to_end,&pos,SPACE_CHAR,YES,0,YES);
     if(pos==0xffffffff) {  pos=pa.to_end;  }

     //if(aaParserSeekToVisibleChar(&pa,NO,YES)==YES)  {   pos=pa.offset;   aaParserOffsetSet(&pa,off);         }
     //else                                            {   aaParserOffsetSet(&pa,off);     pos=pa.to_end;         }

     aaStringNCopy(tok,pa.bp,pos,YES);
     flag=aaBitSet(flag,1);
     if(domain) { aaStringCopyf(domain,"%s",tok); }
     ret=RET_YES;
     }
    }
   break;
   }
  }
 aaTextReaderDelete(&tr);
 if(flag==3) { return ret; }
 return RET_NOTFOUND;
 }






 B aaNetHostsFileEntrySet              (H index,VP domain,VP dotted,H ip,B iscmnt)
 {
 B ret;
 B path[_1K];
 B txt[_4K];
 B dot[_1K];
 H i;
 _textreader tr;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaStringNull(dot);
 if(aaStringIsEmpty(domain,YES)!=NO) { return RET_BADPARM; }
 if(aaStringIsEmpty(dotted,YES)!=NO&&ip==0) { return RET_BADPARM; }
 if(aaStringIsEmpty(dotted,YES)==NO) { aaStringCopyf(dot,"%s",dotted); }
 if(aaStringIsEmpty(dot,YES)==YES) { aaNetIpToString(ip,dot); }
 if(GetSystemDirectory((CP)path,sizeof(path))==0) { return RET_FAILED; }
 aaStringAppendf(path,"\\drivers\\etc\\hosts");
 if((ret=aaTextReaderOpen(&tr,path,0,0))!=YES)
  {
  aaMemoryFill(&tr,sizeof(_textreader),0);
  tr.magic=(H)(PP)aaTextReaderNew;
  tr.is_initialized=YES;
  tr.line_count=0;
  }

 if(index==0xffffffff) { index=tr.line_count; }
 else
  {
  if(index>=tr.line_count)
   {
   aaTextReaderDelete(&tr);
   return RET_BOUNDS;
   }
  }
 aaFileDelete(path);

 for(i=0;i<tr.line_count;i++)
  {
  if((ret=aaTextReaderLineGet(&tr,i,NULL,txt))!=YES) {  oops; aaTextReaderDelete(&tr);  return ret;  }
  if(i==index)
   {
   if(iscmnt)
    {
    if((ret=aaFileAppendf(path,"#%s %s\r\n",dot,domain))!=YES) { oops; aaTextReaderDelete(&tr);  return ret;  }
    }
   else
    {
    if((ret=aaFileAppendf(path,"%s %s\r\n",dot,domain))!=YES) { oops; aaTextReaderDelete(&tr);  return ret;  }
    }
   continue;
   }
  if((ret=aaFileAppendf(path,"%s\r\n",txt))!=YES) { oops; aaTextReaderDelete(&tr);  return ret;  }
  }
 if(i==index)
  {
  if(iscmnt) { if((ret=aaFileAppendf(path,"#%s %s\r\n",dot,domain))!=YES) { oops; aaTextReaderDelete(&tr);  return ret;  }  }
  else       { if((ret=aaFileAppendf(path,"%s %s\r\n",dot,domain))!=YES) { oops; aaTextReaderDelete(&tr);  return ret;  }   }
  }

 aaTextReaderDelete(&tr);
 return RET_YES;
 }




 B aaNetIsPortAvailable                (H ip,W port,B isudp)
 {
 SOCKET sock;
 struct sockaddr_in addr;
 N oval,olen;
 UNUSE(oval);
 UNUSE(olen);

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(port==0) { return RET_BADPARM; }
 if(isudp==YES)
  {
  if((sock=socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP))==INVALID_SOCKET)  {  return RET_FAILED;  }
  WinSockAddrSet(&addr,AF_INET,ip,htons(port));
  if(bind(sock,(struct sockaddr *)&addr,sizeof(addr)))  {  closesocket(sock);  return RET_NO;  }
  }
 else
  {
  if((sock=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP))==INVALID_SOCKET)   {  return RET_FAILED;   }
  WinSockAddrSet(&addr,AF_INET,ip,htons(port));
  if(bind(sock,(struct sockaddr *)&addr,sizeof(addr)))  {  closesocket(sock);   return RET_NO;   }
  }
 closesocket(sock);
 return RET_YES;
 }




 B aaNetRandomUser                     (_randomuser*randomuser)
 {
 H v;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(randomuser==NULL) { return RET_BADPARM; }
 aaMemoryFill(randomuser,sizeof(_randomuser),0);
 if(aaMathRand32(0,1)==0) { randomuser->gender=0; }
 else                     { randomuser->gender=1; }
 aaStringCopy(randomuser->first,aa_common_name[randomuser->gender][aaMathRand32(0,25)]);
 aaStringCopy(randomuser->middle,aa_common_name[aaMathRand32(0,1)][aaMathRand32(0,25)]);
 v=aaMathRand32(0,2);
 if(v==0)  {  aaStringCopyf(randomuser->last,"%ssmith",aa_common_name[aaMathRand32(0,1)][aaMathRand32(0,25)]);  }
 else
 if(v==1)  {  aaStringCopyf(randomuser->last,"%sson",aa_common_name[aaMathRand32(0,1)][aaMathRand32(0,25)]);  }
 else
 if(v==2)  {  aaStringCopyf(randomuser->last,"%sman",aa_common_name[aaMathRand32(0,1)][aaMathRand32(0,25)]);  }


 if(randomuser->gender==0) { randomuser->gender='M'; }
 else                      { randomuser->gender='F'; }
 randomuser->dob=aaMathRand32(0,27);
 randomuser->mob=aaMathRand32(0,11);
 randomuser->yob=aaMathRand32(1950,2002);
 aaStringCopy(randomuser->country,aa_geo_country_name[aaMathRand32(1,250)]);
 if(randomuser->gender=='M')
  {
  while(1)
   {
   if(aaMathRand32(0,2)==0) { aaStringCopyf(randomuser->title,"Mr"); break; }
   if(aaMathRand32(0,2)==0) { aaStringCopyf(randomuser->title,"Dr"); break; }
   if(aaMathRand32(0,2)==0) { aaStringCopyf(randomuser->title,"Sir"); break; }
   if(aaMathRand32(0,2)==0) { aaStringCopyf(randomuser->title,"Prof"); break; }
   }
  }
 else
  {
  while(1)
   {
   if(aaMathRand32(0,2)==0) { aaStringCopyf(randomuser->title,"Mrs"); break; }
   if(aaMathRand32(0,2)==0) { aaStringCopyf(randomuser->title,"Dr"); break; }
   if(aaMathRand32(0,2)==0) { aaStringCopyf(randomuser->title,"Lady"); break; }
   if(aaMathRand32(0,2)==0) { aaStringCopyf(randomuser->title,"Prof"); break; }
   }
  }
 v=aaMathRand32(0,3);
 if(v==0) {  aaStringCopyf(randomuser->email,"%s.%s@",randomuser->first,randomuser->last);  }
 else
 if(v==1) {  aaStringCopyf(randomuser->email,"%s_%s@",randomuser->first,randomuser->last);  }
 else
 if(v==2) {  aaStringCopyf(randomuser->email,"%s%s@",randomuser->first,randomuser->last);  }
 else
 if(v==3) {  aaStringCopyf(randomuser->email,"%c%s@",randomuser->first[0],randomuser->last);  }
 while(1)
  {
  if(aaMathRand32(0,2)==0) { aaStringAppendf(randomuser->email,"gmail.com"); break; }
  if(aaMathRand32(0,2)==0) { aaStringAppendf(randomuser->email,"hotmail.com"); break; }
  if(aaMathRand32(0,2)==0) { aaStringAppendf(randomuser->email,"yahoo.com"); break; }
  }
 aaStringLower(randomuser->email,0,0);
 return RET_YES;
 }




 B aaNetCgiEnvGet                      (_cgienv*cgienv)
 {
 H i;
 C txt[_8K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(cgienv==NULL) { return RET_BADPARM; }
 aaMemoryFill(cgienv,sizeof(_cgienv),0);
 i=0;
 cgienv->ptr[i++]=cgienv->server_software; if(GetEnvironmentVariable("SERVER_SOFTWARE",(CP)txt,sizeof(cgienv->server_software))!=0) { aaStringCopy(cgienv->server_software,txt); }
 cgienv->ptr[i++]=cgienv->server_name; if(GetEnvironmentVariable("SERVER_NAME",(CP)txt,sizeof(cgienv->server_name))!=0) { aaStringCopy(cgienv->server_name,txt); }
 cgienv->ptr[i++]=cgienv->gateway_interface; if(GetEnvironmentVariable("GATEWAY_INTERFACE",(CP)txt,sizeof(cgienv->gateway_interface))!=0) { aaStringCopy(cgienv->gateway_interface,txt); }
 cgienv->ptr[i++]=cgienv->server_protocol; if(GetEnvironmentVariable("SERVER_PROTOCOL",(CP)txt,sizeof(cgienv->server_protocol))!=0) { aaStringCopy(cgienv->server_protocol,txt); }
 cgienv->ptr[i++]=cgienv->server_port; if(GetEnvironmentVariable("SERVER_PORT",(CP)txt,sizeof(cgienv->server_port))!=0) { aaStringCopy(cgienv->server_port,txt); }
 cgienv->ptr[i++]=cgienv->request_uri; if(GetEnvironmentVariable("REQUEST_URI",(CP)txt,sizeof(cgienv->request_uri))!=0) { aaStringCopy(cgienv->request_uri,txt); }
 cgienv->ptr[i++]=cgienv->request_method; if(GetEnvironmentVariable("REQUEST_METHOD",(CP)txt,sizeof(cgienv->request_method))!=0) { aaStringCopy(cgienv->request_method,txt); }
 cgienv->ptr[i++]=cgienv->script_name; if(GetEnvironmentVariable("SCRIPT_NAME",(CP)txt,sizeof(cgienv->script_name))!=0) { aaStringCopy(cgienv->script_name,txt); }
 cgienv->ptr[i++]=cgienv->script_filename; if(GetEnvironmentVariable("SCRIPT_FILENAME",(CP)txt,sizeof(cgienv->script_filename))!=0) { aaStringCopy(cgienv->script_filename,txt); }
 cgienv->ptr[i++]=cgienv->url; if(GetEnvironmentVariable("URL",(CP)txt,sizeof(cgienv->url))!=0) { aaStringCopy(cgienv->url,txt); }
 cgienv->ptr[i++]=cgienv->query_string; if(GetEnvironmentVariable("QUERY_STRING",(CP)txt,sizeof(cgienv->query_string))!=0) { aaStringCopy(cgienv->query_string,txt); }
 cgienv->ptr[i++]=cgienv->remote_host; if(GetEnvironmentVariable("REMOTE_HOST",(CP)txt,sizeof(cgienv->remote_host))!=0) { aaStringCopy(cgienv->remote_host,txt); }
 cgienv->ptr[i++]=cgienv->remote_addr; if(GetEnvironmentVariable("REMOTE_ADDR",(CP)txt,sizeof(cgienv->remote_addr))!=0) { aaStringCopy(cgienv->remote_addr,txt); }
 cgienv->ptr[i++]=cgienv->remote_port; if(GetEnvironmentVariable("REMOTE_PORT",(CP)txt,sizeof(cgienv->remote_port))!=0) { aaStringCopy(cgienv->remote_port,txt); }
 cgienv->ptr[i++]=cgienv->instance_id; if(GetEnvironmentVariable("INSTANCE_ID",(CP)txt,sizeof(cgienv->instance_id))!=0) { aaStringCopy(cgienv->instance_id,txt); }
 cgienv->ptr[i++]=cgienv->path_info; if(GetEnvironmentVariable("PATH_INFO",(CP)txt,sizeof(cgienv->path_info))!=0) { aaStringCopy(cgienv->path_info,txt); }
 cgienv->ptr[i++]=cgienv->path_translated; if(GetEnvironmentVariable("PATH_TRANSLATED",(CP)txt,sizeof(cgienv->path_translated))!=0) { aaStringCopy(cgienv->path_translated,txt); }
 cgienv->ptr[i++]=cgienv->auth_type; if(GetEnvironmentVariable("AUTH_TYPE",(CP)txt,sizeof(cgienv->auth_type))!=0) { aaStringCopy(cgienv->auth_type,txt); }
 cgienv->ptr[i++]=cgienv->auth_user; if(GetEnvironmentVariable("AUTH_USER",(CP)txt,sizeof(cgienv->auth_user))!=0) { aaStringCopy(cgienv->auth_user,txt); }
 cgienv->ptr[i++]=cgienv->remote_user; if(GetEnvironmentVariable("REMOTE_USER",(CP)txt,sizeof(cgienv->remote_user))!=0) { aaStringCopy(cgienv->remote_user,txt); }
 cgienv->ptr[i++]=cgienv->remote_ident; if(GetEnvironmentVariable("REMOTE_IDENT",(CP)txt,sizeof(cgienv->remote_ident))!=0) { aaStringCopy(cgienv->remote_ident,txt); }
 cgienv->ptr[i++]=cgienv->server_admin; if(GetEnvironmentVariable("SERVER_ADMIN",(CP)txt,sizeof(cgienv->server_admin))!=0) { aaStringCopy(cgienv->server_admin,txt); }
 cgienv->ptr[i++]=cgienv->http_cookie; if(GetEnvironmentVariable("HTTP_COOKIE",(CP)txt,sizeof(cgienv->http_cookie))!=0) { aaStringCopy(cgienv->http_cookie,txt); }
 cgienv->ptr[i++]=cgienv->https; if(GetEnvironmentVariable("HTTPS",(CP)txt,sizeof(cgienv->https))!=0) { aaStringCopy(cgienv->https,txt); }
 cgienv->ptr[i++]=cgienv->content_length; if(GetEnvironmentVariable("CONTENT_LENGTH",(CP)txt,sizeof(cgienv->content_length))!=0) { aaStringCopy(cgienv->content_length,txt); }
 cgienv->ptr[i++]=cgienv->server_signature; if(GetEnvironmentVariable("SERVER_SIGNATURE",(CP)txt,sizeof(cgienv->server_signature))!=0) { aaStringCopy(cgienv->server_signature,txt); }
 cgienv->ptr[i++]=cgienv->document_root; if(GetEnvironmentVariable("DOCUMENT_ROOT",(CP)txt,sizeof(cgienv->document_root))!=0) { aaStringCopy(cgienv->document_root,txt); }
 cgienv->ptr[i++]=cgienv->http_referer; if(GetEnvironmentVariable("HTTP_REFERER",(CP)txt,sizeof(cgienv->http_referer))!=0) { aaStringCopy(cgienv->http_referer,txt); }
 cgienv->ptr[i++]=cgienv->http_user_agent; if(GetEnvironmentVariable("HTTP_USER_AGENT",(CP)txt,sizeof(cgienv->http_user_agent))!=0) { aaStringCopy(cgienv->http_user_agent,txt); }
 cgienv->ptr[i++]=cgienv->http_host; if(GetEnvironmentVariable("HTTP_HOST",(CP)txt,sizeof(cgienv->http_host))!=0) { aaStringCopy(cgienv->http_host,txt); }
 cgienv->ptr[i++]=cgienv->http_connection; if(GetEnvironmentVariable("HTTP_CONNECTION",(CP)txt,sizeof(cgienv->http_connection))!=0) { aaStringCopy(cgienv->http_connection,txt); }
 cgienv->ptr[i++]=cgienv->http_accept; if(GetEnvironmentVariable("HTTP_ACCEPT",(CP)txt,sizeof(cgienv->http_accept))!=0) { aaStringCopy(cgienv->http_accept,txt); }
 cgienv->ptr[i]=cgienv->content_type; if(GetEnvironmentVariable("CONTENT_TYPE",(CP)txt,sizeof(cgienv->content_type))!=0) { aaStringCopy(cgienv->content_type,txt); }
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/


 B aa_NetCgiClientUpdate               (H handle)
 {
 B ret;
 _aa_netcgiclientobject*cgop;
 //H thandle;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if((ret=aa_ObjectCheck(aa.net_system.cgiclient_object_id,handle,(VP)&cgop,0))!=RET_YES) { oops; return ret; }
 //thandle=cgop->thread.handle;
 //if(thandle) {}
 if(cgop->c2s_que.handle!=0)
  {
  if((ret=aaQueStatus(cgop->c2s_que.handle,&cgop->c2s_que.status))!=YES) { oops; }
  cgop->status.xmit_bytes=cgop->c2s_que.status.bytes;
  cgop->status.total_xmit_bytes=cgop->c2s_que.status.total_bytes_written;
  }
 if(cgop->s2c_que.handle!=0)
  {
  if((ret=aaQueStatus(cgop->s2c_que.handle,&cgop->s2c_que.status))!=YES) { oops; }
  cgop->status.rcve_bytes=cgop->s2c_que.status.bytes;
  cgop->status.total_rcve_bytes=cgop->s2c_que.status.total_bytes_read;
  }
 aaTimerTikElapsed(cgop->ms_root,&cgop->status.ms);
 aaTimerTikElapsed(cgop->inactive_rcve_ms_root,&cgop->status.rcve_inactivity);
 aaTimerTikElapsed(cgop->inactive_xmit_ms_root,&cgop->status.xmit_inactivity);
 if(cgop->status.rcve_bytes==0) { cgop->status.line_inactivity=0;  }
 else                           { aaTimerTikElapsed(cgop->inactive_line_ms_root,&cgop->status.line_inactivity);}
 return RET_YES;
 }








 B aa_NetCgiClientPseudoThread         (H handle)
 {
 B ret;
 B read_buff[_64K-_1K];
 B doupdate;
 _aa_netcgiclientobject*cgop;
 H todo,done,r,avail;
 H thismsg;
 //DWORD mode;
 BOOL rr;

 if((ret=aa_ObjectCheck(aa.net_system.cgiclient_object_id,handle,(VP)&cgop,0))!=RET_YES) { oops;  }
 cgop->is_running=1;
 while(1)
  {
  doupdate=NO;
  UNUSE(doupdate);
  if((todo=aaNumRoof(cgop->status.xmit_bytes,(sizeof(read_buff)-10)))!=0)
   {
   if(aaQuePeek(cgop->c2s_que.handle,0,todo,read_buff)==YES)
    {
    if(WriteFile(cgop->in_write,read_buff,todo,&done,NULL)==0)
     {
     r=GetLastError();
     if(r==ERROR_NO_DATA||r==ERROR_BROKEN_PIPE) { cgop->status.is_exited=YES;  }
     else                                       { cgop->status.is_failed=YES;  }
     }
    else
     {
     if(done>0)
      {
      if(done!=todo)
       {
       }
      if((ret=aaQueDiscard(cgop->c2s_que.handle,done))!=YES) { aaNote(0,"%s have=%i doing=%i",ret_string[ret],cgop->c2s_que.status.bytes,done); }
      aaNetCgiClientInactivityReset(handle,NO,YES);
      doupdate=YES;
      }
     }
    }
   }
  if((rr=PeekNamedPipe(cgop->out_read,0,0,0,&avail,&thismsg))==0)
   {
   cgop->status.is_exited=YES;
   }
  else
   {
   if(avail!=0)
    {
    todo=avail;
    todo=aaNumRoof(todo,(sizeof(read_buff)-1));
    rr=ReadFile(cgop->out_read,read_buff,todo,&done,NULL);
    if(rr==0)
     {
     r=GetLastError();
     if(cgop->status.is_exited==NO)
      {
      if(r==ERROR_BROKEN_PIPE) {  oof;  cgop->status.is_exited=YES;  oof; }         else
      if(r==ERROR_NO_DATA) {  oof; }
      else { oof;  }
      }
     aaNote(0,"lasterr=%i",r);
     oof;
     }
    if(done!=todo) oof;
    if(done==0) oof;
    if((ret=aaQueWrite(cgop->s2c_que.handle,done,read_buff))!=YES) { oops; }
    aaNetCgiClientInactivityReset(handle,YES,NO);
    doupdate=YES;
    }
   }
  if(doupdate) { aa_NetCgiClientUpdate(handle);   }
  break;
  }
 cgop->is_running=2;
 return RET_YES;
 }






///=====================================================

 structure
 {
 Q first_utc;
 Q last_utc;
 _dnsstatus dns_status;
 }
 _dnscachelistdata;






 V aa_NetDnsYield                      (PP mem)
 {
 B ret;
 H ip;
 _aa_netdnsobject*narp;
 _DNS_HEADER*dns=NULL;
 _DNS_QUESTION*qinfo=NULL;
 _DNS_SOA dnssoap;
 B tok[_1K];
 BP qname=NULL;
 BP reader;
 H i,j,sl,mod;
 H li;
 BP kp,vp;
 Z stop;
 B rrr[_4K];
 _dnscachelistdata dcld;
 _dnscachelistdata*dcldptr;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaCast(narp,_aa_netdnsobject*,*mem);
 aaTimerTikElapsed(narp->ms_tik,&narp->status.ms);
 dns=(_DNS_HEADER *)&narp->buf;

 switch(narp->stage)
  {
  case 100:
  ip=0;
  if((ret=aaNetUdpCreate(&narp->udp.handle,ip,0))!=YES) oops;
  aaNetUdpStatus(narp->udp.handle,&narp->udp.status);
  narp->stage=120;
  break;

  case 120:
  narp->status.attempt++;
  narp->id_match=(W)aaMathRand32(0,F16);
  dns->id=narp->id_match;
  dns->qr=0;
  dns->opcode=0;
  dns->aa=0;
  dns->tc=0;
  dns->rd=1;
  dns->ra=0;
  dns->z=0;
  dns->ad=0;
  dns->cd=0;
  dns->rcode=0;
  dns->q_count=htons(1);
  dns->ans_count=0;
  dns->auth_count=0;
  dns->add_count=0;
  qname=(BP)&narp->buf[sizeof(_DNS_HEADER)];
  aaStringCopyf(narp->dnsName,"%s",narp->status.query);
  aaStringLen(narp->dnsName,&narp->dnsName_sl);
  aa_NetDnsToFormat(narp->dnsName);
  aaStringLen(narp->dnsName,&narp->dnsName_sl);
  for(i=0;i<narp->dnsName_sl;i++) { *(qname+i)=narp->dnsName[i]; }
  *(qname+i)=0;
  qinfo=(_DNS_QUESTION*)&narp->buf[sizeof(_DNS_HEADER)+narp->dnsName_sl+1];
  qinfo->qtype=htons(narp->status.mode);
  qinfo->qclass=htons(1);
  narp->stage=140;
  break;

  case 140:
  mod=(narp->status.attempt-1)%4;
  //mod=3;
  mod=aaMathRand32(0,3);
  switch(mod)
   {
   case 0:      aaNetIpFromString("8.8.8.8",&ip);        break;
   case 1:      aaNetIpFromString("208.67.222.222",&ip); break;
   case 2:      aaNetIpFromString("8.8.4.4",&ip);        break;
   case 3:      aaNetIpFromString("208.67.220.220",&ip); break;
   }
  //aaNetIpFromString("10.0.0.138",&ip);
  //aaDebugf("attempt=%i mod=%i",narp->status.attempt,mod);
  narp->outlen=(H)sizeof(_DNS_HEADER)+narp->dnsName_sl+1+(H)sizeof(_DNS_QUESTION);
  if((ret=aaNetUdpPktSet(&narp->o_pkt,ip,53,0))!=YES) oops;
  if((ret=aaNetUdpPktAppend(&narp->o_pkt,narp->outlen,narp->buf))!=YES) oops;
  if((ret=aaNetUdpPktWrite(narp->udp.handle,&narp->o_pkt))!=YES) { oops; }
  aaTimerInit(&narp->tm,1);
  narp->stage=160;
  break;

  case 160:
  aaTimerUpdate(&narp->tm,1);
  if(narp->tm.elapsed>=narp->timeout)
   {
   //aaDebugf("udpdns timeout");
   narp->timeout+=250;
   if(narp->timeout>3000) narp->timeout=3000;
   narp->stage=120;
   break;
   }
  if((ret=aaNetUdpStatus(narp->udp.handle,&narp->udp.status))!=YES) oops;
  ret=aaNetUdpPktRead(narp->udp.handle,&narp->i_pkt);
  if(ret==RET_NOTREADY) break;
  if(ret!=YES) { oops; break; }
  narp->stage=180;
  break;

  case 180:
  aaMemoryCopy(narp->buf,narp->i_pkt.data_bytes,&narp->i_pkt.data[0]);
  if(narp->i_pkt.address.ip!=narp->o_pkt.address.ip)   {   narp->stage=160;   break;   }
  if(dns->id!=narp->id_match)   {   narp->stage=160;   break;   }
  //aaDebugf("rcode=%i stage=%i fwd=%i if=%i inf=%i isf=%i",dns->rcode,narp->stage,narp->status.is_forward,narp->status.is_found,narp->status.is_notfound,narp->status.is_failed);
  if(dns->rcode==3)
   {
   narp->status.is_inprogress=NO;
   narp->status.is_found=NO;
   narp->status.is_notfound=YES;
   narp->status.is_failed=NO;
   narp->stage=200;
   break;
   }
  reader=&narp->buf[sizeof(_DNS_HEADER)+narp->dnsName_sl+1+sizeof(_DNS_QUESTION)];
  stop=0;
  for(i=0;i<ntohs(dns->ans_count);i++)
   {
   aa_NetDnsReadName(reader,narp->buf,&stop,rrr);
   aaStringCopyf(narp->answers[i].name,"%s",rrr);
   reader=reader+stop;
   narp->answers[i].resource=(_DNS_R_DATA*)(reader);
   reader=reader+sizeof(_DNS_R_DATA);
   narp->answers[i].rdata_off=0;
   switch(ntohs(narp->answers[i].resource->type))
    {
    case 1: //if its an ipv4 address
    aaStringNull(narp->answers[i].rdata);
    for(j=0;j<ntohs(narp->answers[i].resource->data_len);j++)
     {
     narp->answers[i].rdata[narp->answers[i].rdata_off]=reader[j];
     narp->answers[i].rdata_off++;
     }
    reader=reader+ntohs(narp->answers[i].resource->data_len);
    break;

    case 2: // NS
    aaStringNull(narp->answers[i].rdata);
    aa_NetDnsReadName(reader,narp->buf,&stop,rrr);
    aaStringLen(rrr,&sl);
    aaStringCopyf(&narp->answers[i].rdata[narp->answers[i].rdata_off],"%s",rrr);
    narp->answers[i].rdata_off+=(sl+1);
    reader=reader+stop;
    break;

    case 5: // cname
    aaStringNull(narp->answers[i].rdata);
    aa_NetDnsReadName(reader,narp->buf,&stop,rrr);
    aaStringCopyf(&narp->answers[i].rdata[narp->answers[i].rdata_off],"%s",rrr);
    reader=reader+ntohs(narp->answers[i].resource->data_len);
    break;

    case 6:
    aaStringNull(narp->answers[i].rdata);
    aa_NetDnsReadName(reader,narp->buf,&stop,rrr);
    aaStringCopyf(&narp->answers[i].rdata[0],"%s",rrr);
    narp->answers[i].rdata_off+=128;
    reader=reader+stop;
    aa_NetDnsReadName(reader,narp->buf,&stop,rrr);
    aaStringCopyf(&narp->answers[i].rdata[128],"%s",rrr);
    reader=reader+stop;
    aaMemoryCopy(&narp->answers[i].rdata[256],sizeof(H)*5,reader);
    break;


    case 15: // mx
    narp->answers[i].pref=reader[1]+256*reader[0];
    reader+=2;
    aa_NetDnsReadName(reader,narp->buf,&stop,rrr);
    aaStringLen(rrr,&sl);
    aaStringCopyf(&narp->answers[i].rdata[narp->answers[i].rdata_off],"%s",rrr);
    narp->answers[i].rdata_off+=(sl+1);
    reader=reader+(ntohs(narp->answers[i].resource->data_len)-2);
    break;

    case 16: // txt
    aaStringNull(narp->answers[i].rdata);
    aa_NetDnsReadName(reader,narp->buf,&stop,rrr);
    aaStringCopyf(&narp->answers[i].rdata[narp->answers[i].rdata_off],"%s",rrr);
    reader=reader+ntohs(narp->answers[i].resource->data_len);
    break;

    default:
    aaNote(0,"!%s type=%u len=%u stop=%i",narp->answers[i].name,ntohs(narp->answers[i].resource->type),ntohs(narp->answers[i].resource->data_len),stop);
    reader=reader+ntohs(narp->answers[i].resource->data_len);
    break;
    }
   }
  for(i=0;i<ntohs(dns->auth_count);i++)
   {
   aa_NetDnsReadName(reader,narp->buf,&stop,rrr);
   aaStringCopyf(narp->auth[i].name,"%s",rrr);
   reader+=stop;
   narp->auth[i].resource=(_DNS_R_DATA*)(reader);
   reader+=sizeof(_DNS_R_DATA);
   aa_NetDnsReadName(reader,narp->buf,&stop,rrr);
   aaStringLen(rrr,&sl);
   aaStringCopyf(&narp->auth[i].rdata[narp->auth[i].rdata_off],"%s",rrr);
   narp->auth[i].rdata_off+=(sl+1);
   reader+=stop;
   }
  for(i=0;i<ntohs(dns->add_count);i++)
   {
   aa_NetDnsReadName(reader,narp->buf,&stop,rrr);
   aaStringCopyf(narp->addit[i].name,"%s",rrr);
   reader+=stop;
   narp->addit[i].resource=(_DNS_R_DATA*)(reader);
   reader+=sizeof(_DNS_R_DATA);
   if(ntohs(narp->addit[i].resource->type)==1)
    {
    aaStringNull(narp->addit[i].rdata);
    narp->addit[i].rdata_off=0;
    for(j=0;j<ntohs(narp->addit[i].resource->data_len);j++)
     {
     narp->addit[i].rdata[narp->addit[i].rdata_off]=reader[j];
     narp->addit[i].rdata_off++;
     }
    reader+=ntohs(narp->addit[i].resource->data_len);
    }
   else
    {
    aa_NetDnsReadName(reader,narp->buf,&stop,rrr);
    aaStringLen(rrr,&sl);
    aaStringCopyf(&narp->addit[i].rdata[narp->addit[i].rdata_off],"%s",rrr);
    narp->addit[i].rdata_off+=(sl+1);
    reader+=stop;
    }
   }
  for(i=0;i<ntohs(dns->ans_count);i++)
   {
   switch(ntohs(narp->answers[i].resource->type))
    {
    case 1:  //IPv4 address
    aaStringCopyf(narp->status.host[narp->status.result_count],"%s",narp->answers[i].name);
    narp->status.type[narp->status.result_count]=aa_DNS_MODE_A;
    narp->status.ttl[narp->status.result_count]=aaNumSwapDword(narp->answers[i].resource->ttl);
    narp->status.ip[narp->status.result_count]=*(HP)&narp->answers[i].rdata[0];
    narp->status.result_count++;
    break;

    case 2: //NS Record
    narp->status.type[narp->status.result_count]=aa_DNS_MODE_NS;
    narp->status.ttl[narp->status.result_count]=aaNumSwapDword(narp->answers[i].resource->ttl);
    aaStringCopyf(narp->status.host[narp->status.result_count],"%s",narp->answers[i].rdata);
    narp->status.result_count++;
    break;

    case 5:   //Canonical name for an alias
    narp->status.type[narp->status.result_count]=aa_DNS_MODE_CNAME;
    narp->status.ttl[narp->status.result_count]=aaNumSwapDword(narp->answers[i].resource->ttl);
    aaStringCopyf(narp->status.name[narp->status.result_count],"%s",narp->answers[i].rdata);
    narp->status.result_count++;
    break;

    case 6:
    narp->status.type[narp->status.result_count]=aa_DNS_MODE_SOA;
    narp->status.ttl[narp->status.result_count]=aaNumSwapDword(narp->answers[i].resource->ttl);
    aaStringCopyf(narp->status.host[narp->status.result_count],"%s",&narp->answers[i].rdata[0]);
    aaStringCopyf(narp->status.name[narp->status.result_count],"%s",&narp->answers[i].rdata[128]);
    aaMemoryCopy(&dnssoap.serial,sizeof(H)*5,&narp->answers[i].rdata[256]);
    narp->status.data[narp->status.result_count][0]=ntohl(dnssoap.serial);
    narp->status.data[narp->status.result_count][1]=ntohl(dnssoap.refresh);
    narp->status.data[narp->status.result_count][2]=ntohl(dnssoap.retry);
    narp->status.data[narp->status.result_count][3]=ntohl(dnssoap.expire);
    narp->status.data[narp->status.result_count][4]=ntohl(dnssoap.minimum);
    narp->status.result_count++;
    break;

    case 15: //MX Record
    narp->status.type[narp->status.result_count]=aa_DNS_MODE_MX;
    narp->status.ttl[narp->status.result_count]=aaNumSwapDword(narp->answers[i].resource->ttl);
    aaStringCopyf(narp->status.host[narp->status.result_count],"%s",narp->answers[i].rdata);
    narp->status.priority[narp->status.result_count]=narp->answers[i].pref;
    narp->status.result_count++;
    break;

    case 16: // txt
    narp->status.ttl[narp->status.result_count]=aaNumSwapDword(narp->answers[i].resource->ttl);
    aaStringCopyf(narp->status.etc[narp->status.result_count],"%s",narp->answers[i].rdata);
    narp->status.result_count++;
    break;

    default:
    aaNote(0,"      res type=%u",ntohs(narp->answers[i].resource->type));
    break;
    }
   if(narp->status.result_count>=aaElementCount(narp->status.ip)) { break; }
   }

  for(i=0;i<ntohs(dns->auth_count);i++)
   {
   aaNote(0,"Nam1: %s",narp->auth[i].name);
   if(ntohs(narp->auth[i].resource->type)==2)
    {
    aaNote(0,"      has authoritative nameserver : %s",narp->auth[i].rdata);
    }
   }

  for(i=0;i<ntohs(dns->add_count);i++)
   {
   aaNote(0,"Nam2: %s ",narp->addit[i].name);
   if(ntohs(narp->addit[i].resource->type)==1)
    {
    aaNetIpToString(*(HP)&narp->addit[i].rdata[0],tok);
    aaNote(0,"      has IPv4 address :  %s",tok);
    }
   }

  narp->status.is_inprogress=NO;
  if(narp->status.result_count==0) { narp->status.is_notfound=YES; narp->status.is_found=NO; }
  else                             { narp->status.is_found=YES; narp->status.is_notfound=NO; }
  narp->status.is_failed=NO;

  if(narp->status.is_found==YES&&narp->status.is_notfound==NO&&narp->status.is_failed==NO)
   {
   if(narp->status.is_forward==NO)
    {
    if(narp->status.mode==aa_DNS_MODE_A)
     {
     if(aa.net_system.dns_cache.magic!=aaHPP(aaListNew))
      {
      if((ret=aaListNew(&aa.net_system.dns_cache,YES,_64K,NO,NO))!=YES) { oops; }

//      aaDebugf("dns_cache created");
      }
     ret=aaListFind(&aa.net_system.dns_cache,&li,(VP)&kp,(VP)&vp,"%s",narp->status.query);
     if(ret==RET_NOTFOUND)
      {
      aaTimeUtcExGet(&dcld.first_utc);
      aaTimeUtcExGet(&dcld.last_utc);
      aaMemoryCopy(&dcld.dns_status,sizeof(_dnsstatus),&narp->status);
      if((ret=aaListAppend(&aa.net_system.dns_cache,&li,narp->status.query,sizeof(_dnscachelistdata),&dcld))!=YES) { oops; }
      }
     else
     if(ret==RET_YES)
      {
      dcldptr=(_dnscachelistdata*)vp;
      aaTimeUtcExGet(&dcldptr->last_utc);
      }
     else
      {
      aaDebugf("%s find li=%i kp=%s ",arets,li,kp);
      }
     }
    }
   }


  narp->stage=200;
  break;

  case 200:
  break;
  }
 }


///   aaDebugf("stage=%i fwd=%i if=%i inf=%i isf=%i",narp->stage,narp->status.is_forward,narp->status.is_found,narp->status.is_notfound,narp->status.is_failed);





 V aa_NetDnsReadName                   (BP reader,BP buffer,ZP count,BP name)
 {
 H offset,jumped=0;

 aaStringNull(name);
 *count=1;
 while(*reader!=0)
  {
  if(*reader>=192) {  offset=(*reader)*256+*(reader+1)-49152;  reader=buffer+offset-1;   jumped=1;   }
  else             {  aaStringAppendChar(name,*reader);   }
  reader=reader+1;
  if(jumped==0) *count=*count+1;
  }
 if(jumped==1) *count=*count+1;
 aaStringAppendChar(name,0);
 aa_NetDnsFromFormat(name);
 }






 V aa_NetDnsToFormat                   (VP outdns)
 {
 B txt[_1K];
 BP bp;
 H sl,i,o,len,oo,n=0,pos,opos;
 B outp[_1K];

 aaCast(bp,BP,outdns);
 aaStringLen(outdns,&sl);
 oo=i=o=0;
 opos=0;
 aaStringNull(outp);
 while(1)
  {
  if(aaStringFindChar(outdns,sl,&pos,'.',YES,n,YES)!=YES) { oo=(sl-opos)-0; }
  else { oo=pos-opos; }
  aaStringCopyfLen(txt,&len,"%u",oo);
  outp[o]=oo; o++;
  aaStringNCopy(&outp[o],&bp[opos],oo,YES);     o+=oo;
  n++;
  opos+=(oo+1);
  if(pos==0xffffffff)  {   outp[o]=0; o++;   break;  }
  }
 aaStringCopyf(outdns,"%s",outp);
 }




 V aa_NetDnsFromFormat                 (VP outhost)
 {
 BP dns;
 H sl,len,i,o;
 B outp[_1K];

 aaCast(dns,BP,outhost);
 aaStringLen(dns,&sl);
 aaStringNull(outp);
 i=o=0;
 while(i<sl)
  {
  len=dns[i];
  if(len==0) break;
  i++;
  aaStringNCopy(&outp[o],&dns[i],len,NO);
  o+=len;
  i+=len;
  if((sl-i)>1) {  outp[o]='.';             o++; }
  outp[o]=0;
  }
 outp[o]=0;
 aaStringCopyf(dns,"%s",outp);
 }




///=====================================================

 B aa_NetAsn1LenGet                    (VP mem,HP used,HP len)
 {
 H u,l;
 BP p;

 u=0;
 l=0;
 if(used) { *used=u; }
 if(len) { *len=0; }
 p=(BP)mem;
 if((p[u]&0x80)==0)
  {
  l=p[u];
  u=1;
  }
 else
  {
  switch((p[u]&0x7f))
   {
   case 1:
   l=p[u+1];
   u=2;
   break;
   case 2:
   l=(p[u+1]<<8)|(p[u+2]);
   u=3;
   break;
   case 3:
   l=(p[u+1]<<16)|((p[u+2]<<8))|(p[u+3]);
   u=4;
   break;
   case 4:
   l=(p[u+1]<<24)|((p[u+2]<<16))|(p[u+3]<<8)|(p[u+4]);
   u=5;
   break;
   default:
   oof;
   return RET_FAILED;
   }
  }
 if(used) { *used=u; }
 if(len) { *len=l; }
 return RET_YES;
 }



 B aa_NetTls2201Write                  (PP obtr)
 {
 _aa_nettcpcallobject*calp;
 B buf[_2K];
 B hdr[_1K];
 H off;
 H len;
 H i,num;
 BP sp,dp;
 struct timeval tv;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(obtr==NULL)  { return RET_BADPARM; }
 aaCast(calp,_aa_nettcpcallobject*,*obtr);
 aaTimeGetOfDay(&tv);
 aaMemoryFill(buf,sizeof(buf),0);
 off=0;
 buf[off+0]=0x01; // msg type=client_hello
 buf[off+1]=0x00;
 buf[off+2]=0x00; // u24 msg len
 buf[off+3]=0x00;
 off+=4;
 buf[off+0]=0x03; // version
 buf[off+1]=0x01;
 buf[off+2]=(B)(((H)tv.tv_sec&0xff000000)>>24);
 buf[off+3]=(B)(((H)tv.tv_sec&0x00ff0000)>>16);
 buf[off+4]=(B)(((H)tv.tv_sec&0x0000ff00)>>8);
 buf[off+5]=(B)(((H)tv.tv_sec&0x000000ff));
 off+=6;
 aaMemoryRandomSet(&buf[off],28);
 off+=28;
 buf[off+0]=0; // no sesh
 off+=1;
 num=4;
 buf[off+0]=((num*2)/256);
 buf[off+1]=((num*2)%256);
 off+=2;
 for(i=0;i<num;i++)
  {
  switch(i)
   {
   case 0:  buf[off+0]=0x00;  buf[off+1]=0x04;  off+=2; break;// SSL_RC4_128_MD5 0x04
   case 1:  buf[off+0]=0x00;  buf[off+1]=0x05;  off+=2; break;// SSL_RC4_128_SHA 0x05
   case 2:  buf[off+0]=0x00;  buf[off+1]=0x2f;  off+=2; break;// SSL_AES128_SHA  0x2f
   case 3:  buf[off+0]=0x00;  buf[off+1]=0x35;  off+=2; break;// SSL_AES256_SHA  0x35
   default: oof; break;
   }
  }
 buf[off+0]=0x01; // 1 compression method
 buf[off+1]=0x00; // no compression
 off+=2;
 len=off-4;
 sp=(BP)&len;
 dp=(BP)&buf[1];
 dp[0]=sp[2];
 dp[1]=sp[1];
 dp[2]=sp[0];
 len=off;
 hdr[0]=22;
 hdr[1]=0x03;
 hdr[2]=0x01;
 hdr[3]=(len/256);
 hdr[4]=(len%256);
 aaNetTcpCallWrite(calp->self_handle,5,hdr);
 aaNetTcpCallWrite(calp->self_handle,len,buf);
 aaNetTcpCallStatus(calp->self_handle,&calp->status);
 return RET_YES;
 }




 B aa_NetTls2202Rcvd                   (PP obtr)
 {
 BP bp,cp,pp;
 _aa_nettcpcallobject*calp;
 H len,size,left;
 H epoch;
 B randy[28];
 B sesh_len;
 B sesh[256];
 W chosen;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(obtr==NULL)  { return RET_BADPARM; }
 aaCast(calp,_aa_nettcpcallobject*,*obtr);
 bp=(BP)calp->tlssys.in.mem;
 cp=(BP)&bp[5];
 len=(bp[3]*256)+bp[4];
 size=(cp[1]*65536)+(cp[2]*256)+(cp[3]);
 calp->tlssys.p_off=6;
 left=len-calp->tlssys.p_off;
 pp=(BP)&epoch;
 pp[3]=cp[calp->tlssys.p_off+0];
 pp[2]=cp[calp->tlssys.p_off+1];
 pp[1]=cp[calp->tlssys.p_off+2];
 pp[0]=cp[calp->tlssys.p_off+3];
 aaMemoryCopy(randy,28,&cp[calp->tlssys.p_off+4]);
 calp->tlssys.p_off+=32;
 sesh_len=cp[calp->tlssys.p_off+0];
 calp->tlssys.p_off+=1;
 if(sesh_len)
  {
  aaMemoryCopy(sesh,sesh_len,&cp[calp->tlssys.p_off+0]);
  calp->tlssys.p_off+=sesh_len;
  }
 aaMemoryCopy(&chosen,2,&cp[calp->tlssys.p_off+0]);
 chosen=aaNumSwapWord(chosen);
 calp->tlssys.p_off+=2;
 aaDebugf("epoch=%x",epoch);
 aaDebugf("sesh_len=%i",sesh_len);
 aaDebugf("chosen=%x",chosen);
 left=len-calp->tlssys.p_off;
 aaDebugf("len=%i off=%i left=%i",len,calp->tlssys.p_off,left);
 calp->tlssys.p_off+=size;
 return RET_YES;
 }




 B aa_NetTls220bRcvd                   (PP obtr)
 {
 BP bp,cp;
 _aa_nettcpcallobject*calp;
 H len,size,left;
 H used,length;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(obtr==NULL)  { return RET_BADPARM; }
 aaCast(calp,_aa_nettcpcallobject*,*obtr);
 bp=(BP)calp->tlssys.in.mem;
 cp=(BP)&bp[5];
 len=(bp[3]*256)+bp[4];
 size=(cp[1]*65536)+(cp[2]*256)+(cp[3]);
 calp->tlssys.p_off=4;
 left=len-calp->tlssys.p_off;
 aaDebugf("p_off=%i + size=%i = %i",calp->tlssys.p_off,size,calp->tlssys.p_off+size);
 aa_NetAsn1LenGet(&cp[calp->tlssys.p_off+0],&used,&length);
 aaDebugf("used=%i length=%i",used,length);
 if(left) {}
 calp->tlssys.p_off+=size;
 return RET_YES;
 }





 B aa_NetTls220eRcvd                   (PP obtr)
 {
 BP bp,cp;
 _aa_nettcpcallobject*calp;
 H len,size,left;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(obtr==NULL)  { return RET_BADPARM; }
 aaCast(calp,_aa_nettcpcallobject*,*obtr);
 bp=(BP)calp->tlssys.in.mem;
 cp=(BP)&bp[5];
 len=(bp[3]*256)+bp[4];
 size=(cp[1]*65536)+(cp[2]*256)+(cp[3]);
 left=len-calp->tlssys.p_off;
 aaDebugf("p_off=%i + size=%i = %i",calp->tlssys.p_off,size,calp->tlssys.p_off+size);
 calp->tlssys.p_off+=size;
 if(left) {}
 return RET_YES;
 }





 B aa_NetTlsYield                      (PP obtr)
 {
 B ret;
 B buf[_4K];
 B txt[_4K];
 H len,left,todo;//,size;
 BP bp,cp;
 _aa_nettcpcallobject*calp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(obtr==NULL)  { return RET_BADPARM; }
 aaCast(calp,_aa_nettcpcallobject*,*obtr);
 if(calp->status.is_tls==NO) { return RET_YES; }
 if(calp->status.is_connected!=YES) { return RET_NOTREADY; }
 switch(calp->tlssys.stage)
  {
  case 0:
  calp->tlssys.stage=100;
  break;



  case 100:
  aaDebugf("About to send clienthello");
  aa_NetTls2201Write((PP)&calp); // sent clienthello
  calp->tlssys.stage=115;
  break;



  case 115:
  if(calp->tlssys.in.bytes==0)
   {
   aaDebugf("about to allocate tlssys.in,_20K");
   if((ret=aaMemoryUnitAllocate(&calp->tlssys.in,_20K))!=YES) { oops; }
   }
  calp->tlssys.in.used=0;
  calp->tlssys.stage=120;
  break;



  case 120:
  if(calp->status.rcve_bytes<5) { break; }
  aaNetTcpCallPeek(calp->self_handle,0,5,buf);
  len=(buf[3]*256)+buf[4];
  if(calp->status.rcve_bytes<(len+5)) { break; }
  left=calp->tlssys.in.bytes-calp->tlssys.in.used;
  if((len+5+_2K)>=left)
   {
   aaDebugf("about to re-allocate tlssys.in,%i",len+5+_8K);
   if((ret=aaMemoryUnitReAllocate(&calp->tlssys.in,len+5+_8K))!=RET_YES) { oops; }
   }
  if(aaNetTcpCallRead(calp->self_handle,len+5,calp->tlssys.in.mem)!=YES) { oof; }
  bp=(BP)calp->tlssys.in.mem;
  cp=(BP)&bp[5];
  aaDebugf("type=%02x ver=%i.%i len=%i",bp[0],bp[1],bp[2],len);
  aaStringFromArrayHex(txt,1,5,32,YES,YES,bp);
  aaDebugf("%s",txt);
  todo=aaNumRoof(len,123);
  aaStringFromArrayHex(txt,1,todo,32,YES,YES,cp);
  aaDebugf("%s",txt);
  if(bp[0]==22)
   {
   calp->tlssys.stage=1000;
   break;
   }
  calp->tlssys.stage=115;
  break;



  case 1000:
  bp=(BP)calp->tlssys.in.mem;
  cp=(BP)&bp[5];
  len=(bp[3]*256)+bp[4];
  if(len>=1&&cp[0]==0x02)   {   calp->tlssys.stage=1100;   break;   }
  if(len>=1&&cp[0]==0x0b)   {   calp->tlssys.stage=1300;   break;   }
  if(len>=1&&cp[0]==0x0e)   {   calp->tlssys.stage=1500;   break;   }
  aaDebugf("unhandled 1000");
  calp->tlssys.stage=115;
  break;

  case 1100:
  //bp=(BP)calp->tlssys.in.mem;
  //cp=(BP)&bp[5];
  //len=(bp[3]*256)+bp[4];
  //size=(cp[1]*65536)+(cp[2]*256)+(cp[3]);
  //aaDebugf("serverhello size=%i",size);
  //calp->tlssys.p_off=0;
  aa_NetTls2202Rcvd((PP)&calp);
  calp->tlssys.stage=115;
  break;

  case 1300:
 // bp=(BP)calp->tlssys.in.mem;
 // cp=(BP)&bp[5];
 // len=(bp[3]*256)+bp[4];
 // size=(cp[1]*65536)+(cp[2]*256)+(cp[3]);
 // aaDebugf("servercert size=%i",size);
 // calp->tlssys.p_off=0;
  aa_NetTls220bRcvd((PP)&calp);
  calp->tlssys.stage=115;
  break;

  case 1500:
 // bp=(BP)calp->tlssys.in.mem;
 // cp=(BP)&bp[5];
 // len=(bp[3]*256)+bp[4];
 // size=(cp[1]*65536)+(cp[2]*256)+(cp[3]);
 // aaDebugf("serverdone size=%i",size);
 // calp->tlssys.p_off=0;
  aa_NetTls220eRcvd((PP)&calp);
  calp->tlssys.stage=115;
  break;
  }

 return RET_YES;
 }





///=====================================================


 B aaNetCgiClientCreate                (HP handle,B hidden,VP env,VP dir,VP processfilename,VP command)
 {
 B ret;
 _aa_netcgiclientobject*cgop;
 HANDLE out_read_temp,out_write,input_write_temp,input_read;
 HANDLE error_write;
 SECURITY_ATTRIBUTES sa;
 H err,go;
 B apcl[_1K];
 B is_attach;
 DWORD mode;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(processfilename==NULL) { return RET_BADPARM; }
 if((ret=aa_ObjectCreate(aa.net_system.cgiclient_object_id,handle,(VP)&cgop))!=RET_YES)  { oops; return ret;  }
 cgop->self_handle=*handle;
 aaTimerTikGet(&cgop->ms_root);
 cgop->inactive_rcve_ms_root=cgop->ms_root;
 cgop->inactive_xmit_ms_root=cgop->ms_root;
 cgop->inactive_line_ms_root=cgop->ms_root;
 cgop->status.ms=0;
 cgop->status.rcve_inactivity=0;
 cgop->status.xmit_inactivity=0;
 cgop->status.line_inactivity=0;
 while(1)
  {
  if((ret=aaQueCreate(&cgop->c2s_que.handle))!=YES) { break;  }
  if((ret=aaQueCreate(&cgop->s2c_que.handle))!=YES) { break;  }
  break;
  }
 if(ret!=YES)
  {
  if(cgop->c2s_que.handle!=0) { aaQueDestroy(cgop->c2s_que.handle); cgop->c2s_que.handle=0;  }
  if(cgop->s2c_que.handle!=0) { aaQueDestroy(cgop->s2c_que.handle); cgop->s2c_que.handle=0;  }
  aa_ObjectDestroy(aa.net_system.cgiclient_object_id,*handle);
  *handle=0;
  return ret;
  }
 sa.nLength=sizeof(SECURITY_ATTRIBUTES);
 sa.lpSecurityDescriptor=NULL;
 sa.bInheritHandle=TRUE;
 err=0;
 while(1)
  {
  if(!CreatePipe(&out_read_temp,&out_write,&sa,0)) { err=1; break;  }
  if(!DuplicateHandle(GetCurrentProcess(),out_write,GetCurrentProcess(),&error_write,0,TRUE,DUPLICATE_SAME_ACCESS)) { err=2; break;}
  if(!CreatePipe(&input_read,&input_write_temp,&sa,0))   { err=3; break;}
  if(!DuplicateHandle(GetCurrentProcess(),out_read_temp,GetCurrentProcess(),&cgop->out_read,0,FALSE,DUPLICATE_SAME_ACCESS))  { err=4; break;}
  if(!DuplicateHandle(GetCurrentProcess(),input_write_temp,GetCurrentProcess(),&cgop->in_write,0,FALSE,DUPLICATE_SAME_ACCESS))    { err=5; break;}
  if(!CloseHandle(out_read_temp)) { err=6; break;} out_read_temp=0;
  if(!CloseHandle(input_write_temp)) { err=7; break;} input_write_temp=0;
  cgop->std_input=GetStdHandle(STD_INPUT_HANDLE);
  if(cgop->std_input==INVALID_HANDLE_VALUE) { oow; err=8; break;}
  ZeroMemory(&cgop->si,sizeof(STARTUPINFO));
  cgop->si.cb=sizeof(STARTUPINFO);
  cgop->si.dwFlags=STARTF_USESTDHANDLES;
  cgop->si.dwFlags|=STARTF_USESHOWWINDOW;
  if(hidden==YES) { cgop->status.is_hidden=YES; cgop->si.wShowWindow=SW_HIDE; }
  else            { cgop->status.is_hidden=NO; cgop->si.wShowWindow=SW_SHOW; }
  cgop->si.hStdOutput=out_write;
  cgop->si.hStdInput =input_read;
  cgop->si.hStdError =error_write;
  aaStringCopyf(apcl,"%s",processfilename);
  if(aaStringIsNull(command)==NO) { aaStringAppendf(apcl," %s",command); }
  //CREATE_NEW_CONSOLE
  //if(!aa.core_system.CreateProcWithLogin("Ash",NULL,NULL,1,NULL,NULL,CREATE_NEW_CONSOLE,env,dir,&cgop->si,&cgop->pi)) { oow; oow; aaNote(0,"%s\n%s",apcl,0); err=9; break;}
  if(!CreateProcess(0,(CP)apcl,NULL,NULL,TRUE,CREATE_NEW_CONSOLE,env,/*(CP)path*/dir,&cgop->si,&cgop->pi)) { oow; oow; aaNote(0,"%s\n%s",apcl,0); err=9; break;}
  if(!CloseHandle(cgop->pi.hThread)) { err=10; break;}
  if(!CloseHandle(out_write))  { err=11; break;}
  if(!CloseHandle(input_read)) { err=12; break;}
  if(!CloseHandle(error_write)) { err=13; break;}
  CloseHandle(cgop->std_input); cgop->std_input=0;
  cgop->status.tid=cgop->pi.dwThreadId;
  cgop->status.pid=cgop->pi.dwProcessId;
  cgop->status.thread_handle=cgop->pi.hThread;
  cgop->status.process_handle=cgop->pi.hProcess;
  aaQueStatus(cgop->c2s_que.handle,&cgop->c2s_que.status);
  aaQueStatus(cgop->s2c_que.handle,&cgop->s2c_que.status);
  break;
  }
 if(err!=0)
  {
  aaNote(0,"line=%i err=%i",__LINE__,err);
  cgop->is_running=NO;
  if(cgop->out_read!=0) { if(!cgop->out_read) { oow; } cgop->out_read=0; }
  if(cgop->in_write!=0) { if(!cgop->in_write) { oow; } cgop->in_write=0; }
  if(cgop->std_input!=0) { CloseHandle(cgop->std_input); cgop->std_input=0; }
  aaQueDestroy(cgop->s2c_que.handle);  cgop->s2c_que.handle=0;
  aaQueDestroy(cgop->c2s_que.handle);  cgop->c2s_que.handle=0;
  aa_ObjectDestroy(aa.net_system.cgiclient_object_id,*handle);
  *handle=0;
  return RET_FAILED;
  }
 cgop->obj_handle=*handle;
 go=0;
 while(1)
  {
  if(cgop->status.is_ready!=YES)
   {
   mode=PIPE_READMODE_BYTE|PIPE_NOWAIT;
   if(SetNamedPipeHandleState(cgop->in_write,&mode,0,0)!=0)
    {
    mode=PIPE_READMODE_BYTE|PIPE_NOWAIT;
    if(SetNamedPipeHandleState(cgop->out_read,&mode,0,0)!=0) { cgop->status.is_ready=YES; }
    }
   }
  if(cgop->status.is_ready==YES) { break; }
  is_attach=NO;
  if(AttachConsole(cgop->status.pid))
   {
   is_attach=YES;
   SetConsoleCtrlHandler(NULL,TRUE);
    //GenerateConsoleCtrlEvent(CTRL_C_EVENT,0);
   GenerateConsoleCtrlEvent(CTRL_C_EVENT,cgop->status.pid);
   }
  if(cgop->out_read!=0)   { CloseHandle(cgop->out_read); cgop->out_read=0; }
  if(cgop->in_write!=0)   { CloseHandle(cgop->in_write); cgop->in_write=0; }
  if(cgop->std_input!=0)  { CloseHandle(cgop->std_input);  cgop->std_input=0;  }
  if(is_attach)  {   SetConsoleCtrlHandler(NULL,FALSE);  FreeConsole();  }
  if(cgop->status.thread_handle)  { CloseHandle(cgop->status.thread_handle); cgop->status.thread_handle=0; }
  if(cgop->status.process_handle) { CloseHandle(cgop->status.process_handle); cgop->status.process_handle=0; }
  ////
  sa.nLength=sizeof(SECURITY_ATTRIBUTES);
  sa.lpSecurityDescriptor=NULL;
  sa.bInheritHandle=TRUE;
  err=0;
  while(1)
   {
   if(!CreatePipe(&out_read_temp,&out_write,&sa,0)) { err=1; break;  }
   if(!DuplicateHandle(GetCurrentProcess(),out_write,GetCurrentProcess(),&error_write,0,TRUE,DUPLICATE_SAME_ACCESS)) { err=2; break;}
   if(!CreatePipe(&input_read,&input_write_temp,&sa,0))   { err=3; break;}
   if(!DuplicateHandle(GetCurrentProcess(),out_read_temp,GetCurrentProcess(),&cgop->out_read,0,FALSE,DUPLICATE_SAME_ACCESS))  { err=4; break;}
   if(!DuplicateHandle(GetCurrentProcess(),input_write_temp,GetCurrentProcess(),&cgop->in_write,0,FALSE,DUPLICATE_SAME_ACCESS))    { err=5; break;}
   if(!CloseHandle(out_read_temp)) { err=6; break;} out_read_temp=0;
   if(!CloseHandle(input_write_temp)) { err=7; break;} input_write_temp=0;
   cgop->std_input=GetStdHandle(STD_INPUT_HANDLE);
   if(cgop->std_input==INVALID_HANDLE_VALUE) { oow; err=8; break;}
   ZeroMemory(&cgop->si,sizeof(STARTUPINFO));
   cgop->si.cb=sizeof(STARTUPINFO);
   cgop->si.dwFlags=STARTF_USESTDHANDLES;
   cgop->si.dwFlags|=STARTF_USESHOWWINDOW;
   if(hidden==YES) { cgop->status.is_hidden=YES; cgop->si.wShowWindow=SW_HIDE; }
   else            { cgop->status.is_hidden=NO; cgop->si.wShowWindow=SW_SHOW; }
   cgop->si.hStdOutput=out_write;
   cgop->si.hStdInput =input_read;
   cgop->si.hStdError =error_write;
   aaStringCopyf(apcl,"%s",processfilename);
   if(aaStringIsNull(command)==NO) { aaStringAppendf(apcl," %s",command); }
   if(!CreateProcess(0,(CP)apcl,NULL,NULL,TRUE,CREATE_NEW_CONSOLE,env,/*(CP)path*/dir,&cgop->si,&cgop->pi)) { oow; oow; aaNote(0,"%s\n%s",apcl,0); err=9; break;}
   if(!CloseHandle(cgop->pi.hThread)) { err=10; break;}
   if(!CloseHandle(out_write))  { err=11; break;}
   if(!CloseHandle(input_read)) { err=12; break;}
   if(!CloseHandle(error_write)) { err=13; break;}
   CloseHandle(cgop->std_input); cgop->std_input=0;
   cgop->status.tid=cgop->pi.dwThreadId;
   cgop->status.pid=cgop->pi.dwProcessId;
   cgop->status.thread_handle=cgop->pi.hThread;
   cgop->status.process_handle=cgop->pi.hProcess;
   aaQueStatus(cgop->c2s_que.handle,&cgop->c2s_que.status);
   aaQueStatus(cgop->s2c_que.handle,&cgop->s2c_que.status);
   break;
   }
  if(err!=0)
   {
   aaNote(0,"line=%i err=%i",__LINE__,err);
   cgop->is_running=NO;
   if(cgop->out_read!=0) { if(!cgop->out_read) { oow; } cgop->out_read=0; }
   if(cgop->in_write!=0) { if(!cgop->in_write) { oow; } cgop->in_write=0; }
   if(cgop->std_input!=0) { CloseHandle(cgop->std_input); cgop->std_input=0; }
   aaQueDestroy(cgop->s2c_que.handle);  cgop->s2c_que.handle=0;
   aaQueDestroy(cgop->c2s_que.handle);  cgop->c2s_que.handle=0;
   aa_ObjectDestroy(aa.net_system.cgiclient_object_id,*handle);
   *handle=0;
   return RET_FAILED;
   }
  if(go>=10) { oof; }
  go++;
  //aaDebugf("pipe mode go=%i",go);
  }
 return RET_YES;
 }




 B aaNetCgiClientDestroy               (H handle)
 {
 B ret;
 _aa_netcgiclientobject*cgop;
 B isprot;
 B is_attach;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if((ret=aa_ObjectCheck(aa.net_system.cgiclient_object_id,handle,(VP)&cgop,&isprot))!=RET_YES) { return ret; }
 if(isprot==YES) {  return RET_FORBIDDEN; }
 cgop->is_running=0;
 aaSleep(1);
 is_attach=NO;
 if(AttachConsole(cgop->status.pid))
  {
  is_attach=YES;
  SetConsoleCtrlHandler(NULL,TRUE);
  //GenerateConsoleCtrlEvent(CTRL_C_EVENT,0);
  GenerateConsoleCtrlEvent(CTRL_C_EVENT,cgop->status.pid);
  }
 if(cgop->out_read!=0)   { CloseHandle(cgop->out_read); cgop->out_read=0; }
 if(cgop->in_write!=0)   { CloseHandle(cgop->in_write); cgop->in_write=0; }
 if(cgop->std_input!=0)  { CloseHandle(cgop->std_input);  cgop->std_input=0;  }
 if(cgop->s2c_que.handle!=0) { aaQueDestroy(cgop->s2c_que.handle);  }
 if(cgop->c2s_que.handle!=0) { aaQueDestroy(cgop->c2s_que.handle);  }
 if(is_attach)  {   SetConsoleCtrlHandler(NULL,FALSE);  FreeConsole();  }
 if(cgop->status.thread_handle)  { CloseHandle(cgop->status.thread_handle);cgop->status.thread_handle=0; }
 if(cgop->status.process_handle) { CloseHandle(cgop->status.process_handle); cgop->status.process_handle=0; }
 aa_ObjectDestroy(aa.net_system.cgiclient_object_id,handle);
 return RET_YES;
 }






 B aaNetCgiClientStatus                (H handle,_cgiclientstatus*cgiclientstatus)
 {
 B ret;
 _aa_netcgiclientobject*cgop;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.cgiclient_object_id,handle,(VP)&cgop,0))!=RET_YES) { return ret; }
 aa_NetCgiClientPseudoThread(handle);
 if(cgiclientstatus) {  aaMemoryCopy(cgiclientstatus,sizeof(_cgiclientstatus),&cgop->status);  }
 if(cgop->status.is_failed) { return RET_FAILED; }
 return RET_YES;
 }





 B aaNetCgiClientWrite                 (H handle,H bytes,VP data)
 {
 B ret;
 _aa_netcgiclientobject*cgop;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.cgiclient_object_id,handle,(VP)&cgop,0))!=RET_YES) { return ret; }
 if(bytes==0) { return RET_YES; }
 if(data==NULL) { return RET_BADPARM; }
 while(1)
  {
  if(cgop->status.is_exited==YES||cgop->status.is_failed==YES) { break; }
  if((ret=aaQueWrite(cgop->c2s_que.handle,bytes,data))!=YES) { oops; }
  break;
  }
 if(cgop->status.is_failed==YES) { return RET_FAILED; }
 if(cgop->status.is_exited==YES) { return RET_NOTOPEN; }
 aaNetCgiClientInactivityReset(handle,0,YES);
 aa_NetCgiClientPseudoThread(handle);
 aa_NetCgiClientUpdate(handle);
 return RET_YES;
 }




 B aaNetCgiClientWritef                (H handle,VP fmt,...)
 {
 B ret;
 _aa_netcgiclientobject*cgop;
 va_list argptr;
 B txt[_4K];
 BP tmp=NULL_POINTR;
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaCast(tmp,BP,txt);
 if(aa.is_ready==YES)
  {
  if((ret=aa_MemoryTemp((VP)&tmp,_128K,aa_MEMORYTEMP_CgiWritef))!=RET_YES) { return ret; }
  }
 aaFmt(fmt,argptr,tmp);
 if((ret=aa_ObjectCheck(aa.net_system.cgiclient_object_id,handle,(VP)&cgop,NULL))!=RET_YES) { return ret; }
 if(fmt==NULL)
 { return RET_YES; }
 aaStringLen(tmp,&sl);
 if(sl==0) { return RET_YES; }

 if((ret=aaNetCgiClientWrite(handle,sl,tmp))!=RET_YES) { return ret; }
 return RET_YES;
 }






 B aaNetCgiClientRead                  (H handle,H bytes,VP data)
 {
 B ret;
 _aa_netcgiclientobject*cgop;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.cgiclient_object_id,handle,(VP)&cgop,NULL))!=RET_YES) { return ret; }
 aa_NetCgiClientPseudoThread(handle);
 if((ret=aaNetCgiClientPeek(handle,0,bytes,data))!=RET_YES) { return ret; }
 if((ret=aaNetCgiClientDiscard(handle,bytes))!=RET_YES) { return ret; }
 aa_NetCgiClientPseudoThread(handle);
 return RET_YES;
 }




 B aaNetCgiClientPeek                  (H handle,H offset,H bytes,VP data)
 {
 B ret;
 _aa_netcgiclientobject*cgop;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(data==NULL) { return RET_BADPARM; }
 aaStringNull(data);
 if((ret=aa_ObjectCheck(aa.net_system.cgiclient_object_id,handle,(VP)&cgop,NULL))!=RET_YES) { return ret; }
 aa_NetCgiClientPseudoThread(handle);
 if(bytes==0) { return RET_YES; }
 aa_NetCgiClientUpdate(handle);
 if(bytes==0xffffffff) { bytes=cgop->status.rcve_bytes; }
 bp=(BP)data;
 ret=aaQuePeek(cgop->s2c_que.handle,offset,bytes,bp);
 if(ret==RET_YES)  {  return RET_YES;  }
 if(ret==RET_BOUNDS) { ret=RET_NOTREADY; }
 if(ret!=RET_NOTREADY) {  oops;  cgop->status.is_failed=YES; return RET_FAILED; }
 aaNote(0,"######### quepeek (off=%i bytes=%i) ret=%s",offset,bytes,ret_string[ret]);
 return RET_YES;
 }





 B aaNetCgiClientDiscard               (H handle,H bytes)
 {
 B ret;
 _aa_netcgiclientobject*cgop;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.cgiclient_object_id,handle,(VP)&cgop,NULL))!=RET_YES) { return ret; }
 aa_NetCgiClientPseudoThread(handle);
 if(bytes==0) { return RET_YES; }
 aa_NetCgiClientUpdate(handle);
 if(bytes==0xffffffff) { bytes=cgop->status.rcve_bytes; }
 if(bytes>cgop->status.rcve_bytes)  {  return RET_BOUNDS;  }
 if((ret=aaQueDiscard(cgop->s2c_que.handle,bytes))!=RET_YES)  {  return ret;  }
 aaNetCgiClientInactivityReset(handle,YES,NO);
 aa_NetCgiClientUpdate(handle);
 aa_NetCgiClientPseudoThread(handle);
 return RET_YES;
 }








 B aaNetCgiClientStringLen             (H handle,HP chars,BP isdossy,BP stringmode)
 {
 B ret;
 _aa_netcgiclientobject*cgop;
 H offy,tot,totleft,todo,len,left,ok=0;
 H atatime,sl,i=0;
 Z asca,ascb;
 B block[_16K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.cgiclient_object_id,handle,(VP)&cgop,NULL))!=RET_YES) {return ret; }
 if(isdossy) *isdossy=0;
 if(chars) *chars=0;
 if(stringmode) { *stringmode=0; }
 aa_NetCgiClientUpdate(handle);
 tot=cgop->status.rcve_bytes;
 atatime=_8K;
 offy=len=ok=0;
 while(1)
  {
  asca=ascb=-1;
  ok=0;
  i=0;
  totleft=tot-offy;
  todo=aaNumRoof(totleft,atatime);
  if(todo==0) {  break; }
  if((ret=aaQuePeek(cgop->s2c_que.handle,offy,todo,block))!=YES) oops;
  block[todo]=NULL_CHAR;
  for(i=0;i<todo;i++)
   {
   left=todo-i;
   asca=ascb=-1;
   asca=block[i+0];
   if(left>=2) ascb=block[i+1];
   if(asca==CR_CHAR&&ascb==LF_CHAR) { ok=aa_STRINGMODE_CRLF; break; }
   if(asca==LF_CHAR&&ascb!=-1&&ascb!=CR_CHAR) { ok=aa_STRINGMODE_LF; break; }
   if(asca==CR_CHAR&&ascb!=-1) { ok=aa_STRINGMODE_CR; break; }
   }
  if(i!=todo)   {   break;   }
  offy+=i;
  }
 len=offy+i;
 if(chars) *chars=len;
 if(stringmode) *stringmode=ok;
 if(isdossy&&len>=3)
  {
  aaStringLen(block,&sl);
  if(sl>0)
   {
   if(block[sl-1]=='>'&&aaCharIsAlpha(block[0])&&block[1]==':'&&block[2]==BSLASH_CHAR)
    {
    *isdossy=YES;
    }
   }
  }
 aa_NetCgiClientUpdate(handle);
 if(ok==0)  {  return RET_NOTREADY;  }
 return RET_YES;
 }





 B aaNetCgiClientStringRead            (H handle,HP chars,BP isdossy,BP stringmode,H maxchars,VP buf)
 {
 B ret;
 H len,plus=0;
 B mo,isd;
 BP bp;
 _aa_netcgiclientobject*cgop;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.cgiclient_object_id,handle,(VP)&cgop,NULL))!=RET_YES) {return ret; }
 if(isdossy) { *isdossy=NO; }
 if(stringmode) { *stringmode=0; }
 if(chars) *chars=0;
 if(buf==NULL) { return RET_BADPARM; }
 aaStringNull(buf);

 ret=aaNetCgiClientStringLen(handle,&len,&isd,&mo);
 if(stringmode) { *stringmode=mo; }
 if(chars) *chars=len;
 if(isdossy) *isdossy=isd;
 if(ret!=RET_NOTREADY&&ret!=RET_YES) { return ret; }
 if(ret==RET_YES)
  {
  if(mo==aa_STRINGMODE_LF||mo==aa_STRINGMODE_CR) { plus=1; }  else
  if(mo==aa_STRINGMODE_CRLF)                     { plus=2; }  else { oof; }
  if((len+plus)>maxchars)   {   return RET_BOUNDS;  }
  if((ret=aaNetCgiClientRead(handle,len+plus,buf))!=RET_YES) { oops; }
  aaCast(bp,BP,buf);
  bp[len]=NULL_CHAR;
  aa_NetCgiClientUpdate(handle);
  return RET_YES;
  }
 if(len>maxchars) { return RET_BOUNDS; }
 if(len)
  {
  if((ret=aaNetCgiClientPeek(handle,0,len,buf))!=YES) { oops; }
  aaCast(bp,BP,buf);
  bp[len]=NULL_CHAR;
  }
 return RET_NOTREADY;
 }





 B aaNetCgiClientStringPeek            (H handle,HP chars,BP isdossy,BP stringmode,H maxchars,VP buf)
 {
 B ret;
 H len,plus=0;
 B mo,isd;
 BP bp;
 _aa_netcgiclientobject*cgop;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.cgiclient_object_id,handle,(VP)&cgop,NULL))!=RET_YES) {return ret; }
 if(isdossy) { *isdossy=NO; }
 if(stringmode) { *stringmode=0; }
 if(chars) *chars=0;
 if(buf) {  aaStringNull(buf); }
 ret=aaNetCgiClientStringLen(handle,&len,&isd,&mo);
 if(stringmode) { *stringmode=mo; }
 if(chars) *chars=len;
 if(isdossy) *isdossy=isd;
 if(ret!=RET_NOTREADY&&ret!=RET_YES) {  return ret; }
 if(ret==RET_YES)
  {
  if(mo==aa_STRINGMODE_LF||mo==aa_STRINGMODE_CR) { plus=1; }  else
  if(mo==aa_STRINGMODE_CRLF)                     { plus=2; }  else { oof; }
  if(buf)
   {
   if((len+plus)>maxchars)   {   return RET_BOUNDS;  }
   if((ret=aaNetCgiClientPeek(handle,0,len+plus,buf))!=RET_YES) { oops; }
   aaCast(bp,BP,buf);
   bp[len]=NULL_CHAR;
   }
  aa_NetCgiClientUpdate(handle);
  return RET_YES;
  }

 if(buf&&len>maxchars) { return RET_BOUNDS; }
 if(len)
  {
  if(buf)
   {
   if((ret=aaNetCgiClientPeek(handle,0,len,buf))!=YES) { oops; }
   aaCast(bp,BP,buf);
   bp[len]=NULL_CHAR;
   }
  }
 return RET_NOTREADY;
 }




 B aaNetCgiClientStringReadQuick       (H handle,H promptms,HP chars,BP isprompt,BP stringmode,H maxchars,VP buf)
 {
 B ret;
 H ch,chb;
 B isdossy;
 B smode;
 BP txt=NULL_POINTR;
 _aa_netcgiclientobject*cgop;
 _cgiclientstatus status;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.cgiclient_object_id,handle,(VP)&cgop,NULL))!=RET_YES) {return ret; }
 if(chars) { *chars=0; }
 if(isprompt) { *isprompt=0; }
 if(stringmode) { *stringmode=0; }
 if(buf) { aaStringNull(buf); }
 if((ret=aa_MemoryTemp((VP)&txt,_256K,aa_MEMORYTEMP_CgiRead))!=RET_YES) { return ret; }
 while(1)
  {
  ret=RET_NOTREADY;
  if(aaNetCgiClientStatus(handle,&status)!=YES) { return RET_FAILED; }
  if(status.rcve_bytes==0) { break; }
  ret=aaNetCgiClientStringPeek(handle,&ch,&isdossy,&smode,0,NULL);
  if(ret!=RET_YES&&ret!=RET_NOTREADY) { oops; break; }
  if(maxchars!=0&&ch>maxchars)
   {
   if(chars) { *chars=ch; }
   return RET_BOUNDS;
   }
  if(ret==RET_NOTREADY)
   {
   if(isdossy==YES&&status.line_inactivity>promptms&&status.rcve_inactivity>promptms)
    {
    if(aaNetCgiClientRead(handle,ch,txt)!=YES) { oof; }
    if(aaNetCgiClientStatus(handle,&status)!=YES) { return RET_FAILED; }
    txt[ch]=NULL_CHAR;
    smode=aa_STRINGMODE_NULL;
    if(isprompt) { *isprompt=YES; }
    if(chars)    { *chars=ch; }
    if(buf)      { aaMemoryCopy(buf,ch+1,txt); }
    if(stringmode)     { *stringmode=smode; }
    return RET_YES;
    }
   break;
   }
  aaStringLengthModeAdjust(smode,ch,YES,&chb);
  aaNetCgiClientRead(handle,chb,txt);
  if(aaNetCgiClientStatus(handle,&status)!=YES) { return RET_FAILED; }
  txt[ch]=NULL_CHAR;
  if(isprompt) { *isprompt=NO; }
  if(chars)    { *chars=ch; }
  if(buf)      { aaMemoryCopy(buf,ch+1,txt); }
  if(stringmode)     { *stringmode=smode; }
  return RET_YES;
  }
 if(ret!=RET_NOTREADY) { oops; }
 return ret;
 }






 B aaNetCgiClientInactivityReset       (H handle,B rflag,B xflag)
 {
 B ret;
 _aa_netcgiclientobject*cgop;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.cgiclient_object_id,handle,(VP)&cgop,NULL))!=RET_YES) { return ret; }
 if(rflag)  {  aaTimerTikGet(&cgop->inactive_rcve_ms_root);  cgop->status.rcve_inactivity=0;  }
 if(xflag)  {  aaTimerTikGet(&cgop->inactive_xmit_ms_root);  cgop->status.xmit_inactivity=0;  }
 return RET_YES;
 }




 B aaNetCgiClientChildrenTerminate     (H handle)
 {
 B ret;
 _aa_netcgiclientobject*cgop;
 H lev_thread_id,i,han;
 _processentry pe;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.cgiclient_object_id,handle,(VP)&cgop,NULL))!=RET_YES) { return ret; }
 lev_thread_id=cgop->pi.dwProcessId;
 han=0;
 for(i=0;;i++)
  {
  if((ret=aaProcessList(&han,i,&pe))==RET_FINISHED) { ret=RET_YES; break; }
  if(ret!=YES) { oops; break; }
  if(pe.parent_process_id==lev_thread_id)   {   aaProcessTerminateByPid(pe.process_id,0); break; }
  }
 if(han!=0) { aaProcessListDestroy(han); }
 return ret;
 }


/*-----------------------------------------------------------------------*/


 E{
 URL_PARSE_Scheme=50,
 URL_PARSE_Host_Init=100,
 URL_PARSE_Host_Main=120,
 URL_PARSE_Host_End=160,
 URL_PARSE_Port_Init=600,
 URL_PARSE_Port_Main=620,
 URL_PARSE_Port_End=660,

 URL_PARSE_Path_Init=200,
 URL_PARSE_Path_Main=220,
 URL_PARSE_Path_End=240,
 URL_PARSE_File_Init=300,
 URL_PARSE_File_Main=320,
 URL_PARSE_File_End=340,
 URL_PARSE_Query_Init=400,
 URL_PARSE_Query_Main=420,
 URL_PARSE_Query_End=440,
 URL_PARSE_Frag_Init=500,
 URL_PARSE_Frag_Main=520,
 URL_PARSE_Frag_End=540,
 };




 B aaNetUrlParse                       (_url*url,VP urli)
 {
 B ret;
 B input[_8K];
 B fixed[_8K];
 _parser pa;
 N which;
 H stage;
 H chars,pos;
 B txt[_4K];
 H last_known_slash;
 H first_known_colon;
 H first_known_slash;
 H first_known_dot;
 H first_known_at;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(url==NULL) { return RET_BADPARM; }
 aaMemoryFill(url,sizeof(_url),0);
 if(urli==NULL) { return RET_BADPARM; }
 aaMemoryFill(input,sizeof(input),0);
 aaStringCopy(input,urli);
 while(1)
  {
  aaNetUrlDecode(input,0,input);
  if(aaStringFindChar(input,0,&pos,PERC_CHAR,YES,0,YES)!=YES) break;
  }
 aaStringReplaceChar(input,0,' ','+');
 aaNetUrlSqueeze(input,0,input);
 aaStringCopy(fixed,input);



 aaParserInit(&pa,input,0);
 aaStringFindChar(pa.bp,pa.to_end,&first_known_slash,'/',YES,0,YES);
 aaStringFindChar(pa.bp,pa.to_end,&first_known_colon,':',YES,0,YES);
 aaStringFindChar(pa.bp,pa.to_end,&first_known_dot,'.',YES,0,YES);
 aaStringFindChar(pa.bp,pa.to_end,&first_known_at,'@',YES,0,YES);

 stage=0;

 last_known_slash=0xffffffff;
 while(1)
  {
  if(stage==0xffffffff) { break; }
  switch(stage)
   {
   case 0:
   //aaDebugfBlankLine(1);
   ///aaDebugf("--------");
   ///aaDebugf("%s",urli);
   stage=URL_PARSE_Scheme;
   break;



   case URL_PARSE_Scheme:
   if(first_known_at!=0xffffffff&&first_known_at<first_known_colon&&first_known_at<first_known_slash&&aaCharIsAlpha(pa.ch))
    {
    aaStringNCopy(url->user,pa.bp,first_known_at,YES);
    aaParserSeek(&pa,first_known_at+1);
    stage=URL_PARSE_Host_Init;
    break;
    }

   if(first_known_slash==0xffffffff&&first_known_colon!=0xffffffff&&aaCharIsAlpha(pa.ch))
    {
    aaStringNCopy(url->scheme,pa.bp,first_known_colon,YES);
    aaParserSeek(&pa,first_known_colon+1);
    stage=URL_PARSE_Host_Init;
    break;
    }



   ret=aaNetUrlBeginsWith(pa.bp,&which);
   if(ret!=RET_YES) { stage=0xffffffff; break; }
   if(which==0) /// https://
    {
    aaStringCopyf(url->scheme,"https");
    aaParserSeek(&pa,8);
    stage=URL_PARSE_Host_Init;
    break;
    }
   if(which==1) /// http://
    {
    aaStringCopyf(url->scheme,"http");
    aaParserSeek(&pa,7);
    stage=URL_PARSE_Host_Init;
    break;
    }
   if(which==2) /// //
    {
    aaStringCopyf(url->scheme,"//");
    aaParserSeek(&pa,2);
    stage=URL_PARSE_Host_Init;
    break;
    }
   if(which==3) /// /
    {
    stage=URL_PARSE_Path_Init;
    break;
    }
   if(which==4) /// ?
    {
    stage=URL_PARSE_Query_Init;
    break;
    }
   if(which==5) /// #
    {
    stage=URL_PARSE_Frag_Init;
    break;
    }
   if(which==6) /// alpha
    {
    stage=URL_PARSE_Host_Init;
    break;
    }
   //stage=URL_PARSE_DOT_Ini;
   //also handle ip dotted
   aaNote(0,"[%s]",pa.bp);
   break;


   case URL_PARSE_Host_Init:
   aaParserStackPush(&pa);
   stage=URL_PARSE_Host_Main;
   break;


   case URL_PARSE_Host_Main:
   if(pa.ch=='/') // path
    {
    last_known_slash=pa.offset;
    stage=URL_PARSE_Host_End;
    break;
    }
   if(pa.is_end||pa.ch==':'||pa.ch=='?'||pa.ch=='#')
    {
    stage=URL_PARSE_Host_End;
    break;
    }
   aaParserSeek(&pa,1);
   break;


   case URL_PARSE_Host_End:
   if(last_known_slash!=0xffffffff)
    {
    aaParserOffsetSet(&pa,last_known_slash);
    last_known_slash=0xffffffff;
    }
   ret=aaParserStackString(&pa,&chars,sizeof(txt),txt,YES);
   if(ret!=YES) { oops; }
   //aaDebugf("host=[%s]",txt);
   aaStringCopyf(url->host,"%s",txt);
   if(pa.ch=='/')
    {
    stage=URL_PARSE_Path_Init;
    break;
    }
   if(pa.ch==':')
    {
    ///aaDebugf("anextch=%c",pa.ch);
    aaParserSeek(&pa,1);
    stage=URL_PARSE_Port_Init;
    break;
    }
   if(pa.ch=='?')
    {
    ///aaDebugf("anextch=%c",pa.ch);
    aaParserSeek(&pa,1);
    stage=URL_PARSE_Query_Init;
    break;
    }

   if(pa.is_end&&pa.ch==NULL_CHAR)
    {
    stage=9999;
    break;
    }
   aaDebugf("#%i nextch=(isend=%i) 0x%02x %c",__LINE__,pa.is_end,pa.ch,pa.ch);
   aaDebugf("initurl=%s",urli);
   aaDebugf("     to %s",fixed);
   aaNetUrlBug(url,NO);
   stage=9999;
   break;


   case URL_PARSE_Port_Init:
   aaParserStackPush(&pa);
   //aaParserSeek(&pa,1);
   stage=URL_PARSE_Port_Main;
   break;


   case URL_PARSE_Port_Main:
   if(pa.is_end||pa.ch=='/'||pa.ch=='?'||pa.ch=='#')
    {
    stage=URL_PARSE_Port_End;
    break;
    }
   aaParserSeek(&pa,1);
   break;



   case URL_PARSE_Port_End:
   ret=aaParserStackString(&pa,&chars,sizeof(txt),txt,YES);
   if(ret!=YES) { oops; }
   //aaDebugf("path=[%s]",txt);
   aaStringCopyf(url->port,"%s",txt);
   if(pa.ch=='/')
    {
    stage=URL_PARSE_Path_Init;
    break;
    }
   if(pa.ch=='?')
    {
    stage=URL_PARSE_Query_Init;
    break;
    }
   if(pa.ch=='#')
    {
    stage=URL_PARSE_Frag_Init;
    break;
    }
   if(pa.is_end&&pa.ch==NULL_CHAR)
    {
    stage=9999;
    break;
    }

   aaDebugf("#%i nextch=(isend=%i) 0x%02x %c",__LINE__,pa.is_end,pa.ch,pa.ch);
   aaDebugf("    for %s",urli);
   aaDebugf("     to %s",fixed);
   aaNetUrlBug(url,NO);
   stage=9999;
   break;





   case URL_PARSE_Path_Init:
   //last_known_slash=pa.offset;
   aaParserStackPush(&pa);
   aaParserSeek(&pa,1);
   stage=URL_PARSE_Path_Main;
   break;


   case URL_PARSE_Path_Main:
   if(pa.ch=='/') // path
    {
    last_known_slash=pa.offset;
    aaParserSeek(&pa,1);
    break;
    }
   if(pa.is_end||pa.ch=='?'||pa.ch=='#') //pa.ch==':'||
    {
    stage=URL_PARSE_Path_End;
    break;
    }
   aaParserSeek(&pa,1);
   break;


   case URL_PARSE_Path_End:
   if(last_known_slash!=0xffffffff)
    {
    aaParserOffsetSet(&pa,last_known_slash);
    last_known_slash=0xffffffff;
    }
   ret=aaParserStackString(&pa,&chars,sizeof(txt),txt,YES);
   if(ret!=YES) { oops; }
   //aaDebugf("path=[%s]",txt);
   aaStringCopyf(url->path,"%s",txt);
   if(pa.ch=='/')
    {
    stage=URL_PARSE_File_Init;
    break;
    }
   if(pa.ch=='?')
    {
    stage=URL_PARSE_Query_Init;
    break;
    }
   if(pa.ch=='#')
    {
    stage=URL_PARSE_Frag_Init;
    break;
    }
   if(pa.is_end&&pa.ch==NULL_CHAR)
    {
    stage=9999;
    break;
    }

   aaDebugf("#%i nextch=(isend=%i) 0x%02x %c",__LINE__,pa.is_end,pa.ch,pa.ch);
   aaDebugf("    for %s",urli);
   aaDebugf("     to %s",fixed);
   aaNetUrlBug(url,NO);
   stage=9999;
   break;



   case URL_PARSE_File_Init:
   if(pa.ch=='/') { aaParserSeek(&pa,1); }
   aaParserStackPush(&pa);
   stage=URL_PARSE_File_Main;
   break;



   case URL_PARSE_File_Main:
   if(pa.is_end||pa.ch=='?'||pa.ch=='#')
    {
    stage=URL_PARSE_File_End;
    break;
    }
   aaParserSeek(&pa,1);
   break;


   case URL_PARSE_File_End:
   ret=aaParserStackString(&pa,&chars,sizeof(txt),txt,YES);
   if(ret!=YES) { oops; }
   //aaDebugf("file=[%s]",txt);
   aaStringCopyf(url->file,"%s",txt);
   if(pa.ch=='?')
    {
    stage=URL_PARSE_Query_Init;
    break;
    }
   if(pa.ch=='#')
    {
    stage=URL_PARSE_Frag_Init;
    break;
    }
   if(pa.is_end&&pa.ch==NULL_CHAR)
    {
    stage=9999;
    break;
    }

   aaDebugf("#%i nextch=(isend=%i) 0x%02x %c",__LINE__,pa.is_end,pa.ch,pa.ch);
   aaDebugf("initurl=%s",urli);
   aaDebugf("     to %s",fixed);
   aaNetUrlBug(url,NO);
   stage=9999;
   break;



   case URL_PARSE_Query_Init:
   if(pa.ch=='?') { aaParserSeek(&pa,1); }
   aaParserStackPush(&pa);
   stage=URL_PARSE_Query_Main;
   break;


   case URL_PARSE_Query_Main:
   if(pa.is_end||pa.ch=='#')
    {
    stage=URL_PARSE_Query_End;
    break;
    }
   aaParserSeek(&pa,1);
   break;



   case URL_PARSE_Query_End:
   ret=aaParserStackString(&pa,&chars,sizeof(txt),txt,YES);
   if(ret!=YES) { oops; }
   //aaDebugf("query=[%s]",txt);
   aaStringCopyf(url->query,"%s",txt);
   if(pa.ch=='#')
    {
    stage=URL_PARSE_Frag_Init;
    break;
    }
   if(pa.is_end&&pa.ch==NULL_CHAR)
    {
    stage=9999;
    break;
    }
   aaDebugf("#%i nextch=(isend=%i) 0x%02x %c",__LINE__,pa.is_end,pa.ch,pa.ch);
   aaDebugf("    for %s",urli);
   aaDebugf("     to %s",fixed);
   aaNetUrlBug(url,NO);
   stage=9999;
   break;


   case URL_PARSE_Frag_Init:
   if(pa.ch=='#') { aaParserSeek(&pa,1); }
   aaParserStackPush(&pa);
   stage=URL_PARSE_Frag_Main;
   break;


   case URL_PARSE_Frag_Main:
   if(pa.is_end)
    {
    stage=URL_PARSE_Frag_End;
    break;
    }
   aaParserSeek(&pa,1);
   break;


   case URL_PARSE_Frag_End:
   ret=aaParserStackString(&pa,&chars,sizeof(txt),txt,YES);
   if(ret!=YES) { oops; }
   //aaDebugf("frag=[%s]",txt);
   aaStringCopyf(url->frag,"%s",txt);
   if(pa.is_end&&pa.ch==NULL_CHAR)
    {
    stage=9999;
    break;
    }
   aaDebugf("#%i nextch=(isend=%i) 0x%02x %c",__LINE__,pa.is_end,pa.ch,pa.ch);
   aaDebugf("    for %s",urli);
   aaDebugf("     to %s",fixed);
   aaNetUrlBug(url,NO);

   stage=9999;
   break;


   case 9999:
   stage=0xffffffff;
   break;

   default:
   aaNote(0,"stage=%i",stage);
   stage=0xffffffff;
   break;
   }
  }
 //aaNetUrlBug(url,NO);
 return RET_YES;
 }





 B aaNetUrlBug                         (_url*url,B doempty)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(url==NULL) { return RET_BADPARM; }
 doempty&=1;
 if(doempty||url->scheme[0]) aaDebugf("scheme=%s",url->scheme);
 if(doempty||url->user[0]) aaDebugf("  user=%s",url->user);
 if(doempty||url->host[0]) aaDebugf("  host=%s",url->host);
 if(doempty||url->port[0]) aaDebugf("  port=%s",url->port);
 if(doempty||url->path[0]) aaDebugf("  path=%s",url->path);
 if(doempty||url->file[0]) aaDebugf("  file=%s",url->file);
 if(doempty||url->query[0]) aaDebugf(" query=%s",url->query);
 if(doempty||url->frag[0]) aaDebugf("  frag=%s",url->frag);
 return RET_YES;
 }




/*

 B aaNetUrlBuild                       (VP urli,VP href,VP urlo)
 {
 B pre[_4K];
 B etc[_4K];
 B out[_4K];
 _url uze[2];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(href==NULL) { return RET_MISSINGPARM; }
 aaStringCopyf(pre,"%s",href);
 aaNetUrlParse(&uze[0],pre);
 aaNetUrlParse(&uze[1],urli);
 if(pre[0]=='#')      {      }
 if(aaStringIsEmpty(uze[0].scheme,1)) { aaStringCopy(uze[0].scheme,uze[1].scheme);      }
 if(aaStringIsEmpty(uze[0].host,1))   { aaStringCopy(uze[0].host,uze[1].host);      }
 if(aaStringIsEmpty(uze[0].path,1))   { aaStringCopy(uze[0].path,uze[1].path);      }
 aaStringNull(etc);
 aaStringAppendf(etc,"%s://",uze[0].scheme);
 aaStringAppendf(etc,"%s",uze[0].host);
 aaStringAppendf(etc,"%s",uze[0].path);
 aaStringAppendf(etc,"%s",uze[0].file);
 if(uze[0].query[0]) aaStringAppendf(etc,"?%s",uze[0].query);
 if(uze[0].frag[0])  aaStringAppendf(etc,"#%s",uze[0].frag);
 //ret=myNetUrlClean(etc,0,out);
 //if(ret!=RET_YES) { oops; }
 if(urlo) { aaStringCopyf(urlo,"%s",out); }
 return RET_YES;
 }


*/

 B aaNetUrlBeginsWith                  (VP urli,NP which)
 {
 N mode;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(which) { *which=-1; }
 if(urli==NULL) { return RET_BADPARM; }
 mode=-1;
 while(1)
  {
  if(aaStringNICompare(urli,"https://",0xffffffff,0)==YES) { mode=0; break; }
  if(aaStringNICompare(urli,"http://",0xffffffff,0)==YES)  { mode=1; break; }
  if(aaStringNICompare(urli,"//",0xffffffff,0)==YES)       { mode=2; break; }
  if(aaStringNICompare(urli,"/",0xffffffff,0)==YES)        { mode=3; break; }
  if(aaStringNICompare(urli,"?",0xffffffff,0)==YES)        { mode=4; break; }
  if(aaStringNICompare(urli,"#",0xffffffff,0)==YES)        { mode=5; break; }
  bp=(BP)urli;
  if(aaCharIsAlphaNum(bp[0]))                       { mode=6; break; }
  break;
  }
 if(which) { *which=mode; }
 if(mode==-1) { return RET_NO; }
 return RET_YES;
 }




 B aaNetUrlBuild                       (VP urli,VP urlb,VP urlo,_url*url)
 {
 N which;
 BP href;
 _url uzei;
 _url uzeb;
 B inp[_4K];
 B out[_4K];
 B ascii;
 N what;

 if(urli==NULL) oof;
 if(urlb==NULL) oof;
 if(urlo==NULL) oof;
 aaStringCopy(inp,urli);

 what=0;
 while(1)
  {
  if(aaStringNICompare(urli,"./",0xffffffff,0)==YES) { what=1; break; }
  if(aaStringNICompare(urli,"../",0xffffffff,0)==YES) { what=2; break; }
  break;
  }
 if(what==1||what==2)
  {
  if(urlb!=NULL)
   {
   aaStringCopy(inp,urlb);
   aaStringAppend(inp,urli);
   aaNetUrlSqueeze(inp,0,inp);
   if(url)
    {
    if(aaNetUrlParse(url,inp)!=YES) { oof; }
    }
   aaStringCopy(urlo,inp);
   return RET_YES;
   }
  }

 if(inp[0]=='.'&&inp[1]==NULL_CHAR)
  {
  aaNetUrlParse(&uzeb,urlb);
  aaStringAppendf(out,"%s://",uzeb.scheme);
  aaStringAppendf(out,"%s",uzeb.host);
  if(uzeb.path[0]) aaStringAppendf(out,"%s",uzeb.path);
  aaStringLastCharGet(out,0,&ascii);
  if(ascii!=FSLASH_CHAR)
   {
   if(uzei.file[0]!=NULL_CHAR||uzei.query[0]!=NULL_CHAR||uzei.frag[0]!=NULL_CHAR)  { aaStringAppendf(out,"/");   }
   }
  aaStringCopy(urlo,out);
  if(url)
   {
   if(aaNetUrlParse(url,out)!=YES) { oof; }
   }
  return RET_YES;
  }

 href=inp;

 while(1)
  {
  aaNetUrlBeginsWith(href,&which);
  if(which==6)
   {
   aaNetUrlParse(&uzeb,urlb);
   aaStringCopyf(out,"%s://",uzeb.scheme);
   aaStringAppendf(out,"%s/%s",uzeb.host,href);
   if(urlo) aaStringCopy(urlo,out);
   if(url)  {  if(aaNetUrlParse(url,out)!=YES) { oof; }  }
   return RET_YES;
   }
  if(which==0||which==1)
   {
   aaStringCopy(out,urli);
   break;
   }
  aaNetUrlParse(&uzeb,urlb);
  aaNetUrlParse(&uzei,urli);
  aaStringNull(out);
  if(which==2)
   {
   aaStringAppendf(out,"%s://",uzeb.scheme);
   aaStringAppendf(out,"%s",&href[2]);
   break;
   }
  if(which==3||which==4||which==5)
   {
   aaStringAppendf(out,"%s://",uzeb.scheme);
   aaStringAppendf(out,"%s",uzeb.host);
   if(uzei.path[0]) aaStringAppendf(out,"%s",uzei.path);
   aaStringLastCharGet(out,0,&ascii);
   if(ascii!=FSLASH_CHAR)
    {
    if(uzei.file[0]!=NULL_CHAR||uzei.query[0]!=NULL_CHAR||uzei.frag[0]!=NULL_CHAR)  { aaStringAppendf(out,"/");   }
    }
   aaStringAppendf(out,"%s",uzei.file);
   if(uzei.query[0]!=NULL_CHAR)  { aaStringAppendf(out,"?%s",uzei.query);     }
   if(uzei.frag[0]!=NULL_CHAR)   { aaStringAppendf(out,"#%s",uzei.frag);     }
   if(uzei.query[0]==NULL_CHAR&&uzei.frag[0]==NULL_CHAR)   {   }
   break;
   }
  aaStringCopy(urlo,urli);
  if(urli)
   {
   if(aaNetUrlParse(url,out)!=YES) { oof; }
   }
  return RET_CORRUPTED;
  //aaNote(0,"which=%i\n%s",which,urli);
  }

 if(urlo) aaStringCopy(urlo,out);
 if(url)  {  if(aaNetUrlParse(url,out)!=YES) { oof; }  }
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/





 B aaNetUrlSqueeze                     (VP urli,H chars,VP urlo)
 {
 C inbuf[_4K];
 C clonebuf[_4K];
 C outbuf[_4K];
 CP out;
 CP outptr;
 CP orgclone;
 CP queryp;
 CP clone;
 Z inlen,clen;
 CP input;
 Z qlen;
 Z oindex;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(urli==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(urli,&chars); }
 if(chars==0)
  {
  if(urlo&&urlo!=urli) { aaStringNull(urlo); }
  return RET_YES;
  }
 if(urlo&&urlo!=urli) { aaStringNull(urlo); }
 aaStringNCopy(inbuf,urli,chars,YES);

 inlen=chars;
 clen=inlen;
 input=inbuf;
 out=outbuf;
 clone=clonebuf;
 orgclone=clonebuf;
 if(!out) { oof; }
 aaStringCopy(clone,input);
 aaStringCopy(orgclone,clone);
 outptr=out;
 //if(!*clone)  {  oof;  }
 queryp=strchr(clone,'?');
 if(queryp) *queryp = 0;
  do
   {
   if(aaStringNICompare(clone,"./",2,0)==YES)    {    clone+=2;    clen-=2;    }
   else
   if(aaStringNICompare(clone,"../",3,0)==YES)   {    clone+=3;    clen-=3;    }
   else
   if(aaStringNICompare(clone,"/./",3,0)==YES)   {    clone+=2;    clen-=2;    }
   else
   if(aaStringNICompare(clone,"/./",3,0)==YES)   {    clone+=2;    clen-=2;    }
   else
   if(aaStringCompare(clone,"/.",0)==YES)   {    clone[1]='/';  clone++; clen-=1; }
   else
   if(aaStringNICompare(clone,"/../",4,0)==YES)
    {
    clone+=3;
    clen-=3;
    while(outptr>out)
     {
     outptr--;
     if(*outptr=='/')    break;
     }
    *outptr=NULL_CHAR;
    }
   else
   if(aaStringCompare(clone,"/..",0)==YES)
    {
    clone[2]='/';
    clone+=2;
    clen-=2;
    while(outptr>out)
     {
     outptr--;
     if(*outptr=='/')   break;
     }
    *outptr=NULL_CHAR;
    }
   else
   if((aaStringCompare(clone,".",0)==YES)||(aaStringCompare(clone,"..",0)==YES))
    {
    *clone=NULL_CHAR;
    }
    else
     {
     do
      {
      *outptr++=*clone++;
      clen--;
      }
    while(*clone&&(*clone!='/'));
    *outptr=NULL_CHAR;
    }
   }
  while(*clone);
 if(queryp)
  {
  oindex=queryp-orgclone;
  aaStringLen(&input[oindex],(HP)&qlen);
  aaMemoryCopy(outptr,qlen+1,&input[oindex]);
  }
 if(urlo) { aaStringCopy(urlo,out); }
 return RET_YES;
 }






 B aaNetUrlDecode                      (VP url,H chars,VP durl)
 {
 H val,count;
 BP sp;
 BP dp;
 B orig[_4K];
 B solv[_4K];
 B tmp[_4K];
 H go;
 B changed;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(url==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(url,&chars); }
 aaStringCopy(orig,url);
 aaStringCopy(solv,url);
 changed=NO;
 //aaLog(-555,"    urldec orig: %s",orig);
 go=0;
 while(1)
  {
  sp=solv;
  dp=tmp;
  aaStringLen(sp,&chars);
  //aaLog(-555,"   go=%i    solv: %s",go,solv);
  if(chars==0) { return RET_BADPARM; }
  go++;
  while(1)
   {
   if(*sp=='+') { *dp=SPACE_CHAR; }
   else         { *dp=*sp; }
   if(*sp==NULL_CHAR) { break; }
   dp++;
   sp++;
   }
  //aaLog(-555,"    first: go=%i =%s",go,tmp);
  sp=tmp;
  dp=solv;
  while(*sp)
   {
   if(*sp=='%')
    {
    sp++;
    if(aaCharIsHex(sp[0])&&aaCharIsHex(sp[1])) { aaStringHexToNumber(sp,2,&val,0,NULL,NULL);  *dp++=(B)val;  sp+=2;  continue;    }
    else                                       { *dp=*sp;  dp++;    continue;    }
    }
   if(*sp=='&'&&*(sp+1)=='#')
    {
    aaStringCountNumbers(&sp[2],0,&count,YES);
    if(count>=1)
     {
     if(aaStringToNumber(&sp[2],count,&val,0,0,0)==YES)
      {
      if(*(sp+2+count)==';')
       {
       if(val<=255)  {  *dp++=(B)val;   sp+=(1+2+count);   continue;       }
       }
      }
     }
    }
   *dp++=*sp++;
   }
  *dp=NULL_CHAR;
 if(aaStringICompare(solv,orig,0)==YES)
  {
  //aaDebugf("  good: go=%i =%s",go,solv);
//  aaDebugf("alldone %s",tmp);
//  aaDebugf("   orig %s",orig);
  if(changed)
   {
   //aaLog(-555,"  orign=%s",url);
   //aaLog(-555,"decoded=%s",solv);
   }
  if(durl) { aaStringCopyf(durl,"%s",solv);  }
  return RET_YES;
  }
 //aaStringCopyf(solv,"%s",tmp);
// aaLog(-555,"           sameh %s",solv);
 //aaLog(-555,"          a orig %s",orig);
 //aaLog(-555,"     change orig");
 aaStringCopyf(orig,"%s",solv);
 changed=YES;
  }
oof;


 return RET_YES;
 }




 B aaNetUrlPartsGet                    (_urlparts*urlparts,VP url,B spaceplus,B decode)
 {
 B req[_4K];
 B txt[_4K];
 H off,pos,spo;
 B ascii;
 N which;
 H newoff=0;
 B slash_added;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 slash_added=NO;
 if(urlparts==NULL) { return RET_BADPARM; }
 aaMemoryFill(urlparts,sizeof(_urlparts),0);
 if(url==NULL) { return RET_BADPARM; }

 aaStringCopy(urlparts->raw_url,url);
 if(decode) aaNetUrlDecode(urlparts->raw_url,0,urlparts->dec_url);
 else       aaStringCopy(urlparts->dec_url,urlparts->raw_url);

 // if spaceplus, then after decode, convert all spaces to + char
 // e.g if were about to do a httpreq and weve already replaced spaces with pluses
 // in the url, we want to retain them after calling urldecode
 if(spaceplus) { aaStringReplaceChar(urlparts->dec_url,0,32,'+');   }
 aaStringCopy(txt,urlparts->dec_url);
 aaStringReplaceChar(txt,0,BSLASH_CHAR,FSLASH_CHAR);
 aaStringIsIStringPartial(txt,&which,"http://","telnet://","https://","ftp://","ws://",NULL);
 if(which!=-1)
  {
  if(which==0) { aaStringCopy(urlparts->scheme,"http");  newoff=3+4; }
  if(which==1) { aaStringCopy(urlparts->scheme,"telnet"); newoff=3+6; }
  if(which==2) { aaStringCopy(urlparts->scheme,"https"); newoff=3+5; }
  if(which==3) { aaStringCopy(urlparts->scheme,"ftp"); newoff=3+3; }
  if(which==4) { aaStringCopy(urlparts->scheme,"ws");  newoff=3+2; }
  aaStringCopyf(req,"%s",txt);
  }
 else
  {
  aaStringCopyf(req,"http://%s",txt);
  newoff=3+4;
  }

 aaStringFindChar(req,0,&off,'?',YES,0,YES);
 if(off!=0xffffffff)
  {
  aaStringCopy(urlparts->parms,&req[off]);
  aaStringCharSet(req,0,off,NULL_CHAR);
  }
 aaStringReplaceChar(req,0,BSLASH_CHAR,FSLASH_CHAR);
 off=(newoff+1);
 while(1)
  {
  ascii=req[off];
  if(ascii==NULL_CHAR) { break; }
  if(ascii!=FSLASH_CHAR) { off++; continue; }
  if(req[off+1]!=FSLASH_CHAR) { off++; continue; }
  aaStringDeleteChar(req,0,off);
  off++;
  }
 off=(newoff+1);
 while(1)
  {
  ascii=req[off];
  if(ascii==NULL_CHAR) { break; }
  if(ascii!=FSLASH_CHAR) { off++; continue; }
  if(req[off+1]!='.'||req[off+1]==NULL_CHAR) { off++; continue; }
  if(req[off+2]!='.'||req[off+2]==NULL_CHAR) { off++; continue; }
  if(req[off+3]!='/'||req[off+3]==NULL_CHAR) { off++; continue; }
  if(req[off+4]==NULL_CHAR) { off++; continue; }
  aaStringDeleteChars(req,0,off,3);
  }
 aaStringFindChar(req,0,&pos,FSLASH_CHAR,YES,2,YES);
 aaStringCopy(urlparts->absolute,req);
 aaStringReplaceChar(urlparts->absolute,0,BSLASH_CHAR,FSLASH_CHAR);
 aaStringFindChar(req,0,&off,FSLASH_CHAR,YES,0,NO);
 aaStringFindChar(req,0,&pos,FSLASH_CHAR,YES,2,YES);
 aaStringFindChar(req,0,&spo,'.',YES,0,NO);
 aaStringCopy(txt,req);
 if(off==0xffffffff||spo==0xffffffff||pos==0xffffffff)
  {
#if 0
  if(aaStringCompare(&txt[newoff],"localhost/",NULL)==YES)
   {
   aaNote(0,"z url=%s)       %i %i %i",txt,newoff,spo,pos);
   return RET_CORRUPTED;
   }
   #endif
  }
 if((spo<pos&&spo<off)&&(off!=0xffffffff&&pos!=0xffffffff&&spo!=0xffffffff))
  {
  aaStringCharGet(txt,0,-1,&ascii);
  if(ascii!=FSLASH_CHAR)
   {
   }
  }
 aaStringCopy(urlparts->relative,&urlparts->absolute[pos]);
 if(spo!=0xffffffff)
  {
  if(spo>off)
   {
   aaStringCopy(urlparts->ext,&txt[spo]);
   }
  }
 if(off!=0xffffffff)
  {
  aaStringCopy(urlparts->file,&txt[off+1]);
  if(spo!=0xffffffff&&spo>off)
   {
   urlparts->file[(spo-off)-1]=NULL_CHAR;
   }
  }
 if(pos!=0xffffffff)
  {
  aaStringNCopy(urlparts->host,&txt[newoff],pos-newoff,YES);
  }
 if((pos!=0xffffffff&&off!=0xffffffff)&&off>=pos)
  {
  aaStringCopy(&urlparts->path,&txt[pos]);
  urlparts->path[(off-pos)+1]=NULL_CHAR;
  }
 if(aaStringIsNull(urlparts->host)==NO)
  {
  aaStringFindChar(urlparts->host,0,&off,':',YES,0,NO);
  if(off!=0xffffffff)
   {
   aaStringLen(&urlparts->host[off+1],&pos);
   aaStringCountNumbers(&urlparts->host[off+1],pos,&spo,YES);
   if((spo==0||spo>5)||(spo!=pos))
    {
    return RET_CORRUPTED;
    }
   else
    {
    if(aaStringToNumber(&urlparts->host[off+1],0,&pos,0,0,0)==YES)
     {
     if(pos>65535)
      {
      return RET_CORRUPTED;
      }
     else
      {
      urlparts->adr.port=(W)pos;
      urlparts->host[off]=NULL_CHAR;
      }
     }
    }
   }
  }
 if(aaNetIpIsValid(urlparts->host)==YES)
  {
  aaNetIpFromString(urlparts->host,&urlparts->adr.ip);
  }
 aaStringFindChar(urlparts->absolute,0,&off,FSLASH_CHAR,YES,0,NO);
 if(off==0xffffffff)
  {
//  aaNote(0,"line=%i abs=%s",__LINE__,urlparts->absolute);
  aaDebugf("#line=%i [%s] abs=[%s]",__LINE__,url,urlparts->absolute);
  return RET_CORRUPTED;
  }
 aaStringCopy(urlparts->filename,&urlparts->absolute[off+1]);
 if(urlparts->relative[1]!=NULL_CHAR)
  {
  aaStringLastCharGet(urlparts->relative,0,&ascii);
  if(ascii==FSLASH_CHAR&&slash_added==YES)
   {
    {
    aaStringLastCharSet(urlparts->relative,0,NULL_CHAR,NO);
    }
   }
  }

 return RET_YES;
 }




 B aaNetUrlPartsToString               (_urlparts*urlparts,VP buf)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(buf==NULL) { return RET_BADPARM; }
 aaStringNull(buf);
 if(urlparts==NULL) { return RET_BADPARM; }
 if(urlparts->scheme[0])   { aaStringAppendf(buf,"sceme=%s\n",urlparts->scheme);  }
 if(urlparts->dec_url[0])  { aaStringAppendf(buf,"real=%s\n",urlparts->dec_url);  }
 if(urlparts->host[0])     { aaStringAppendf(buf,"host=%s\n",urlparts->host);     }
 if(urlparts->absolute[0]) { aaStringAppendf(buf,"abss=%s\n",urlparts->absolute); }
 if(urlparts->path[0])     { aaStringAppendf(buf,"path=%s\n",urlparts->path);     }
 if(urlparts->relative[0]) { aaStringAppendf(buf,"rela=%s\n",urlparts->relative); }
 if(urlparts->filename[0]) { aaStringAppendf(buf,"fnam=%s\n",urlparts->filename); }
 if(urlparts->file[0])     { aaStringAppendf(buf,"file=%s\n",urlparts->file);     }
 if(urlparts->ext[0])      { aaStringAppendf(buf,"ext=%s\n",urlparts->ext);       }
 if(urlparts->parms[0])    { aaStringAppendf(buf,"parms=%s\n",urlparts->parms);   }
 if(urlparts->adr.ip||urlparts->adr.port) { aaStringAppendf(buf,"adr=%lu %u\n",urlparts->adr.ip,urlparts->adr.port); }
 return RET_YES;
 }




 B aaNetUrlToFilename                  (VP rootpath,VP relative,VP filename)
 {
 B ascii;
 B rp[_1K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(relative==NULL) { return RET_BADPARM; }
 if(rootpath==NULL)  {  aaStringCopy(rp,aa.core_system.module_path);  }
 else                {  aaStringCopy(rp,rootpath);  }
 if(filename==NULL) { return RET_BADPARM; }
 aaStringCopyf(filename,"%s",rp);
 aaStringLastCharGet(filename,0,&ascii);
 if(ascii==BSLASH_CHAR) { aaStringLastCharSet(filename,0,0,0); }
 aaStringAppendf(filename,"%s",relative);
 aaStringReplaceChar(filename,0,FSLASH_CHAR,BSLASH_CHAR);
 return RET_YES;
 }




 B aaNetSetCookieDecode                (VP str,H chars,_cookie*cookie)
 {
 _parser pa,pb;
 H pos;
 B buf[_4K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(cookie==NULL) { return RET_BADPARM; }
 aaMemoryFill(cookie,sizeof(_cookie),0);
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 aaParserInit(&pa,str,chars);
 while(1)
  {
  aaParserSeekToVisibleChar(&pa,YES,YES);
  aaParserStackPush(&pa);
  aaParserCopy(&pb,&pa,NO);
  aaParserSeekToChar(&pa,'=',YES,YES);
  aaParserStackString(&pa,0,sizeof(buf),buf,YES);
  aaStringCopyf(cookie->name,"%s",buf);
  if(pa.to_end<2) { break; }
  aaParserSeek(&pa,1);
  aaParserStackPush(&pa);
  aaParserCopy(&pb,&pa,NO);
  if(aaParserSeekToString(&pa,"; ",YES,YES,PARSERFLAG_SAFE)!=YES)     {     if(aaParserSeek(&pa,pa.to_end)!=YES) oof;     }
  aaParserStackString(&pa,0,sizeof(buf),buf,YES);
  aaStringCopyf(cookie->value,"%s",buf);
  if(pa.to_end<2) { break; }
  aaParserSeek(&pa,2);
  aaParserSeekToVisibleChar(&pa,YES,YES);
  aaParserStackPush(&pa);
  aaParserCopy(&pb,&pa,NO);
  if(aaParserSeekToString(&pa,"; ",YES,YES,PARSERFLAG_SAFE)!=YES)     {     if(aaParserSeek(&pa,pa.to_end)!=YES) oof;     }
  aaParserStackString(&pa,0,sizeof(buf),buf,YES);
  aaStringFindChar(buf,0,&pos,'=',YES,0,YES);
  if(pos!=0xffffffff)
   {
   if(aaStringNICompare(buf,"expires",pos,0)==YES)
    {
    aaStringCopyf(cookie->expires_text,"%s",&buf[pos+1]);
    if(aaTimeFromString(&cookie->expires,&buf[pos+1])!=YES)
     {
     aaNote(0,"a %s",&buf[pos+1]);
     }
    }
   else
   if(aaStringNICompare(buf,"path",pos,0)==YES)     {    aaStringCopyf(cookie->path,"%s",&buf[pos+1]);    }
   else
   if(aaStringNICompare(buf,"domain",pos,0)==YES)   {    aaStringCopyf(cookie->domain,"%s",&buf[pos+1]);    }
   }
  else
   {
   if(aaStringICompare(buf,"HttpOnly",0)==YES) { cookie->is_http_only=YES; }
   else
   if(aaStringICompare(buf,"secure",0)==YES) { cookie->is_secure=YES; }
   }
  if(pa.to_end<2) { break; }
  aaParserSeek(&pa,2);
  aaParserSeekToVisibleChar(&pa,YES,YES);
  aaParserStackPush(&pa);
  aaParserCopy(&pb,&pa,NO);
  if(aaParserSeekToString(&pa,"; ",YES,YES,PARSERFLAG_SAFE)!=YES)     {     if(aaParserSeek(&pa,pa.to_end)!=YES) oof;     }
  aaParserStackString(&pa,0,sizeof(buf),buf,YES);
  aaStringFindChar(buf,0,&pos,'=',YES,0,YES);
  if(pos!=0xffffffff)
   {
   if(aaStringNICompare(buf,"expires",pos,0)==YES)
    {
    aaStringCopyf(cookie->expires_text,"%s",&buf[pos+1]);
    if(aaTimeFromString(&cookie->expires,&buf[pos+1])!=YES) oof;
    }
   else
   if(aaStringNICompare(buf,"path",pos,0)==YES)     {    aaStringCopyf(cookie->path,"%s",&buf[pos+1]);    }
   else
   if(aaStringNICompare(buf,"domain",pos,0)==YES)   {    aaStringCopyf(cookie->domain,"%s",&buf[pos+1]);    }
   }
  else
   {
   if(aaStringICompare(buf,"HttpOnly",0)==YES) { cookie->is_http_only=YES; }
   else
   if(aaStringICompare(buf,"secure",0)==YES) { cookie->is_secure=YES; }
   }
  if(pa.to_end<2) { break; }
  aaParserSeek(&pa,2);
  aaParserSeekToVisibleChar(&pa,YES,YES);
  aaParserStackPush(&pa);
  aaParserCopy(&pb,&pa,NO);
  if(aaParserSeekToString(&pa,"; ",YES,YES,PARSERFLAG_SAFE)!=YES)     {     if(aaParserSeek(&pa,pa.to_end)!=YES) oof;     }
  aaParserStackString(&pa,0,sizeof(buf),buf,YES);
  aaStringFindChar(buf,0,&pos,'=',YES,0,YES);
  if(pos!=0xffffffff)
   {
   if(aaStringNICompare(buf,"expires",pos,0)==YES)
    {
    aaStringCopyf(cookie->expires_text,"%s",&buf[pos+1]);
    if(aaTimeFromString(&cookie->expires,&buf[pos+1])!=YES) oof;
    }
   else
   if(aaStringNICompare(buf,"path",pos,0)==YES)     {    aaStringCopyf(cookie->path,"%s",&buf[pos+1]);    }
   else
   if(aaStringNICompare(buf,"domain",pos,0)==YES)   {    aaStringCopyf(cookie->domain,"%s",&buf[pos+1]);    }
   }
  else
   {
   if(aaStringICompare(buf,"HttpOnly",0)==YES) { cookie->is_http_only=YES; }
   else
   if(aaStringICompare(buf,"secure",0)==YES) { cookie->is_secure=YES; }
   }
  if(pa.to_end<2) { break; }
  aaParserSeek(&pa,2);
  aaParserSeekToVisibleChar(&pa,YES,YES);
  aaParserStackPush(&pa);
  aaParserCopy(&pb,&pa,NO);
  if(aaParserSeekToString(&pa,"; ",YES,YES,PARSERFLAG_SAFE)!=YES)     {     if(aaParserSeek(&pa,pa.to_end)!=YES) oof;     }
  aaParserStackString(&pa,0,sizeof(buf),buf,YES);
  aaStringFindChar(buf,0,&pos,'=',YES,0,YES);
  if(pos!=0xffffffff)
   {
   if(aaStringNICompare(buf,"expires",pos,0)==YES)
    {
    aaStringCopyf(cookie->expires_text,"%s",&buf[pos+1]);
    if(aaTimeFromString(&cookie->expires,&buf[pos+1])!=YES) oof;
    }
   else
   if(aaStringNICompare(buf,"path",pos,0)==YES)     {    aaStringCopyf(cookie->path,"%s",&buf[pos+1]);    }
   else
   if(aaStringNICompare(buf,"domain",pos,0)==YES)   {    aaStringCopyf(cookie->domain,"%s",&buf[pos+1]);    }
   }
  else
   {
   if(aaStringICompare(buf,"HttpOnly",0)==YES) { cookie->is_http_only=YES; }
   else
   if(aaStringICompare(buf,"secure",0)==YES) { cookie->is_secure=YES; }
   }
  if(pa.to_end<2) { break; }
  break;
  }
 if(cookie->expires_text[0])
  {
  aaTimeCompare(&cookie->expires,0,&cookie->expires_in);
  if(cookie->expires_in>0)
   {
   cookie->expires_in=aaNumNeg(cookie->expires_in);
   cookie->is_expired=YES;
   }
  else
   {
   cookie->expires_in=aaNumAbs(cookie->expires_in);
   cookie->is_expired=NO;
   }
  }
 return YES;
 }






 B aaNetAdrSet                         (_netadr*netadr,H ip,W port)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(netadr==NULL) { return RET_BADPARM;  }
 netadr->ip=ip;
 netadr->port=port;
 return RET_YES;
 }




 B aaNetAdrSetFromString               (_netadr*netadr,VP ip,W port)
 {
 B ret;
 H val;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(netadr==NULL) { return RET_BADPARM;  }
 aaNetAdrSet(netadr,0,0);
 if((ret=aaNetIpFromString(ip,&val))!=RET_YES) { return ret; }
 return(aaNetAdrSet(netadr,val,port));
 }





 B aaNetAdrCopy                        (_netadr*netadr,_netadr*snetadr)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(snetadr==NULL) { return RET_BADPARM; }
 return(aaNetAdrSet(netadr,snetadr->ip,snetadr->port));
 }




 B aaNetAdrToString                    (_netadr*netadr,VP string)
 {
 B txt[129];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(netadr==NULL) { return RET_BADPARM;  }
 aaNetIpToString(netadr->ip,txt);
 return(aaStringCopyf(string,"%s:%u",txt,netadr->port));
 }



 B aaNetAdrFromString                  (_netadr*netadr,VP string)
 {
 B txt[129];
 H pos,val;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(netadr==NULL) { return RET_BADPARM;  }
 aaNetAdrSet(netadr,0,0);
 if(string==NULL) {  return RET_BADPARM;  }
 if(aaStringFindChar(string,0,&pos,':',YES,0,YES)!=YES)
  {
  return(aaNetIpFromString(string,&netadr->ip));
  }
 aaStringCopy(txt,string);
 txt[pos]=NULL_CHAR;
 aaNetIpFromString(txt,&netadr->ip);
 if(aaStringToNumber(&txt[pos+1],0,&val,0,0,0)!=YES) { return RET_FAILED; }
 if(val>65535) { return RET_FAILED; }
 netadr->port=(W)val;
 return RET_YES;
 }




 B aaNetAdrEqualsAdr                   (_netadr*netadr,_netadr*netadr2)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(netadr==NULL) { return RET_BADPARM;  }
 if(netadr2==NULL) { return RET_BADPARM;  }
 if(netadr->ip!=netadr2->ip) { return RET_NO; }
 if(netadr->port!=netadr2->port) { return RET_NO; }
 return RET_YES;
 }




 B aaNetAdrToHashGet                   (_netadr*netadr,BP hash)
 {
 H i;
 B b;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(hash==NULL) { return RET_BADPARM; }
 *hash=b=0;
 if(netadr==NULL) { return RET_BADPARM; }
 aaCast(bp,BP,hash);
 for(i=0;i<4;i++) { b^=bp[i]; }
 b^=bp[4];
 b^=bp[5];
 *hash=b;
 return RET_YES;
 }



 B aaNetAdrFromFtpAdr                  (_netadr*netadr,VP string)
 {
 _parser pa;
 H sl,cnt,val,num;
 B txt[_1K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(netadr==NULL) { return RET_BADPARM; }
 netadr->ip=0;
 netadr->port=0;
 if(string==NULL) { return RET_BADPARM; }
 aaStringLen(string,&sl);
 if(sl<11||sl>23) { return RET_BADPARM; }
 aaParserInit(&pa,string,sl);
   aaParserSeekToChar(&pa,',',YES,YES);   aaParserSeekToChar(&pa,',',NO,YES);
   aaParserSeekToChar(&pa,',',YES,YES);   aaParserSeekToChar(&pa,',',NO,YES);
   aaParserSeekToChar(&pa,',',YES,YES);   aaParserSeekToChar(&pa,',',NO,YES);
   aaParserSeekToChar(&pa,',',YES,YES);   aaParserSeekToChar(&pa,',',NO,YES);
   aaStringNCopy(txt,&pa.bp[-pa.offset],pa.offset-1,YES);
   aaStringReplaceChar(txt,pa.offset-1,',','.');
   aaStringCountNumbers(pa.bp,pa.to_end,&cnt,YES);
   aaStringToNumber(pa.bp,cnt,&val,0,0,0);
   aaParserSeek(&pa,cnt);
   aaParserSeekToNumber(&pa,YES);
   aaStringCountNumbers(pa.bp,pa.to_end,&cnt,YES);
   aaStringToNumber(pa.bp,cnt,&num,0,0,0);
   val=(val*256)+num;
   aaNetIpFromString(txt,&netadr->ip);
   netadr->port=(W)val;
 return RET_YES;
 }






 B aaNetSubnetFromIp                   (_netsubnet*netsubnet,H ip,H mask)
 {
 H network_address;
 H bcast_ip;
 Z px=0;
 H mini,maxi;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(netsubnet==NULL) { return RET_BADPARM; }
 network_address=ip&mask;
 bcast_ip=~mask;
 bcast_ip=bcast_ip+network_address;
 mini=aaNumSwapDword(network_address)+1;
 mini=aaNumSwapDword(mini);
 maxi=aaNumSwapDword(bcast_ip)-1;
 maxi=aaNumSwapDword(maxi);
 while(mask) { px+=(mask&0x01); mask>>=1; }
 netsubnet->ip=ip;
 netsubnet->mask=mask;
 netsubnet->prefix=px;
 netsubnet->network_ip=network_address;
 netsubnet->broadcast_ip=bcast_ip;
 netsubnet->min_ip=mini;
 netsubnet->max_ip=maxi;
 return RET_YES;
 }




 B aaNetDnsCreate                      (HP handle,VP address,B mode,B bypass)
 {
 B ret;
 _aa_netdnsobject*narp;
 H bin;
 C ipa[4];
 B fwd;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(address==NULL) { return RET_BADPARM; }
 bypass&=1;
 if(aaNetIpFromString(address,&bin)==RET_YES)  {  fwd=YES;  }
 else                                          {  fwd=NO;   }
 if(fwd==NO)
  {
  if(mode==0) { mode=aa_DNS_MODE_A; }
  if(mode!=aa_DNS_MODE_A&&mode!=aa_DNS_MODE_MX&&mode!=aa_DNS_MODE_NS&&mode!=aa_DNS_MODE_SOA&&mode!=aa_DNS_MODE_CNAME&&mode!=aa_DNS_MODE_TXT)  {   return RET_BADPARM;   }
  }
 else
  {
  if(mode!=0) { return RET_BADPARM; }
  bypass=0;
  }
 if((ret=aa_ObjectCreate(aa.net_system.dns_object_id,handle,(VP)&narp))!=RET_YES) { oops;return ret; }
 narp->self_handle=*handle;
 aaMemoryFill(&narp->status,sizeof(_dnsstatus),0);
 aaStringCopy(narp->status.query,address);
 aaTimerTikGet(&narp->ms_tik);
 narp->status.mode=mode;
 narp->status.bypass=bypass;
 if(fwd==YES)
  {
  //aaDebugf("fwd=%i %s",fwd,narp->status.query);
  narp->status.is_forward=fwd;
  narp->status.is_inprogress=YES;
  narp->stage=20;
  (*(HP)&ipa)=bin;
  narp->resolver_handle=WSAAsyncGetHostByAddr(aa.net_system.window,aa.net_system.dns_message_id,ipa,4,AF_INET,(CP)narp->host_ent,MAXGETHOSTSTRUCT);
  if(narp->resolver_handle==NULL) { oof; }
  }
 else
  {
  //aaDebugf("fwd=%i %s, mode=%i",fwd,narp->status.query,narp->status.mode);
  narp->status.is_forward=fwd;
  narp->status.is_inprogress=YES;
  narp->timeout=500;
  narp->stage=100;
  }
 logg("name resolver Create ok");
 return RET_YES;
 }







 B aaNetDnsDestroy                     (H handle)
 {
 B ret;
 _aa_netdnsobject*narp;
 B isprot;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.dns_object_id,handle,(VP)&narp,&isprot))!=RET_YES) { return ret; }
 if(isprot==YES) { return RET_FORBIDDEN; }
 if(narp->resolver_handle!=NULL&&narp->status.is_inprogress)  {  WSACancelAsyncRequest(narp->resolver_handle); narp->resolver_handle=0; }
 if(narp->resolver_handle!=NULL) { WSACancelAsyncRequest(narp->resolver_handle);  narp->resolver_handle=0; }
 narp->resolver_handle=0;
 if(narp->udp.handle) { aaNetUdpDestroy(narp->udp.handle); narp->udp.handle=0; }
 aa_ObjectDestroy(aa.net_system.dns_object_id,handle);
 return RET_YES;
 }




 B aaNetDnsStatus                      (H handle,_dnsstatus*dnsstatus)
 {
 B ret;
 _aa_netdnsobject*narp;
 struct hostent *hp;
 N i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.dns_object_id,handle,(VP)&narp,NULL))!=RET_YES) { return ret; }
 aa_NetDnsYield((VP)&narp);

 if(narp->stage==3) /// complete
  {
  narp->status.is_inprogress=NO;
  aaCast(hp,struct hostent *,narp->host_ent);
  for(i=0;i<64;i++)
   {
   if(hp->h_addr_list[i]==NULL) break;
   narp->status.type[i]=0;
   narp->status.ip[i]=*(HP)&hp->h_addr_list[i];
   aaStringCopy(narp->status.host[i],hp->h_name);
   }
  narp->status.result_count=i;
  if(i==0)     {   narp->status.is_found=NO;   narp->status.is_notfound=NO;   narp->status.is_failed=YES;  }
  else         {   narp->status.is_found=YES;   narp->status.is_notfound=NO;   narp->status.is_failed=NO;   }
  narp->stage=4;
  }
 else
 if(narp->stage==1)  /// failed
  {
  narp->status.is_inprogress=NO;
  narp->status.is_found=NO;   narp->status.is_notfound=NO;   narp->status.is_failed=YES;
  }
 else
 if(narp->stage==2)  /// not found
  {
  narp->status.is_inprogress=NO;
  narp->status.is_found=NO;   narp->status.is_failed=NO;   narp->status.is_notfound=YES;
  }
 else
 if(narp->stage>=100&&narp->stage<=180)
  {
  //aaDebugf("stage=%i fwd=%i if=%i inf=%i isf=%i",narp->stage,narp->status.is_forward,narp->status.is_found,narp->status.is_notfound,narp->status.is_failed);
  }
 if(dnsstatus) { aaMemoryCopy(dnsstatus,sizeof(_dnsstatus),&narp->status); }
 return RET_YES;
 }

///=====================================================






 B aaNetIcmpPktSet                     (_icmppkt*icmppkt,H remoteip,B type,B code,W id,W seq,W databytes)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(icmppkt==NULL) { return RET_BADPARM; }
 if(remoteip==0) { return RET_BADPARM; }
 if(databytes>65000) { return RET_BADPARM; }
 icmppkt->local_ip=0;
 icmppkt->remote_ip=remoteip;
 icmppkt->type=type;
 icmppkt->code=code;
 icmppkt->data_bytes=databytes;
 icmppkt->id=id;
 icmppkt->seq=seq;
 return RET_YES;
 }





 B aaNetIcmpPktCopy                    (_icmppkt*icmppkt,_icmppkt*sicmppkt)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(icmppkt==NULL) { return RET_BADPARM; }
 if(sicmppkt==NULL) { return RET_BADPARM; }
 icmppkt->local_ip=sicmppkt->local_ip;
 icmppkt->remote_ip=sicmppkt->remote_ip;
 icmppkt->type=sicmppkt->type;
 icmppkt->code=sicmppkt->code;
 icmppkt->data_bytes=sicmppkt->data_bytes;
 icmppkt->seq=sicmppkt->seq;
 icmppkt->id=sicmppkt->id;
 return RET_YES;
 }







 B aaNetIcmpCreate                     (HP handle)
 {
 B ret;
 _aa_neticmpobject*icmpp;
 SOCKET sock;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCreate(aa.net_system.icmp_object_id,handle,(VP)&icmpp))!=RET_YES) { oops;return ret; }
 if((ret=aaQueCreate(&icmpp->rcve_que))!=RET_YES)
  {
  aa_ObjectDestroy(aa.net_system.icmp_object_id,*handle);
  *handle=0;
  return RET_FAILED;
  }
 if((ret=aaQueCreate(&icmpp->xmit_que))!=RET_YES)
  {
  aaQueDestroy(icmpp->rcve_que);
  aa_ObjectDestroy(aa.net_system.icmp_object_id,*handle);
  *handle=0;
  return RET_FAILED;
  }
 icmpp->self_handle=*handle;
 sock=socket(AF_INET,SOCK_RAW,IPPROTO_ICMP);
 if(sock==(SOCKET)SOCKET_ERROR)
  {
  aaQueDestroy(icmpp->rcve_que);
  aaQueDestroy(icmpp->xmit_que);
  aa_ObjectDestroy(aa.net_system.icmp_object_id,*handle);
  *handle=0;
  return RET_FAILED;
  }
 icmpp->sock=sock;
 if(WSAAsyncSelect(sock,aa.net_system.window,aa.net_system.icmp_message_id,FD_READ|FD_WRITE))
  {
  closesocket(sock);
  aaQueDestroy(icmpp->rcve_que);
  aaQueDestroy(icmpp->xmit_que);
  aa_ObjectDestroy(aa.net_system.icmp_object_id,*handle);
  *handle=0;
  return RET_FAILED;
  }
 aaTimerTikGet(&icmpp->ms_root);
 icmpp->inactive_ms_root=icmpp->ms_root;
 return RET_YES;
 }






 B aaNetIcmpDestroy                    (H handle)
 {
 B ret;
 _aa_neticmpobject*icmpp;
 B isprot;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.icmp_object_id,handle,(VP)&icmpp,&isprot))!=RET_YES) { return ret; }
 if(isprot) { return RET_FORBIDDEN; }
 if(closesocket(icmpp->sock)==SOCKET_ERROR) { aaNote(0,"icmpdest"); }
 aaQueDestroy(icmpp->rcve_que);
 aaQueDestroy(icmpp->xmit_que);
 aa_ObjectDestroy(aa.net_system.icmp_object_id,handle);
 return RET_YES;
 }




 B aaNetIcmpStatus                     (H handle,_icmpstatus*icmpstatus)
 {
 B ret;
 _aa_neticmpobject*icmpp;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.icmp_object_id,handle,(VP)&icmpp,NULL))!=RET_YES) { return ret; }
 aa_NetSystemProcessIcmp((VP)&icmpp,YES,YES);
 if(icmpstatus) { aaMemoryCopy(icmpstatus,sizeof(_icmpstatus),&icmpp->status); }
 return RET_YES;
 }






 B aaNetIcmpPktWrite                   (H handle,_icmppkt*icmppkt,VP data)
 {
 B ret;
 _aa_neticmpobject*icmpp;
 BP tmp=NULL_POINTR;
 _aa_neticmpheader*icmphdr;
 struct sockaddr_in addr;
 H by;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(icmppkt==NULL) { return RET_BADPARM; }
 if(icmppkt->data_bytes!=0&&data==NULL) { return RET_BADPARM; }
 if((ret=aa_ObjectCheck(aa.net_system.icmp_object_id,handle,(VP)&icmpp,NULL))!=RET_YES) { return ret; }
 if((ret=aa_MemoryTemp((VP)&tmp,_64K+_1K,aa_MEMORYTEMP_IcmpWritef))!=RET_YES) { return ret; }
 WinSockAddrSet(&addr,AF_INET,icmppkt->remote_ip,0);
 aaCast(icmphdr,_aa_neticmpheader*,tmp);
 icmphdr->type=icmppkt->type;
 icmphdr->code=icmppkt->code;
 icmphdr->crc=0;
 icmphdr->seq=icmppkt->seq;
 icmphdr->id=icmppkt->id;
 by=icmppkt->data_bytes;
 aaMemoryCopy(&tmp[sizeof(_aa_neticmpheader)],(H)by,data);
 aaNetRfcCrcGet(tmp,sizeof(_aa_neticmpheader)+by,&icmphdr->crc);
 if((ret=aaQueWrite(icmpp->xmit_que,sizeof(addr),&addr))!=RET_YES)  {  oops; return ret;  }
 if((ret=aaQueWrite(icmpp->xmit_que,4,&by))!=RET_YES)  { oops; return ret;  }
 if((ret=aaQueWrite(icmpp->xmit_que,sizeof(_aa_neticmpheader)+by,tmp))!=RET_YES)  { oops; return ret;  }
 icmpp->status.xmit_pkts_qued++;
 icmpp->status.total_bytes_sent+=(icmppkt->data_bytes+4);
 aa_NetSystemProcessIcmp((VP)&icmpp,YES,YES);
 return RET_YES;
 }






 B aaNetIcmpPktRead                    (H handle,_icmppkt*icmppkt,H maxbytes,VP data)
 {
 B ret;
 _aa_neticmpobject*icmpp;
 _aa_neticmpheader icmphdr;
 struct sockaddr_in addr;
 B tmp[128];
 H len;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(icmppkt==NULL) { return RET_BADPARM; }
 aaMemoryFill(icmppkt,sizeof(_icmppkt),0);
 if(maxbytes!=0&&data==NULL) { return RET_BADPARM; }
 if((ret=aa_ObjectCheck(aa.net_system.icmp_object_id,handle,(VP)&icmpp,NULL))!=RET_YES) { return ret; }
 aa_NetSystemProcessIcmp((VP)&icmpp,YES,NO);
 if(icmpp->status.rcve_pkts_qued==0) { return RET_NOTREADY; }
 if((ret=aaQuePeek(icmpp->rcve_que,0,sizeof(addr)+4+4+1,tmp))!=RET_YES) { return ret; }
 aaMemoryCopy(&addr,sizeof(addr),tmp);
 aaMemoryPeekDword(&tmp[sizeof(addr)],0,&len);
 icmppkt->remote_ip=(*(HP)&addr.sin_addr);
 icmppkt->data_bytes=(W)(len);
 icmppkt->local_ip=(*(HP)&tmp[sizeof(addr)+4]);
 if(icmppkt->data_bytes>maxbytes) { return RET_BOUNDS; }
 if((ret=aaQueDiscard(icmpp->rcve_que,sizeof(addr)+4+4))!=RET_YES) { return ret; }
 if((ret=aaQueRead(icmpp->rcve_que,sizeof(_aa_neticmpheader),&icmphdr))!=RET_YES) { return ret; }
 if(icmppkt->data_bytes)
  {
  if((ret=aaQueRead(icmpp->rcve_que,icmppkt->data_bytes,data))!=RET_YES) { return ret; }
  }
 icmppkt->type=icmphdr.type;
 icmppkt->code=icmphdr.code;
 icmppkt->seq=icmphdr.seq;
 icmppkt->id=icmphdr.id;
 icmpp->status.total_pkts_received++;
 icmpp->status.rcve_pkts_qued--;
 icmpp->status.total_bytes_received+=(icmppkt->data_bytes+4);
 return RET_YES;
 }







 B aaNetIcmpPktPeek                    (H handle,_icmppkt*icmppkt,H maxbytes,VP data)
 {
 B ret;
 _aa_neticmpobject*icmpp;
 _aa_neticmpheader icmphdr;
 struct sockaddr_in addr;
 B tmp[128];
 H len,off;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(icmppkt==NULL) { return RET_BADPARM; }
 aaMemoryFill(icmppkt,sizeof(_icmppkt),0);
 if(maxbytes!=0&&data==NULL) { return RET_BADPARM; }
 if((ret=aa_ObjectCheck(aa.net_system.icmp_object_id,handle,(VP)&icmpp,NULL))!=RET_YES) { return ret; }
 aa_NetSystemProcessIcmp((VP)&icmpp,YES,NO);
 if(icmpp->status.rcve_pkts_qued==0) { return RET_NOTREADY; }
  if((ret=aaQuePeek(icmpp->rcve_que,0,sizeof(addr)+4+4,tmp))!=RET_YES) { return ret; }
 aaMemoryCopy(&addr,sizeof(addr),tmp);
 aaMemoryPeekDword(&tmp[sizeof(addr)],0,&len);
 icmppkt->remote_ip=(*(HP)&addr.sin_addr);
 icmppkt->data_bytes=(W)(len);
 icmppkt->local_ip=(*(HP)&tmp[sizeof(addr)+4]);
 if(icmppkt->data_bytes>maxbytes) { return RET_BOUNDS; }
 off=sizeof(addr)+4+4;
 if((ret=aaQuePeek(icmpp->rcve_que,off,sizeof(_aa_neticmpheader),&icmphdr))!=RET_YES) { return ret; }
 off+=sizeof(_aa_neticmpheader);
 if(icmppkt->data_bytes)
  {
  if((ret=aaQuePeek(icmpp->rcve_que,off,icmppkt->data_bytes,data))!=RET_YES) { return ret; }
  }
 icmppkt->type=icmphdr.type;
 icmppkt->code=icmphdr.code;
 icmppkt->seq=icmphdr.seq;
 icmppkt->id=icmphdr.id;
 return RET_YES;
 }






 B aaNetIcmpPktDiscard                 (H handle)
 {
 B ret;
 _aa_neticmpobject*icmpp;
 struct sockaddr_in addr;
 B tmp[128];
 H len;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.icmp_object_id,handle,(VP)&icmpp,NULL))!=RET_YES) { return ret; }
 aa_NetSystemProcessIcmp((VP)&icmpp,YES,NO);
 if(icmpp->status.rcve_pkts_qued==0) { return RET_NOTREADY; }
 if((ret=aaQuePeek(icmpp->rcve_que,0,sizeof(addr)+4+4+1,tmp))!=RET_YES) { return ret; }
 aaMemoryPeekDword(&tmp[sizeof(addr)],0,&len);
 if((ret=aaQueDiscard(icmpp->rcve_que,len+sizeof(_aa_neticmpheader)+sizeof(addr)+4+4))!=RET_YES) { return ret; }

 icmpp->status.total_pkts_received++;
 icmpp->status.total_bytes_received+=(len+4);

 icmpp->status.rcve_pkts_qued--;
 if(addr.sin_family!=addr.sin_family) {}
 return RET_YES;
 }





 B aaNetIcmpPktReturn                  (H handle)
 {
 B ret;
 //_icmppkt pkt;
 _aa_neticmpobject*icmpp;
 struct sockaddr_in addr;
 B data[_64K];
 B tmp[128];
 H len;
 _aa_neticmpheader icmphdr;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.icmp_object_id,handle,(VP)&icmpp,NULL))!=RET_YES) { return ret; }
 aa_NetSystemProcessIcmp((VP)&icmpp,YES,NO);
 if(icmpp->status.rcve_pkts_qued==0) { return RET_NOTREADY; }
 if(icmpp->status.rcve_pkts_qued==1) { return RET_YES; }

 if((ret=aaQueRead(icmpp->rcve_que,sizeof(addr)+4+4,tmp))!=RET_YES) {oops; return ret; }

 aaMemoryCopy(&addr,sizeof(addr),tmp);
 aaMemoryPeekDword(&tmp[sizeof(addr)],0,&len);
 if((ret=aaQueRead(icmpp->rcve_que,sizeof(_aa_neticmpheader),&icmphdr))!=RET_YES) { oops; return ret; }
 if(len)
  {
  if((ret=aaQueRead(icmpp->rcve_que,len,data))!=RET_YES) { oops; return ret; }
  }

 if((ret=aaQueWrite(icmpp->rcve_que,sizeof(addr)+4+4,tmp))!=YES) { oops; return ret; }
 if((ret=aaQueWrite(icmpp->rcve_que,sizeof(_aa_neticmpheader),&icmphdr))!=YES) { oops; return ret; }
 if(len)
  {
  if((ret=aaQueWrite(icmpp->rcve_que,len,data))!=YES) { oops; return ret; }
  }
// icmpp->status.rcve_pkts_qued++;
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/




 B aaNetSniffCreate                  (HP handle,H ip)
 {
 B ret;
 struct sockaddr_in sniff_addr;
 _aa_netsniffobject*snifp;
 SOCKET sock;
 int optval;
 H dwlen,i;
 _localip lip;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(ip==0)
  {
  if(handle) { *handle=0; }
  aaNetLocalIpGet(&lip,NO,NO);
  for(i=0;i<32;i++) {   if(lip.type[i]=='P') break;   }
  if(i==32)
   {
   for(i=0;i<32;i++) {  if(lip.type[i]=='I') break; }
   }
  if(i!=32) { ip=lip.ip[i]; }
  if(ip==0) { return RET_FAILED; }
  }
 if((ret=aa_ObjectCreate(aa.net_system.sniff_object_id,handle,(VP)&snifp))!=RET_YES) { oops;return ret; }
 if((ret=aaQueCreate(&snifp->rcve_que))!=RET_YES)
  {
  aa_ObjectDestroy(aa.net_system.sniff_object_id,*handle);
  *handle=0;
  return RET_FAILED;
  }
 snifp->self_handle=*handle;
 sock=socket(AF_INET,SOCK_RAW,IPPROTO_IP);
 if(sock==(SOCKET)SOCKET_ERROR)
  {
  aaQueDestroy(snifp->rcve_que);
  aa_ObjectDestroy(aa.net_system.sniff_object_id,*handle);
  *handle=0;
  return RET_FAILED;
  }
 snifp->sock=sock;
 WinSockAddrSet(&sniff_addr,AF_INET,ip,0);
 if(bind(snifp->sock,(struct sockaddr*)&sniff_addr,sizeof(sniff_addr))==SOCKET_ERROR)
  {
  oof;
  aaQueDestroy(snifp->rcve_que);
  aa_ObjectDestroy(aa.net_system.sniff_object_id,*handle);
  *handle=0;
  return RET_FAILED;
  }

 optval=3; dwlen=4;
 if(WSAIoctl(snifp->sock,/*SIO_RCVALL*/(IOC_IN|(0x18000000)|(1)),&optval,sizeof(optval),NULL,0,&dwlen,NULL,NULL)==SOCKET_ERROR)
  {
  oof;
  oow;
  aaQueDestroy(snifp->rcve_que);
  aa_ObjectDestroy(aa.net_system.sniff_object_id,*handle);
  *handle=0;
  oof;
  return RET_FAILED;
  }
 if(WSAAsyncSelect(snifp->sock,aa.net_system.window,aa.net_system.sniff_message_id,FD_READ|FD_ACCEPT|FD_CLOSE|FD_CONNECT))
  {
  closesocket(snifp->sock);
  aaQueDestroy(snifp->rcve_que);
  aa_ObjectDestroy(aa.net_system.sniff_object_id,*handle);
  *handle=0;
  return RET_FAILED;
  }
 optval=_2MEG; dwlen=4;
 if(setsockopt(snifp->sock,SOL_SOCKET,SO_RCVBUF,(CP)&optval,dwlen)!=0) oof;
 aaTimerTikGet(&snifp->ms_root);
 snifp->inactive_ms_root=snifp->ms_root;
 return RET_YES;
 }





 B aaNetSniffDestroy                 (H handle)
 {
 B ret;
 _aa_netsniffobject*snifp;
 B isprot;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.sniff_object_id,handle,(VP)&snifp,&isprot))!=RET_YES) { return ret; }
 if(isprot) { return RET_FORBIDDEN; }
 if(closesocket(snifp->sock)==SOCKET_ERROR) { aaNote(0,"sniffdest"); }
 aaQueDestroy(snifp->rcve_que);
 aa_ObjectDestroy(aa.net_system.sniff_object_id,handle);
 return RET_YES;
 }



 B aaNetSniffStatus                  (H handle,_sniffstatus*sniffstatus)
 {
 B ret;
 _aa_netsniffobject*snifp;
 H go,prq;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.sniff_object_id,handle,(VP)&snifp,NULL))!=RET_YES) { return ret; }
 prq=snifp->status.rcve_pkts_qued;
 for(go=0;go<256;go++)
  {
  aa_NetSystemProcessSniff((VP)&snifp);
  if(snifp->status.rcve_pkts_qued==prq) break;
  prq=snifp->status.rcve_pkts_qued;
  }
 if(sniffstatus) { aaMemoryCopy(sniffstatus,sizeof(_sniffstatus),&snifp->status); }
 return RET_YES;
 }



 B aaNetSniffPktRead                   (H handle,_sniffpkt*sniffpkt)
 {
 B ret;
 _aa_netsniffobject*snifp;
 _questatus qs;
 H lens[8];
 Q ts;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(sniffpkt==NULL) { return RET_BADPARM; }
 aaMemoryFill(sniffpkt,(sizeof(_sniffpkt)-sizeof(sniffpkt->data)),0);
 if((ret=aa_ObjectCheck(aa.net_system.sniff_object_id,handle,(VP)&snifp,NULL))!=RET_YES) { return ret; }
 aaNetSniffStatus(handle,NULL);
 if(snifp->status.rcve_pkts_qued==0) { return RET_NOTREADY; }
 aaQueStatus(snifp->rcve_que,&qs);
 if((ret=aaQuePeek(snifp->rcve_que,0,8,&ts))!=YES) { oops; return ret; }
 sniffpkt->time_stamp=ts;
 if((ret=aaQuePeek(snifp->rcve_que,8+0,8,lens))!=YES) { oops; return ret; }
 sniffpkt->total_length=lens[0];
 sniffpkt->header_ip_length=lens[1];

 if((ret=aaQuePeek(snifp->rcve_que,8+8,lens[1],&sniffpkt->header_ip))!=YES) { oops; return ret; }
 if(sniffpkt->header_ip.protocol==6)
  {
  if((ret=aaQuePeek(snifp->rcve_que,8+8+lens[1],4,&lens[2]))!=YES) { oops; return ret; }
  sniffpkt->header_tcp_length=lens[2];
  if((ret=aaQuePeek(snifp->rcve_que,8+8+lens[1]+4,lens[2],&sniffpkt->header_tcp))!=YES) { oops; return ret; }
  }
 else
 if(sniffpkt->header_ip.protocol==17)
  {
  if((ret=aaQuePeek(snifp->rcve_que,8+8+lens[1],4,&lens[2]))!=YES) { oops; return ret; }
  sniffpkt->header_udp_length=lens[2];
  if((ret=aaQuePeek(snifp->rcve_que,8+8+lens[1]+4,lens[2],&sniffpkt->header_udp))!=YES) { oops; return ret; }
  }
 if((ret=aaQuePeek(snifp->rcve_que,8+8+lens[1]+4+lens[2],4,&lens[3]))!=YES) { oops; return ret; }
 sniffpkt->data_length=lens[3];
 if(sniffpkt->data_length!=0)
  {
  if((ret=aaQuePeek(snifp->rcve_que,8+8+lens[1]+4+lens[2]+4,lens[3],sniffpkt->data))!=YES) { oops; return ret; }
  }
 return(aaNetSniffPktDiscard(handle));
 return RET_YES;
 }




 B aaNetSniffPktPeek                   (H handle,H index,_sniffpkt*sniffpkt,B dataflag)
 {
 B ret;
 _aa_netsniffobject*snifp;
 _questatus qs;
 H lens[8],i,po;
 Q ts;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(sniffpkt==NULL) { return RET_BADPARM; }
 aaMemoryFill(sniffpkt,(sizeof(_sniffpkt)-sizeof(sniffpkt->data)),0);
 if((ret=aa_ObjectCheck(aa.net_system.sniff_object_id,handle,(VP)&snifp,NULL))!=RET_YES) { return ret; }
 aaNetSniffStatus(handle,NULL);
 if(snifp->status.rcve_pkts_qued==0) { return RET_NOTREADY; }
 if(index>=snifp->status.rcve_pkts_qued) { return RET_BOUNDS; }
 aaQueStatus(snifp->rcve_que,&qs);
 po=0;
 for(i=0;i<index;i++)
  {
  if((ret=aaQuePeek(snifp->rcve_que,po+0,8,&ts))!=YES) { oops; return ret; }
  if((ret=aaQuePeek(snifp->rcve_que,8+po+0,8,lens))!=YES) { oops; return ret; }
  if((ret=aaQuePeek(snifp->rcve_que,8+po+8+lens[1],4,&lens[2]))!=YES) { oops; return ret; }
  if((ret=aaQuePeek(snifp->rcve_que,8+po+8+lens[1]+4+lens[2],4,&lens[3]))!=YES) { oops; return ret; }
  po+=8+4+4+lens[1]+4+lens[2]+4+lens[3];
  }
 if((ret=aaQuePeek(snifp->rcve_que,po,8,&ts))!=YES)
  {
  oops; return ret;
  }
 if((ret=aaQuePeek(snifp->rcve_que,8+po+0,8,lens))!=YES)
  {
  oops; return ret;
  }
  sniffpkt->time_stamp=ts;
 sniffpkt->total_length=lens[0];
 sniffpkt->header_ip_length=lens[1];

 if((ret=aaQuePeek(snifp->rcve_que,8+po+8,lens[1],&sniffpkt->header_ip))!=YES) { oops; return ret; }
 if(sniffpkt->header_ip.protocol==6)
  {
  if((ret=aaQuePeek(snifp->rcve_que,8+po+8+lens[1],4,&lens[2]))!=YES) { oops; return ret; }
  sniffpkt->header_tcp_length=lens[2];
  if((ret=aaQuePeek(snifp->rcve_que,8+po+8+lens[1]+4,lens[2],&sniffpkt->header_tcp))!=YES) { oops; return ret; }
  }
 else
 if(sniffpkt->header_ip.protocol==17)
  {
  if((ret=aaQuePeek(snifp->rcve_que,8+po+8+lens[1],4,&lens[2]))!=YES) { oops; return ret; }
  sniffpkt->header_udp_length=lens[2];
  if((ret=aaQuePeek(snifp->rcve_que,8+po+8+lens[1]+4,lens[2],&sniffpkt->header_udp))!=YES) { oops; return ret; }
  }
 if((ret=aaQuePeek(snifp->rcve_que,8+po+8+lens[1]+4+lens[2],4,&lens[3]))!=YES) { oops; return ret; }
 sniffpkt->data_length=lens[3];
 if(sniffpkt->data_length!=0)
  {
  if(dataflag)
   {
   if((ret=aaQuePeek(snifp->rcve_que,8+po+8+lens[1]+4+lens[2]+4,lens[3],sniffpkt->data))!=YES) { oops; return ret; }
   }
  }
 return RET_YES;
 }



 B aaNetSniffPktDiscard                (H handle)
 {
 B ret;
 _aa_netsniffobject*snifp;
 _questatus qs;
 H lens[8];
 Q ts;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.sniff_object_id,handle,(VP)&snifp,NULL))!=RET_YES) { return ret; }
 aaNetSniffStatus(handle,NULL);
 if(snifp->status.rcve_pkts_qued==0) { return RET_NOTREADY; }
 aaQueStatus(snifp->rcve_que,&qs);
 if((ret=aaQuePeek(snifp->rcve_que,0,8,&ts))!=YES) { oops; return ret; }
 if((ret=aaQuePeek(snifp->rcve_que,8+0,8,lens))!=YES) { oops; return ret; }
 if((ret=aaQuePeek(snifp->rcve_que,8+8+lens[1],4,&lens[2]))!=YES) { oops; return ret; }
 if((ret=aaQuePeek(snifp->rcve_que,8+8+lens[1]+4+lens[2],4,&lens[3]))!=YES) { oops; return ret; }
 aaQueDiscard(snifp->rcve_que,8+4+4+lens[1]+4+lens[2]+4+lens[3]);
 snifp->status.rcve_pkts_qued--;
 snifp->status.total_pkts_received++;
 snifp->status.total_bytes_received+=lens[0];
 return RET_YES;
 }




 B aaNetSniffPktReturn                 (H handle)
 {
 B ret;
 _aa_netsniffobject*snifp;
 _questatus qs;
 H lens[8];
 BP tmp=NULL_POINTR;
 Q ts;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.sniff_object_id,handle,(VP)&snifp,NULL))!=RET_YES) { return ret; }
 aaNetSniffStatus(handle,NULL);
 if(snifp->status.rcve_pkts_qued==0) { return RET_NOTREADY; }
 if(snifp->status.rcve_pkts_qued==1) { return RET_YES; }
 aaQueStatus(snifp->rcve_que,&qs);
 if((ret=aaQuePeek(snifp->rcve_que,0,8,&ts))!=YES) { oops; return ret; }
 if((ret=aaQuePeek(snifp->rcve_que,8+0,8,lens))!=YES) { oops; return ret; }
 if((ret=aaQuePeek(snifp->rcve_que,8+8+lens[1],4,&lens[2]))!=YES) { oops; return ret; }
 if((ret=aaQuePeek(snifp->rcve_que,8+8+lens[1]+4+lens[2],4,&lens[3]))!=YES) { oops; return ret; }
 if((ret=aa_MemoryTemp((VP)&tmp,_64K+_1K,aa_MEMORYTEMP_SniffPktRet))!=RET_YES) { return ret; }
 if((ret=aaQueRead(snifp->rcve_que,8+4+4+lens[1]+4+lens[2]+4+lens[3],tmp))!=YES) { oops; }
 if((ret=aaQueWrite(snifp->rcve_que,8+4+4+lens[1]+4+lens[2]+4+lens[3],tmp))!=YES) { oops; }
 aaQueStatus(snifp->rcve_que,&qs);
 aaNetSniffStatus(handle,NULL);
 return RET_YES;
 }





/*-----------------------------------------------------------------------*/


 B aaNetServerCreate                   (HP handle,H ip,W port,H maxcalls,H extra)
 {
 B ret;
 H han;
 _aa_netserverobject*srvop;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(port==0) { return RET_BADPARM; }
 if(maxcalls==0) { return RET_BADPARM; }
 if((ret=aa_ObjectCreate(aa.net_system.server_object_id,handle,(VP)&srvop))!=RET_YES) { return ret; }
 srvop->self_handle=*handle;
 srvop->status.max_calls=maxcalls;
 srvop->status.extra_bytes=extra;
 if((ret=aaNetTcpPortCreate(&han,ip,port,extra+32))!=YES)
  {
  aa_ObjectDestroy(aa.net_system.server_object_id,*handle);
  *handle=0;
  return ret;
  }
 srvop->status.port.handle=han;
 srvop->status.is_calls_allowed=YES;
 aaNetTcpPortStatus(srvop->status.port.handle,&srvop->status.port.status);
 return RET_YES;
 }





 B aaNetServerDestroy                  (H handle)
 {
 B ret;
 B isprot;
 _aa_netserverobject*srvop;
 _tcpcallunit cu;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.server_object_id,handle,(VP)&srvop,&isprot))!=RET_YES) { return ret; }
 if(isprot==YES) { return RET_FORBIDDEN; }
 //srvop->status.is_calls_allowed=NO;
 while(1)
  {
  if(srvop->status.port.handle==0) { break; }
  if((ret=aaNetTcpPortStatus(srvop->status.port.handle,&srvop->status.port.status))!=YES) { oops; }
  if(srvop->status.port.status.calls_inuse==0&&srvop->status.port.status.calls_waiting==0&&srvop->status.port.status.calls_answered==0) { break; }
 // if(srvop->status.port.status.calls_waiting==0&&srvop->status.port.status.calls_answered==0) { break; }
  if((ret=aaNetTcpPortCallNext(srvop->status.port.handle,&cu.handle,&cu.status,0))!=YES)  { oops; continue; }
  if((ret=aaNetTcpCallDestroy(cu.handle))!=YES)  { oops; continue; }
  }
 if(srvop->status.port.handle!=0) {   aaNetTcpPortDestroy(srvop->status.port.handle); }
 aa_ObjectDestroy(aa.net_system.server_object_id,handle);
 return RET_YES;
 }




 B aaNetServerDisconnect               (H handle,VP proc)
 {
 B ret;
// B rv;
 B isprot;
 _tcpcallunit cu;
 _aa_netserverobject*srvop;
 B(*theproc)(H,_tcpcallunit*);

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.server_object_id,handle,(VP)&srvop,&isprot))!=RET_YES) { return ret; }
 if(proc==NULL) { return RET_BADPARM; }
 theproc=proc;
 while(1)
  {
  if(srvop->status.port.handle==0) { break; }
  if((ret=aaNetTcpPortStatus(srvop->status.port.handle,&srvop->status.port.status))!=YES) { oops; }
  if(srvop->status.port.status.calls_waiting==0&&srvop->status.port.status.calls_answered==0)
   {
   if(srvop->status.port.status.calls_inuse==0) { break; }
   }
  if((ret=aaNetTcpPortCallNext(srvop->status.port.handle,&cu.handle,&cu.status,0))!=YES)  { oops; continue; }
  if(theproc(handle,&cu)==RET_YES)
   {
   if((ret=aaNetTcpCallDestroy(cu.handle))!=YES)  { oops; continue; }
   }
  return RET_NOTREADY;
  }
 return RET_YES;
 }




 B aaNetServerStatus                   (H handle,_serverstatus*serverstatus,_tcpcallunit*tcpcallunit,PP extraptr)
 {
 B ret;
 B isprot;
 _aa_netserverobject*srvop;
 _tcpcallunit cu;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(tcpcallunit) { tcpcallunit->handle=0; }
 if(extraptr)    { *extraptr=NULL;        }
 if((ret=aa_ObjectCheck(aa.net_system.server_object_id,handle,(VP)&srvop,&isprot))!=RET_YES) { return ret; }
 cu.handle=0;
 if((ret=aaNetTcpPortStatus(srvop->status.port.handle,&srvop->status.port.status))!=YES) { oops;  }
 while(1)
   {
   if(srvop->status.port.status.calls_answered==0&&srvop->status.port.status.calls_waiting==0)  { break; }
   if((ret=aaNetTcpPortCallNext(srvop->status.port.handle,&cu.handle,&cu.status,0))!=YES) { oops; break; }
   if(cu.status.local_adr.port!=srvop->status.port.status.local_adr.port)                 { oof;  break; }
   if(cu.status.is_incoming==NO||cu.handle==0)                                            { oof;  break; }

   if(cu.status.is_connected!=YES)
    {
    if((srvop->status.port.status.calls_answered>=srvop->status.max_calls)||srvop->status.is_calls_allowed==NO)
     {
     if(aaNetTcpCallDestroy(cu.handle)!=YES) { oof; }
     cu.handle=0;
     if(aaNetTcpPortStatus(srvop->status.port.handle,&srvop->status.port.status)!=YES) { oof; }
     break;
     }
    if(aaNetTcpCallAnswer(cu.handle)!=YES) { oof; }
    aaNetTcpCallSlicerLengthSet(cu.handle,_8K,_8K);
    aaNetTcpCallBufferLengthSet(cu.handle,_32K,_32K);
    if(aaNetTcpCallStatus(cu.handle,&cu.status)!=YES) { oof; }
    if(aaNetTcpPortStatus(srvop->status.port.handle,&srvop->status.port.status)!=YES) { oof; }
    }

   if(cu.status.is_connected!=YES) {  oof;    }
   if(extraptr)                    { *extraptr=cu.status.extra_data;  }
   break;
   }

 if(serverstatus) { aaMemoryCopy(serverstatus,sizeof(_serverstatus),&srvop->status); }
 if(tcpcallunit&&cu.handle!=0)
  {
  tcpcallunit->handle=cu.handle;
  aaMemoryCopy(&tcpcallunit->status,sizeof(_tcpcallstatus),&cu.status);
  }
 return RET_YES;
 }




 B aaNetServerCallsAllow               (H handle,B state)
 {
 B ret;
 B isprot;
 _aa_netserverobject*srvop;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.server_object_id,handle,(VP)&srvop,&isprot))!=RET_YES) { return ret; }
 if(state==YES) { srvop->status.is_calls_allowed=YES; }
 else           { srvop->status.is_calls_allowed=NO; }
 return RET_YES;
 }





/*-----------------------------------------------------------------------*/



 B aaNetWebsocketInit                  (_websocket*websocket,H tcpcallhandle,VP fmt,...)
 {
 B ret;
 _tcpcallstatus cs;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(websocket==NULL) { return RET_MISSINGPARM; }
 aaVargsf4K(fmt);
 if((ret=aaNetTcpCallStatus(tcpcallhandle,&cs))!=YES) { return ret; }
 aaMemoryFill(websocket,sizeof(_websocket),0);
 websocket->magic=aaHPP(aaNetWebsocketInit);
 if(cs.is_incoming) { websocket->is_incoming=YES;  }
 websocket->tcp_handle=tcpcallhandle;
 if(websocket->is_incoming==NO)
  {
  if(str4k.buf[0]==NULL_CHAR) { return RET_MISSINGPARM; }
  aaStringCopyf(websocket->url,"%s",str4k.buf);
  }
 /*
 if(str4k.buf[0]!=NULL_CHAR)
  {
  aaStringCopyf(websocket->url,"%s",str4k.buf);
  aaStringReplaceChar(websocket->url,0,32,'+');
  //if((ret=aaNetUrlPartsGet(&websocket->up,websocket->url,YES,YES))!=YES) { oops; }
  }
 */
 websocket->stage=WEBSOCKET_STAGE_HANDSHAKE;
 return RET_YES;
 }






 B aaNetWebsocketYield                 (_websocket*websocket)
 {
 B ret;
 _tcpcallstatus cs;
 _httprequest req;
 _httpheader hed;
 B buf[_16K];
 B etc[_1K];
 B txt[_1K];
 B str[_1K];
 H sl,i;
 _digestunit dig;
 B asca,ascb;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(websocket==NULL) { return RET_MISSINGPARM; }
 if(websocket->magic!=aaHPP(aaNetWebsocketInit)) { return RET_NOTINITIALIZED; }
 if(websocket->phaze<50)
  {
  if((ret=aaNetTcpCallStatus(websocket->tcp_handle,&cs))!=YES) { return ret; }
  }

 //aaTimerTikElapsed(websocket->ms_root,&websocket->ms);
 switch(websocket->stage)
  {
  case WEBSOCKET_STAGE_HANDSHAKE:
  case WEBSOCKET_STAGE_OPEN:
  if(cs.is_ready!=YES)   {   break;   }
  if(websocket->is_incoming==YES)
   {
   switch(websocket->phaze)
    {
    case 0:
    if(aaNetHttpRequestRead(websocket->tcp_handle,&req)!=YES) break;
    aaStringCopyf(websocket->url,"%s",req.url);
    websocket->phaze=20;
    break;


    case 20:
    if(aaNetHttpHeaderRead(websocket->tcp_handle,&hed)!=YES) break;
    if(hed.field_code==aa_HTTPFIELD_HOST)
     {
     aaStringCopyf(websocket->url,"ws://%s",hed.data);
     aaStringReplaceChar(websocket->url,0,32,'+');
     //if((ret=aaNetUrlPartsGet(&websocket->up,websocket->url,YES,YES))!=YES) { oops; }
     }
    if(aaStringICompare(hed.field,"sec-websocket-key",0)==YES)
     {
     aaStringCopyf(websocket->sec_key,"%s",hed.data);
     aaStringCopyf(txt,"%s258EAFA5-E914-47DA-95CA-C5AB0DC85B11",hed.data);
     aaDigestQuick(aa_DIGESTTYPE_Sha1,0,str,0,txt);
     aaStringLen(str,&sl);
     aaStringHexToMemory(str,sl,0,etc);
     if(aaBase64Encode(etc,sl/2,str,&sl)!=YES) oof;
     aaStringCopyf(websocket->out_key,"%s",str);
     }
    if(hed.field_code!=aa_HTTPFIELD_BLANK) break;
      aaStringCopyf(buf,"HTTP/1.1 101 WebSocket Protocol Handshake\r\n");
    aaStringAppendf(buf,"Upgrade: WebSocket\r\n");
    aaStringAppendf(buf,"Connection: Upgrade\r\n");
    aaStringAppendf(buf,"Sec-WebSocket-Accept: %s\r\n",websocket->out_key);
    aaNetTcpCallWritef(websocket->tcp_handle,"%s\r\n",buf);
    websocket->stage=WEBSOCKET_STAGE_OPEN;
    websocket->is_open=YES;
    websocket->phaze=50;
    break;
    }
   }
  else
   {
   switch(websocket->phaze)
    {
    case 0:
    aaMemoryRandomSet(buf,16);
    if(aaBase64Encode(buf,0,str,&sl)!=YES) oof;
    aaStringCopyf(websocket->out_key,"%s",str);
    aaStringCopyf(buf,"%s258EAFA5-E914-47DA-95CA-C5AB0DC85B11",str);
    if(aaDigestCreate(&dig.handle,aa_DIGESTTYPE_Sha1)!=YES) oof;
    if(aaDigestWrite(dig.handle,0,buf,YES,0,txt)!=YES) oof;
    aaDigestDestroy(dig.handle);
    aaStringLen(txt,&sl);
    for(i=0;i<sl;i+=2)
     {
     asca=txt[i+0]; if(asca>='A'&&asca<='F') asca+=32;
     ascb=txt[i+1]; if(ascb>='A'&&ascb<='F') ascb+=32;
     if(asca>='0'&&asca<='9') { asca=asca-'0'; }  else  { asca=(asca-'a')+10;  }
     if(ascb>='0'&&ascb<='9') { ascb=ascb-'0'; }  else  { ascb=(ascb-'a')+10;  }
     str[i/2]=(asca*16)+ascb;
     }
    if(aaBase64Encode(str,sl/2,txt,&sl)!=YES) oof;
    aaStringCopyf(websocket->sec_key,"%s",txt);
    aaStringNull(buf);
    aaStringAppendf(buf,"GET %s HTTP/1.1\r\n",websocket->url);
    if(cs.host[0]!=NULL_CHAR)  {   aaStringAppendf(buf,"Host: %s:%u\r\n",cs.host,cs.remote_adr.port);     }
    else                       {   aaStringAppendf(buf,"Host: %s\r\n",cs.remote_dot);     }
    aaStringAppendf(buf,"Connection: Upgrade\r\n");
    aaStringAppendf(buf,"Sec-WebSocket-Key: %s\r\n",websocket->out_key);
    aaStringAppendf(buf,"Upgrade: websocket\r\n");
    aaStringAppendf(buf,"\r\n");
    if(aaNetTcpCallWritef(websocket->tcp_handle,"%s",buf)!=YES) break;
   // aaDebugf("%s",buf);
    websocket->phaze=20;
    break;

    case 20:
    case 26:
    if(aaNetHttpHeaderRead(websocket->tcp_handle,&hed)!=YES) break;
    if(aaStringICompare(hed.field,"sec-websocket-accept",0)==YES)
     {
     if(aaStringCompare(hed.data,websocket->sec_key,0)==YES) {  websocket->phaze=26; }
     }
    if(hed.field_code!=aa_HTTPFIELD_BLANK) break;
    if(websocket->phaze!=26) { break; }
    websocket->stage=WEBSOCKET_STAGE_OPEN;
    websocket->is_open=YES;
    websocket->phaze=50;
    break;
    }
   }

  break;


  default:
  break;
  }
 //if(wockstatus) { aaMemoryCopy(wockstatus,sizeof(_wockstatus),&websocket->status); }
 return RET_YES;
 }







 B aaNetWebsocketClose                 (_websocket*websocket)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(websocket==NULL) { return RET_MISSINGPARM; }
 if(websocket->magic!=aaHPP(aaNetWebsocketInit)) { return RET_NOTINITIALIZED; }
 if(websocket->is_close_sent==YES) { return RET_YES; }
 aaNetWebsocketWrite(websocket,WEBSOCKET_OPCODE_CLOSE,YES,0,0);
 websocket->is_close_sent=YES;
 return RET_YES;
 }





 B aaNetWebsocketWrite                 (_websocket*websocket,B opcode,B finflag,H bytes,VP data)
 {
 B ret;
 _tcpcallstatus cs;
 H mask,i,j,off,len,todo;
 H pktbytes,pktdone;
 Q qlen;
 B buf[_16K];
 BP mbp,bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(websocket==NULL) { return RET_MISSINGPARM; }
 if(websocket->magic!=aaHPP(aaNetWebsocketInit)) { return RET_NOTINITIALIZED; }
 if(websocket->stage!=WEBSOCKET_STAGE_OPEN)      { return RET_BADSTATE; }
 if(websocket->is_close_sent==YES)               { return RET_NOTOPEN;  }
 if(opcode>15)                                   { return RET_BADPARM; }
 if(bytes==0)
  {
  if(data!=NULL)
   {
   if(opcode==WEBSOCKET_OPCODE_TEXT||opcode==WEBSOCKET_OPCODE_BINARY)
    {
    aaStringLen(data,&bytes);
    }
   }
  }
 mbp=NULL;
 aaMemoryRandomDwordSet(&mask,0x00000001,0xfffffffe);
 i=opcode;
 if(finflag) { i=aaBitSet(i,7); }
 else        { i=aaBitClr(i,7); }
 buf[0]=(B)i;
 if(bytes<=125)
  {
  j=bytes;
  if(websocket->is_incoming==NO) { j=aaBitSet(j,7); }
  buf[1]=(B)j;
  off=2;
  }
 else
 if(bytes>=126&&bytes<=65536)
  {
  j=126;
  if(websocket->is_incoming==NO) { j=aaBitSet(j,7); }
  buf[1]=(B)j;
  j=aaNumSwapWord(bytes);
  *(WP)&buf[2]=j;
  off=4;
  }
 else
  {
  j=127;
  if(websocket->is_incoming==NO) { j=aaBitSet(j,7); }
  buf[1]=(B)j;
  qlen=bytes;
  *(QP)&buf[2]=qlen;
  bp=(BP)&buf[2];
  qlen=*(QP)&bp[0];;    qlen=aaNumSwapQuad(qlen);    *(QP)&bp[0]=qlen;
  len=*(HP)&bp[0];       len=aaNumSwapDword(len);    *(HP)&bp[0]=len;
  len=*(HP)&bp[4];       len=aaNumSwapDword(len);    *(HP)&bp[4]=len;
  off=10;
  }
 if(websocket->is_incoming==NO)
  {
  *(HP)&buf[off]=mask;
  aaCast(mbp,BP,&mask);
  off+=4;
  }
 pktdone=0;
 pktbytes=off+bytes;
 aaNetTcpCallWrite(websocket->tcp_handle,off,buf);
 pktdone+=off;
 j=0;
 aaCast(bp,BP,data);
 while(1)
  {
  todo=pktbytes-pktdone;
  if(todo==0) break;
  todo=aaNumRoof(todo,_2K);
  if(websocket->is_incoming==NO)
   {
   for(i=0;i<todo;i++) { buf[i]=bp[j]^mbp[j%4]; j++; }
   }
  else
   {
   for(i=0;i<todo;i++) { buf[i]=bp[j]; j++; }
   }
  aaNetTcpCallWrite(websocket->tcp_handle,todo,buf);
  pktdone+=todo;
  }
 websocket->xmit_pkts_total++;
 if((ret=aaNetTcpCallStatus(websocket->tcp_handle,&cs))!=YES) { return ret; }
 return RET_YES;
 }





 B aaNetWebsocketRead                  (_websocket*websocket,BP opcode,BP finflag,HP bytes,H maxbytes,VP data)
 {
 B ret;
 _tcpcallstatus cs;
 H todo,len,i,j;
 Q qlen;
 BP bp;
 BP dp;
 B zuf[128];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(websocket==NULL) { return RET_MISSINGPARM; }
 if(websocket->magic!=aaHPP(aaNetWebsocketInit)) { return RET_NOTINITIALIZED; }
 if(websocket->stage!=WEBSOCKET_STAGE_OPEN)      { return RET_BADSTATE; }
 if(websocket->phaze<50)                         { return RET_BADSTATE; }
 if(data==NULL)                                  { return RET_MISSINGPARM; }
 if(opcode)  { *opcode=0;  }
 if(finflag) { *finflag=0; }
 if(bytes)   { *bytes=0;   }

 if((ret=aaNetTcpCallStatus(websocket->tcp_handle,&cs))!=YES) { return ret; }
 switch(websocket->phaze)
  {
  case 50:
  todo=aaNumRoof(cs.rcve_bytes,16);
  if(todo<2) break;
  if(aaNetTcpCallPeek(websocket->tcp_handle,0,todo,zuf)!=YES) oof;
  websocket->frame_done=websocket->frame_bytes=0;
  websocket->frame_data_bytes=websocket->frame_data_offset=0;
  websocket->frame_size_bytes=websocket->frame_mask_offset=0;
  websocket->frame_is_fin=aaBitGet(zuf[0],7);
  websocket->frame_is_mask=aaBitGet(zuf[1],7);
  if(websocket->frame_is_fin!=1) { oof; }
  websocket->frame_opcode=zuf[0]&0x0f;
  len=zuf[1]&~128;
  websocket->frame_bytes=2;
  if(len<=125)
   {
   //aaDebugf("line=%i",__LINE__);
   websocket->frame_size_bytes=0;
   if(websocket->frame_is_mask) {  websocket->frame_mask_offset=websocket->frame_bytes+websocket->frame_size_bytes;  websocket->frame_bytes+=4; }
   websocket->frame_data_offset=websocket->frame_bytes+websocket->frame_size_bytes;
   websocket->frame_data_bytes=len;
   }
  else
  if(len==126)
   {
   //aaDebugf("line=%i",__LINE__);
   websocket->frame_size_bytes=2;
   websocket->frame_bytes+=websocket->frame_size_bytes;
   if(websocket->frame_is_mask) {  websocket->frame_mask_offset=websocket->frame_bytes;  websocket->frame_bytes+=4; }
   websocket->frame_data_offset=websocket->frame_bytes;
   len=*(WP)&zuf[2];
   len=aaNumSwapWord(len);
   websocket->frame_data_bytes=len;
   }
  else
  if(len==127)
   {
   ///aaDebugf("line=%i",__LINE__);
   websocket->frame_size_bytes=6;
   websocket->frame_bytes+=websocket->frame_size_bytes;
   if(websocket->frame_is_mask) { websocket->frame_mask_offset=websocket->frame_bytes;  websocket->frame_bytes+=4; }
   websocket->frame_data_offset=websocket->frame_bytes;
   bp=(BP)&zuf[2];
   qlen=*(QP)&bp[0];;    qlen=aaNumSwapQuad(qlen);    *(QP)&bp[0]=qlen;
   len=*(HP)&bp[0];       len=aaNumSwapDword(len);    *(HP)&bp[0]=len;
   len=*(HP)&bp[4];       len=aaNumSwapDword(len);    *(HP)&bp[4]=len;
   qlen=*(QP)&bp[0];
   websocket->frame_data_bytes=qlen;
   }
  websocket->frame_bytes+=websocket->frame_data_bytes;
  if(todo<websocket->frame_data_offset) break;
  if(websocket->frame_is_mask) {  websocket->frame_mask=*(HP)&zuf[websocket->frame_mask_offset]; }
  websocket->frame_done=websocket->frame_data_offset;
  aaNetTcpCallDiscard(websocket->tcp_handle,websocket->frame_done);
  if((ret=aaNetTcpCallStatus(websocket->tcp_handle,&cs))!=YES) { return ret; }
   //aaDebugf("fb=%i done=%i",websocket->frame_bytes,websocket->frame_done);
    //aaQueWrite(websocket->rcve_que.handle,1,&buf[0]);
    //aaQueWrite(websocket->rcve_que.handle,4,&websocket->frame_data_bytes);
    //aaQueStatus(websocket->rcve_que.handle,&websocket->rcve_que.status);
  websocket->phaze=100;
  //break;


  case 100:
  if(opcode)  { *opcode=websocket->frame_opcode;    }
  if(finflag) { *finflag=websocket->frame_is_fin;   }
  if(bytes)   { *bytes=websocket->frame_data_bytes; }
  if((websocket->frame_data_bytes+1)>maxbytes) { return RET_BOUNDS; }
  if((todo=aaNumRoof(cs.rcve_bytes,_4K))==0) { break; }
  todo=websocket->frame_bytes-websocket->frame_done;
  if(cs.rcve_bytes<todo) { break; }
  dp=(BP)data;
  if((ret=aaNetTcpCallRead(websocket->tcp_handle,todo,dp))!=YES) oops;
  if(websocket->frame_is_mask==YES)
   {
   bp=(BP)&websocket->frame_mask;
   for(i=0;i<todo;i++) { j=websocket->frame_done+websocket->frame_data_offset+i; dp[i]=dp[i]^bp[j%4];  }
   }
  //aaDebugf("fd=%i todo=%i fb=%i",websocket->frame_done,todo,websocket->frame_bytes);
  //aaQueWrite(websocket->rcve_que.handle,todo,buf);
  //aaQueStatus(websocket->rcve_que.handle,&websocket->rcve_que.status);
  websocket->frame_done+=todo;
  ///if(websocket->frame_done>websocket->frame_bytes) { oof; }
  if(websocket->frame_done!=websocket->frame_bytes) { oof; break; }
  //websocket->rcve_pkts++;
  websocket->rcve_pkts_total++;
  if(websocket->frame_opcode==WEBSOCKET_OPCODE_CLOSE) { websocket->is_close_received=YES; }
  dp[websocket->frame_data_bytes]=0;
  websocket->phaze=50;
  return RET_YES;
  }
 return RET_NOTREADY;
 }





/*-----------------------------------------------------------------------*/


 B aaNetUdpCreate                      (HP handle,H ip,W port)
 {
 B ret;
 _aa_netudpobject*udpp;
 _localip lip;
 SOCKET sock;
 struct sockaddr_in addr;
 N olen,oval;
 N len,k;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if((ret=aaNetLocalIpGet(&lip,0,1))!=YES) { return ret;  }
 if(ip==0)
  {
  for(k=0;k<(N)aaElementCount(lip.ip);k++)
   {
   if(lip.ip[k]==0) { continue; }
   ip=lip.ip[k];
   break;
   }
  }
 if((ret=aa_ObjectCreate(aa.net_system.udp_object_id,handle,(VP)&udpp))!=RET_YES) { oops;return ret; }
 udpp->self_handle=*handle;
 sock=socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP);
 if(sock==INVALID_SOCKET)
  {
  aa_ObjectDestroy(aa.net_system.udp_object_id,*handle);
  *handle=0;
  return RET_FAILED;
  }

 oval=1; olen=sizeof(oval); if(setsockopt(sock,SOL_SOCKET,SO_EXCLUSIVEADDRUSE,(CP)&oval,olen)!=0) oof;
 WinSockAddrSet(&addr,AF_INET,ip,htons(port));
 if(bind(sock,(struct sockaddr*)&addr,sizeof(addr)))
  {
  oow;
  aaNote(0,"ip=%i port=%i",ip,port);
  aaNote(0,"%i %i",__LINE__,WSAGetLastError());
  closesocket(sock);
  aa_ObjectDestroy(aa.net_system.udp_object_id,*handle);
  *handle=0;
  return RET_FAILED;
  }

 if((ret=aaQueCreate(&udpp->rcve_que))!=RET_YES)
  {
  closesocket(sock);
  aa_ObjectDestroy(aa.net_system.udp_object_id,*handle);
  *handle=0;
  return RET_FAILED;
  }
 if((ret=aaQueCreate(&udpp->xmit_que))!=RET_YES)
  {
  closesocket(sock);
  aaQueDestroy(udpp->rcve_que);
  aa_ObjectDestroy(aa.net_system.udp_object_id,*handle);
  *handle=0;
  return RET_FAILED;
  }
 udpp->sock=sock;
 udpp->last_total_pkts_sent=0xffffffff;
 aaTimerTikGet(&udpp->ms_root);
 udpp->inactive_ms_root=udpp->ms_root;
 aaTimerProfilerInit(&udpp->recent_profiler,1);
 olen=sizeof(BOOL);
 oval=0;
 if(getsockopt(udpp->sock,IPPROTO_UDP,1,(VP)&oval,(Z*)&olen)!=SOCKET_ERROR)
  {
  if(oval==TRUE) { udpp->status.is_checksum_set=YES; }
  else           { udpp->status.is_checksum_set=NO; }
  }
  len=sizeof(addr);
  WinSockAddrSet(&addr,AF_INET,0,0);
  if(getsockname(sock,(struct sockaddr *)&addr,(VP)&len)!=SOCKET_ERROR)
   {
   udpp->status.local_adr.port=htons(addr.sin_port);
   }
  else
   {
   oof;
   }
  udpp->status.local_adr.ip=ip;
  udpp->status.user_data=udpp->user_data;
  udpp->status.user_bytes=sizeof(udpp->user_data);
 aaTimerTikGet(&udpp->sub_tik);
  if((ret=aaNetUdpBufferLengthSet(*handle,_512K,_512K))!=RET_YES) { oops; }
  if((ret=aaNetUdpFlowControlSet(*handle,NO))!=RET_YES) { oops;  }
  if((ret=aaNetUdpXmitSpeedSet(*handle,0.00000))!=RET_YES) { oops; }
  if((ret=aaNetUdpChecksumSet(*handle,NO))!=RET_YES) { oops;  }

 oval=1; if(setsockopt(udpp->sock,SOL_SOCKET,SO_BROADCAST,(CP)&oval,sizeof(oval))!=0) oof;

  for(k=0;k<(N)aaElementCount(lip.ip);k++)
   {
   if(lip.ip[k]==0) { continue; }
   if(lip.ip[k]!=udpp->status.local_adr.ip) { continue; }
   if(lip.bcast_ip[k]==0) { continue; }
   udpp->status.bcast_adr.ip=lip.bcast_ip[k];
   udpp->status.bcast_adr.port=udpp->status.local_adr.port;
   break;
   }
 return RET_YES;
 }




 B aaNetUdpOpen                        (HP handle,H ip,W port)
 {
 H han;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aa_NetSystemFindUdpByAddress(&han,0,ip,port)==YES)
  {
  if(handle) { *handle=han; }
  return RET_YES;
  }
 return RET_NOTFOUND;
 }





 B aaNetUdpCreateAny                   (HP handle,H ip,W portstart,W portend)
 {
 B ret;
 H p,han;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==NULL) { return RET_BADPARM; }
 *handle=0;
 if(portstart==portend)
  {
  if((ret=aaNetIsPortAvailable(ip,portstart,YES))!=YES) { oops; }
  return(aaNetUdpCreate(handle,ip,portstart));
  }
 if(portstart>portend) { return RET_BADPARM; }
 p=(portend-portstart)+1;
 while(1)
  {
  if((ret=aaNetIsPortAvailable(ip,portstart,YES))==YES)
   {
   if((ret=aaNetUdpCreate(&han,ip,portstart))==RET_YES) { *handle=han; return ret; }
   else { oops; }
   }
  p--;
  if(p==0) { break; }
  portstart++;
  }
 return RET_FAILED;
 }








 B aaNetUdpDestroy                     (H handle)
 {
  B ret;
 _aa_netudpobject*udpp;
 B isprot;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.udp_object_id,handle,(VP)&udpp,&isprot))!=RET_YES) { return ret; }
 if(isprot==YES) { return RET_FORBIDDEN; }
 closesocket(udpp->sock);
 udpp->sock=0;
 aaQueDestroy(udpp->rcve_que);
 aaQueDestroy(udpp->xmit_que);
 if(udpp->status.extra_bytes!=0)       {  if((ret=aaMemoryRelease(udpp->status.extra_data))!=RET_YES) { oops; }  }
 aa_ObjectDestroy(aa.net_system.udp_object_id,handle);
 return RET_YES;
 }







 B aaNetUdpChecksumSet                 (H handle,B state)
 {
  B ret;
 _aa_netudpobject*udpp;
 N optlen;
 BOOL optval;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.udp_object_id,handle,(VP)&udpp,NULL))!=RET_YES) { return ret; }
 if(state==YES)
  {
  optlen=sizeof(BOOL);
  optval=TRUE;
  }
 else
  {
  optlen=sizeof(BOOL);
  optval=FALSE;
  }
 if(setsockopt(udpp->sock,IPPROTO_UDP,1,(CP)&optval,optlen)!=SOCKET_ERROR)
  {
  optlen=sizeof(BOOL);
  if(getsockopt(udpp->sock,IPPROTO_UDP,1,(CP)&optval,(ZP)&optlen)!=SOCKET_ERROR)
   {
   if(optval==TRUE) { udpp->status.is_checksum_set=YES; }
   else             { udpp->status.is_checksum_set=NO; }
   if(state==YES&&udpp->status.is_checksum_set!=YES) { return RET_FAILED; }
   if(state!=YES&&udpp->status.is_checksum_set==YES) { return RET_FAILED; }
   }
  }
 return RET_YES;
 }




 B aaNetUdpFlowControlSet              (H handle,B state)
 {
  B ret;
 _aa_netudpobject*udpp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.udp_object_id,handle,(VP)&udpp,NULL))!=RET_YES) { return ret; }
 if(state==YES) { udpp->status.is_flowcontrol_set=YES; }
 else  { udpp->status.is_flowcontrol_set=NO; }
 return RET_YES;
 }





 B aaNetUdpStatus                      (H handle,_udpstatus*udpstatus)
 {
  B ret;
 _aa_netudpobject*udpp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.udp_object_id,handle,(VP)&udpp,NULL))!=RET_YES) { return ret; }
 if((ret=aa_NetSystemProcessUdp((VP)&udpp))!=RET_YES) { oops; }
 if(udpstatus) { aaMemoryCopy(udpstatus,sizeof(_udpstatus),&udpp->status); }
 return RET_YES;
 }





 B aaNetUdpBufferLengthSet             (H handle,H rbytes,H xbytes)
 {
 N opt,olen;
  B ret;
 _aa_netudpobject*udpp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.udp_object_id,handle,(VP)&udpp,NULL))!=RET_YES) { return ret; }
 if(rbytes!=udpp->status.rcve_buffer_length)
  {
  opt=rbytes; olen=4;
  if(setsockopt(udpp->sock,SOL_SOCKET,SO_RCVBUF,(CP)&opt,olen)!=0) oof;
  udpp->status.rcve_buffer_length=rbytes;
  }
 if(xbytes!=udpp->status.xmit_buffer_length)
  {
  opt=xbytes; olen=4;
  if(setsockopt(udpp->sock,SOL_SOCKET,SO_SNDBUF,(CP)&opt,olen)!=0) oof;
  udpp->status.xmit_buffer_length=xbytes;
  }
 return RET_YES;
 }





 B aaNetUdpXmitSpeedSet                (H handle,D micro)
 {
 B ret;
 _aa_netudpobject*udpp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.udp_object_id,handle,(VP)&udpp,NULL))!=RET_YES) { return ret; }
 if(micro<=0.0) { udpp->status.xmit_speed=0.0; }
 else
  {
  udpp->status.xmit_speed=micro;
  aaTimerProfilerInit(&udpp->xmit_profiler,1);
  aaTimerProfilerInit(&udpp->xmit_profiler_direct,1);
  }
 return RET_YES;
 }




 B aaNetUdpExtraDataSet                (H handle,H bytes)
 {
 B ret;
 _aa_netudpobject*udpp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.udp_object_id,handle,(VP)&udpp,NULL))!=RET_YES) { return ret; }
 if(bytes==0)
  {
  if(udpp->status.extra_bytes!=0)  {   if((ret=aaMemoryRelease(udpp->status.extra_data))!=RET_YES) { oops; }   }
  udpp->status.extra_data=NULL;
  udpp->status.extra_bytes=bytes;
  }
 else
  {
  if(udpp->status.extra_bytes==0) {  udpp->status.extra_data=NULL;   }
  if(udpp->status.extra_bytes!=bytes)
   {
   if((ret=aaMemoryMake((VP)&udpp->status.extra_data,bytes))!=RET_YES) { oops; }
   }
  udpp->status.extra_bytes=bytes;
  }
 return RET_YES;
 }



 B aaNetUdpPktDirectSet                (H handle,B state)
 {
 B ret;
 _aa_netudpobject*udpp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.udp_object_id,handle,(VP)&udpp,NULL))!=RET_YES) { return ret; }
 if(state==YES)  {  udpp->status.is_direct=YES;  }
 else            {  udpp->status.is_direct=NO;  }
 return RET_YES;
 }





 B aaNetUdpPktWrite                    (H handle,_udppkt*udppkt)
 {
 B ret;
 _aa_netudpobject*udpp;
 B buf[_1K];
 struct sockaddr_in addr;
 H by;
 N len;
 B can_xmit;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.udp_object_id,handle,(VP)&udpp,NULL))!=RET_YES) { return ret; }
 if(udppkt==NULL) { return RET_BADPARM; }

 WinSockAddrSet(&addr,AF_INET,udppkt->address.ip,htons(udppkt->address.port));
 by=(H)udppkt->data_bytes;

 if(udpp->status.is_direct==YES)
  {
  can_xmit=YES;
  if(udpp->status.xmit_speed!=0.0)
   {
   aaTimerProfilerUpdate(&udpp->xmit_profiler_direct,1);
   if(udpp->xmit_profiler_direct.ms<udpp->status.xmit_speed)
    {
    if(udpp->status.xmit_pkts_total!=udpp->last_total_pkts_sent)
     {
     udpp->status.xmit_direct_misses++;
     udpp->last_total_pkts_sent=udpp->status.xmit_pkts_total;
     }
    can_xmit=NO;
    }
   }
  if(udpp->status.xmit_pkts_qued==0&&can_xmit==YES)
   {
   if((len=sendto(udpp->sock,(CP)&udppkt->data[0],by,0,(struct sockaddr *)&addr,sizeof(addr)))>=0)
    {
    if(len!=(N)by) { oof; return RET_FAILED; }
    udpp->status.xmit_bytes_total+=(Q)by;
    udpp->xmit_bytes_total_recent+=(by+8);
    udpp->xmit_pkts_total_recent++;
    udpp->status.xmit_pkts_total++;
    aa.net_system.net_status.total_udp_packets_sent++;
    if(udpp->status.xmit_speed!=0.0)  {   aaTimerProfilerInit(&udpp->xmit_profiler_direct,1); }
    aa_NetSystemProcessUdp((VP)&udpp);
    return RET_YES;
    }
   }
  }



 #if 0
 if((ret=aaQueWrite(udpp->xmit_que,sizeof(addr),&addr))!=RET_YES)  {  return ret;  }
 if((ret=aaQueWrite(udpp->xmit_que,4,&by))!=RET_YES)  { return ret;  }
 #else
 aaMemoryCopy(&buf[0],sizeof(addr),&addr);
 *(HP)&buf[sizeof(addr)]=by;
 if((ret=aaQueWrite(udpp->xmit_que,sizeof(addr)+4,buf))!=RET_YES)  { return ret;  }
 #endif

 if(udppkt->data_bytes!=0)
  {
  if((ret=aaQueWrite(udpp->xmit_que,udppkt->data_bytes,udppkt->data))!=RET_YES)  { return ret;  }
  }
 udpp->status.xmit_pkts_qued++;
 aa_NetSystemProcessUdp((VP)&udpp);
 return RET_YES;
 }




 B aaNetUdpPktRead                     (H handle,_udppkt*udppkt)
 {
  B ret;
 _aa_netudpobject*udpp;
 _questatus qs;
 struct sockaddr_in addr;
 B tmp[128];
 H len;
 fd_set set;
 struct timeval tv;
 Z val,flags,bytes;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(udppkt==NULL) { return RET_BADPARM; }
 udppkt->data_bytes=0;
 udppkt->address.ip=0;
 udppkt->address.port=0;
 if((ret=aa_ObjectCheck(aa.net_system.udp_object_id,handle,(VP)&udpp,NULL))!=RET_YES) { return ret; }

 if(udpp->status.is_direct==YES)
  {
  if(udpp->status.rcve_pkts_qued==0)
   {
   aa_NetSystemCalculateUdpTimers((VP)&udpp);
   FD_ZERO(&set);
   FD_SET(udpp->sock,&set);
   WSASetLastError(0);
   tv.tv_sec=0;
   tv.tv_usec=0;
   val=select(0,&set,0,0,&tv);
   if(val==SOCKET_ERROR) oof;
   if(val>=1)
    {
    if(FD_ISSET(udpp->sock,&set)!=0)
     {
     len=sizeof(addr);
     flags=0;
     if((bytes=recvfrom(udpp->sock,(CP)&udppkt->data[0],0x10000,flags,(struct sockaddr *)&addr,(ZP)&len))>=0)
      {
      udppkt->address.ip=(*(HP)&addr.sin_addr);
      udppkt->address.port=htons(addr.sin_port);
      udppkt->data_bytes=(W)bytes;
      if(flags==MSG_PEEK) {  recvfrom(udpp->sock,0,0,0,0,0); }
      udpp->status.rcve_bytes_total+=(Q)bytes;
      udpp->rcve_bytes_total_recent+=(bytes+8);
      udpp->rcve_pkts_total_recent++;
      aaTimerTikGet(&udpp->inactive_ms_root);
      udpp->status.inactivity=0;
      udpp->status.rcve_pkts_total++;
      return RET_YES;
      }
     }
    }
   return RET_NOTREADY;
   }
  }



 aa_NetSystemProcessUdp((VP)&udpp);
 if(udpp->status.rcve_pkts_qued==0) { return RET_NOTREADY; }
 aaQueStatus(udpp->rcve_que,&qs);
 if(qs.bytes<(sizeof(addr)+4)) { return RET_NOTREADY; }

 if((ret=aaQuePeek(udpp->rcve_que,0,sizeof(addr)+4,tmp))!=RET_YES) { return ret; }
 aaMemoryPeekDword(&tmp[sizeof(addr)],0,&len);
 if(qs.bytes<(len+sizeof(addr)+4)) { return RET_FAILED; }
 aaMemoryCopy(&addr,sizeof(addr),tmp);
 udppkt->address.ip=(*(HP)&addr.sin_addr);
 udppkt->address.port=htons(addr.sin_port);
 udppkt->data_bytes=(W)len;
 aaQueDiscard(udpp->rcve_que,sizeof(addr)+4);
 if(udppkt->data_bytes!=0)
  {
  if((ret=aaQueRead(udpp->rcve_que,len,udppkt->data))!=RET_YES) { return ret; }
  }
 udpp->status.rcve_pkts_total++;
 udpp->status.rcve_pkts_qued--;
 return RET_YES;
 }




 B aaNetUdpPktPeek                     (H handle,_udppkt*udppkt,H pktoff,H maxbytes)
 {
  B ret;
 _aa_netudpobject*udpp;
 _questatus qs;
 struct sockaddr_in addr;
 B tmp[128];
 H len;
 H from,avail;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(udppkt==NULL) { return RET_BADPARM; }
 udppkt->data_bytes=0;
 udppkt->address.ip=0;
 udppkt->address.port=0;
 if((ret=aa_ObjectCheck(aa.net_system.udp_object_id,handle,(VP)&udpp,NULL))!=RET_YES) { return ret; }
 aa_NetSystemProcessUdp((VP)&udpp);
 if(udpp->status.rcve_pkts_qued==0) { return RET_NOTREADY; }
 if(pktoff>=udpp->status.rcve_pkts_qued) { return RET_NOTREADY; }
 from=0;

 while(1)
  {
  aaQueStatus(udpp->rcve_que,&qs);
  avail=qs.bytes-from;
  if(avail<(sizeof(addr)+4)) { return RET_NOTREADY; }
  if((ret=aaQuePeek(udpp->rcve_que,from,sizeof(addr)+4,tmp))!=RET_YES) { return ret; }
  aaMemoryPeekDword(&tmp[sizeof(addr)],0,&len);
  if(avail<(sizeof(addr)+4+len)) { return RET_FAILED; }
  if(pktoff!=0)
   {
   pktoff--;
   from+=(sizeof(addr)+4+len);
   continue;
   }
  if(maxbytes==0xffffffff) { maxbytes=len; }
  if(maxbytes!=0&&len!=0)
   {
   maxbytes=aaNumRoof(maxbytes,len);
   if((ret=aaQuePeek(udpp->rcve_que,from+sizeof(addr)+4,maxbytes,udppkt->data))!=RET_YES) { return ret; }
   }
  aaMemoryCopy(&addr,sizeof(addr),tmp);
  udppkt->address.ip=(*(HP)&addr.sin_addr);
  udppkt->address.port=htons(addr.sin_port);
  udppkt->data_bytes=(W)len;
  break;
  }
 return RET_YES;
 }










 B aaNetUdpPktDiscard                  (H handle)
 {
 B ret;
 _aa_netudpobject*udpp;
 _questatus qs;
 struct sockaddr_in addr;
 B tmp[128];
 H len;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.udp_object_id,handle,(VP)&udpp,NULL))!=RET_YES) { return ret; }
 aa_NetSystemProcessUdp((VP)&udpp);
 if(udpp->status.rcve_pkts_qued==0) { return RET_NOTREADY; }
 aaQueStatus(udpp->rcve_que,&qs);
 if(qs.bytes<(sizeof(addr)+4)) { return RET_NOTREADY; }
 if((ret=aaQuePeek(udpp->rcve_que,0,sizeof(addr)+4,tmp))!=RET_YES) { return ret; }
 aaMemoryPeekDword(&tmp[sizeof(addr)],0,&len);
 if(qs.bytes<(len+sizeof(addr)+4)) { return RET_FAILED; }
 if((ret=aaQueDiscard(udpp->rcve_que,len+sizeof(addr)+4))!=RET_YES) { return ret; }
 udpp->status.rcve_pkts_qued--;
 udpp->status.rcve_pkts_total++;
 if(addr.sin_family!=addr.sin_family) {}
 return RET_YES;
 }






 B aaNetUdpPktReturn                   (H handle)
 {
 B ret;
 _aa_netudpobject*udpp;
 struct sockaddr_in addr;
 BP tmp=NULL_POINTR;
 H len;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.udp_object_id,handle,(VP)&udpp,NULL))!=RET_YES) { return ret; }
 if(udpp->status.rcve_pkts_qued==0) { return RET_NOTREADY; }
 if(udpp->status.rcve_pkts_qued==1) { return RET_YES; }
 if((ret=aa_MemoryTemp((VP)&tmp,_64K+_1K,aa_MEMORYTEMP_UdpPktRet))!=RET_YES) { oops; }
 if((ret=aaQuePeek(udpp->rcve_que,sizeof(addr),4,&len))!=RET_YES) { return ret; }
 if((ret=aaQuePeek(udpp->rcve_que,0,sizeof(addr)+4+len,tmp))!=RET_YES) { return ret; }
 if((ret=aaNetUdpPktDiscard(handle))!=RET_YES) { return ret; }
 if((ret=aaQueWrite(udpp->rcve_que,sizeof(addr)+4+len,tmp))!=RET_YES) { return ret; }
 aa_NetSystemProcessUdp((VP)&udpp);
 if(addr.sin_family!=addr.sin_family) {}
 return RET_YES;
 }






 B aaNetUdpPktAllocate                 (_udppkt**udppkt)
 {
 B ret;
 BP mem;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(udppkt==NULL) { return RET_BADPARM; }
 *udppkt=NULL;
 if((ret=aaMemoryAllocate((VP)&mem,sizeof(_udppkt)))!=YES) { return ret; }
 aaMemoryNameSet(mem,"udppkt");
 *udppkt=(_udppkt*)mem;
 return RET_YES;
 }




 B aaNetUdpPktRelease                  (_udppkt*udppkt)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(udppkt==NULL) { return RET_BADPARM; }
 udppkt->address.ip=0;
 udppkt->address.port=0;
 udppkt->data_bytes=0;
 udppkt->data[udppkt->data_bytes]=0;
 if((ret=aaMemoryRelease(udppkt))!=YES) { oops; return ret; }
 return RET_YES;
 }





 B aaNetUdpPktSet                      (_udppkt*udppkt,H remoteip,W remoteport,W databytes)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(udppkt==NULL) { return RET_BADPARM; }
 if(remoteport==0) { return RET_BADPARM; }
 if(remoteip==0) { return RET_BADPARM; }
 udppkt->address.ip=remoteip;
 udppkt->address.port=remoteport;
 udppkt->data_bytes=databytes;
 return RET_YES;
 }






 B aaNetUdpPktCopy                     (_udppkt*udppkt,_udppkt*sudppkt,B copydata)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(sudppkt==NULL) { return RET_BADPARM; }
 if((ret=aaNetUdpPktSet(udppkt,sudppkt->address.ip,sudppkt->address.port,sudppkt->data_bytes))!=RET_YES) { return ret; }
 if(copydata) { aaMemoryCopy(udppkt->data,sudppkt->data_bytes,sudppkt->data); }
 return ret;
 }




 B aaNetUdpPktAppend                   (_udppkt*udppkt,H bytes,VP data)
 {
 N left;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(udppkt==NULL) { return RET_BADPARM; }
 left=sizeof(udppkt->data)-udppkt->data_bytes;
 if(left<0) { return RET_CORRUPTED; }
 if(bytes==0) { return RET_YES; }
 if(bytes>(H)left) { return RET_BOUNDS; }
 if(data!=NULL) {  aaMemoryCopy(&udppkt->data[udppkt->data_bytes],bytes,data);  }
 udppkt->data_bytes+=(W)bytes;
 return RET_YES;
 }





 B aaNetUdpPktByteAppend               (_udppkt*udppkt,B val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaNetUdpPktAppend(udppkt,1,&val));
 }




 B aaNetUdpPktWordAppend               (_udppkt*udppkt,W val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaNetUdpPktAppend(udppkt,2,&val));
 }




 B aaNetUdpPktDwordAppend              (_udppkt*udppkt,H val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaNetUdpPktAppend(udppkt,4,&val));
 }



 B aaNetUdpPktQuadAppend               (_udppkt*udppkt,Q val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaNetUdpPktAppend(udppkt,8,&val));
 }






 B aaNetUdpPktTrim                     (_udppkt*udppkt,H bytes)
 {
 N left;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(udppkt==NULL) { return RET_BADPARM; }
 left=sizeof(udppkt->data)-udppkt->data_bytes;
 if(left<0) { return RET_CORRUPTED; }
 if(bytes==0) { return RET_YES; }
 if(bytes>udppkt->data_bytes) { return RET_BOUNDS; }
 udppkt->data_bytes-=(W)bytes;
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/


 B aaNetStunClientCreate               (HP handle,H udphandle,H serverip,W serverport)
 {
 B ret;
 _aa_netstunclientobject*stcp;
 _aa_netudpobject*udpp;
 _localip locip;
 H han,i,myip;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle) { *handle=0; }

 aaNetLocalIpGet(&locip,NO,NO);
 for(i=0;i<4;i++)
  {
  if(locip.type[i]!='P') { continue; }
  break;
  }
 if(i==4) { return RET_FAILED; }
 myip=locip.ip[i];
 if(serverport==0) { serverport=3478; }
 if(serverip==0) { return RET_BADPARM; }
 if(udphandle==0)
  {
  if((ret=aaNetUdpCreateAny(&han,0,49152,65535))!=RET_YES) { return ret; }
  if((ret=aa_ObjectCheck(aa.net_system.udp_object_id,han,(VP)&udpp,NULL))!=RET_YES) { oops; }
  }
 else
  {
  if((ret=aa_ObjectCheck(aa.net_system.udp_object_id,udphandle,(VP)&udpp,NULL))!=RET_YES) { return ret; }
  han=udphandle;
  }
 if((ret=aa_ObjectCreate(aa.net_system.stunclient_object_id,handle,(VP)&stcp))!=RET_YES) {oops; return ret; }
 stcp->self_handle=*handle;
 stcp->stage=10;
 stcp->status.is_inprogress=YES;
 stcp->status.is_complete=NO;
 stcp->status.ms=0;
 aaNetAdrSet(&stcp->status.server_adr,serverip,serverport);
 aaNetAdrSet(&stcp->status.mapped_adr,0,0);
 aaNetAdrSet(&stcp->status.remapped_adr,0,0);
 stcp->status.type=0;
 stcp->attempt=0;
 aaNetRttInit(&stcp->rtt,200,3000,500);
 stcp->test_num=1;
 stcp->udp_handle=han;
 aaNetAdrSet(&stcp->status.local_adr,myip,udpp->status.local_adr.port);
 if(udphandle==0) { stcp->is_udp_created=YES; }
 else             { stcp->is_udp_created=NO; }
 return RET_YES;
 }



 B aaNetStunClientDestroy              (H handle)
 {
  B ret;
 _aa_netstunclientobject*stcp;
 B isprot;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.stunclient_object_id,handle,(VP)&stcp,&isprot))!=RET_YES) { return ret; }
 if(isprot==YES) { return RET_FORBIDDEN; }
 if(stcp->is_udp_created==YES)
  {
  if((ret=aaNetUdpDestroy(stcp->udp_handle))!=RET_YES) { oops; }
  }
 aa_ObjectDestroy(aa.net_system.stunclient_object_id,handle);
 return RET_YES;
 }








 B aaNetStunClientStatus               (H handle,_stunclientstatus*stunclientstatus)
 {
 B ret;
 _aa_netstunclientobject*stcp;
 _netadr adr;
 B chip,chport;
 W msg_typ,msg_len;
 W atr_typ,atr_len;
 H off;
 _netadr pkt_adr,map_adr,src_adr,oth_adr;
 B tmp[_1K];
 W pos,mlen;
 H bit;
 B isok;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.stunclient_object_id,handle,(VP)&stcp,NULL))!=RET_YES) { return ret; }

 switch(stcp->stage)
  {
  case 10:
  if(stcp->attempt==4) {  stcp->stage=20; break; }
  switch(stcp->test_num)
   {
   default: oof;
   case 1:  aaNetAdrCopy(&adr,&stcp->status.server_adr); chip=NO;  chport=NO; break;  // initial check for nat
   case 2:  aaNetAdrCopy(&adr,&stcp->status.server_adr); chip=YES; chport=YES; break; // nat not detected, check for firewall
   case 3:  aaNetAdrCopy(&adr,&stcp->status.server_adr); chip=YES; chport=YES; break; // nat detected
   case 4:  aaNetAdrCopy(&adr,&stcp->status.other_adr); chip=NO; chport=NO; break;    // nat detected, server#2 same address/port
   case 5:  aaNetAdrCopy(&adr,&stcp->status.server_adr); chip=NO; chport=YES; break;   // nat detected, IP constant, check restricted type
   }
  aaMemoryRandomSet(stcp->tid,16);
  pos=0;
  *(WP)&tmp[pos+0]=aaNumSwapWord(0x0001); // bind request
  mlen=8;
  #if 0
  if(responseadr!=NULL)  { mlen+=(W)12; }
  #endif
  *(WP)&tmp[pos+2]=(W)aaNumSwapWord(mlen);
  aaMemoryCopy(&tmp[pos+4],16,stcp->tid);
  pos+=(W)20;
  *(WP)&tmp[pos+0]=(W)aaNumSwapWord(0x0003); // change request
  *(WP)&tmp[pos+2]=(W)aaNumSwapWord(4);
  bit=0;
  if(chip)   { bit=(B)aaBitSet(bit,2); }
  if(chport) { bit=(B)aaBitSet(bit,1); }
  *(HP)&tmp[pos+4]=(H)aaNumSwapDword(bit);
  pos+=(W)8;
  #if 0
  if(responseadr!=NULL)
   {
   *(WP)&tmp[pos+0]=aaNumSwapWord(0x0002); // response request
   *(WP)&tmp[pos+2]=aaNumSwapWord(8);
   tmp[pos+4]=0x00;
   tmp[pos+5]=0x01;
   *(WP)&tmp[pos+6]=(W)(aaNumSwapWord(responseadr->port));
   *(HP)&tmp[pos+8]=(H)((responseadr->ip));
   pos+=(W)12;
   }
  #endif
  aaNetUdpPktSet(&aa.net_system.tmp_udp_pkt,adr.ip,adr.port,0);
  aaNetUdpPktAppend(&aa.net_system.tmp_udp_pkt,pos,tmp);
  aaNetUdpPktWrite(stcp->udp_handle,&aa.net_system.tmp_udp_pkt);
  aaTimerTikGet(&stcp->root_ms);
  stcp->attempt++;
  stcp->stage=30;
  break;


  case 20:
  switch(stcp->test_num)
   {
   default: break;
   case 1:   stcp->status.type=aa_NET_STUN_BLOCKED;            stcp->stage=900;   break;
   case 2:   stcp->status.type=aa_NET_STUN_SYMETRICFIREWALL;   stcp->stage=900;   break;
   case 3:   stcp->attempt=0;   stcp->test_num=4;              stcp->stage=10;   aaNetRttInit(&stcp->rtt,200,3000,500); break;
   case 4:   stcp->status.is_failed=YES;                       stcp->stage=900;   break;
   case 5:   stcp->status.type=aa_NET_STUN_RESTRICTEDPORT;     stcp->stage=900;   break;
   }
  break;


  case 30:
  aaTimerPrimitive(aa.timer_system.last_tik,stcp->root_ms,&stcp->status.ms);
  if(stcp->status.ms>stcp->rtt.timeout) {  aaNetRttUpdate(&stcp->rtt,stcp->status.ms,YES); stcp->stage=10; break; }
  if(aaNetUdpPktPeek(stcp->udp_handle,&aa.net_system.tmp_udp_pkt,0,0xffffffff)!=YES) { break; }
  isok=NO;
  while(1)
   {
   if(stcp->status.other_adr.ip!=0)
    {
    if(aa.net_system.tmp_udp_pkt.address.ip==stcp->status.other_adr.ip) { isok=YES; break; }
    }
   if(stcp->status.server_adr.ip!=0)
    {
    if(aa.net_system.tmp_udp_pkt.address.ip==stcp->status.server_adr.ip) { isok=YES; break; }
    }
   break;
   }
  if(isok==NO)
   {
   if(aaNetUdpPktReturn(stcp->udp_handle)!=YES) oof;
   break;
   }
  aaNetUdpPktDiscard(stcp->udp_handle);
  if(aa.net_system.tmp_udp_pkt.data_bytes<20) {  break; }
  msg_typ=(W)aaNumSwapWord(*(WP)&aa.net_system.tmp_udp_pkt.data[0]);
  msg_len=(W)aaNumSwapWord(*(WP)&aa.net_system.tmp_udp_pkt.data[2]);
  if(aa.net_system.tmp_udp_pkt.data_bytes!=(msg_len+20)) {  break; }
  if(aaMemoryCompare(&aa.net_system.tmp_udp_pkt.data[4],16,stcp->tid,NULL)!=YES)  {   break; }
  if(msg_typ==0x0111)    { /* BUG," Stun cmd binderr");*/ break; } // bind error
  if(msg_typ!=0x0101)    { oof;  break; } // bid reply
  off=0;
  aaNetAdrSet(&pkt_adr,0,0);   aaNetAdrSet(&map_adr,0,0);   aaNetAdrSet(&src_adr,0,0);   aaNetAdrSet(&oth_adr,0,0);
  while(1)
   {
   if(off>=(H)msg_len) { break; }
   atr_typ=(W)aaNumSwapWord(*(WP)&aa.net_system.tmp_udp_pkt.data[20+off]);
   atr_len=(W)aaNumSwapWord(*(WP)&aa.net_system.tmp_udp_pkt.data[22+off]);
   aaNetAdrCopy(&pkt_adr,&aa.net_system.tmp_udp_pkt.address);
   aaNetAdrSet(&adr,(H)((*(HP)&aa.net_system.tmp_udp_pkt.data[20+off+8])),(W)(aaNumSwapWord(*(WP)&aa.net_system.tmp_udp_pkt.data[20+off+6])));
   switch(atr_typ)
    {
    default: oof; break;
    case 0x0001:    if(atr_len!=8) { aaNote(0,"qwe %i %i",atr_typ,atr_len); } aaNetAdrCopy(&map_adr,&adr);       break;
    case 0x0004:    if(atr_len!=8) { aaNote(0,"aqa %i %i",atr_typ,atr_len); } aaNetAdrCopy(&src_adr,&adr);       break;
    case 0x0005:    if(atr_len!=8) { aaNote(0,"qqaz %i %i",atr_typ,atr_len); } aaNetAdrCopy(&oth_adr,&adr);       break;
    }
   off+=(4+atr_len);
   }
  aaNetRttUpdate(&stcp->rtt,stcp->status.ms,NO);

  #if 0
   aaNetAdrToString(&stcp->status.local_adr,&str[0]); ;
   aaNetAdrToString(&stcp->status.server_adr,&str[100]); ;
   aaNetAdrToString(&pkt_adr,&str[200]);
   aaNetAdrToString(&map_adr,&str[300]);
   aaNetAdrToString(&src_adr,&str[400]);
   aaNetAdrToString(&oth_adr,&str[500]);
   aaStringCopyf(info,"Handle reply: test=%i \nLocAdr: %-25s StunSvrAdr: %-25s PktAdr: %-25s\nMapAdr: %-25s SrcAdr:     %-25s OthAdr: %-25s",stcp->test_num,&str[0],&str[100],&str[200],&str[300],&str[400],&str[500]);
   #endif

  switch(stcp->test_num)
   {
   default:
   break;

   case 1:
   aaNetAdrCopy(&stcp->status.mapped_adr,&map_adr);
   aaNetAdrCopy(&stcp->status.remapped_adr,&map_adr);
   aaNetAdrCopy(&stcp->status.other_adr,&oth_adr);
   stcp->attempt=0;
   if(aaNetAdrEqualsAdr(&map_adr,&stcp->status.local_adr)==YES)    {  stcp->test_num=2;    stcp->stage=10;    }
   else                                                            {  stcp->test_num=3;    stcp->stage=10;    }
   break;

   case 2:
   stcp->status.type=aa_NET_STUN_OPEN;
   stcp->stage=900;
   break;

   case 3:
   stcp->status.type=aa_NET_STUN_FULLCONE;
   stcp->stage=900;
   break;

   case 4:
   stcp->attempt=0;
   aaNetAdrCopy(&stcp->status.remapped_adr,&map_adr);
   if(aaNetAdrEqualsAdr(&stcp->status.mapped_adr,&stcp->status.remapped_adr)==YES)  {    stcp->test_num=5;     stcp->stage=10;     }
   else                                                                             {    stcp->status.type=aa_NET_STUN_SYMETRICNAT;   stcp->stage=900;   }
   break;

   case 5:
   stcp->status.type=aa_NET_STUN_RESTRICTEDCONE;
   stcp->stage=900;
   break;
   }
  break;


  case 900:
  stcp->status.is_inprogress=NO;
  stcp->status.is_complete=YES;
  stcp->stage=1000;
  break;

  default:
  break;
  }


 if(stunclientstatus)
  {
  aaMemoryCopy(stunclientstatus,sizeof(_stunclientstatus),&stcp->status);
  }
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/


 B aaNetSocksHelloWrite                (H tcpcallhandle)
 {
 B ret;
 B buf[_1K];
 _aa_nettcpcallobject*calp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,tcpcallhandle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 buf[0]=0x05;
 buf[1]=0x01;
 buf[2]=0x00;
 return(aaNetTcpCallWrite(tcpcallhandle,3,buf));
 }



 B aaNetSocksConnectWrite              (H tcpcallhandle,VP host,H ip,W port)
 {
 B ret;
 B buf[_1K];
 _aa_nettcpcallobject*calp;
 H sl,off;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,tcpcallhandle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(port==0)           { return RET_BADPARM; }
 if(host==NULL&&ip==0) { return RET_BADPARM; }
 if(host!=NULL&&ip==0) { aaNetIpFromString(host,&ip);  }
 if(ip==0)             { aaStringLen(host,&sl);  }
 buf[0]=0x05;
 buf[1]=0x01;
 buf[2]=0x00;
 if(ip!=0)
  {
  buf[3]=0x01;
  *(HP)&buf[4]=ip;
  *(WP)&buf[8]=aaNumSwapWord(port);
  return(aaNetTcpCallWrite(tcpcallhandle,10,buf));
  }
 buf[3]=0x03;
 buf[4]=(B)sl;
 aaMemoryCopy(&buf[5],buf[4],host);
 off=5+buf[4];
 *(WP)&buf[off]=aaNumSwapWord(port);
 off+=2;
 return(aaNetTcpCallWrite(tcpcallhandle,off,buf));
 }




#if  0



 B aaNetSocksConnectIp4Write           (H tcpcallhandle,H ip,W port)
 {
 B ret;
 B buf[_1K];
 _aa_nettcpcallobject*calp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,tcpcallhandle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 buf[0]=0x05;
 buf[1]=0x01;
 buf[2]=0x00;
 buf[3]=0x01;
 *(HP)&buf[4]=ip;
 *(WP)&buf[8]=aaNumSwapWord(port);
 return(aaNetTcpCallWrite(tcpcallhandle,10,buf));
 }






 B aaNetSocksConnectDomainWrite        (H tcpcallhandle,W port,VP fmt,...)
 {
 B ret;
 B buf[_1K];
 H off;
 _aa_nettcpcallobject*calp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaVargsf4K(fmt);
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,tcpcallhandle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 buf[0]=0x05;
 buf[1]=0x01;
 buf[2]=0x00;
 buf[3]=0x03;
 buf[4]=(B)str4k.len;
 aaMemoryCopy(&buf[5],buf[4],str4k.buf);
 off=5+buf[4];
 *(WP)&buf[off]=aaNumSwapWord(port);
 off+=2;
 return(aaNetTcpCallWrite(tcpcallhandle,off,buf));
 }
#endif







/*--------------------------------------------*/


 B aaNetTcpPortCreate                  (HP handle,H ip,W port,H extrabytes)
 {
 B ret;
 _aa_nettcpportobject*prtp;
 SOCKET sock;
 struct sockaddr_in addr;
 N oval,olen;
 Z r;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(port==0)  {  return RET_BADPARM;  }
 if((ret=aa_ObjectCreate(aa.net_system.tcpport_object_id,handle,(VP)&prtp))!=RET_YES) { return ret; }
 prtp->self_handle=*handle;
 if((sock=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP))==INVALID_SOCKET)
  {
  aa_ObjectDestroy(aa.net_system.tcpport_object_id,*handle);
  *handle=0;
  return RET_FAILED;
  }
 //oval=1; olen=sizeof(oval); if(setsockopt(sock,SOL_SOCKET,SO_EXCLUSIVEADDRUSE,(CP)&oval,olen)!=0) { oow; }
 oval=1; olen=sizeof(oval); if(setsockopt(sock,SOL_SOCKET,SO_EXCLUSIVEADDRUSE,(CP)&oval,olen)!=0) { oow; }
 WinSockAddrSet(&addr,AF_INET,ip,htons(port));
 if((r=bind(sock,(struct sockaddr*)&addr,sizeof(addr)))!=0)
  {
  r=WSAGetLastError();
  if(r==10048) { ret=RET_INUSE; }
  else
  if(r==10049) { ret=RET_NOTFOUND; }
  else         { ret=RET_FAILED; }
  //aaNote(0,"e %i %i %i",ip,port,r);
  aa_ObjectDestroy(aa.net_system.tcpport_object_id,*handle);
  closesocket(sock);
  *handle=0;
  return ret;
  }
 prtp->socket_used=YES;
 prtp->sock=sock;
 prtp->status.local_adr.port=port;
 prtp->status.extra_bytes=extrabytes;
 logg("%s:%i about to listen",__func__,__LINE__);
 listen(sock,aa_NET_SOMAXCONN);
 logg("%s:%i about to asyncsel",__func__,__LINE__);
 if(WSAAsyncSelect(sock,aa.net_system.window,aa.net_system.tcp_message_id,FD_ACCEPT|FD_CLOSE))
  {
  aa_ObjectDestroy(aa.net_system.tcpport_object_id,*handle);
  closesocket(sock);
  *handle=0;
  return RET_FAILED;
  }
 logg("about to resolve pair");
 if(aa_NetSystemResolveIpPortPair(prtp->sock,&prtp->status.local_adr.ip,&prtp->status.local_adr.port,0,0)!=YES)
  {
  oof;
  }
 aaNetAdrToString(&prtp->status.local_adr,prtp->status.local_dot);
 aa.net_system.net_status.incoming_tcp_ports_inuse++;
 return RET_YES;
 }



 B aaNetTcpPortCreateAny               (HP handle,H ip,W portstart,W portend,H extrabytes)
 {
 B ret;
 H p,han;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==NULL) { return RET_BADPARM; }
 *handle=0;
 if(portstart==portend)
  {
  return(aaNetTcpPortCreate(handle,ip,portstart,extrabytes));
  }
 if(portstart>portend) { return RET_BADPARM; }
 p=(portend-portstart)+1;
 while(1)
  {
  if((ret=aaNetTcpPortCreate(&han,ip,portstart,extrabytes))==RET_YES) { *handle=han; return ret; }
  p--;
  if(p==0) { break; }
  portstart++;
  }
 return RET_NOMEMORY;
 }





 B aaNetTcpPortDestroy                 (H handle)
 {
 B ret;
 _aa_nettcpportobject*prtp;
 H call_handle,go;
 B isprot;
 B junk[_1K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aa_last_line_executed=__LINE__;
 if((ret=aa_ObjectCheck(aa.net_system.tcpport_object_id,handle,(VP)&prtp,&isprot))!=RET_YES) { return ret; }
 aa_last_line_executed=__LINE__;
 if(isprot==YES) { return RET_FORBIDDEN; }
 logg("destroying calls connected to port %i,, portsock=%i",prtp->status.local_adr.port,prtp->sock);
 aa_last_line_executed=__LINE__;
 while(1)
  {
  aa_last_line_executed=__LINE__;
  if(aa_NetSystemFindCallByPortSock(&call_handle,NULL,prtp->sock)!=YES) { break; }
  aa_last_line_executed=__LINE__;
  aaNetTcpCallDestroy(call_handle);
  aa_last_line_executed=__LINE__;
  logg("destroyed call %i  port.calls_total=%i",call_handle,prtp->status.calls_total);
  }
 if(prtp->status.calls_waiting!=0||prtp->status.calls_answered!=0)
  {
  logg("cw=%i cc=%i",prtp->status.calls_waiting,prtp->status.calls_answered);
  }
  aa_last_line_executed=__LINE__;
  shutdown(prtp->sock,SD_BOTH);
  go=0;
  aa_last_line_executed=__LINE__;
  while(1)
   {
   if(recv(prtp->sock,(CP)junk,576,0)<=0) { break; }
   if(is_aa_quit_posted==YES) {  break; }
   if((go++)>10) { break; }
   }
   aa_last_line_executed=__LINE__;
 closesocket(prtp->sock);
  aa.net_system.net_status.incoming_tcp_ports_inuse--;
 aa_ObjectDestroy(aa.net_system.tcpport_object_id,handle);
 return RET_YES;
 }






 B aaNetTcpPortStatus                  (H handle,_tcpportstatus*tcpportstatus)
 {
 B ret;
 _aa_nettcpportobject*prtp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpport_object_id,handle,(VP)&prtp,NULL))!=RET_YES) { return ret; }
 if(tcpportstatus) { aaMemoryCopy(tcpportstatus,sizeof(_tcpportstatus),&prtp->status); }
 return RET_YES;
 }




 B aaNetTcpPortCallNext                (H handle,HP callhandle,_tcpcallstatus*tcpcallstatus,HP iterator)
 {
 B ret;
 _aa_nettcpportobject*prtp;
 _aa_nettcpcallobject*calp;
 H ch;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(callhandle==NULL) { return RET_BADPARM; }
 *callhandle=0;
 if((ret=aa_ObjectCheck(aa.net_system.tcpport_object_id,handle,(VP)&prtp,NULL))!=RET_YES) { return ret; }
 if(prtp->status.calls_answered==0&&prtp->status.calls_waiting==0) { return RET_NOTFOUND; }
 if(iterator==NULL)
  {
  if((ret=aa_NetSystemNextTcpCall(&ch,(VP)&calp,prtp->status.local_adr.port,&prtp->next_call_counter))!=RET_YES) { return ret; }
  }
 else
  {
  if((ret=aa_NetSystemNextTcpCall(&ch,(VP)&calp,prtp->status.local_adr.port,iterator))!=RET_YES) { return ret; }
  }
 if(calp->status.is_inprogress==YES)
  {
  if(calp->status.is_incoming==NO)  { return RET_NOTFOUND; }
  if(calp->status.local_adr.port!=prtp->status.local_adr.port)  { oof;  return RET_NOTFOUND;  }
  }
 if(calp->status.is_incoming!=YES) oof;
 if(tcpcallstatus)
  {
  if((ret=aaNetTcpCallStatus(ch,tcpcallstatus))!=YES) { oops; }
  }
 else
  {
  }
 *callhandle=ch;
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/






 B aaNetTcpCallCreate                  (HP handle,H sip,W sport,VP host,H ip,W port,B tls)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 H ii,li,i;
 BP bp,kp,vp;
 Q now_utc;
 Q age_utc;
 _dnscachelistdata*dcldptr;
 _aa_objectinstanceheader*oih;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(port==0)  {  return RET_BADPARM;  }
 if(ip==0&&aaStringIsNull(host)!=NO) { return RET_BADPARM; }
 if((ret=aa_ObjectCreate(aa.net_system.tcpcall_object_id,handle,(VP)&calp))!=RET_YES)
  {
  oops;
  aaNote(0,"net_system.server_object_id=%i",aa.net_system.server_object_id);
  aaNote(0,"%i %i",__LINE__,aa.net_system.sniff_object_id);
  aaNote(0,"%i %i",__LINE__,aa.net_system.icmp_object_id);
  aaNote(0,"%i %i",__LINE__,aa.net_system.udp_object_id);
  aaNote(0,"%i %i",__LINE__,aa.net_system.stunclient_object_id);
  aaNote(0,"%i %i",__LINE__,aa.net_system.tcpport_object_id);
  aaNote(0,"%i %i",__LINE__,aa.net_system.tcpcall_object_id);
  aaNote(0,"%i %i",__LINE__,aa.net_system.client_object_id);
  aaNote(0,"%i %i",__LINE__,aa.net_system.cgiclient_object_id);
  aaNote(0,"%i %i",__LINE__,aa.net_system.server_object_id);
  return ret;
  }
 tls&=1;
 calp->status.is_tls=tls;
 calp->self_handle=*handle;
 calp->status.remote_adr.port=port;
  calp->status.index=*handle-((aa.net_system.tcpcall_object_id*aa_OBJ_MAX_PER_ID)+aa_OBJ_BASE_HANDLE);
  aaCast(bp,BP,calp);
  bp-=sizeof(_aa_objectinstanceheader);
  aaCast(oih,_aa_objectinstanceheader*,bp);
  calp->status.session=oih->sesh;
  calp->status.number=aa.net_system.net_status.total_tcp_call_count;
  aaStringCopyf(calp->status.hancock,"%s",aa_common_name[calp->status.is_incoming][calp->status.number%26]);
  if((calp->status.number/26)>0) aaStringAppendf(calp->status.hancock,"%u",(calp->status.number/26));
  aa.net_system.net_status.total_tcp_call_count++;
 calp->status.is_incoming=NO;
  calp->status.is_inprogress=YES;
 aaTimerTikGet(&calp->ms_root);
 aaStringNull(calp->status.host);
 calp->status.src_adr.ip=sip;
 calp->status.src_adr.port=sport;
 aaNetAdrToString(&calp->status.src_adr,calp->status.src_dot);

 if(aaStringIsNull(host)==NO&&ip==0)
  {
  if(aaStringICompare(host,"localhost",0)==YES)
   {
   aaStringCopy(calp->status.host,host);
   calp->is_dns=NO;
   calp->status.is_resolving=NO;
   ip=aaLoopBack;
   return(aa_NetSystemTcpCallCreate(handle,ip,port,calp->status.src_adr.ip,calp->status.src_adr.port));
   }
  }


 if(aaStringIsNull(host)==NO&&ip==0)
  {
  aaNetIpFromString(host,&ii);
  if(ii==0)
   {
   dcldptr=NULL;
   if(aa.net_system.dns_cache.magic==aaHPP(aaListNew))
    {
    if(aaListFind(&aa.net_system.dns_cache,&li,(VP)&kp,(VP)&vp,"%s",host)==RET_YES)
     {
     dcldptr=(_dnscachelistdata*)vp;
     aaTimeUtcExGet(&now_utc);
     age_utc=now_utc-dcldptr->last_utc;
     }
    }
   aaStringCopy(calp->status.host,host);
   if(dcldptr!=NULL&&age_utc<(20*1000000LL)&&dcldptr->dns_status.mode==1)
    {
    if(aaMathRand32(0,100)!=0)
     {
     calp->is_dns=NO;
     calp->status.is_resolving=NO;
     for(i=0;i<32;i++)      {      if(dcldptr->dns_status.ip[i]!=0) { ip=dcldptr->dns_status.ip[i]; break; }      }
     if(i==32) oof;
     return(aa_NetSystemTcpCallCreate(handle,ip,port,calp->status.src_adr.ip,calp->status.src_adr.port));
     }
    dcldptr=NULL;
    }
   if((ret=aaNetDnsCreate(&calp->dns_handle,host,1,0))!=YES) { oops; }
   calp->is_dns=1;
   calp->status.is_resolving=calp->is_dns;
   return RET_YES;
   }
  if(ip!=0) { oof; }
  ip=ii;
  }
 return(aa_NetSystemTcpCallCreate(handle,ip,port,calp->status.src_adr.ip,calp->status.src_adr.port));
 }




 B aaNetTcpCallDestroy                 (H handle)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 _aa_nettcpportobject*prtp;
 B isprot;
 H port_handle;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,&isprot))!=RET_YES) { return ret; }
 if(isprot==YES) { return RET_FORBIDDEN; }
 if(calp->status.proc!=NULL) { calp->status.proc(handle); }

 if(calp->status.is_incoming==YES)
  {
  if(aa_NetSystemFindPortBySock(&port_handle,(VP)&prtp,calp->port_sock)!=YES) { oof; Boop; }
  if(calp->status.is_connected==YES) { prtp->status.calls_answered--; }
  else                               { prtp->status.calls_waiting--; }
  prtp->status.calls_inuse--;
  }
 else
  {
  if(calp->dns_handle)
   {
   aaNetDnsDestroy(calp->dns_handle);
   calp->dns_handle=0;
   calp->is_dns=0;
   calp->status.is_resolving=calp->is_dns;
   aa_ObjectDestroy(aa.net_system.tcpcall_object_id,handle);
   return RET_YES;
   }
  }
 if(calp->status.is_closed_by_remote==NO)
  {
  calp->status.is_closed_by_local=YES;
  }
 calp->status.is_close_protected=NO;
 aaNetTcpCallClose(handle);
 if(calp->xmit_que!=0)
  {
  if((ret=aaQueDestroy(calp->xmit_que))!=RET_YES) { oops; }
  }
 if(calp->rcve_que!=0)
  {
  if((ret=aaQueDestroy(calp->rcve_que))!=RET_YES) { oops; }
  }
 if(calp->status.is_incoming==NO)  {  aa.net_system.net_status.current_outgoing_tcp_call_count--;  }
 else                                {  aa.net_system.net_status.current_incoming_tcp_call_count--;  }
 if(calp->status.is_connected==YES)  {  aa.net_system.net_status.current_tcp_calls_connected--;  }
 if(calp->status.extra_bytes!=0)       {  if((ret=aaMemoryRelease(calp->status.extra_data))!=RET_YES) { oops; } calp->status.extra_bytes=0;  }
 if(calp->socket_used)
  {
  Z rr;
  if((rr=closesocket((SOCKET)calp->sock))!=0)
   {
   aaNote(0,"line=%i sock=%x aa.c han=%x %i %i",__LINE__,calp->sock,handle,rr,WSAGetLastError());
   }
  }
 aa_ObjectDestroy(aa.net_system.tcpcall_object_id,handle);
 return RET_YES;
 }





 B aaNetTcpCallDestroyProcSet          (H handle,V(*proc)(H))
 {
 B ret;
 _aa_nettcpcallobject*calp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 calp->status.proc=proc;
 return RET_YES;
 }





 B aaNetTcpCallCloseProtect            (H handle,B state)
 {
 B ret;
 _aa_nettcpcallobject*calp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(state) { calp->status.is_close_protected=YES; }
 else      { calp->status.is_close_protected=NO; }
 return RET_YES;
 }




 B aaNetTcpCallClose                   (H handle)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 B junk[_2K];
 H go;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(calp->dns_handle) { return RET_BADSTATE; }
 if(calp->status.is_close_protected) { return RET_DENIED; }
 if((ret=aaNetTcpCallInactivityReset(handle,YES,YES))!=YES) { oops; }
 if(calp->socket_used==YES&&calp->is_shutdown!=YES)
  {
  shutdown(calp->sock,SD_BOTH);
  go=0;
  while(1)
   {
   if(recv(calp->sock,(CP)junk,576,0)<=0) { break; }
   if(is_aa_quit_posted==YES) {  break; }
   if((go++)>10) { break; }
   }
  calp->is_shutdown=YES;
  if(calp->status.is_closed_by_local!=YES)
   {
   aaTimerTikGet(&calp->local_closed_ms_root);
   calp->status.local_closed_ms=0;
   calp->status.closed_ms=calp->status.local_closed_ms;
   }
  calp->status.is_closed_by_local=YES;
  }
 return RET_YES;
 }





 B aaNetTcpCallStatus                  (H handle,_tcpcallstatus*tcpcallstatus)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 F f1;
 _dnsstatus dns_status;
 H i,mip;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { return ret; }

 aaTimerTikElapsed(calp->ms_root,&calp->status.ms);

 if(calp->dns_handle)
  {
  ret=aaNetDnsStatus(calp->dns_handle,&dns_status);
  if(ret!=YES) { oops; }

  if(dns_status.is_inprogress!=YES)
   {
   if(dns_status.is_found)
    {
    for(i=0;i<32;i++)
     {
     if(dns_status.ip[i]==0)
      {
      if(aaStringIsNull(dns_status.host[i])==NO)
       {
       aaNetIpFromString(dns_status.host[i],&mip);
       if(calp->is_dns==1&&(mip!=dns_status.ip[i]||mip==0))
        {
        if((ret=aaNetDnsDestroy(calp->dns_handle))!=YES) { oops; }
        calp->is_dns=2;
        calp->dns_handle=0;
        calp->status.is_resolving=calp->is_dns;
        if(tcpcallstatus) { aaMemoryCopy(tcpcallstatus,sizeof(_tcpcallstatus),&calp->status); }
        return RET_YES;
        }
       }
      }
     }
    for(i=0;i<32;i++)
     {
     if(dns_status.ip[i]==0) { continue; }
     if((ret=aaNetDnsDestroy(calp->dns_handle))!=YES) { oops; }
     calp->is_dns=0;
     calp->status.is_resolving=calp->is_dns;
     calp->dns_handle=0;
     if((ret=aa_NetSystemTcpCallCreate(&handle,dns_status.ip[i],calp->status.remote_adr.port,calp->status.src_adr.ip,calp->status.src_adr.port))!=YES) { oops; }
     if(tcpcallstatus) { aaMemoryCopy(tcpcallstatus,sizeof(_tcpcallstatus),&calp->status); }
     return RET_YES;
     }

    dns_status.is_notfound=YES;
    }

   if(dns_status.is_notfound)
    {
    aaDebugf("dns %s not found",dns_status.query);
    if((ret=aaNetDnsDestroy(calp->dns_handle))!=YES) { oops; }
    calp->is_dns=0;
    calp->status.is_resolving=calp->is_dns;
    calp->dns_handle=0;
    calp->status.is_notfound=YES;
    calp->status.is_failed=YES;
    if(tcpcallstatus) { aaMemoryCopy(tcpcallstatus,sizeof(_tcpcallstatus),&calp->status); }
    return RET_YES;
    }
   if(dns_status.is_failed)
    {
    if((ret=aaNetDnsDestroy(calp->dns_handle))!=YES) { oops; }
    calp->is_dns=0;
    calp->status.is_resolving=calp->is_dns;
    calp->dns_handle=0;
    calp->status.is_failed=YES;
    if(tcpcallstatus) { aaMemoryCopy(tcpcallstatus,sizeof(_tcpcallstatus),&calp->status); }
    return RET_YES;
    }
   }
  if(tcpcallstatus) { aaMemoryCopy(tcpcallstatus,sizeof(_tcpcallstatus),&calp->status); }
  return RET_YES;
  }


 if(calp->status.is_inprogress)
  {
  if(calp->status.is_connected==YES)
   {
   if(calp->status.remote_adr.port==80)    {    }
   aa_NetSystemProcessTcp((VP)&calp);
   }
  }

 aaTimerTikElapsed(calp->inactive_xmit_ms_root,&calp->status.xmit_inactivity);
 aaTimerTikElapsed(calp->inactive_rcve_ms_root,&calp->status.rcve_inactivity);
 if(calp->status.ms>0)
  {
  f1=(F)calp->status.ms/1000.0;
  calp->status.rcve_rate=(H)((F)calp->status.rcve_bytes_total/f1);
  calp->status.xmit_rate=(H)((F)calp->status.xmit_bytes_total/f1);
  }
 if(calp->line_chars>_1MEG) { /* BUG,"Peek[%lu] is %lu off=%lu crlfstate=%i",handle,calp->line_chars,calp->line_peek_offset,calp->crlf_state); */ }
 calp->status.user_data=calp->user_data;
 calp->status.user_bytes=sizeof(calp->user_data);
 if(tcpcallstatus) { aaMemoryCopy(tcpcallstatus,sizeof(_tcpcallstatus),&calp->status); }
 return RET_YES;
 }






 B aaNetTcpCallNext                    (HP handle,HP iter,_tcpcallstatus*tcpcallstatus)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==NULL) { return RET_BADPARM; }
 *handle=0;
 if(iter==NULL)
  {
  if((ret=aa_NetSystemNextTcpCall(handle,0,0,&aa.net_system.next_tcpcall_counter))!=RET_YES) { return ret; }
  }
 else
  {
  if((ret=aa_NetSystemNextTcpCall(handle,0,0,iter))!=RET_YES) { return ret; }
  }
 if(tcpcallstatus) { aaNetTcpCallStatus(*handle,tcpcallstatus); }
 return RET_YES;
 }





 B aaNetTcpCallByIndex                 (HP handle,H index,_tcpcallstatus*tcpcallstatus)
 {
 BP bp;
 _aa_objectinstanceheader*oih;
 H base,instance_stride;
 B id;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle)  { *handle=0; }
 id=aa.net_system.tcpcall_object_id;
 if(aa.object_system.object[id].instance_limit==0)     { return RET_NOTFOUND; }
 if(index>=aa.object_system.object[id].instance_slots) { return RET_BOUNDS;   }
 instance_stride=aa.object_system.object[id].instance_bytes+sizeof(_aa_objectinstanceheader);
 base=(H)id*aa_OBJ_MAX_PER_ID;
 base+=aa_OBJ_BASE_HANDLE;
 bp=aa.object_system.object[id].instance_mem;
 bp+=(index*instance_stride);
 aaCast(oih,_aa_objectinstanceheader*,bp);
 if(oih->in_use==YES)
  {
  if(handle!=NULL)  { *handle=(base+index); }
  if(tcpcallstatus) { if(aaNetTcpCallStatus((base+index),tcpcallstatus)!=YES) oof; }
  return RET_YES;
  }
 return RET_NOTFOUND;
 }


 #if 0
 B aaNetTcpCallFindByAddress           (HP handle,B dir,B onlyconnected,H ip,W port,_tcpcallstatus*tcpcallstatus)
 {
 B ret;
 H i_calls,i_calls_connected;
 H o_calls,o_calls_connected;
 _netstatus ns;
 _tcpcallunit call;
 H x;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 i_calls=o_calls=0;
 i_calls_connected=o_calls_connected=0;
 if((ret=aaNetStatus(&ns))!=YES) { oops; }
 for(x=0;x<F24;x++)
  {
  if(i_calls>=ns.current_incoming_tcp_call_count&&o_calls>=ns.current_outgoing_tcp_call_count)
   {
   if((i_calls_connected+o_calls_connected)>=ns.current_tcp_calls_connected)   {   break;     }
   }
  if((ret=aaNetTcpCallByIndex(&call.handle,x,&call.status))!=YES) {   continue;   }
  if(dir==1)
   {
   if(call.status.is_incoming==NO) { continue; }
   }
  if(dir==0)
   {
   if(call.status.is_incoming==YES) { continue; }
   }
  if(onlyconnected)
   {
   if(call.status.is_connected==NO) { continue; }
   }
  else
   {
   //if(call.status.is_connected!=YES) { continue; }
   }

  if(ip!=0&&call.status.remote_adr.ip!=ip) { continue; }
  if(port!=0&&call.status.remote_adr.port!=port) { continue; }
  if(handle) { *handle=call.handle; }
  if(tcpcallstatus) { aaMemoryCopy(tcpcallstatus,sizeof(_tcpcallstatus),&call.status); }
  return RET_YES;
  }
 return RET_NOTFOUND;
 }
#endif

#if 0

 B aaNetTcpCallByNumber                (HP handle,H index,_tcpcallstatus*tcpcallstatus)
 {
 BP bp;
 _aa_objectinstanceheader*oih;
 H base,instance_stride,i,c;
 B id;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle)  { *handle=0; }
 id=aa.net_system.tcpcall_object_id;
 if(aa.object_system.object[id].instance_limit==0)      { return RET_NOTFOUND; }
 if(index>=aa.object_system.object[id].instance_slots) { return RET_BOUNDS;   }
 instance_stride=aa.object_system.object[id].instance_bytes+sizeof(_aa_objectinstanceheader);
 base=(H)id*aa_OBJ_MAX_PER_ID;
 base+=aa_OBJ_BASE_HANDLE;
 c=0;
 for(i=0;i<aa.object_system.object[id].instance_slots;i++)
  {
  bp=aa.object_system.object[id].instance_mem;
  bp+=(i*instance_stride);
  aaCast(oih,_aa_objectinstanceheader*,bp);
  if(oih->in_use!=YES) { continue; }
  if(c==index)
   {
   if(handle!=NULL)  { *handle=(base+i); }
   if(tcpcallstatus) { if(aaNetTcpCallStatus((base+i),tcpcallstatus)!=YES) oof; }
   return RET_YES;
   }
  c++;
  }
 return RET_NOTFOUND;
 }

#endif




 B aaNetTcpCallOfferWrite              (H handle,H pid,H tcpcallhandle,_tcpcallterms*tcpcallterms)
 {
 B ret;
 BOOL rt;
 _aa_nettcpcallobject*calp;
 _aa_nettcpcallobject*tcalp;
 _str1k guid;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { aaNote(0,"aax4 %i %s",handle,ret_string[ret]); return ret; }
 if(pid==0) { return RET_BADPARM;   }
 if((ret=aaNetTcpCallStatus(handle,0))!=YES) { return ret; }
 if(tcpcallterms==NULL) { return RET_BADPARM; }
 if(calp->status.is_connected!=YES)  { return RET_BADSTATE; }
 if(calp->status.is_closed)          { return RET_BADSTATE; }
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,tcpcallhandle,(VP)&tcalp,NULL))!=RET_YES) { aaNote(0,"aax4 %i %s",handle,ret_string[ret]); return ret; }
 if((ret=aaNetTcpCallStatus(tcpcallhandle,0))!=YES) { return ret; }
 if(tcalp->status.is_connected!=YES)  { return RET_BADSTATE; }
 if(tcalp->status.is_closed)          { return RET_BADSTATE; }
 aaMemoryFill(tcpcallterms,sizeof(_tcpcallterms),0);
 tcpcallterms->magic=0x50054004;
 tcpcallterms->pid=pid;
 tcpcallterms->call.handle=handle;
 aaMemoryCopy(&tcpcallterms->call.status,sizeof(_tcpcallstatus),&calp->status);
 rt=WSADuplicateSocket(calp->status.sock,pid,&tcpcallterms->prot_info);
 if(rt==SOCKET_ERROR) { oof; }
 aaStringCopyfLen(guid.buf,&guid.len,"6b67718a-8922-4dd8-8d19-ab7ddfd80384");
 aaNetTcpCallWriteDword(tcpcallhandle,guid.len);
      aaNetTcpCallWrite(tcpcallhandle,guid.len,guid.buf);
 aaNetTcpCallWriteDword(tcpcallhandle,sizeof(_tcpcallterms));
      aaNetTcpCallWrite(tcpcallhandle,sizeof(_tcpcallterms),tcpcallterms);
 aaNetTcpCallWriteDword(tcpcallhandle,0);
 if(aaNetTcpCallStatus(tcpcallhandle,0)!=YES) { oof; }
 return RET_YES;
 }





 B aaNetTcpCallOfferRead               (H handle,_tcpcallterms*tcpcallterms)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 H chunkbytesa;
 H chunkbytesb;
 H chunkbytesc;
 H need;
 _str1k guid;
 H todo,off;
 B tmp[_8K];
 H term_off;
 H term_len;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { aaNote(0,"aax4 %i %s",handle,ret_string[ret]); return ret; }
 if((ret=aaNetTcpCallStatus(handle,0))!=YES) { return ret; }
 if(calp->dns_handle)   { return RET_BADSTATE; }
 if(tcpcallterms==NULL) { return RET_BADPARM; }
 if(aaNetTcpCallStatus(handle,0)!=YES)  { oof; }
 if(calp->status.is_connected!=YES) { return RET_BADSTATE; }
 if(calp->status.is_closed)  { return RET_BADSTATE; }
 aaStringCopyfLen(guid.buf,&guid.len,"6b67718a-8922-4dd8-8d19-ab7ddfd80384");
 todo=calp->status.rcve_bytes;
 todo=aaNumRoof(todo,sizeof(tmp));
 need=4;
 if(todo<need) { return RET_NOTREADY; }

 aaNetTcpCallPeek(handle,0,todo,tmp);
 off=0;
 chunkbytesa=*(HP)&tmp[off];
 off+=4;
 need+=chunkbytesa;
 if(todo<need) { return RET_NOTREADY; }

 if(aaStringNCompare(&tmp[off],guid.buf,guid.len,0)!=YES) { oof; }
 off+=guid.len;
 need+=4;
 if(todo<need) { return RET_NOTREADY; }

 chunkbytesb=*(HP)&tmp[off];
 off+=4;
 need+=chunkbytesb;
 if(todo<need) { return RET_NOTREADY; }

 need+=4;
 if(todo<need) { return RET_NOTREADY; }
 aaMemoryCopy(tcpcallterms,chunkbytesb,&tmp[off]);
 term_off=off;
 term_len=chunkbytesb;

 off+=chunkbytesb;
 chunkbytesc=*(HP)&tmp[off];
 if(chunkbytesc!=0) { oof; }
 off+=4;
 if(todo<need) { return RET_NOTREADY; }
 if(term_len!=sizeof(_tcpcallterms)) { oof; }
 aaMemoryCopy(tcpcallterms,term_len,&tmp[term_off]);
 aaNetTcpCallDiscard(handle,off);
 if(aaNetTcpCallStatus(handle,0)!=YES)  { oof; }
 return RET_YES;
 }




 B aaNetTcpCallOfferAccept             (HP handle,_tcpcallterms*tcpcallterms)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 BP bp;
 _aa_objectinstanceheader*oih;
 SOCKET sock;
 struct sockaddr_in addr;
 H sip;
 W sport;
 D er;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(tcpcallterms==NULL) { return RET_BADPARM; }
 if((ret=aa_ObjectCreate(aa.net_system.tcpcall_object_id,handle,(VP)&calp))!=RET_YES) { oops;  return ret; }
 calp->self_handle=*handle;
 calp->status.index=*handle-((aa.net_system.tcpcall_object_id*aa_OBJ_MAX_PER_ID)+aa_OBJ_BASE_HANDLE);
 aaCast(bp,BP,calp);
 bp-=sizeof(_aa_objectinstanceheader);
 aaCast(oih,_aa_objectinstanceheader*,bp);
 calp->status.session=oih->sesh;
 calp->status.number=aa.net_system.net_status.total_tcp_call_count;
 aaStringCopyf(calp->status.hancock,"%s",aa_common_name[calp->status.is_incoming][calp->status.number%26]);
  if((calp->status.number/26)>0) aaStringAppendf(calp->status.hancock,"%u",(calp->status.number/26));
 aa.net_system.net_status.total_tcp_call_count++;
 calp->status.is_incoming=NO;
 calp->status.is_inprogress=YES;
 aaTimerTikGet(&calp->ms_root);
 aaStringNull(calp->status.host);
 sip=0;
 sport=0;
 calp->status.src_adr.ip=sip;
 calp->status.src_adr.port=sport;

 aaNetAdrToString(&calp->status.src_adr,calp->status.src_dot);
 sock=WSASocket(AF_INET,SOCK_STREAM,IPPROTO_TCP,&tcpcallterms->prot_info,0,0);
 if(sock==INVALID_SOCKET) { aaNote(0,"err=sock=%u",sock); }
 if(sip||sport)
  {
  oof;
  WinSockAddrSet(&addr,AF_INET,sip,htons(sport));
  if(bind(sock,(struct sockaddr *)&addr,sizeof(addr))) { oof; }
  }
 calp->socket_used=YES;
 WinSockAddrSet(&addr,AF_INET,tcpcallterms->call.status.remote_adr.ip,htons(tcpcallterms->call.status.remote_adr.port));
 while(1)
  {
  er=WSAAsyncSelect(sock,aa.net_system.window,aa.net_system.tcp_message_id,FD_CLOSE);
  if(er==SOCKET_ERROR)
   {
   aaNote(0,"winsockerr=%i",WSAGetLastError());
   ret=RET_FAILED;
   break;
   }
/*
  if(error==SOCKET_ERROR)
   {
   error=WSAGetLastError();
   if(error == WSAENOBUFS||error!=WSAEWOULDBLOCK)     {     ret=RET_FAILED;     break;     }
   }
   */
  if((ret=aaQueCreate(&calp->xmit_que))!=RET_YES) {  break; }
  if((ret=aaQueCreate(&calp->rcve_que))!=RET_YES) {  break; }
  break;
  }
 if(ret!=RET_YES) { oops; }
 calp->sock=sock;
 calp->status.sock=sock;
 calp->status.remote_adr.ip=tcpcallterms->call.status.remote_adr.ip;
 calp->status.remote_adr.port=tcpcallterms->call.status.remote_adr.port;

 if((ret=aa_NetSystemResolveIpPortPair(calp->sock,&calp->status.local_adr.ip,&calp->status.local_adr.port,0,0))!=YES) { oops; }
 aaNetAdrToString(&calp->status.remote_adr,calp->status.remote_dot);
 aaNetAdrToString(&calp->status.local_adr,calp->status.local_dot);
 calp->inactive_rcve_ms_root=calp->ms_root;
 calp->inactive_xmit_ms_root=calp->ms_root;
 aa.net_system.net_status.current_outgoing_tcp_call_count++;
 aa.net_system.net_status.total_outgoing_tcp_call_count++;
 aaNetTcpCallSlicerLengthSet(*handle,_8K,_8K);
 aaNetTcpCallBufferLengthSet(*handle,_32K,_32K);
 calp->status.user_data=calp->user_data;
 calp->status.user_bytes=sizeof(calp->user_data);
 aa.net_system.net_status.current_tcp_calls_connected++;
 calp->status.is_connected=YES;
 if(calp->status.is_tls==NO)
  {
  calp->status.is_ready=YES;
  }
 aaStringCopyf(calp->status.host,"%s",tcpcallterms->call.status.host);
 calp->status.rcve_buffer_length=tcpcallterms->call.status.rcve_buffer_length;
 calp->status.xmit_buffer_length=tcpcallterms->call.status.xmit_buffer_length;
 calp->status.rcve_slicer_length=tcpcallterms->call.status.rcve_slicer_length;
 calp->status.xmit_slicer_length=tcpcallterms->call.status.xmit_slicer_length;
 calp->status.stage=tcpcallterms->call.status.stage;
 aaNetTcpCallStatus(*handle,0);
 return RET_YES;
 }






 B aaNetTcpCallAnswer                  (H handle)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 _aa_nettcpportobject*prtp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(calp->status.is_incoming==NO)  {  return RET_FAILED;  }
 if(calp->status.is_connected==YES)  {  return RET_ALREADYOPEN; }
 if((ret=aa_NetSystemFindPortBySock(NULL,(VP)&prtp,calp->port_sock))!=RET_YES)
  {
  aaNetTcpCallDestroy(handle);
  return ret;
  }
 if(prtp->status.calls_waiting==0)
  {
  aaNetTcpCallDestroy(handle);
  return RET_FAILED;
  }
 if((ret=aaQueCreate(&calp->xmit_que))!=RET_YES)
  {
  logg("oops=%i line=%i",ret,__LINE__);
  aaNetTcpCallDestroy(handle);
  return ret;
  }
 if((ret=aaQueCreate(&calp->rcve_que))!=RET_YES)
  {
  logg("oops=%i line=%i",ret,__LINE__);
  aaNetTcpCallDestroy(handle);
  return ret;
  }
 logg("tcpcallanswwer rcve que handle=%i",calp->rcve_que);
 logg("tcpcallanswwer xmit que handle=%i",calp->xmit_que);
 if(WSAAsyncSelect(calp->sock,aa.net_system.window,aa.net_system.tcp_message_id,FD_CLOSE))
  {
  aaNetTcpCallDestroy(handle);
  return RET_FAILED;
  }
 prtp->status.calls_waiting--;
 prtp->status.calls_answered++;
 aa.net_system.net_status.current_tcp_calls_connected++;
 calp->status.is_connected=YES;
 if(calp->status.is_tls==NO)
  {
  calp->status.is_ready=YES;
  }
 #if 1
 aaNetTcpCallSlicerLengthSet(handle,_8K,_8K);
 aaNetTcpCallBufferLengthSet(handle,_32K,_32K);
 #else
 aaNetTcpCallSlicerLengthSet(handle,_8K,_8K);
 aaNetTcpCallBufferLengthSet(handle,_32K,_32K);
 #endif
  calp->status.user_data=calp->user_data;
  calp->status.user_bytes=sizeof(calp->user_data);
 if(prtp->status.extra_bytes!=0)
  {
  if((ret=aaNetTcpCallExtraDataSet(handle,prtp->status.extra_bytes))!=YES) { oops; }
  }
 aaNetTcpCallInactivityReset(handle,YES,YES);
 if(calp->status.is_nodelay)
  {
  Z bnod=calp->status.is_nodelay;
  setsockopt(calp->sock,IPPROTO_TCP,TCP_NODELAY,(CP)&bnod,sizeof(Z));
  }
 aaNetTcpCallStatus(handle,0);
 return RET_YES;
 }



 B aaNetTcpCallWrite                   (H handle,H bytes,VP data)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 _questatus qs;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { aaNote(0,"aax4 %i %s",handle,ret_string[ret]); return ret; }
 if(calp->dns_handle) { return RET_BADSTATE; }
 if(bytes==0) { return RET_YES; }
 if(data==NULL) { return RET_BADPARM; }
 aa_NetSystemProcessTcp((VP)&calp);
 #if 1
 if((ret=aaQueStatus(calp->xmit_que,&qs))!=RET_YES) { oops; }
 if(calp->status.xmit_bytes!=qs.bytes) { oof; }
 calp->status.xmit_bytes=qs.bytes;
 #endif
 aaCast(bp,BP,data);
 if(bytes==0) oof;
 if((ret=aaQueWrite(calp->xmit_que,bytes,bp))!=RET_YES) { return ret; }
 aa_NetSystemProcessTcp((VP)&calp);
 return RET_YES;
 }




 B aaNetTcpCallWritef                  (H handle,VP fmt,...)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 va_list argptr;
 B txt[_4K];
 BP tmp=NULL_POINTR;
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaCast(tmp,BP,txt);
 if(aa.is_ready==YES)
  {
  if((ret=aa_MemoryTemp((VP)&tmp,_128K,aa_MEMORYTEMP_CallWritef))!=RET_YES) { return ret; }
  }
 aaFmt(fmt,argptr,tmp);
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(fmt==NULL) { return RET_YES; }
 aaStringLen(tmp,&sl);
 if(sl==0) { return RET_YES; }
 if((ret=aaNetTcpCallWrite(handle,sl,tmp))!=RET_YES) { return ret; }
 return RET_YES;
 }





 B aaNetTcpCallWriteByte               (H handle,B val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaNetTcpCallWrite(handle,1,&val));
 }



 B aaNetTcpCallWriteWord               (H handle,W val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaNetTcpCallWrite(handle,2,&val));
 }


 B aaNetTcpCallWriteDword              (H handle,H val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaNetTcpCallWrite(handle,4,&val));
 }


 B aaNetTcpCallWriteQuad               (H handle,Q val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaNetTcpCallWrite(handle,8,&val));
 }


 B aaNetTcpCallRead                    (H handle,H bytes,VP data)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaNetTcpCallPeek(handle,0,bytes,data))!=RET_YES) { return ret; }
 if((ret=aaNetTcpCallDiscard(handle,bytes))!=RET_YES) { return ret; }
 return RET_YES;
 }



 B aaNetTcpCallReadByte                (H handle,BP val)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaNetTcpCallPeek(handle,0,1,val))!=RET_YES) { return ret; }
 if((ret=aaNetTcpCallDiscard(handle,1))!=RET_YES) { return ret; }
 return RET_YES;
 }


 B aaNetTcpCallReadWord                (H handle,WP val)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaNetTcpCallPeek(handle,0,2,val))!=RET_YES) { return ret; }
 if((ret=aaNetTcpCallDiscard(handle,2))!=RET_YES) { return ret; }
 return RET_YES;
 }


 B aaNetTcpCallReadDword               (H handle,HP val)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaNetTcpCallPeek(handle,0,4,val))!=RET_YES) { return ret; }
 if((ret=aaNetTcpCallDiscard(handle,4))!=RET_YES) { return ret; }
 return RET_YES;
 }

 B aaNetTcpCallReadQuad                (H handle,QP val)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaNetTcpCallPeek(handle,0,8,val))!=RET_YES) { return ret; }
 if((ret=aaNetTcpCallDiscard(handle,8))!=RET_YES) { return ret; }
 return RET_YES;
 }



 B aaNetTcpCallPeek                    (H handle,H offset,H bytes,VP data)
 {
 B ret;
 _aa_nettcpcallobject*calp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(calp->dns_handle) { return RET_BADSTATE; }
 if(bytes==0) { return RET_YES; }
 if(data==NULL) { return RET_BADPARM; }
 aa_NetSystemProcessTcp((VP)&calp);
 if((ret=aaQuePeek(calp->rcve_que,offset,bytes,data))!=RET_YES) {  return ret; }
 return RET_YES;
 }






 B aaNetTcpCallDiscard                 (H handle,H bytes)
 {
 B ret;
 _aa_nettcpcallobject*calp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(bytes==0) { return RET_YES; }
 if((ret=aaQueDiscard(calp->rcve_que,bytes))!=RET_YES) { return ret; }
 calp->crlf_state=0;
 aa_NetSystemProcessTcp((VP)&calp);
 return RET_YES;
 }




 B aaNetTcpCallFindByte                (H handle,H offset,H bytes,HP pos,B ch,B logic,H number)
 {
 B ret;
 _aa_nettcpcallobject*calp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 return(aaQueFindByte(calp->rcve_que,offset,bytes,pos,ch,logic,number));
 }




 B aaNetTcpCallReturn                  (H handle,H bytes)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 B block[_4K];
 H todo;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(bytes==0) { return RET_YES; }
 if(bytes>calp->status.rcve_bytes) { return RET_BOUNDS; }
 if(bytes==calp->status.rcve_bytes) { return RET_YES; }
 while(1)
  {
  if(bytes==0) { break; }
  todo=aaNumRoof(bytes,_4K);
  if((ret=aaNetTcpCallRead(handle,todo,block))!=RET_YES) { oops; }
  if((ret=aaQueWrite(calp->rcve_que,todo,block))!=RET_YES) { oops; }
  bytes-=todo;
  }
 aa_NetSystemProcessTcp((VP)&calp);
 return RET_YES;
 }




 B aaNetTcpCallPush                    (H handle,H bytes,VP data)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 H todo;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(bytes==0) { return RET_YES; }
 if(data==NULL) { return RET_BADPARM; }
 aaCast(bp,BP,data);
 while(1)
  {
  if(bytes==0) { break; }
  todo=aaNumRoof(bytes,_4K);
  if((ret=aaQueWrite(calp->rcve_que,todo,bp))!=RET_YES) { oops; }
  bytes-=todo;
  bp+=todo;
  }
 aa_NetSystemProcessTcp((VP)&calp);
 return RET_YES;
 }



 B aaNetTcpCallRelay                   (H handle,H bytes,H relayhandle,B how)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 _aa_nettcpcallobject*calp_relay;
 H todo;
 B block[_4K],id;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if((ret=aa_ObjectFromHandle(&id,relayhandle))!=YES) { return ret; }

 if(id==aa.net_system.tcpcall_object_id)
  {
  if((ret=aa_ObjectCheck(id,relayhandle,(VP)&calp_relay,NULL))!=RET_YES) { return ret; }

  while(1)
   {
   todo=aaNumRoof(bytes,_2K);
   if(todo==0) { break; }
   if(how==1||how==3)
    {
    if((ret=aaNetTcpCallRead(relayhandle,todo,block))!=YES) { oops; }
    if((ret=aaNetTcpCallWrite(handle,todo,block))!=YES) { oops; }
    }
   if(how==2||how==3)
    {
    if((ret=aaNetTcpCallRead(handle,todo,block))!=YES) { oops; }
    if((ret=aaNetTcpCallWrite(relayhandle,todo,block))!=YES) { oops; }
    }
   bytes-=todo;
   }
  return RET_YES;
  }
 return RET_DENIED;
 }





 B aaNetTcpCallMirror                  (H handle,_tcpcallstatus*callstatus,H bytes,H han2,_tcpcallstatus*callstatus2,VP buf)
  {
 B ret;
 _aa_nettcpcallobject*calp1;
 _aa_nettcpcallobject*calp2;
 BP tmpbuf=NULL_POINTR;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(buf) { aaStringNull(buf); }
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp1,NULL))!=RET_YES) { return ret; }
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,han2,(VP)&calp2,NULL))!=RET_YES) { return ret; }
 if(callstatus)  { if((ret=aaNetTcpCallStatus(handle,callstatus))!=RET_YES) { oops; }  }
 else            { if((ret=aaNetTcpCallStatus(handle,0))!=RET_YES) { oops; }  }
 if(callstatus2) { if((ret=aaNetTcpCallStatus(han2,callstatus2))!=RET_YES) { oops; }  }
 else            { if((ret=aaNetTcpCallStatus(han2,0))!=RET_YES) { oops; }  }
 if(bytes==0) { return RET_YES; }
 if(bytes==0xffffffff) { bytes=calp1->status.rcve_bytes; }
 if(bytes==0) { return RET_YES; }
 if(bytes>calp1->status.rcve_bytes) { return RET_NOTREADY; }
 if(buf==NULL)
  {
  if(bytes<_128K)
   {
   if((ret=aa_MemoryTemp((VP)&tmpbuf,_128K,aa_MEMORYTEMP_CallMirror))!=RET_YES) { return ret; }
   }
  else
   {
   if((ret=aa_MemoryTemp((VP)&tmpbuf,bytes+_4K,aa_MEMORYTEMP_CallMirror))!=RET_YES) { return ret; }
   }
  }
 else
  {
  tmpbuf=buf;
  }
 if((ret=aaNetTcpCallRead(handle,bytes,tmpbuf))!=RET_YES) { oops; }
 if((ret=aaNetTcpCallWrite(han2,bytes,tmpbuf))!=RET_YES) { oops; }
 if(callstatus)  { if((ret=aaNetTcpCallStatus(handle,callstatus))!=RET_YES) { oops; }  }
 else            { if((ret=aaNetTcpCallStatus(handle,0))!=RET_YES) { oops; }  }
 if(callstatus2) { if((ret=aaNetTcpCallStatus(han2,callstatus2))!=RET_YES) { oops; }  }
 else            { if((ret=aaNetTcpCallStatus(han2,0))!=RET_YES) { oops; }  }
 return RET_YES;
 }





 B aaNetTcpCallStringLen               (H handle,HP chars,BP stringmode)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 H ma,ch;
 B mo;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(chars) *chars=0;
 if(stringmode) *stringmode=0;
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) {return ret; }
 ret=aaNetTcpCallStringLook(handle,0,0,0,0,&ch,&mo,0,0);
 if(stringmode) *stringmode=mo;
 if(chars)
  {
  if(mo==aa_STRINGMODE_LF)   { ma=1; } else
  if(mo==aa_STRINGMODE_CR)   { ma=1; } else
  if(mo==aa_STRINGMODE_CRLF) { ma=2; } else { ma=0; }
  ch=ch+ma;
  *chars=ch;
  }
 return ret;
 }



 B aaNetTcpCallStringRead              (H handle,HP chars,BP stringmode,H maxchars,VP buf)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 H off,len,ma=0;
 B mo;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(chars) *chars=0;
 if(stringmode) *stringmode=0;
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) {return ret; }
 ret=aaNetTcpCallStringLook(handle,0,0,0,&off,&len,&mo,maxchars,buf);
 if(chars) *chars=len;
 if(stringmode) *stringmode=mo;
 if(ret!=YES) { return ret; }
 if(off!=0) { oof; }
 if(mo==aa_STRINGMODE_LF)   { ma=1; } else
 if(mo==aa_STRINGMODE_CR)   { ma=1; } else
 if(mo==aa_STRINGMODE_CRLF) { ma=2; } else { oof; }
 if((ret=aaNetTcpCallDiscard(handle,len+ma))!=YES) { oops; }
 aaNetTcpCallStatus(handle,0);
 return ret;
 }



 B aaNetTcpCallStringPeek              (H handle,HP chars,BP stringmode,H maxchars,VP buf)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 H off;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(chars) *chars=0;
 if(stringmode) *stringmode=0;
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) {return ret; }
 ret=aaNetTcpCallStringLook(handle,0,0,0,&off,chars,stringmode,maxchars,buf);
 if(ret!=YES) { return ret; }
 aaNetTcpCallStatus(handle,0);
 return ret;
 }




 B aaNetTcpCallStringLook              (H handle,H fromoff,H index,HP count,HP offset,HP chars,BP stringmode,H maxchars,VP buf)
 {
 B ret;
 H off,cnt,frm;
 H todo,k,sl,to;
 H atatime,prevatatime,have,go,ma;
 B tmp[_16K];
 B was_found;
 _aa_nettcpcallobject*calp;
 BP bp;
 B mo;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(count) *count=0;
 if(offset) *offset=0;
 if(chars) *chars=0;
 if(stringmode) *stringmode=0;
 if(buf) { aaStringNull(buf); }
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) {return ret; }
 prevatatime=atatime=512;
 aaNetTcpCallStatus(handle,0);
 have=calp->status.rcve_bytes;
 if(fromoff>=have) { return RET_NOTREADY; }
 have-=fromoff;
 off=cnt=frm=0;
 was_found=NO;
 mo=0;
 ma=0;
 go=0;
 while(1)
  {
  todo=have-off;
  if(todo<2) break;
  todo=aaNumRoof(todo,atatime);
  aaNetTcpCallPeek(handle,fromoff+off,todo,tmp);
  mo=0;
  for(k=0;k<todo-1;k++)
   {
   mo=0;
   if(tmp[k+0]==LF_CHAR&&tmp[k+1]!=CR_CHAR) { mo=aa_STRINGMODE_LF; ma=1; }   else
   if(tmp[k+0]==CR_CHAR&&tmp[k+1]!=LF_CHAR) { mo=aa_STRINGMODE_CR; ma=1; }   else
   if(tmp[k+0]==CR_CHAR&&tmp[k+1]==LF_CHAR) { mo=aa_STRINGMODE_CRLF; ma=2; } else { continue; }
   to=off+k;
   sl=to-frm;
   if(was_found!=YES)
    {
    if(offset) *offset=frm;
    if(chars) *chars=sl;
    if(stringmode) *stringmode=mo;
    }
   if(cnt==index)
    {
    was_found=YES;
    if(buf)
     {
     if(sl>=maxchars) { return RET_BOUNDS; }
     if((ret=aaNetTcpCallPeek(handle,fromoff+frm,sl,buf))!=YES) { oops; return ret; }
     bp=(BP)buf;
     bp[sl]=NULL_CHAR;
     if(count==NULL) { return RET_YES; }
     }
    }
   frm=to+ma;
   cnt++;
   off+=(sl+ma);
   break;
   }
  go++;
  if(mo==0)
   {
   atatime=(go+1)*512;
   if(atatime>=_8K) { break; }
   if(go>32) {  break; }
   atatime=aaNumRoof(atatime,_8K);
   aaNetTcpCallStatus(handle,0);
   have=calp->status.rcve_bytes;
   have-=fromoff;
   atatime=aaNumRoof(atatime,have);

   if(atatime==prevatatime)  { break; }
   prevatatime=atatime;
   off=cnt=frm=0;
   mo=0;
   ma=0;
   continue;
   }
  }
 if(count) { *count=cnt; }
 if(was_found) { return RET_YES; }
 return RET_NOTREADY;
 }






 B aaNetTcpCallStringDiscard           (H handle)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 H off,chars,ma=0;
 B mo;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) {return ret; }
 ret=aaNetTcpCallStringLook(handle,0,0,0,&off,&chars,&mo,0,0);
 if(ret!=YES) { return ret; }
 if(off!=0) { oof; }
 if(mo==aa_STRINGMODE_LF)   { ma=1; } else
 if(mo==aa_STRINGMODE_CR)   { ma=1; } else
 if(mo==aa_STRINGMODE_CRLF) { ma=2; } else { oof; }
 if((ret=aaNetTcpCallDiscard(handle,chars+ma))!=YES) { oops; }
 aaNetTcpCallStatus(handle,0);
 return ret;
 }




 B aaNetTcpCallPause                   (H handle,B rstate,B xstate)
 {
 B ret;
 _aa_nettcpcallobject*calp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(calp->dns_handle) { return RET_BADSTATE; }
 if(rstate==YES) { calp->status.is_rcve_paused=YES; }
 else            { calp->status.is_rcve_paused=NO; }
 if(xstate==YES) { calp->status.is_xmit_paused=YES; }
 else            { calp->status.is_xmit_paused=NO; }
 return RET_YES;
 }



 B aaNetTcpCallAllowThenPause          (H handle,H rbytes,H xbytes)
 {
 B ret;
 _aa_nettcpcallobject*calp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(calp->dns_handle) { return RET_BADSTATE; }
 if(rbytes==0) { calp->status.is_rcve_paused=YES; }
 else
  {
  calp->status.rcve_then_pause=rbytes;
  calp->status.is_rcve_paused=NO;
  }

 if(xbytes==0) { calp->status.is_xmit_paused=YES; }
 else
  {
  calp->status.xmit_then_pause=xbytes;
  calp->status.is_xmit_paused=NO;
  }


 return RET_YES;
 }



 B aaNetTcpCallExtraDataSet            (H handle,H bytes)
 {
 B ret;
 _aa_nettcpcallobject*calp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(bytes==0)
  {
  if(calp->status.extra_bytes!=0)
   {
   if((ret=aaMemoryRelease(calp->status.extra_data))!=RET_YES) { oops; }
   }
  calp->status.extra_data=NULL;
  calp->status.extra_bytes=bytes;
  }
 else
  {
  if(calp->status.extra_bytes==0)
   {
   calp->status.extra_data=NULL;
   }
  if(calp->status.extra_bytes!=bytes)
   {
   if((ret=aaMemoryMake((VP)&calp->status.extra_data,bytes))!=RET_YES) { oops; }
   aaMemoryNameSet(calp->status.extra_data,"callextra");
   }
  calp->status.extra_bytes=bytes;
  }
 return RET_YES;
 }





 B aaNetTcpCallExtraDataGet            (H handle,HP bytes,PP ptr)
 {
 B ret;
 _aa_nettcpcallobject*calp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(bytes) { *bytes=0; }
 if(ptr)   { *ptr=0; }
 if(calp->status.extra_bytes!=0)
  {
  if(bytes) { *bytes=calp->status.extra_bytes; }
  if(ptr) { *ptr=calp->status.extra_data; }
  }
 return RET_YES;
 }






 B aaNetTcpCallBufferLengthSet         (H handle,H rbytes,H xbytes)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 N opt,olen;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(calp->dns_handle) { return RET_BADSTATE; }
 if(rbytes!=calp->status.rcve_buffer_length)
  {
  opt=rbytes; olen=4;
  if(setsockopt(calp->sock,SOL_SOCKET,SO_RCVBUF,(CP)&opt,olen)!=0) oof;
  calp->status.rcve_buffer_length=rbytes;
  }
 if(xbytes!=calp->status.xmit_buffer_length)
  {
  opt=xbytes; olen=4;
  if(setsockopt(calp->sock,SOL_SOCKET,SO_SNDBUF,(CP)&opt,olen)!=0) oof;
  calp->status.xmit_buffer_length=xbytes;
  }
 return RET_YES;
 }




 B aaNetTcpCallSlicerLengthSet         (H handle,H rbytes,H xbytes)
 {
 B ret;
 _aa_nettcpcallobject*calp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 calp->status.rcve_slicer_length=aaNumClamp(rbytes,1,_64K);
 calp->status.xmit_slicer_length=aaNumClamp(xbytes,1,_64K);
 return RET_YES;
 }





 B aaNetTcpCallNoDelaySet              (H handle,B state)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 B os;
 Z bnod=0;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 state&=1;
 os=calp->status.is_nodelay;
 if(os==state) { return RET_YES; }
 calp->status.is_nodelay=state;
 if(calp->status.is_connected)
  {
  bnod=(Z)calp->status.is_nodelay;
  setsockopt(calp->sock,IPPROTO_TCP,TCP_NODELAY,(CP)&bnod,sizeof(Z));
  }
 return RET_YES;
 }


///=====================================================

 #define SIO_KEEPALIVE_VALS            _WSAIOW(IOC_VENDOR,4)

 struct tcp_keepalive
 {
 ULONG onoff;
 ULONG keepalivetime;
 ULONG keepaliveinterval;
 };

///=====================================================

 B aaNetTcpCallKeepAliveSet            (H handle,B state,H alivetime,H aliveinterval)
 {
 B ret;
 _aa_nettcpcallobject*calp;
  struct tcp_keepalive alive;
 B os;
 H done;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 state&=1;
 os=calp->status.is_keepalive;
 if(os==state) { return RET_YES; }
 alive.onoff=state;
 alive.keepalivetime=alivetime;
 alive.keepaliveinterval=aliveinterval;
 done=0;
 if(WSAIoctl(calp->sock,SIO_KEEPALIVE_VALS,&alive,sizeof(alive),NULL,0,&done,NULL,NULL)==SOCKET_ERROR)
  {
  aaNote(0,"WSAIotcl(SIO_KEEPALIVE_VALS) failed; %d",WSAGetLastError());
  return RET_FAILED;
  }
 calp->status.is_keepalive=state;
 calp->status.keepalive_time=alivetime;
 calp->status.keepalive_interval=aliveinterval;
 /*
 aaDebugf("SIO_KEEPALIVE_VALS set:\n");
    aaDebugf("   Keepalive Time     = %lu\n", alive.keepalivetime);
    aaDebugf("   Keepalive Interval = %lu\n", alive.keepaliveinterval);
 */
 return RET_YES;
 }




 B aaNetTcpCallStageSet                (H handle,H stage)
 {
 B ret;
 _aa_nettcpcallobject*calp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(calp->dns_handle) { return RET_BADSTATE; }
 calp->status.stage=stage;
 return RET_YES;
 }





 B aaNetTcpCallMaxRateSet              (H handle,H rrate,H xrate)
 {
 B ret;
 _aa_nettcpcallobject*calp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 calp->status.max_xmit_rate=xrate;
 calp->status.max_rcve_rate=rrate;
 if(rrate>=(0xffffffff-2000)) { rrate=0xffffffff-2000; }
 if(xrate>=(0xffffffff-2000)) { xrate=0xffffffff-2000; }
 if(rrate==0)
  {
  calp->is_rcve_backoff=NO;
  }
 else
  {
  if(calp->status.rcve_rate>=rrate)
   {
   calp->is_rcve_backoff=YES;
   }
  }

 if(xrate==0)
  {
  calp->is_xmit_backoff=NO;
  }
 else
  {
  if(calp->status.xmit_rate>=xrate)
   {
   calp->is_xmit_backoff=YES;
   }
  }
 return RET_YES;
 }





 B aaNetTcpCallInactivityReset         (H handle,B rflag,B xflag)
 {
 B ret;
 _aa_nettcpcallobject*calp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(calp->dns_handle) { return RET_BADSTATE; }
 if(rflag)  {  aaTimerTikGet(&calp->inactive_rcve_ms_root);  calp->status.rcve_inactivity=0;  }
 if(xflag)  {  aaTimerTikGet(&calp->inactive_xmit_ms_root);  calp->status.xmit_inactivity=0;  }
 return RET_YES;
 }




 B aaNetTcpCallProtocolSet             (H handle,H protocol)
 {
 B ret;
 _aa_nettcpcallobject*calp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 calp->status.protocol=protocol;
 return RET_YES;
 }




 B aaNetTcpCallIsActive                (H handle,H timeout)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 H rina,icbr,icbl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if((ret=aaNetTcpCallStatus(handle,NULL))!=YES) { return ret; }
 if(calp->status.is_connected!=YES) { return RET_NOTREADY; }
 rina=calp->status.rcve_inactivity;
 icbr=calp->status.is_closed_by_remote;
 icbl=calp->status.is_closed_by_local;
 if(icbl&&icbr)
  {
  return RET_NO;
  }
 if(icbr)
  {
  if(rina>timeout) { return RET_NO;   }
  return RET_TIMEOUT;
  }
 if(rina>(timeout*2))
  {
  return RET_TIMEOUT;
  }
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/


 B aaNetHttpHeaderPrepare              (VP str,N result,B close,N cache,B chunked,G conlen,VP contype)
 {
 _systime st;
 B txt[_1K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 aaStringNull(str);
 if(result>0&&result<1000) {  aaStringAppendf(str,"HTTP/1.1 %u\r\n",result);  }

 aaTimeSystemGet(&st);
 aaTimeToString(&st,txt,"GMT",0);
 aaStringAppendf(str,"Date: %s\r\n",txt);
 aaStringAppendf(str,"Server: aaBoost\r\n");
 if(close) { aaStringAppendf(str,"Connection: close\r\n"); }
 else      { aaStringAppendf(str,"Connection: keep-alive\r\n"); }
 if(cache>0)   {  aaStringAppendf(str,"Pragma: public\r\nCache-Control: public; max-age=%ld\r\n",cache); }
 else
 if(cache<0)   {  aaStringAppendf(str,"Pragma: no-cache\r\nCache-Control: no-cache, private, no-store; must-revalidate\r\nExpires: 0\r\n"); }
 if(aaStringIsEmpty(contype,YES)==NO) { aaStringAppendf(str,"Content-type: %s\r\n",contype);  }
 if(chunked==YES) { aaStringAppendf(str,"Transfer-Encoding: chunked\r\n");  }
 else             { if(conlen>=0) { aaStringAppendf(str,"Content-length: %I64d\r\n",conlen); }  }
 return RET_YES;
 }





 B aaNetHttpHeaderCookiePrepare        (VP str,B servermode,VP domain,VP path,G expires,VP name,VP fmt,...)
 {
 va_list argptr;
 B out[_4K];
 B txt[_1K];
 B tmp[_4K];
 BP bp;
 H i,sl;
 _systime st;
 B ascii;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,tmp);
 if(str==NULL) { return RET_BADPARM; }
 aaStringNull(str);
 if(name==NULL) { return RET_BADPARM; }
 aaCast(bp,BP,tmp);
 aaStringLen(bp,&sl);
 if(sl>255) { return RET_BADPARM; }
 for(i=0;i<sl;i++) { if(bp[i]==';'||bp[i]==SPACE_CHAR||bp[i]==COMMA_CHAR) { oof; return RET_FAILED; } }
 aaCast(bp,BP,name);
 aaStringLen(bp,&sl);
 if(sl==0||sl>255) { return RET_BADPARM; }
 for(i=0;i<sl;i++) { if(bp[i]==';'||bp[i]==SPACE_CHAR||bp[i]==COMMA_CHAR) {  return RET_FAILED; } }
 if(path!=NULL)   {  aaStringLen(path,&sl); if(sl==0||sl>255) { return RET_BADPARM; }  }
 if(domain!=NULL)  {  aaStringLen(domain,&sl); if(sl==0||sl>255) { return RET_BADPARM; }  }
 if(expires!=0)
  {
  if(expires==-1)  {  aaStringCopyf(txt,"Thu, 01-Jan-1970 00:00:00 GMT");  }
  else
   {
   aaTimeSystemGet(&st);
   aaTimeAdjust(&st,&st,expires);
   aaTimeToString(&st,txt,"GMT",0);
   txt[7]='-';
   txt[11]='-';
   }
  aaStringReplaceChar(txt,0,'-',SPACE_CHAR);
  }
 if(servermode) { aaStringCopyf(out,"Set-Cookie: %s=%s;",name,tmp); }
 else           { aaStringCopyf(out,"Cookie: %s=%s;",name,tmp); }
 if(domain!=NULL) {  aaStringAppendf(out," Domain=%s;",domain); }
 if(expires!=0)   { aaStringAppendf(out," Expires=%s;",txt); }
 if(path!=NULL)   {  aaStringAppendf(out," Path=%s;",path); }
 while(1)
  {
  aaStringLastCharGet(out,0,&ascii);
  if(ascii==0) { break; }
  if(ascii==';') { aaStringLastCharSet(out,0,0,NO); continue; }
  if(aaCharIsVisible(ascii)!=YES) { aaStringLastCharSet(out,0,0,NO); continue; }
  break;
  }
 aaStringAppendf(str,"%s\r\n",out);
 return RET_YES;
 }





 B aaNetHttpHeaderFieldCodeGet         (VP str,H chars,NP which,HP len)
 {
 H i;
 S B textual_string[128][64];
 S H textual_chars[128];
 S H textual_count=0;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(textual_count==0)
  {
  aaStringCopy(textual_string[textual_count],"vary:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"accept-ranges:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"location:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"p3p:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"x-aspnet-version:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"x-powered-by:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"expires:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"pragma:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"set-cookie:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"etag:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"x-cache:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"cache-control:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"content-type:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"last-modified:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"server:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"date:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"content-length:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"content-range:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"connection:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"keep-alive:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"host:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"cookie:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"cookie2:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"user-agent:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"accept-encoding:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"accept-language:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"accept-charset:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"transfer-encoding:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"referer:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"accept:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"If-Modified-Since:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"te:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"via:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"status:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"x-forwarded-for:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"age:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"x-pad:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"ua-os:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"ua-cpu:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"ua-pixels:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"ua-color:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"from:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"x-cache-lookup:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"authorization:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"content-transfer-encoding:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"origin:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"Access-Control-Request-Method:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"Access-Control-Allow-Origin:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"Content-Encoding:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"Dnt:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"Upgrade-Insecure-Requests:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  }
 if(len) { *len=0; }
 if(which==NULL) { return RET_BADPARM; }
 *which=-1;
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { *which=aa_HTTPFIELD_BLANK; if(len) { *len=0; } return RET_YES; }
 for(i=0;i<textual_count;i++)
  {
  if(aaStringNICompare(str,textual_string[i],textual_chars[i],0)!=YES) { continue; }
  if(len) { *len=textual_chars[i]; }
  *which=i+aa_HTTPFIELD_VARY;
  return RET_YES;
  }
 if(len)
  {
  aaStringFindChar(str,chars,&i,':',YES,0,YES);
  if(i==0xffffffff) { *len=chars; }
  else       { *len=i+1;  }
  }
 *which=aa_HTTPFIELD_UNIMPLEMENTED;
 return RET_NOTFOUND;
 }




/*-----------------------------------------------------------------------*/

 B aaNetHttpResultReadFromString       (_httpresult*httpresult,H bytes,VP str)
 {
 H chars,val;
 B txt[_2K],token[2][_2K];
 N which;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(httpresult==NULL) { return RET_BADPARM; }
 httpresult->is_success=NO;
 httpresult->is_failed=NO;
 if(str==NULL) { return RET_BADPARM; }
 if(bytes==0) { aaStringLen(str,&bytes); }
 if(bytes==0) { return RET_BADPARM; }
 chars=bytes;
 aaMemoryFill(httpresult,sizeof(_httpresult),0);
 if(chars>512) { httpresult->is_failed=YES; return RET_YES; }
 aaStringCopy(txt,str);
 if(chars>1)
  {
  aaStringReplaceChar(txt,chars,HTAB_CHAR,SPACE_CHAR);
  aaStringRemoveMultipleSpaces(txt,chars,NO);
  aaStringLen(txt,&chars);
  }
 if(chars<12) {          httpresult->is_failed=YES; return RET_YES; }
 if(txt[8]!=SPACE_CHAR) {      httpresult->is_failed=YES; return RET_YES; }
 if(aaStringIsNumerical(&txt[9],0,0,3)!=RET_YES)  {      httpresult->is_failed=YES;  return RET_YES; }
 aaStringNCopy(&token[0],&txt[0],8,YES);
 aaStringNCopy(&token[1],&txt[9],3,YES);
 aaStringLower(token[0],0,NULL);
 aaStringIsIString(token[0],&which,"HTTP/0.9","HTTP/1.0","HTTP/1.1","HTTP/1.2",NULL);
 if(which==-1) { httpresult->is_failed=YES; oof; return RET_YES; }
 httpresult->is_failed=NO;
 if(which==0) { httpresult->version[0]=0; httpresult->version[1]=9; }
 else
 if(which==1) { httpresult->version[0]=1; httpresult->version[1]=0; }
 else
 if(which==2) { httpresult->version[0]=1; httpresult->version[1]=1; }
 else
 if(which==3) { httpresult->version[0]=1; httpresult->version[1]=2; }
 aaStringToNumber(token[1],3,&val,NULL,0,0);
 httpresult->code=val;
 httpresult->is_success=YES;
 return RET_YES;
 }












 B aaNetHttpHeaderReadFromString       (_httpheader*httpheader,H bytes,VP str)
 {
 B ret;
 H chars,sl,o,count;
 B txt[_4K],token[3][_3K];
 B etc[_2K];
 N which;
 H pos,off,xl,ul;
 BP bp;
 _stringexplode se;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(httpheader==NULL) { return RET_BADPARM; }
 httpheader->field_code=0;
 httpheader->field[0]=NULL_CHAR;
 httpheader->data[0]=NULL_CHAR;
 httpheader->value[0]=0xffffffff;
 httpheader->value[1]=0xffffffff;
 httpheader->value[2]=0xffffffff;
 httpheader->is_success=NO;
 httpheader->is_failed=NO;
 httpheader->bytes=0;
 aaTimeNull(&httpheader->time);
 httpheader->data_bytes=0;
 if(str==NULL) { return RET_BADPARM; }
 if(bytes==0) { aaStringLen(str,&bytes); }
 if(bytes==0) { return RET_BADPARM; }
 chars=bytes;
 aaStringCopy(txt,str);
 httpheader->bytes=chars;
 if(chars==0)  {  httpheader->is_success=YES;  httpheader->is_failed=NO;  httpheader->field_code=aa_HTTPFIELD_BLANK;  return RET_YES;  }
 if(chars>1)   {  aaStringReplaceChar(txt,chars,HTAB_CHAR,SPACE_CHAR);  aaStringRemoveMultipleSpaces(txt,chars,NO);  aaStringLen(txt,&chars);  }
 sl=chars;
 if(aaStringFindChar(txt,0,&o,':',YES,0,YES)!=YES) {  /* BUG,"a %i %s",sl,txt); */ httpheader->is_failed=YES;  return RET_YES; }
 if(o>64) {  return RET_NOTREADY; }

 aaStringNCopy(token[0],&txt[0],o,YES);
 aaCast(bp,BP,&txt[o]);
 sl-=o;
 if(sl<1)   {   httpheader->is_failed=YES;  return RET_YES; }
 bp++;     sl--;
 if(aaStringFindChar(bp,0,&o,SPACE_CHAR,NO,0,YES)!=YES) {  bp[60]=0; /* BUG,"line=%i  chars=%i  %s",__LINE__,chars,bp); */ httpheader->is_failed=YES; return RET_YES;  }
 bp+=o;    sl-=o;
 if(sl>=1900) {  aaNote(0,"sss sl=%i %s",sl,token[0]);  httpheader->is_failed=YES;aaStringLen(httpheader->data,&httpheader->data_bytes);return RET_YES; }
 aaStringNCopy(token[1],bp,sl,YES);
 aaStringCopy(httpheader->data,token[1]);
 aaStringLower(token[0],0,NULL);
 aaStringLen(token[0],&xl);
 if(xl>64)
  {
  return RET_NOTREADY;
  }
 aaStringCopy(httpheader->field,token[0]);
 aaStringIsIString(token[0],&which,"vary",         "accept-ranges", "location",      "p3p",           "x-aspnet-version",
                                   "x-powered-by", "expires",       "pragma",        "set-cookie",    "etag",
                                   "x-cache",      "cache-control", "content-type",  "last-modified", "server",
                                   "date",         "content-length","content-range", "connection",    "keep-alive",
                                   "host",         "cookie",        "cookie2",       "user-agent",    "accept-encoding",
                                   "accept-language", "accept-charset","transfer-encoding","referer", "accept",
                                   "If-Modified-Since","te","via","status",    "x-forwarded-for", "age","x-pad",
                                   "ua-os","ua-cpu","ua-pixels","ua-color","from","x-cache-lookup",
                                   "authorization",
                                   "content-transfer-encoding",
                                   "origin",
                                   "Access-Control-Request-Method",
                                   "Access-Control-Allow-Origin",
                                   "Content-Encoding","dnt","Upgrade-Insecure-Requests",
                                   NULL);

 if(which==-1)
  {
  aaStringCopy(httpheader->field,token[0]);
  aaStringCopy(httpheader->data,token[1]);
  httpheader->is_success=YES;
  httpheader->is_failed=NO;
  httpheader->field_code=aa_HTTPFIELD_UNIMPLEMENTED;
   aaStringLen(httpheader->data,&httpheader->data_bytes);
  return RET_YES;
  }

 which+=2;
 httpheader->field_code=which;

 if(which==aa_HTTPFIELD_CONTENTTYPE)
  {
  aaStringLen(httpheader->data,&ul);
  while(1)
   {
   aaStringFindFirstIString(httpheader->data,0,"application/x-www-form-urlencoded",0,&pos); if(pos!=0xffffffff) {  httpheader->value[0]=aa_HTTPFORM_URLENCODED; break; }
   aaStringFindFirstIString(httpheader->data,0,"multipart/form-data",0,&pos); if(pos!=0xffffffff) {  httpheader->value[0]=aa_HTTPFORM_MULTIPART; break; }
   aaStringFindFirstIString(httpheader->data,0,"text/plain",0,&pos); if(pos!=0xffffffff) { httpheader->value[0]=aa_HTTPFORM_PLAIN; break; }
   aaStringFindFirstIString(httpheader->data,0,"multipart/mixed",0,&pos); if(pos!=0xffffffff) {  httpheader->value[0]=aa_HTTPFORM_MULTIPARTMIXED; break; }
   break;
   }
  if(httpheader->value[0]==aa_HTTPFORM_MULTIPART||httpheader->value[0]==aa_HTTPFORM_MULTIPARTMIXED)
   {
   aaStringFindFirstIString(httpheader->data,0,"boundary=",0,&pos);
   if(pos!=0xffffffff)
    {
    pos+=9;
    aaStringFindChar(&httpheader->data[pos],0,&off,SPACE_CHAR,YES,0,YES);
    if(off!=0xffffffff)
     {
     pos+=off;
     aaStringFindChar(&httpheader->data[pos],0,&off,SPACE_CHAR,NO,0,YES);
     if(off!=0xffffffff) pos+=off;
     }
    httpheader->value[1]=pos;
    aaStringLen(&httpheader->data[pos],&httpheader->value[2]);
    etc[0]=etc[1]='-';
    etc[2]=0;
    aaStringNCopy(&etc[2],&httpheader->data[httpheader->value[1]],httpheader->value[2],YES);
    aaMemoryFill(httpheader->data,ul,0);
    if(httpheader->value[0]==aa_HTTPFORM_MULTIPART) aaStringCopy(httpheader->data,"multipart/form-data");
    else  aaStringCopy(httpheader->data,"multipart/mixed");
    aaStringCopy(&httpheader->data[50],etc);
    httpheader->value[1]=50;
    httpheader->value[2]+=2;
    }
   }
  }
 else
 if(which==aa_HTTPFIELD_TE)
  {
  aaStringFindFirstIString(httpheader->data,0,"chunked",0,&pos); if(pos!=0xffffffff) { httpheader->value[0]=1;  }
  aaStringFindFirstIString(httpheader->data,0,"deflate",0,&pos); if(pos!=0xffffffff) { httpheader->value[1]=1;  }
  aaStringFindFirstIString(httpheader->data,0,"gzip",0,&pos); if(pos!=0xffffffff) { httpheader->value[2]=1;  }
  }
 else
 if(which==aa_HTTPFIELD_CONNECTION)
  {
  aaStringIsIString(token[1],(NP)&httpheader->value[0],"close","keep-alive",NULL);
  if((N)httpheader->value[0]!=-1) { httpheader->value[0]++; }
  if((N)httpheader->value[0]==-1)
   {
   while(1)
    {
    aaStringFindFirstIString(httpheader->data,0,"close",0,&pos); if(pos!=0xffffffff) { httpheader->value[0]=1; break; }
    aaStringFindFirstIString(httpheader->data,0,"keep-alive",0,&pos); if(pos!=0xffffffff) { httpheader->value[0]=2; break; }
    break;
    }
   }
  aaStringFindFirstIString(httpheader->data,0,"te",0,&pos);
  if(pos!=0xffffffff)
   {
   httpheader->value[1]=1;
   aaStringFindFirstIString(httpheader->data,0,"chunked",0,&pos);
   if(pos!=0xffffffff) { httpheader->value[2]=1; }
   }
  }
 else
 if(which==aa_HTTPFIELD_EXPIRES||which==aa_HTTPFIELD_LASTMODIFIED||which==aa_HTTPFIELD_DATE||which==aa_HTTPFIELD_IFMODIFIEDSINCE)
  {
  if(which==aa_HTTPFIELD_EXPIRES&&sl<10)
   {
   if(aaStringExplode(token[1],0,&se,SPACE_CHAR)==YES)
    {
    if(se.count==1&&(se.type[0]==1||se.type[0]==2))
     {
     aaStringCopy(httpheader->field,token[0]);
     aaStringCopy(httpheader->data,token[1]);
     httpheader->is_success=YES;
     httpheader->is_failed=NO;
     httpheader->field_code=aa_HTTPFIELD_UNIMPLEMENTED;
     aaStringLen(httpheader->data,&httpheader->data_bytes);
     return RET_YES;
     }
    }
   }
  if(aaTimeFromString(&httpheader->time,token[1])!=RET_YES)
   {
   httpheader->is_failed=YES;
   aaStringLen(httpheader->data,&httpheader->data_bytes);
   return RET_YES;
   }
  }
 else
 if(which==aa_HTTPFIELD_STATUS)
  {
  ret=aaStringCountNumbers(token[1],0,&o,YES);
  if(ret!=YES||o!=3)
   {
   httpheader->is_failed=YES;
   aaStringLen(httpheader->data,&httpheader->data_bytes);
   return RET_YES;
   }
  if(aaStringToNumber(token[1],0,&httpheader->value[0],NULL,0,0)!=RET_YES)
   {
   httpheader->is_failed=YES;
   aaStringLen(httpheader->data,&httpheader->data_bytes);
   return RET_YES;
   }
  }
 else
 if(which==aa_HTTPFIELD_CONTENTLENGTH)
  {
  if(aaStringIsNumerical(token[1],0,0,0)!=RET_YES)
   {
   httpheader->is_failed=YES;
   aaStringLen(httpheader->data,&httpheader->data_bytes);
   return RET_YES;
   }
  if(aaStringToNumber(token[1],0,&httpheader->value[0],&httpheader->value[1],0,0)!=RET_YES)
   {
   httpheader->is_failed=YES;
   aaStringLen(httpheader->data,&httpheader->data_bytes);
   return RET_YES;
   }
  }
 else
 if(which==aa_HTTPFIELD_KEEPALIVE)
  {
  if(aaStringIsNumerical(token[1],0,0,0)!=RET_YES)
   {
   httpheader->is_failed=YES;
   aaStringLen(httpheader->data,&httpheader->data_bytes);
   return RET_YES;
   }
  if(aaStringToNumber(token[1],0,&httpheader->value[0],&httpheader->value[1],0,0)!=RET_YES)
   {
   httpheader->is_failed=YES;
   aaStringLen(httpheader->data,&httpheader->data_bytes);
   return RET_YES;
   }
  httpheader->is_success=YES;
  return RET_YES;
  }
 else
 if(which==aa_HTTPFIELD_CONTENTRANGE)
  {
  aaCast(bp,BP,token[1]);
  aaStringLen(bp,&sl);
  aaStringFindFirstString(bp,0,"bytes ",6,&o);
  if(o==0xffffffff) {  httpheader->is_failed=YES; aaStringLen(httpheader->data,&httpheader->data_bytes); return RET_YES; }
  bp+=(o+6);      sl-=(o+6);
  if(sl<5) {  httpheader->is_failed=YES; aaStringLen(httpheader->data,&httpheader->data_bytes); return RET_YES; }
  aaStringFindChar(bp,sl,&o,'-',YES,0,YES);
  if(o==0xffffffff||o==0) {  httpheader->is_failed=YES; aaStringLen(httpheader->data,&httpheader->data_bytes);return RET_YES; }
  if(aaStringIsNumerical(bp,0,0,o)!=YES) {  httpheader->is_failed=YES;aaStringLen(httpheader->data,&httpheader->data_bytes);return RET_YES; }
  aaStringNCopy(token[2],bp,o,YES);
  if(aaStringToNumber(token[2],0,&httpheader->value[0],NULL,0,0)!=RET_YES)
   {

   httpheader->is_failed=YES;
   aaStringLen(httpheader->data,&httpheader->data_bytes);
   return RET_YES;
   }
  bp+=o;   sl-=o;
  if(sl<2) {  httpheader->is_failed=YES; aaStringLen(httpheader->data,&httpheader->data_bytes);return RET_YES; }
  bp++;  sl--;
  aaStringFindChar(bp,sl,&o,FSLASH_CHAR,YES,0,YES);
  if(o==0xffffffff||o==0) {  httpheader->is_failed=YES; aaStringLen(httpheader->data,&httpheader->data_bytes);return RET_YES; }
  aaStringNCopy(token[2],bp,o,YES);
  if(aaStringToNumber(token[2],0,&httpheader->value[1],NULL,0,0)!=RET_YES)
   {
   httpheader->is_failed=YES;
   aaStringLen(httpheader->data,&httpheader->data_bytes);
   return RET_YES;
   }
  bp+=o;  sl-=o;
  if(sl<2) {  httpheader->is_failed=YES; aaStringLen(httpheader->data,&httpheader->data_bytes);return RET_YES; }
  bp++;  sl--;
  aaStringCountNumbers(bp,sl,&count,YES);
  if(count<1) { /* BUG,"line=%i %i %i ",__LINE__,sl,count);*/ httpheader->is_failed=YES; aaStringLen(httpheader->data,&httpheader->data_bytes);return RET_YES; }
  aaStringNCopy(token[2],bp,count,YES);
  if(aaStringToNumber(token[2],0,&httpheader->value[2],NULL,0,0)!=RET_YES)
   {
   httpheader->is_failed=YES;
   aaStringLen(httpheader->data,&httpheader->data_bytes);
   return RET_YES;
   }
  }
 else
 if(which==aa_HTTPFIELD_TRANSFERENCODING)
  {
  aaCast(bp,BP,token[1]);
  aaStringLen(bp,&sl);
  if(aaStringFindFirstString(bp,0,"chunked",7,&o)==RET_YES)
   {
   if(o!=0xffffffff)
    {
    httpheader->value[0]=1;
    }
   }
  }
 else
 if(which==aa_HTTPFIELD_AUTHORIZATION)
  {
  }

 else
 if(which==aa_HTTPFIELD_REFERER)
  {
  aaCast(bp,BP,token[1]);
  aaStringLen(bp,&sl);
  if(sl>=sizeof(httpheader->data)) {  httpheader->is_failed=YES; }
  }
 else
 if(which==aa_HTTPFIELD_KEEPALIVE)
  {
  aaNote(0,"az  unhandled %s: %s %i %i",httpheader->field,httpheader->data,which,aa_HTTPFIELD_KEEPALIVE);
  }
 else
 if(which==aa_HTTPFIELD_CONXFERENCODING)
  {
  }
 else
 if(which==aa_HTTPFIELD_CONTENTENCODING)
  {
  aaStringFindFirstIString(httpheader->data,0,"deflate",0,&pos); if(pos!=0xffffffff) { httpheader->value[1]=1;  }
  aaStringFindFirstIString(httpheader->data,0,"gzip",0,&pos); if(pos!=0xffffffff) { httpheader->value[2]=1;  }
  }
 else
 if(which==aa_HTTPFIELD_DNT)
  {
  if(aaStringIsNumerical(token[1],0,0,0)!=RET_YES)
   {
   httpheader->is_failed=YES;
   aaStringLen(httpheader->data,&httpheader->data_bytes);
   return RET_YES;
   }
  if(aaStringToNumber(token[1],0,&httpheader->value[0],&httpheader->value[1],0,0)!=RET_YES)
   {
   httpheader->is_failed=YES;
   aaStringLen(httpheader->data,&httpheader->data_bytes);
   return RET_YES;
   }
  }
 else
 if(which==aa_HTTPFIELD_UPGRADEINSECREQS)
  {
  if(aaStringIsNumerical(token[1],0,0,0)!=RET_YES)
   {
   httpheader->is_failed=YES;
   aaStringLen(httpheader->data,&httpheader->data_bytes);
   return RET_YES;
   }
  if(aaStringToNumber(token[1],0,&httpheader->value[0],&httpheader->value[1],0,0)!=RET_YES)
   {
   httpheader->is_failed=YES;
   aaStringLen(httpheader->data,&httpheader->data_bytes);
   return RET_YES;
   }
  }




 httpheader->is_success=YES;
 aaStringLen(httpheader->data,&httpheader->data_bytes);
 return RET_YES;
 }





 B aaNetHttpRequestReadFromString      (_httprequest*httprequest,H bytes,VP str)
 {
 B txt[_4K],token[3][_2K];
 B etc[_4K];
 H chars,off,sl;
 N which;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(httprequest==NULL) { return RET_BADPARM; }
 httprequest->is_success=NO;
 httprequest->is_failed=NO;
 if(str==NULL) { return RET_BADPARM; }
 if(bytes==0) { aaStringLen(str,&bytes); }
 if(bytes==0) { return RET_BADPARM; }
 chars=bytes;
 aaStringCopy(txt,str);
 aaMemoryFill(httprequest,sizeof(_httprequest),0);
 if(chars>=1500) { /* BUG,"chars>=1500=%i",chars); */ httprequest->is_failed=YES; return RET_YES; }
 if(chars==0)
  {
  httprequest->is_success=YES;
  httprequest->is_failed=NO;
  httprequest->method=0;
  return RET_YES;
  }
 if(chars>1)
  {
  aaStringReplaceChar(txt,chars,HTAB_CHAR,SPACE_CHAR);
  aaStringRemoveMultipleSpaces(txt,chars,NO);
  aaStringLen(txt,&chars);
  }
 if(chars<14)
  {
  aaHistory(-1,"got here again");
  httprequest->is_failed=YES;
  httprequest->method=0;
  return RET_YES;
  }

 sl=chars;
 aaStringFindChar(txt,0,&off,SPACE_CHAR,NO,0,YES);
 if(off==0xffffffff) {  /*oof;*/ httprequest->is_failed=YES;  return RET_YES; }
 aaStringCopy(token[0],&txt[off]);
 sl-=off;
 aaStringFindChar(token[0],0,&off,SPACE_CHAR,YES,0,YES);
 if(off==0xffffffff) {   /*oof;*/ httprequest->is_failed=YES;  return RET_YES; }
 aaStringCopy(etc,&token[0][off]);
 token[0][off]=NULL_CHAR;


 aaStringLen(etc,&sl);
 aaStringFindChar(etc,0,&off,SPACE_CHAR,NO,0,YES);
 if(off==0xffffffff) { oof; httprequest->is_failed=YES;  return RET_YES; }
 aaStringCopy(token[1],&etc[off]);
 sl-=off;
 aaStringFindChar(token[1],0,&off,SPACE_CHAR,YES,0,YES);
 if(off==0xffffffff) {  /* BUG,"******\nciii %i \n*********",__LINE__); */ httprequest->is_failed=YES;  return RET_YES; }
 aaStringCopy(etc,&token[1][off]);
 token[1][off]=NULL_CHAR;

 aaStringLen(etc,&sl);
 aaStringFindChar(etc,0,&off,SPACE_CHAR,NO,0,YES);
 if(off==0xffffffff) { oof; httprequest->is_failed=YES;  return RET_YES; }
 aaStringCopy(token[2],&etc[off]);

 aaStringIsIString(token[0],&which,"get","head","post","put","trace","delete","options","connect",NULL);
 if(which==-1)
  {
  httprequest->is_failed=YES;
  httprequest->method=0;
  return RET_FAILED;
  }
 httprequest->method=(B)(which+1);

 aaStringIsIString(token[2],&which,"HTTP/0.9","HTTP/1.0","HTTP/1.1","HTTP/1.2",NULL);
 if(which==-1) { /* BUG,"******\ndiii %s %i \n*********",token[2],__LINE__); */ httprequest->is_failed=YES; return RET_YES; }
 if(which==0) { httprequest->version[0]=0; httprequest->version[1]=9; }
 else
 if(which==1) { httprequest->version[0]=1; httprequest->version[1]=0; }
 else
 if(which==2) { httprequest->version[0]=1; httprequest->version[1]=1; }
 else
 if(which==3) { httprequest->version[0]=1; httprequest->version[1]=2; }

 aaStringCopy(httprequest->url,token[1]);
 if(aaStringNICompare(httprequest->url,"http://",7,0)==YES)
  {
  aaStringFindChar(httprequest->url,0,&off,FSLASH_CHAR,YES,2,YES);
  if(off!=0xffffffff)
   {
   aaStringDeleteChars(httprequest->url,0,0,off);
   }
  }
 aaStringLen(httprequest->url,&httprequest->url_chars);
 httprequest->is_success=YES;
 return RET_YES;
 }


/*-----------------------------------------------------------------------*/





 B aaNetHttpRequestWrite               (H tcpcallhandle,VP host,VP path,H start,H end,B condtype,_systime*condtime,B head,N cache,B close,VP fmt,...)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 B txt[_4K],dot[129],str[_1K];
 _systime st;
 BP bp;
 va_list argptr;
 B etc[_8K];


 aaFmt(fmt,argptr,etc);
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,tcpcallhandle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(condtime!=NULL&&(condtype<aa_HTTPCONDTYPE_IFMODSINCE||condtype>aa_HTTPCONDTYPE_IFRANGE)) { return RET_BADPARM; }
 if(condtime!=NULL)
  {
  if(aaTimeIsValid(condtime)!=RET_YES) {  return RET_BADPARM;   }
  }
 aaStringNull(txt);
 if(path==NULL)        {  aaStringAppendf(txt,"%s / HTTP/1.1\r\n",(head)?"HEAD":"GET");  }
 else
  {
  aaCast(bp,BP,path);
  if(bp[0]==NULL_CHAR) {  aaStringAppendf(txt,"%s / HTTP/1.1\r\n",(head)?"HEAD":"GET"); }
  else                 {  aaStringAppendf(txt,"%s %s HTTP/1.1\r\n",(head)?"HEAD":"GET",path); }
  }

 if(host==NULL)
  {
  aaNetIpToString(calp->status.remote_adr.ip,dot);
  if(calp->status.remote_adr.port!=80) { aaStringAppendf(txt,"Host: %s:%i\r\n",dot,calp->status.remote_adr.port); }
  else                                 { aaStringAppendf(txt,"Host: %s\r\n",dot); }
  }
 else                                     { aaStringAppendf(txt,"Host: %s\r\n",host);  }
 aaStringAppendf(txt,"Accept: */*\r\n");
 aaTimeSystemGet(&st);
 aaTimeToString(&st,str,"GMT",0);
 aaStringAppendf(txt,"Date: %s\r\n",str);

 if(condtime)
  {
  aaTimeToString(condtime,str,"GMT",0);
  if(condtype==aa_HTTPCONDTYPE_IFMODSINCE) {  aaStringAppendf(txt,"If-Modified-Since: %s\r\n",str); }
  else
  if(condtype==aa_HTTPCONDTYPE_IFRANGE)    {  aaStringAppendf(txt,"If-Range: %s\r\n",str);  }
  }
 if(start!=0xffffffff&&end==0xffffffff) { aaStringAppendf(txt,"Range: bytes=%i-\r\n",start); }
 else
 if(start==0xffffffff&&end!=0xffffffff) { aaStringAppendf(txt,"Range: bytes=-%i\r\n",end); }
 else
 if(start==0xffffffff&&end==0xffffffff) {  }
 else                         { aaStringAppendf(txt,"Range: bytes=%i-%i\r\n",start,end); }
 aaStringAppendf(txt,"User-agent: Mozilla/5.0 (Windows NT 6.0; rv:6.0) Gecko/20100101 Firefox/6.0\r\n");

 #if 0
 if(aa.net_system.local_email_checked!=YES) {  aa_NetSystemLocalEmailCheck();  }
 for(i=0;i<aa.net_system.local_email_count;i++)
  {
  if(aa.net_system.local_email[i][0]!=NULL_CHAR)
   {
   aaStringAppendf(txt,"x-htv-usermail-%02i: %s\r\n",i,aa.net_system.local_email[i]);
   }
  }
 #endif
 if(cache>0)  {  aaStringAppendf(txt,"Cache-Control: no-cache, private, no-store; must-revalidate\r\nPragma: no-cache\r\nExpires: %ld\r\n",cache);  }
 else
 if(cache<0)       {  aaStringAppendf(txt,"Cache-Control: public; max-age=%ld\r\nPragma: public\r\n",cache);  }

 if(aaStringIsNull(etc)==NO) { aaStringAppendf(txt,"%s",etc); }
 if(close==YES) {  aaStringAppendf(txt,"Connection: close\r\n"); }
 else
 if(close==NO)  {  aaStringAppendf(txt,"Connection: Keep-Alive\r\n"); }
 aaStringAppendf(txt,"\r\n");
 if((ret=aaNetTcpCallWritef(tcpcallhandle,"%s",txt))!=RET_YES) { return ret; }


 return RET_YES;
 }







 B aaNetHttpResultRead                 (H tcpcallhandle,_httpresult*httpresult)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 H chars,val;
 B txt[_2K],token[2][_2K],mo;
 N which;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,tcpcallhandle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(httpresult==NULL) { return RET_BADPARM; }
 httpresult->is_success=NO;
 httpresult->is_failed=NO;

 if((ret=aaNetTcpCallStringLen(tcpcallhandle,&chars,&mo))!=RET_YES)  {  return ret;  }
 aaMemoryFill(httpresult,sizeof(_httpresult),0);
 if(chars>512) { httpresult->is_failed=YES; return RET_YES; }
 if((ret=aaNetTcpCallRead(tcpcallhandle,chars,txt))!=YES) { oops; }
 if(mo==aa_STRINGMODE_CR)
  {
  if(chars<1) { oof; }
  if(txt[chars-1]!=CR_CHAR) { oof; }
  chars-=1;
  txt[chars]=0;
  }
 else
 if(mo==aa_STRINGMODE_LF)
  {
  if(chars<1) { oof; }
  if(txt[chars-1]!=LF_CHAR) { oof; }
  chars-=1;
  txt[chars]=0;
  }
 else
 if(mo==aa_STRINGMODE_CRLF)
  {
  if(chars<2) { oof; }
  if(txt[chars-2]!=CR_CHAR) { oof; }
  if(txt[chars-1]!=LF_CHAR) { oof; }
  chars-=2;
  txt[chars]=0;
  }
 else
  {
  oof;
  }
 if(chars>1)
  {
  aaStringReplaceChar(txt,chars,HTAB_CHAR,SPACE_CHAR);
  aaStringRemoveMultipleSpaces(txt,chars,NO);
  aaStringLen(txt,&chars);
  }
 if(chars<12) {      httpresult->is_failed=YES; return RET_YES; }
 if(txt[8]!=SPACE_CHAR) {  httpresult->is_failed=YES; return RET_YES; }
 if(txt[12]!=SPACE_CHAR) {  httpresult->is_failed=YES; return RET_YES; }
 if(aaStringIsNumerical(&txt[9],0,0,3)!=RET_YES)  { httpresult->is_failed=YES;  return RET_YES; }
 aaStringNCopy(&token[0],&txt[0],8,YES);
 aaStringNCopy(&token[1],&txt[9],3,YES);
 aaStringLower(token[0],0,NULL);
 aaStringIsIString(token[0],&which,"HTTP/0.9","HTTP/1.0","HTTP/1.1","HTTP/1.2",NULL);
 if(which==-1) { httpresult->is_failed=YES; return RET_YES; }
 httpresult->is_failed=NO;
 if(which==0) { httpresult->version[0]=0; httpresult->version[1]=9; }
 else
 if(which==1) { httpresult->version[0]=1; httpresult->version[1]=0; }
 else
 if(which==2) { httpresult->version[0]=1; httpresult->version[1]=1; }
 else
 if(which==3) { httpresult->version[0]=1; httpresult->version[1]=2; }
 aaStringToNumber(token[1],3,&val,NULL,0,0);
 httpresult->code=val;
 httpresult->is_success=YES;
 return RET_YES;
 }





 B aaNetHttpResultWrite                (H tcpcallhandle,H code,VP fmt,...)
 {
 va_list argptr;
 B str[_8K];
 B txt[_8K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,str);
 if(code<100||code>999) { return RET_BADPARM; }
 aaStringCopyf(txt,"HTTP/1.1 %i %s\r\n",code,str);
 return(aaNetTcpCallWritef(tcpcallhandle,"%s",txt));
 }







 B aaNetHttpHeaderRead                 (H tcpcallhandle,_httpheader*httpheader)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 H chars,sl,o,count;
 B txt[_4K],token[3][_3K];
 B etc[_2K],mo;
 N which;
 H pos,off,xl,ul;
 BP bp;
 _stringexplode se;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,tcpcallhandle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(httpheader==NULL) { return RET_BADPARM; }

 httpheader->field_code=0;
 httpheader->field[0]=NULL_CHAR;
 httpheader->data[0]=NULL_CHAR;
 httpheader->value[0]=0xffffffff;
 httpheader->value[1]=0xffffffff;
 httpheader->value[2]=0xffffffff;
 httpheader->is_success=NO;
 httpheader->is_failed=NO;
 httpheader->bytes=0;
 aaTimeNull(&httpheader->time);
 httpheader->data_bytes=0;

 if((ret=aaNetTcpCallStringRead(tcpcallhandle,&chars,&mo,_2K,txt))!=YES)
  {
  if(ret==RET_NOTREADY) { return ret; }
  oof;
  return ret;
  }
 httpheader->bytes=chars;
 if(chars==0)  {  httpheader->is_success=YES;  httpheader->is_failed=NO;  httpheader->field_code=aa_HTTPFIELD_BLANK;  return RET_YES;  }
 if(chars>1)   {  aaStringReplaceChar(txt,chars,HTAB_CHAR,SPACE_CHAR);  aaStringRemoveMultipleSpaces(txt,chars,NO);  aaStringLen(txt,&chars);  }
 sl=chars;
 if(aaStringFindChar(txt,0,&o,':',YES,0,YES)!=YES) {  /* BUG,"a %i %s",sl,txt); */ httpheader->is_failed=YES;  return RET_YES; }
 if(o>64) {  return RET_NOTREADY; }
 aaStringNCopy(token[0],&txt[0],o,YES);
 aaCast(bp,BP,&txt[o]);
 sl-=o;
 if(sl<1)   {   httpheader->is_failed=YES;  return RET_YES; }
 bp++;     sl--;
 if(aaStringFindChar(bp,0,&o,SPACE_CHAR,NO,0,YES)!=YES) {  bp[60]=0; /* BUG,"line=%i  chars=%i  %s",__LINE__,chars,bp); */ httpheader->is_failed=YES; return RET_YES;  }
 bp+=o;    sl-=o;
 if(sl>=1900) {  aaNote(0,"sss sl=%i %s",sl,token[0]);  httpheader->is_failed=YES;aaStringLen(httpheader->data,&httpheader->data_bytes);return RET_YES; }
 aaStringNCopy(token[1],bp,sl,YES);
 aaStringCopy(httpheader->data,token[1]);
 aaStringLower(token[0],0,NULL);
 aaStringLen(token[0],&xl);
 if(xl>64)
  {
  return RET_NOTREADY;
  }
 aaStringCopy(httpheader->field,token[0]);
 aaStringIsIString(token[0],&which,"vary",         "accept-ranges", "location",      "p3p",           "x-aspnet-version",
                                   "x-powered-by", "expires",       "pragma",        "set-cookie",    "etag",
                                   "x-cache",      "cache-control", "content-type",  "last-modified", "server",
                                   "date",         "content-length","content-range", "connection",    "keep-alive",
                                   "host",         "cookie",        "cookie2",       "user-agent",    "accept-encoding",
                                   "accept-language", "accept-charset","transfer-encoding","referer", "accept",
                                   "If-Modified-Since","te","via","status",    "x-forwarded-for", "age","x-pad",
                                   "ua-os","ua-cpu","ua-pixels","ua-color","from","x-cache-lookup",
                                   "authorization",
                                   "content-transfer-encoding",
                                   "origin",
                                   "Access-Control-Request-Method",
                                   "Access-Control-Allow-Origin",
                                   "Content-Encoding","dnt","Upgrade-Insecure-Requests",
                                   NULL);

 if(which==-1)
  {
  aaStringCopy(httpheader->field,token[0]);
  aaStringCopy(httpheader->data,token[1]);
  httpheader->is_success=YES;
  httpheader->is_failed=NO;
  httpheader->field_code=aa_HTTPFIELD_UNIMPLEMENTED;
   aaStringLen(httpheader->data,&httpheader->data_bytes);
  return RET_YES;
  }

 which+=2;
 httpheader->field_code=which;

 if(which==aa_HTTPFIELD_CONTENTTYPE)
  {
  aaStringLen(httpheader->data,&ul);
  while(1)
   {
   aaStringFindFirstIString(httpheader->data,0,"application/x-www-form-urlencoded",0,&pos); if(pos!=0xffffffff) {  httpheader->value[0]=aa_HTTPFORM_URLENCODED; break; }
   aaStringFindFirstIString(httpheader->data,0,"multipart/form-data",0,&pos); if(pos!=0xffffffff) {  httpheader->value[0]=aa_HTTPFORM_MULTIPART; break; }
   aaStringFindFirstIString(httpheader->data,0,"text/plain",0,&pos); if(pos!=0xffffffff) { httpheader->value[0]=aa_HTTPFORM_PLAIN; break; }
   aaStringFindFirstIString(httpheader->data,0,"multipart/mixed",0,&pos); if(pos!=0xffffffff) {  httpheader->value[0]=aa_HTTPFORM_MULTIPARTMIXED; break; }
   break;
   }
  if(httpheader->value[0]==aa_HTTPFORM_MULTIPART||httpheader->value[0]==aa_HTTPFORM_MULTIPARTMIXED)
   {
   aaStringFindFirstIString(httpheader->data,0,"boundary=",0,&pos);
   if(pos!=0xffffffff)
    {
    pos+=9;
    aaStringFindChar(&httpheader->data[pos],0,&off,SPACE_CHAR,YES,0,YES);
    if(off!=0xffffffff)
     {
     pos+=off;
     aaStringFindChar(&httpheader->data[pos],0,&off,SPACE_CHAR,NO,0,YES);
     if(off!=0xffffffff) pos+=off;
     }
    httpheader->value[1]=pos;
    aaStringLen(&httpheader->data[pos],&httpheader->value[2]);
    etc[0]=etc[1]='-';
    etc[2]=0;
    aaStringNCopy(&etc[2],&httpheader->data[httpheader->value[1]],httpheader->value[2],YES);
    aaMemoryFill(httpheader->data,ul,0);
    if(httpheader->value[0]==aa_HTTPFORM_MULTIPART) aaStringCopy(httpheader->data,"multipart/form-data");
    else  aaStringCopy(httpheader->data,"multipart/mixed");
    aaStringCopy(&httpheader->data[50],etc);
    httpheader->value[1]=50;
    httpheader->value[2]+=2;
    }
   }
  }
 else
 if(which==aa_HTTPFIELD_TE)
  {
  aaStringFindFirstIString(httpheader->data,0,"chunked",0,&pos); if(pos!=0xffffffff) { httpheader->value[0]=1;  }
  aaStringFindFirstIString(httpheader->data,0,"deflate",0,&pos); if(pos!=0xffffffff) { httpheader->value[1]=1;  }
  aaStringFindFirstIString(httpheader->data,0,"gzip",0,&pos); if(pos!=0xffffffff) { httpheader->value[2]=1;  }
  }
 else
 if(which==aa_HTTPFIELD_CONNECTION)
  {
  aaStringIsIString(token[1],(NP)&httpheader->value[0],"close","keep-alive",NULL);
  if((N)httpheader->value[0]!=-1) { httpheader->value[0]++; }
  if((N)httpheader->value[0]==-1)
   {
   while(1)
    {
    aaStringFindFirstIString(httpheader->data,0,"close",0,&pos); if(pos!=0xffffffff) { httpheader->value[0]=1; break; }
    aaStringFindFirstIString(httpheader->data,0,"keep-alive",0,&pos); if(pos!=0xffffffff) { httpheader->value[0]=2; break; }
    break;
    }
   }
  aaStringFindFirstIString(httpheader->data,0,"te",0,&pos);
  if(pos!=0xffffffff)
   {
   httpheader->value[1]=1;
   aaStringFindFirstIString(httpheader->data,0,"chunked",0,&pos);
   if(pos!=0xffffffff) { httpheader->value[2]=1; }
   }
  }
 else
 if(which==aa_HTTPFIELD_EXPIRES||which==aa_HTTPFIELD_LASTMODIFIED||which==aa_HTTPFIELD_DATE||which==aa_HTTPFIELD_IFMODIFIEDSINCE)
  {
  if(which==aa_HTTPFIELD_EXPIRES&&sl<10)
   {
   if(aaStringExplode(token[1],0,&se,SPACE_CHAR)==YES)
    {
    if(se.count==1&&(se.type[0]==1||se.type[0]==2))
     {
     aaStringCopy(httpheader->field,token[0]);
     aaStringCopy(httpheader->data,token[1]);
     httpheader->is_success=YES;
     httpheader->is_failed=NO;
     httpheader->field_code=aa_HTTPFIELD_UNIMPLEMENTED;
     aaStringLen(httpheader->data,&httpheader->data_bytes);
     return RET_YES;
     }
    }
   }
  if(aaTimeFromString(&httpheader->time,token[1])!=RET_YES)
   {
   httpheader->is_failed=YES;
   aaStringLen(httpheader->data,&httpheader->data_bytes);
   return RET_YES;
   }
  }
 else
 if(which==aa_HTTPFIELD_STATUS)
  {
  ret=aaStringCountNumbers(token[1],0,&o,YES);
  if(ret!=YES||o!=3)
   {
   httpheader->is_failed=YES;
   aaStringLen(httpheader->data,&httpheader->data_bytes);
   return RET_YES;
   }
  if(aaStringToNumber(token[1],0,&httpheader->value[0],NULL,0,0)!=RET_YES)
   {
   httpheader->is_failed=YES;
   aaStringLen(httpheader->data,&httpheader->data_bytes);
   return RET_YES;
   }
  }
 else
 if(which==aa_HTTPFIELD_CONTENTLENGTH)
  {
  if(aaStringIsNumerical(token[1],0,0,0)!=RET_YES)
   {
   httpheader->is_failed=YES;
   aaStringLen(httpheader->data,&httpheader->data_bytes);
   return RET_YES;
   }
  if(aaStringToNumber(token[1],0,&httpheader->value[0],&httpheader->value[1],0,0)!=RET_YES)
   {
   httpheader->is_failed=YES;
   aaStringLen(httpheader->data,&httpheader->data_bytes);
   return RET_YES;
   }
  }
 else
 if(which==aa_HTTPFIELD_KEEPALIVE)
  {
  if(aaStringIsNumerical(token[1],0,0,0)!=RET_YES)
   {
   httpheader->is_failed=YES;
   aaStringLen(httpheader->data,&httpheader->data_bytes);
   return RET_YES;
   }
  if(aaStringToNumber(token[1],0,&httpheader->value[0],&httpheader->value[1],0,0)!=RET_YES)
   {
   httpheader->is_failed=YES;
   aaStringLen(httpheader->data,&httpheader->data_bytes);
   return RET_YES;
   }
  httpheader->is_success=YES;
  return RET_YES;
  }
 else
 if(which==aa_HTTPFIELD_CONTENTRANGE)
  {
  aaCast(bp,BP,token[1]);
  aaStringLen(bp,&sl);
  aaStringFindFirstString(bp,0,"bytes ",6,&o);
  if(o==0xffffffff) { httpheader->is_failed=YES; aaStringLen(httpheader->data,&httpheader->data_bytes); return RET_YES; }
  bp+=(o+6);      sl-=(o+6);
  if(sl<5) {  httpheader->is_failed=YES; aaStringLen(httpheader->data,&httpheader->data_bytes); return RET_YES; }
  aaStringFindChar(bp,sl,&o,'-',YES,0,YES);
  if(o==0xffffffff||o==0) {  httpheader->is_failed=YES; aaStringLen(httpheader->data,&httpheader->data_bytes);return RET_YES; }
  if(aaStringIsNumerical(bp,0,0,o)!=YES) {  httpheader->is_failed=YES;aaStringLen(httpheader->data,&httpheader->data_bytes);return RET_YES; }
  aaStringNCopy(token[2],bp,o,YES);
  if(aaStringToNumber(token[2],0,&httpheader->value[0],NULL,0,0)!=RET_YES)
   {
   httpheader->is_failed=YES;
   aaStringLen(httpheader->data,&httpheader->data_bytes);
   return RET_YES;
   }
  bp+=o;   sl-=o;
  if(sl<2) {  httpheader->is_failed=YES; aaStringLen(httpheader->data,&httpheader->data_bytes);return RET_YES; }
  bp++;  sl--;
  aaStringFindChar(bp,sl,&o,FSLASH_CHAR,YES,0,YES);
  if(o==0xffffffff||o==0) {  httpheader->is_failed=YES; aaStringLen(httpheader->data,&httpheader->data_bytes);return RET_YES; }
  aaStringNCopy(token[2],bp,o,YES);
  if(aaStringToNumber(token[2],0,&httpheader->value[1],NULL,0,0)!=RET_YES)
   {
   httpheader->is_failed=YES;
   aaStringLen(httpheader->data,&httpheader->data_bytes);
   return RET_YES;
   }
  bp+=o;  sl-=o;
  if(sl<2) { httpheader->is_failed=YES; aaStringLen(httpheader->data,&httpheader->data_bytes);return RET_YES; }
  bp++;  sl--;
  aaStringCountNumbers(bp,sl,&count,YES);
  if(count<1) { /* BUG,"line=%i %i %i ",__LINE__,sl,count);*/ httpheader->is_failed=YES; aaStringLen(httpheader->data,&httpheader->data_bytes);return RET_YES; }
  aaStringNCopy(token[2],bp,count,YES);
  if(aaStringToNumber(token[2],0,&httpheader->value[2],NULL,0,0)!=RET_YES)
   {
   httpheader->is_failed=YES;
   aaStringLen(httpheader->data,&httpheader->data_bytes);
   return RET_YES;
   }
  }
 else
 if(which==aa_HTTPFIELD_TRANSFERENCODING)
  {
  aaCast(bp,BP,token[1]);
  aaStringLen(bp,&sl);
  if(aaStringFindFirstString(bp,0,"chunked",7,&o)==RET_YES)
   {
   if(o!=0xffffffff)
    {
    httpheader->value[0]=1;
    }
   }
  }
 else
 if(which==aa_HTTPFIELD_AUTHORIZATION)
  {
  }

 else
 if(which==aa_HTTPFIELD_REFERER)
  {
  aaCast(bp,BP,token[1]);
  aaStringLen(bp,&sl);
  if(sl>=sizeof(httpheader->data)) {  httpheader->is_failed=YES; }
  }
 else
 if(which==aa_HTTPFIELD_KEEPALIVE)
  {
  aaNote(0,"az  unhandled %s: %s %i %i",httpheader->field,httpheader->data,which,aa_HTTPFIELD_KEEPALIVE);
  }
 else
 if(which==aa_HTTPFIELD_CONXFERENCODING)
  {
  }
 else
 if(which==aa_HTTPFIELD_CONTENTENCODING)
  {
  aaStringFindFirstIString(httpheader->data,0,"deflate",0,&pos); if(pos!=0xffffffff) { httpheader->value[1]=1;  }
  aaStringFindFirstIString(httpheader->data,0,"gzip",0,&pos); if(pos!=0xffffffff) { httpheader->value[2]=1;  }
  }
 else
 if(which==aa_HTTPFIELD_DNT)
  {
  if(aaStringIsNumerical(token[1],0,0,0)!=RET_YES)
   {
   httpheader->is_failed=YES;
   aaStringLen(httpheader->data,&httpheader->data_bytes);
   return RET_YES;
   }
  if(aaStringToNumber(token[1],0,&httpheader->value[0],&httpheader->value[1],0,0)!=RET_YES)
   {
   httpheader->is_failed=YES;
   aaStringLen(httpheader->data,&httpheader->data_bytes);
   return RET_YES;
   }
  }
 else
 if(which==aa_HTTPFIELD_UPGRADEINSECREQS)
  {
  if(aaStringIsNumerical(token[1],0,0,0)!=RET_YES)
   {
   httpheader->is_failed=YES;
   aaStringLen(httpheader->data,&httpheader->data_bytes);
   return RET_YES;
   }
  if(aaStringToNumber(token[1],0,&httpheader->value[0],&httpheader->value[1],0,0)!=RET_YES)
   {
   httpheader->is_failed=YES;
   aaStringLen(httpheader->data,&httpheader->data_bytes);
   return RET_YES;
   }
  }



 httpheader->is_success=YES;
 aaStringLen(httpheader->data,&httpheader->data_bytes);
 return RET_YES;
 }






 B aaNetHttpRequestRead                (H tcpcallhandle,_httprequest*httprequest)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 B txt[_4K],token[3][_2K];
 B etc[_4K],mo;
 H chars,off,sl;
 N which;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,tcpcallhandle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(httprequest==NULL) { return RET_BADPARM; }

 httprequest->is_success=NO;
 httprequest->is_failed=NO;
 if((ret=aaNetTcpCallStringLen(tcpcallhandle,&chars,&mo))!=RET_YES)
  {
  return ret;
  }
 aaMemoryFill(httprequest,sizeof(_httprequest),0);
 if(chars>=1500) { /* BUG,"chars>=1500=%i",chars); */ httprequest->is_failed=YES; return RET_YES; }
 aaNetTcpCallRead(tcpcallhandle,chars,txt);
  if(mo==aa_STRINGMODE_CR)
  {
  if(chars<1) { oof; }
  if(txt[chars-1]!=CR_CHAR) { oof; }
  chars-=1;
  txt[chars]=0;
  }
 else
 if(mo==aa_STRINGMODE_LF)
  {
  if(chars<1) { oof; }
  if(txt[chars-1]!=LF_CHAR) { oof; }
  chars-=1;
  txt[chars]=0;
  }
 else
 if(mo==aa_STRINGMODE_CRLF)
  {
  if(chars<2) { oof; }
  if(txt[chars-2]!=CR_CHAR) { oof; }
  if(txt[chars-1]!=LF_CHAR) { oof; }
  chars-=2;
  txt[chars]=0;
  }
 else
  {
  oof;
  }
 if(chars==0)
  {
  httprequest->is_success=YES;
  httprequest->is_failed=NO;
  httprequest->method=0;
  return RET_YES;
  }
 if(chars>1)
  {
  aaStringReplaceChar(txt,chars,HTAB_CHAR,SPACE_CHAR);
  aaStringRemoveMultipleSpaces(txt,chars,NO);
  aaStringLen(txt,&chars);
  }
 if(chars<14)
  {
  aaHistory(-1,"got here again");
  httprequest->is_failed=YES;
  httprequest->method=0;
  return RET_YES;
  }

 sl=chars;
 aaStringFindChar(txt,0,&off,SPACE_CHAR,NO,0,YES);
 if(off==0xffffffff) {  /*oof;*/ httprequest->is_failed=YES;  return RET_YES; }
 aaStringCopy(token[0],&txt[off]);
 sl-=off;
 aaStringFindChar(token[0],0,&off,SPACE_CHAR,YES,0,YES);
 if(off==0xffffffff) {   /*oof;*/ httprequest->is_failed=YES;  return RET_YES; }
 aaStringCopy(etc,&token[0][off]);
 token[0][off]=NULL_CHAR;
 aaStringLen(etc,&sl);
 aaStringFindChar(etc,0,&off,SPACE_CHAR,NO,0,YES);
 if(off==0xffffffff) { oof; httprequest->is_failed=YES;  return RET_YES; }
 aaStringCopy(token[1],&etc[off]);
 sl-=off;
 aaStringFindChar(token[1],0,&off,SPACE_CHAR,YES,0,YES);
 if(off==0xffffffff) {  /* BUG,"******\nciii %i \n*********",__LINE__); */ httprequest->is_failed=YES;  return RET_YES; }
 aaStringCopy(etc,&token[1][off]);
 token[1][off]=NULL_CHAR;
 aaStringLen(etc,&sl);
 aaStringFindChar(etc,0,&off,SPACE_CHAR,NO,0,YES);
 if(off==0xffffffff) { oof; httprequest->is_failed=YES;  return RET_YES; }
 aaStringCopy(token[2],&etc[off]);
 aaStringIsIString(token[0],&which,"get","head","post","put","trace","delete","options","connect",NULL);
 if(which==-1)
  {
  httprequest->is_failed=YES;
  httprequest->method=0;
  return RET_FAILED;
  }
 httprequest->method=(B)(which+1);

 aaStringIsIString(token[2],&which,"HTTP/0.9","HTTP/1.0","HTTP/1.1","HTTP/1.2",NULL);
 if(which==-1) { /* BUG,"******\ndiii %s %i \n*********",token[2],__LINE__); */ httprequest->is_failed=YES; return RET_YES; }
 if(which==0) { httprequest->version[0]=0; httprequest->version[1]=9; }
 else
 if(which==1) { httprequest->version[0]=1; httprequest->version[1]=0; }
 else
 if(which==2) { httprequest->version[0]=1; httprequest->version[1]=1; }
 else
 if(which==3) { httprequest->version[0]=1; httprequest->version[1]=2; }

 aaStringCopy(httprequest->url,token[1]);
 if(aaStringNICompare(httprequest->url,"http://",7,0)==YES)
  {
  aaStringFindChar(httprequest->url,0,&off,FSLASH_CHAR,YES,2,YES);
  if(off!=0xffffffff)
   {
   aaStringDeleteChars(httprequest->url,0,0,off);
   }
  }
 aaStringLen(httprequest->url,&httprequest->url_chars);
 httprequest->is_success=YES;
 return RET_YES;
 }









 B aaNetHttpBasicAuthorizationWrite    (H tcpcallhandle,VP username,VP password)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 B str[_4K];
 H chars;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,tcpcallhandle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(username==NULL) { return RET_BADPARM; }
 if(password==NULL) { return RET_BADPARM; }
 if(aaStringIsNull(username)==YES) { return RET_BADPARM; }
 if(aaStringIsNull(password)==YES) { return RET_BADPARM; }
 aaStringCopyf(str,"%s:%s",username,password);
 aaBase64Encode(str,0,&str[_2K],&chars);
 ret=aaNetTcpCallWritef(tcpcallhandle,"Authorization: Basic %s\r\n",&str[_2K]);
 return ret;
 }





  // remember to put dashes between date, month, year -- not spaces

 B aaNetHttpCookieSet                  (H tcpcallhandle,VP domain,VP path,G expires,VP name,VP fmt,...)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 va_list argptr;
 B str[_4K];
 B txt[_1K];
 B tmp[_4K];
 BP bp;
 H i,sl;
 _systime st;
 B ascii;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,tmp);
 if(name==NULL) { return RET_BADPARM; }
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,tcpcallhandle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 aaCast(bp,BP,tmp);
 aaStringLen(bp,&sl);
 if(sl==0||sl>255) { return RET_BADPARM; }
 for(i=0;i<sl;i++) { if(bp[i]==';'||bp[i]==SPACE_CHAR||bp[i]==COMMA_CHAR) { return RET_FAILED; } }
 aaCast(bp,BP,name);
 aaStringLen(bp,&sl);
 if(sl==0||sl>255) { return RET_BADPARM; }
 for(i=0;i<sl;i++) { if(bp[i]==';'||bp[i]==SPACE_CHAR||bp[i]==COMMA_CHAR) { return RET_FAILED; } }
 if(path!=NULL)  {  aaStringLen(path,&sl); if(sl==0||sl>255) { return RET_BADPARM; }  }
 if(domain!=NULL)  {  aaStringLen(domain,&sl); if(sl==0||sl>255) { return RET_BADPARM; }  }
 if(expires!=-1)
  {
  aaTimeSystemGet(&st);
  aaTimeAdjust(&st,&st,expires);
  aaTimeToString(&st,txt,"GMT",0);
  txt[7]='-';
  txt[11]='-';
  }
 aaStringCopyf(str,"Set-Cookie: %s=%s;",name,tmp);
 if(domain!=NULL) {  aaStringAppendf(str," domain=%s;",domain); }
 if(path!=NULL)   {  aaStringAppendf(str," path=%s;",path); }
 if(expires!=-1)   { aaStringAppendf(str," expires=%s;",txt); }
 aaStringLastCharGet(str,0,&ascii); if(ascii==';') { aaStringLastCharSet(str,0,0,NO); }
 return(aaNetTcpCallWritef(tcpcallhandle,"%s\r\n",str));
 }



 B aaNetHttpChunkSizePeek              (H tcpcallhandle,HP bytes)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 H by,sz;
 B tmp[_1K];
 B mode;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bytes==NULL) { return RET_BADPARM; }
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,tcpcallhandle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if((ret=aaNetTcpCallStringPeek(tcpcallhandle,&by,&mode,sizeof(tmp),tmp))!=RET_YES) { return ret; }
 if(by>10) { return RET_CORRUPTED; }
 if(by==0) { return RET_NOTREADY; }
 aaStringHexToNumber(tmp,by,&sz,0,NULL,NULL);
 *bytes=sz;
 return ret;
 }



 B aaNetHttpChunkSizeRead              (H tcpcallhandle,HP bytes)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 H by,sz;
 B tmp[_1K];
 B mode;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bytes==NULL) { return RET_BADPARM; }
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,tcpcallhandle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if((ret=aaNetTcpCallStringRead(tcpcallhandle,&by,&mode,sizeof(tmp),tmp))!=RET_YES) { return ret; }
 if(by>10) { return RET_CORRUPTED; }
 if(by==0) { return RET_NOTREADY; }
 aaStringHexToNumber(tmp,by,&sz,0,NULL,NULL);
 *bytes=sz;
 return ret;
 }








 B aaNetHttpChunkSizeWrite             (H tcpcallhandle,H bytes)
 {
 B ret;
 _aa_nettcpcallobject*calp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,tcpcallhandle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 return(aaNetTcpCallWritef(tcpcallhandle,"%lx;\r\n",bytes));
 }





 B aaNetHttpChunkWritef                (H tcpcallhandle,VP fmt,...)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 va_list argptr;
 H bytes;
 B tmp[_8K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,tmp);
 aaStringLen(tmp,&bytes);
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,tcpcallhandle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if((ret=aaNetTcpCallWritef(tcpcallhandle,"%lx;\r\n%s\r\n",bytes,tmp))!=YES) { oops; }
 return RET_YES;
 }




 B aaNetHttpChunkWrite                 (H tcpcallhandle,H bytes,VP data)
 {
 B ret;
 _aa_nettcpcallobject*calp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bytes!=0&&data==NULL) { return RET_BADPARM; }
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,tcpcallhandle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(bytes==0&&data==NULL)
  {
  if((ret=aaNetTcpCallWritef(tcpcallhandle,"%lx;\r\n",bytes))!=YES) { oops; }
  if((ret=aaNetTcpCallWritef(tcpcallhandle,"\r\n"))!=YES) { oops; }
  return RET_YES;
  }
 if(bytes==0)  {  aaStringLen(data,&bytes);  }
 if((ret=aaNetTcpCallWritef(tcpcallhandle,"%lx;\r\n",bytes))!=YES) { oops; }
 if((ret=aaNetTcpCallWrite(tcpcallhandle,bytes,data))!=YES) { oops; }
 if((ret=aaNetTcpCallWritef(tcpcallhandle,"\r\n"))!=YES) { oops; }
 return RET_YES;
 }





/*-----------------------------------------------------------------------*/



 B aaNetSmtpResultRead                 (H tcpcallhandle,_smtpresult*smtpresult)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 H chars,s_code,off,len;
 B txt[_2K],s_txt[_4K],mo;
 _parser sp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,tcpcallhandle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(smtpresult==NULL) { return RET_BADPARM; }
 smtpresult->code=0;
 smtpresult->is_fold=NO;
 smtpresult->is_failed=NO;
 smtpresult->is_success=NO;
 aaStringNull(smtpresult->text);
 if((ret=aaNetTcpCallStringLen(tcpcallhandle,&chars,&mo))!=RET_YES)  {  return ret;  }
 if(chars>=_2K) { smtpresult->is_failed=YES; return RET_YES; }
 if((ret=aaNetTcpCallRead(tcpcallhandle,chars,txt))!=RET_YES) oops;

 if(mo==aa_STRINGMODE_CR)
  {
  if(chars<1) { oof; }
  if(txt[chars-1]!=CR_CHAR) { oof; }
  chars-=1;
  txt[chars]=0;
  }
 else
 if(mo==aa_STRINGMODE_LF)
  {
  if(chars<1) { oof; }
  if(txt[chars-1]!=LF_CHAR) { oof; }
  chars-=1;
  txt[chars]=0;
  }
 else
 if(mo==aa_STRINGMODE_CRLF)
  {
  if(chars<2) { oof; }
  if(txt[chars-2]!=CR_CHAR) { oof; }
  if(txt[chars-1]!=LF_CHAR) { oof; }
  chars-=2;
  txt[chars]=0;
  }
 else
  {
  oof;
  }
 if(chars>1)
  {
  aaStringReplaceChar(txt,chars,HTAB_CHAR,SPACE_CHAR);
  aaStringRemoveMultipleSpaces(txt,chars,NO);
  aaStringLen(txt,&chars);
  }
 s_code=0;
 aaStringNull(s_txt);

 aaParserInit(&sp,txt,chars);

 aaStringFindChar(sp.bp,sp.to_end,&off,SPACE_CHAR,NO,0,YES);
 if(off==0xffffffff) { smtpresult->is_failed=YES; return RET_YES; }
 aaParserSeek(&sp,off);
 aaStringCountNumbers(sp.bp,sp.to_end,&len,YES);
 if(len!=3) { smtpresult->is_failed=YES; return RET_YES; }
 aaStringToNumber(sp.bp,len,&s_code,NULL,0,0);
 if(s_code==0)
  {
  if(chars!=0)
   {
   if(chars>=_2K) { chars=_2K; }
   aaStringNCopy(smtpresult->text,txt,chars,YES);
   }
  smtpresult->is_failed=YES;
  return RET_YES;
  }
 smtpresult->code=s_code;
 aaParserSeek(&sp,3);
 if(*sp.bp=='-')
  {
  smtpresult->is_success=YES;
  smtpresult->is_fold=YES;
  smtpresult->is_failed=NO;
  aaStringCopy(smtpresult->text,sp.bp);
  return RET_YES;
  }
 aaStringFindChar(sp.bp,sp.to_end,&off,SPACE_CHAR,NO,0,YES);
 if(off!=0xffffffff)
  {
  aaParserSeek(&sp,off);
  if(*sp.bp>=33) { aaStringCopy(smtpresult->text,sp.bp); }
  }
 smtpresult->is_success=YES;
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/


 B aaNetTorResultRead                  (H tcpcallhandle,_torresult*torresult)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 H ch,count,val;
 B txt[_32K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,tcpcallhandle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(torresult==NULL) { return RET_BADPARM; }
 torresult->code=0;
 torresult->is_end=NO;
 torresult->is_fold=NO;
 torresult->is_multi=NO;
 torresult->is_failed=NO;
 torresult->is_success=NO;
 aaStringNull(torresult->text);
 if((ret=aaNetTcpCallStringRead(tcpcallhandle,&ch,0,sizeof(txt),txt))==RET_NOTREADY) { return ret; }
 if(ret!=RET_YES) { oops; }
 if(ch>=_2K) { torresult->is_failed=YES; return RET_YES; }
 aaStringNCopy(torresult->text,txt,ch,YES);
 if(ch==1&&txt[0]=='.')  { torresult->is_end=YES; }
 if(txt[3]=='-')         { torresult->is_fold=YES;  }  else
 if(txt[3]=='+')         { torresult->is_multi=YES; }  //else
 aaStringCountNumbers(txt,ch,&count,YES);
 if(count==3)
  {
  aaStringToNumber(txt,count,&val,0,0,0);
  torresult->code=val;
  }
 torresult->is_success=YES;
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/



 B aaNetFtpResultRead                  (H tcpcallhandle,_ftpresult*ftpresult)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 H chars,s_code,off,len,pos,cnt,i,val;
 B txt[_2K],s_txt[_4K],tok[_2K],mo;
 _parser sp,pa;
 BP byteptr;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,tcpcallhandle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(ftpresult==NULL) { return RET_BADPARM; }
 ftpresult->code=0;
 ftpresult->is_fold=NO;
 ftpresult->is_failed=NO;
 ftpresult->is_success=NO;
 ftpresult->pasv_adr.ip=0;
 ftpresult->pasv_adr.port=0;
 aaStringNull(ftpresult->text);
 ret=aaNetTcpCallStringRead(tcpcallhandle,&chars,&mo,sizeof(txt),txt);
 if(ret==RET_NOTREADY) { return ret; }
 if(ret!=YES) { oops; }
 if(chars>1)
  {
  aaStringReplaceChar(txt,chars,HTAB_CHAR,SPACE_CHAR);
  aaStringRemoveMultipleSpaces(txt,chars,NO);
  aaStringLen(txt,&chars);
  }
 if(txt[0]==SPACE_CHAR&&txt[1]==NULL_CHAR&&chars==1)
  {
  return RET_NOTREADY;
  }
 s_code=0;
 aaStringNull(s_txt);

 aaParserInit(&sp,txt,chars);
 if(chars!=0) { if(chars>=_2K) { chars=_2K; } aaStringNCopy(ftpresult->text,txt,chars,YES);   }
 aaStringFindChar(sp.bp,sp.to_end,&off,SPACE_CHAR,NO,0,YES);
 if(off==0xffffffff) { ftpresult->is_failed=YES; return RET_YES; }
 aaParserSeek(&sp,off);
 aaStringCountNumbers(sp.bp,sp.to_end,&len,YES);
 if(len!=3) { ftpresult->is_failed=YES; return RET_YES; }
 aaStringToNumber(sp.bp,len,&s_code,NULL,0,0);
 if(s_code==0)
  {
  ftpresult->is_failed=YES;
  return RET_YES;
  }
 ftpresult->code=s_code;
 aaParserSeek(&sp,3);
   if(ftpresult->code==227)
    {
    aaParserCopy(&pa,&sp,YES);
    if(aaStringFindChar(pa.bp,pa.to_end,&pos,'(',YES,0,YES)==YES)
     {
     aaParserSeek(&pa,pos);
     if(aaStringFindChar(pa.bp,pa.to_end,&pos,')',YES,0,YES)==YES)
      {
      aaStringNCopy(tok,pa.bp,pos+1,YES);
      tok[0]=tok[pos]=',';
      aaStringCountChars(tok,0,&cnt,',',NO,YES);
      if(cnt==7)
       {
       aaParserInit(&pa,tok,0);
       aaCast(byteptr,BP,&ftpresult->pasv_adr);
       for(i=0;i<6;i++)
        {
        if(aaStringFindChar(pa.bp,pa.to_end,&off,',',YES,i+0,YES)!=YES) { break; }
        if(aaStringFindChar(pa.bp,pa.to_end,&pos,',',YES,i+1,YES)!=YES) { break; }
        off++;
        len=(pos-off);
        if(len>=1&&len<=3)
         {
         aaStringCountNumbers(&pa.bp[off],len,&cnt,NO);
         if(len==cnt)
          {
          aaStringToNumber(&pa.bp[off],len,&val,0,0,0);
          byteptr[i]=(B)val;
          }
         }
        }
       if(i==6) { ftpresult->pasv_adr.port=(W)aaNumSwapWord(ftpresult->pasv_adr.port); }
       else     { aaNetAdrSet(&ftpresult->pasv_adr,0,0); }
       }
      }
     }
    }

 if(*sp.bp=='-')
  {
  ftpresult->is_success=YES;
  ftpresult->is_fold=YES;
  aaStringCopy(ftpresult->text,sp.bp);
  return RET_YES;
  }
 aaStringFindChar(sp.bp,sp.to_end,&off,SPACE_CHAR,NO,0,YES);
 if(off!=0xffffffff)
  {
  aaParserSeek(&sp,off);
  if(*sp.bp>=33) { aaStringCopy(ftpresult->text,sp.bp); }
  }
 ftpresult->is_success=YES;
 return RET_YES;
 }







 B aaNetFtpMlsdRead                    (H tcpcallhandle,_ftpmlsd*ftpmlsd)
 {
 B ret;
 H chars,i,pos,crc,sl,dw;
 B buf[_4K];
 _stringexplode sex;
 B txt[_4K],tok[_4K],key[_2K],val[_2K];
 N which;

 _aa_nettcpcallobject*calp;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,tcpcallhandle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(ftpmlsd==NULL) { return RET_BADPARM; }
 ftpmlsd->bytes=0;
 ftpmlsd->is_file=NO;
 ftpmlsd->is_dir=NO;
 ftpmlsd->is_parent_dir=NO;
 ftpmlsd->is_current_dir=NO;
 ftpmlsd->type=0;
 ftpmlsd->permission[0]=0;
 ftpmlsd->modified_string[0]=0;
 ftpmlsd->name[0]=0;
 aaTimeNull(&ftpmlsd->modified);
 if((ret=aaNetTcpCallStringRead(tcpcallhandle,&chars,0,sizeof(buf),buf))!=YES) { return ret; }
 if((ret=aaStringExplode(buf,chars,&sex,';'))!=YES) oops;
 for(i=0;i<sex.count;i++)
  {
  if(aaStringExplodeTokenGet(buf,i,&sex,txt)!=YES) continue;
  if(aaStringFindChar(txt,0,&pos,'=',YES,0,YES)==YES&&aaStringSplit(txt,0,pos,NO,&tok[0],&tok[_2K])==YES)
   {
   crc=0;
   aaStringCopyf(key,"%s",&tok[0]);
   aaStringCopyf(val,"%s",&tok[_2K]);
   aaStringHashGet(key,0,&crc,NO);
   if(crc==0x3165b05d)
    {
    aaStringIsIString(val,&which,"file","dir","cdir","pdir",NULL);
    if(which!=-1)
     {
     if(which==0) { ftpmlsd->is_file=YES; }
     else
     if(which==1) { ftpmlsd->is_dir=YES; }
     else
     if(which==2) { ftpmlsd->is_current_dir=YES; }
     else
     if(which==3) { ftpmlsd->is_parent_dir=YES; }
     ftpmlsd->type=(B)(which+1);      continue;
     }
    }
   else
   if(crc==0xc052dea7||crc==0x92e983d5)
    {
    aaStringToNumber(val,0,0,0,0,&ftpmlsd->bytes);
    continue;
    }
   else
   if(crc==0x346708ed)
    {
    aaStringLen(val,&sl);
    if(sl==14)
     {
     if(aaStringIsNumerical(val,0,0,sl)==YES)
      {
      aaStringToNumber(&val[0],4,&dw,0,0,0); ftpmlsd->modified.year=(W)dw;
      aaStringToNumber(&val[4],2,&dw,0,0,0); ftpmlsd->modified.month=(W)dw;
      aaStringToNumber(&val[6],2,&dw,0,0,0); ftpmlsd->modified.date=(W)dw;
      aaStringToNumber(&val[8],2,&dw,0,0,0); ftpmlsd->modified.hour=(W)dw;
      aaStringToNumber(&val[10],2,&dw,0,0,0); ftpmlsd->modified.minute=(W)dw;
      aaStringToNumber(&val[12],2,&dw,0,0,0); ftpmlsd->modified.second=(W)dw;
      }
     }
    continue;
    }
   continue;
   }
  aaStringRemoveSpaces(txt,0,YES,YES);
  aaStringCopyf(txt,"%s",txt);
  aaStringCopyf(ftpmlsd->name,"%s",txt);
  }
 aaTimeToString(&ftpmlsd->modified,ftpmlsd->modified_string,0,0);
 return RET_YES;
 }







 B aaNetRedisPacketRead                (H tcpcallhandle,BP type,GP arg,HP chars,H maxchars,VP buf)
 {
 B ret;
 _tcpcallstatus cs;
 H off,charss,also,need,hash;
 B buff[_4K];
 G gval;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(type) *type=0;
 if(arg) *arg=0;
 if(chars) *chars=0;
 if(buf) aaStringNull(buf);
 aaCast(bp,BP,buf);
 if((ret=aaNetTcpCallStatus(tcpcallhandle,&cs))!=YES) { return ret; }
 if((ret=aaNetTcpCallStringLook(tcpcallhandle,0,0,0,&off,&charss,0,sizeof(buff),buff))!=YES) { return ret; }
 if(charss==0) { oof; return RET_FAILED; }

 if(buff[0]=='+') ///===================================== STATUS
  {
  if(type) *type=aa_REDISTYPE_Status;
  if(buf)
   {
   also=charss-1;
   if(also>=maxchars) return RET_BOUNDS;
   aaMemoryCopy(bp,also,&buff[1]);
   bp[also]=NULL_CHAR;
   if(chars) *chars=also;
   }
  if(arg)
   {
   if((charss-1)==6) {    if(aaStringNCompare(&buff[1],"QUEUED",6,0)==YES) { *arg=aa_REDISARG_QUEUED; }    }
   else
   if((charss-1)==2) {    if(aaStringNCompare(&buff[1],"OK",2,0)==YES) { *arg=aa_REDISARG_OK; }    }
   }
  aaNetTcpCallStringDiscard(tcpcallhandle);
  return RET_YES;
  }
 if(buff[0]=='-') ///===================================== ERROR
  {
  if(type) *type=aa_REDISTYPE_Error;
  if(buf)
   {
   also=charss-1;
   if(also>=maxchars) return RET_BOUNDS;
   aaMemoryCopy(bp,also,&buff[1]);
   bp[also]=NULL_CHAR;
   if(chars) *chars=also;
   }
  aaNetTcpCallStringDiscard(tcpcallhandle);
  return RET_YES;
  }
 if(buff[0]==':') ///===================================== INTEGER
  {
  also=charss;
  if(buff[1]=='-') { also-=2; aaStringToNumber(&buff[2],0,0,0,&gval,0); gval=aaNumNeg(gval); }
  else             { also-=1; aaStringToNumber(&buff[1],0,0,0,&gval,0);  }
  if(type) *type=aa_REDISTYPE_Integer;
  if(arg) *arg=gval;
  aaNetTcpCallStringDiscard(tcpcallhandle);
  return RET_YES;
  }
 if(buff[0]=='$') ///===================================== BULK
  {
  if(buff[1]=='-') { aaStringToNumber(&buff[2],0,0,0,&gval,0); gval=aaNumNeg(gval); }
  else             { aaStringToNumber(&buff[1],0,0,0,&gval,0);  }
  need=off+charss+2;
  if(gval>=0) need+=gval;
  need+=2;
  if(cs.rcve_bytes<need) { return RET_NOTREADY;; }
  if(type) *type=aa_REDISTYPE_Bulk;
  if(gval>0) also=(H)gval;
  else       also=0;

  if(buf)   {   if(also>=maxchars) return RET_BOUNDS;   }
  if((aaNetTcpCallDiscard(tcpcallhandle,off+charss+2))!=YES) oof;
  if(buf)
   {
   if(also)
    {
    if((aaNetTcpCallRead(tcpcallhandle,also,bp))!=YES) oof;
    bp[also]=NULL_CHAR;
    if(arg)
     {
     hash=0;
     aaStringHashGet(bp,also,&hash,NO);
     *arg=hash;
     }
    if(chars) *chars=also;
    }
   }
  if((aaNetTcpCallDiscard(tcpcallhandle,2))!=YES) oof;
  return RET_YES;
  }
 if(buff[0]=='*') ///===================================== MULTI
  {
  if(buff[1]=='-') { aaStringToNumber(&buff[2],0,0,0,&gval,0); gval=aaNumNeg(gval); }
  else             { aaStringToNumber(&buff[1],0,0,0,&gval,0);  }
  if(type) *type=aa_REDISTYPE_Multi;
  if(arg) *arg=gval;
  if(aaNetTcpCallStringDiscard(tcpcallhandle)!=YES) oof;
  return RET_YES;
  }
 aaNote(0,"???  %i %i %s",off,charss,buff);
 return RET_FAILED;
 }





 B aaNetRedisPacketWritef              (H tcpcallhandle,VP fmt,...)
 {
 B ret;
 _tcpcallstatus cs;
 B str[_16K];
 B ascii;
 va_list argptr;
 _stringtokermini toker;
 H i,sl;
 B tok[_2K];
 B out[_16K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaNetTcpCallStatus(tcpcallhandle,&cs))!=YES) { return ret; }
 aaFmt(fmt,argptr,str);
 while(1)
  {
  aaStringLastCharGet(str,0,&ascii);
  if(ascii==NULL_CHAR) break;
  if(ascii==CR_CHAR) { aaStringLastCharSet(str,0,0,1); continue; }
  if(ascii==LF_CHAR) { aaStringLastCharSet(str,0,0,1); continue; }
  break;
  }
 if((ret=aaStringTokerMini(str,0,&toker))!=YES) { oops; }
 aaStringNull(out);
 aaStringAppendf(out,"*%i\r\n",toker.count);
 for(i=0;i<toker.count;i++)
  {
  if(toker.sl[i]>=sizeof(tok)) {  oof; }
  sl=toker.sl[i];
  aaStringNCopy(tok,&str[toker.off[i]],sl,YES);
  if(sl>=2)
   {
   if(tok[0]==DQUOTE_CHAR&&tok[sl-1]==DQUOTE_CHAR) { aaStringContract(tok,sl,1); sl-=2; }
   else
   if(tok[0]==SQUOTE_CHAR&&tok[sl-1]==SQUOTE_CHAR) { aaStringContract(tok,sl,1); sl-=2; }
   }
  aaStringAppendf(out,"$%i\r\n",sl);
  aaStringAppendf(out,"%s\r\n",tok);
  }
 if((ret=aaNetTcpCallWritef(tcpcallhandle,"%s\r\n",out))!=YES) { return ret; }
 return(aaNetTcpCallStatus(tcpcallhandle,0));
 }



 B aaNetRedisRespBegin                 (H tcpcallhandle,H elcount)
 {
 B ret;
 _tcpcallstatus cs;
 B out[_4K];
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaNetTcpCallStatus(tcpcallhandle,&cs))!=YES) { return ret; }
 aaStringCopyfLen(out,&sl,"*%u\r\n",elcount);
 if((ret=aaNetTcpCallWrite(tcpcallhandle,sl,out))!=YES) { return ret; }
 return(aaNetTcpCallStatus(tcpcallhandle,0));
 }


 B aaNetRedisRespBulkAppend            (H tcpcallhandle,H bytes,VP data)
 {
 B ret;
 _tcpcallstatus cs;
 B out[_4K];
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaNetTcpCallStatus(tcpcallhandle,&cs))!=YES) { return ret; }
 if(data!=NULL)
  {
  if(bytes==0) { aaStringLen(data,&bytes); }
  }
 aaStringCopyfLen(out,&sl,"$%u\r\n",bytes);
 if((ret=aaNetTcpCallWrite(tcpcallhandle,sl,out))!=YES) { return ret; }
 if(bytes)
  {
  if((ret=aaNetTcpCallWrite(tcpcallhandle,bytes,data))!=YES) { return ret; }
  aaStringCopyfLen(out,&sl,"\r\n");
  if((ret=aaNetTcpCallWrite(tcpcallhandle,sl,out))!=YES) { return ret; }
  }
 return(aaNetTcpCallStatus(tcpcallhandle,0));
 }




 B aaNetRedisRespBulkAppendf           (H tcpcallhandle,VP fmt,...)
 {
 B ret;
 B str[_4K];
 va_list argptr;
 _tcpcallstatus cs;
 B out[_4K];
 H sl,bytes;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,str);
 aaStringLen(str,&bytes);
 if((ret=aaNetTcpCallStatus(tcpcallhandle,&cs))!=YES) { return ret; }
 aaStringCopyfLen(out,&sl,"$%u\r\n",bytes);
 if((ret=aaNetTcpCallWrite(tcpcallhandle,sl,out))!=YES) { return ret; }
 if((ret=aaNetTcpCallWrite(tcpcallhandle,bytes,str))!=YES) { return ret; }
 out[0]=CR_CHAR; out[1]=LF_CHAR;
 if((ret=aaNetTcpCallWrite(tcpcallhandle,2,out))!=YES) { return ret; }
 return(aaNetTcpCallStatus(tcpcallhandle,0));
 }


 B aaNetRedisRespIntegerAppend         (H tcpcallhandle,G val)
 {
 B ret;
 _tcpcallstatus cs;
 B out[_4K];
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaNetTcpCallStatus(tcpcallhandle,&cs))!=YES) { return ret; }
 aaStringCopyfLen(out,&sl,":%I64d\r\n",val);
 if((ret=aaNetTcpCallWrite(tcpcallhandle,sl,out))!=YES) { return ret; }
 return(aaNetTcpCallStatus(tcpcallhandle,0));
 }

/*-----------------------------------------------------------------------*/





 B aaNetIrcAdrToParts                  (VP address,_ircadrparts*ircadrparts)
 {
 B flag;
 B tok[_4K];
 B etc[_4K];
 H off,pos,ooo;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(address==NULL) { return RET_BADPARM; }
 aaMemoryFill(ircadrparts,sizeof(_ircadrparts),0);
 if(aaStringIsEmpty(address,YES)!=NO) { return RET_BADPARM; }
 aaStringCopyf(ircadrparts->address,"%s",address);
 flag=0;
 aaStringCopyf(tok,"%s",address);
 aaStringNull(&etc[_0K]);  aaStringNull(&etc[_1K]);   aaStringNull(&etc[_2K]);   aaStringNull(&etc[_3K]);
 off=0;
 while(1)
  {
  if(aaStringFindFirstIString(&tok[off],0,"!",0,&pos)!=YES) { break; }
  aaStringNCopy(&etc[_0K],&tok[off],pos,YES); off+=(pos+1);
  if(aaStringFindFirstIString(&tok[off],0,"@",0,&pos)!=YES) { break; }
  aaStringNCopy(&etc[_1K],&tok[off],pos,YES); off+=(pos+1);

  aaStringCopy(&etc[_2K],&tok[off]);
  if(aaNetIpIsValid(&etc[_2K])==YES)
   {
   flag=aaBitSet(flag,0);
   break;
   }
  if(aaStringFindCharList(&etc[_2K],0,&ooo,":",YES,0,NO)==YES)
   {
   flag=aaBitSet(flag,0);
   break;
   }
  if(aaStringFindCharList(&etc[_2K],0,&pos,"./",YES,0,YES)==YES)
   {
   flag=aaBitSet(flag,0);
   break;
   }
  if(aaStringIsEmpty(&etc[_2K],YES)==NO)
   {
   flag=aaBitSet(flag,0);
   break;
   }
  break;
  }
 if(aaBitGet(flag,0)!=YES) { return RET_FAILED; }
 aaStringCopyf(ircadrparts->nick,"%s",&etc[_0K]);
 aaStringCopyf(ircadrparts->user,"%s",&etc[_1K]);
 aaStringCopyf(ircadrparts->host,"%s",&etc[_2K]);
 return RET_YES;
 }



 B aaNetIrcMsgRead                     (H tcpcallhandle,_ircmsg*ircmsg,VP raw)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 BP bp;
 B buf[_8K];
 B prefix[_1K];
 B trailer[_1K];
 B command[_1K];
 B params[_1K];
 B midsec[_4K];
 B tok[_2K];
 _parser pa,pb,pc;
 H mid_pos,i,j;
 H pos,hh,chars;
 _stringtokermini toker_mini;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,tcpcallhandle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(ircmsg==NULL) { return RET_BADPARM; }
 if(raw) { aaStringNull(raw); }

 aaStringNull(prefix);
 aaStringNull(command);
 aaStringNull(params);
 aaStringNull(midsec);
 aaStringNull(trailer);
 ircmsg->is_failed=NO;
 ircmsg->is_success=NO;
 ircmsg->is_prefix=NO;
 ircmsg->prefix_is_adr=NO;
 ircmsg->is_command=NO;
 ircmsg->command_is_num=NO;
 ircmsg->is_target=NO;
 ircmsg->is_params=NO;
 ircmsg->is_trailer=NO;
 ircmsg->trailer_is_adr=NO;
 ircmsg->command_code=0;
 aaStringNull(ircmsg->prefix);
  ircmsg->prefix_adr.address[0]=NULL_CHAR;
  ircmsg->prefix_adr.nick[0]=NULL_CHAR;
  ircmsg->prefix_adr.user[0]=NULL_CHAR;
  ircmsg->prefix_adr.host[0]=NULL_CHAR;
 aaStringNull(ircmsg->command);
 aaStringNull(ircmsg->target);
 aaStringNull(ircmsg->params);
 ircmsg->param_count=0;
 for(i=0;i<aaElementCount(ircmsg->param_offlen);i++)
  {
  ircmsg->param_offlen[i][0]=ircmsg->param_offlen[i][1]=0;
  ircmsg->param_is_adr[i]=NO;
  ircmsg->param[i][0]=NULL_CHAR;
  ircmsg->param_adr[i].address[0]=NULL_CHAR;
  ircmsg->param_adr[i].nick[0]=NULL_CHAR;
  ircmsg->param_adr[i].user[0]=NULL_CHAR;
  ircmsg->param_adr[i].host[0]=NULL_CHAR;
  }
 aaStringNull(ircmsg->trailer);
 ircmsg->trailer_is_adr=NO;
  ircmsg->trailer_adr.address[0]=NULL_CHAR;
  ircmsg->trailer_adr.nick[0]=NULL_CHAR;
  ircmsg->trailer_adr.user[0]=NULL_CHAR;
  ircmsg->trailer_adr.host[0]=NULL_CHAR;
 if((ret=aaNetTcpCallStringRead(tcpcallhandle,&chars,0,sizeof(buf),buf))!=YES) return ret;
 if(raw) { aaStringCopy(raw,buf); }
 aaCast(bp,BP,buf);
 aaParserInit(&pa,bp,0);
 aaParserInit(&pc,bp,0);
 if(aaParserSeekToVisibleChar(&pa,YES,YES)!=YES) oof;
 if(pa.bp[0]==':')
  {
  aaParserSeek(&pa,1);
  aaParserCopy(&pb,&pa,NO);
  if(aaStringFindChar(pa.bp,pa.to_end,&pos,32,YES,0,YES)!=YES) { oof; }
  aaStringNCopy(prefix,pa.bp,pos,YES);
  aaParserSeek(&pa,pos);
  if(aaParserSeekToVisibleChar(&pa,YES,YES)!=YES) oof;
  }
 mid_pos=pa.offset;
 aaParserSeek(&pc,mid_pos);
 aaStringNCopy(midsec,pc.bp,pc.to_end,YES);
 aaStringFindFirstIString(pa.bp,pa.to_end," :",0,&pos);
 if(pos!=0xffffffff)  {  midsec[pos]=0;  }
 if(pos!=0xffffffff)
  {
  aaParserCopy(&pb,&pa,NO);
  aaParserSeek(&pa,pos+2);
  if(pa.to_end>0)   {   aaStringNCopy(trailer,pa.bp,pa.to_end,YES);   }
  aaParserCopy(&pa,&pb,NO);
  }
 if(aaStringFindChar(midsec,0,&pos,SPACE_CHAR,YES,0,YES)==YES)
  {
  aaStringCopyf(params,"%s",&midsec[pos+1]);
  midsec[pos]=0;
  aaStringCopyf(command,"%s",midsec);
  }
 else
  {
  aaStringCopyf(command,"%s",midsec);
  }
 ircmsg->is_failed=NO;
 ircmsg->is_success=YES;
 if(aaStringIsEmpty(prefix,YES)==NO) { ircmsg->is_prefix=YES; aaStringCopyf(ircmsg->prefix,"%s",prefix); }
 if(aaStringIsEmpty(command,YES)==NO) { ircmsg->is_command=YES; aaStringCopyf(ircmsg->command,"%s",command); }
 if(aaStringIsEmpty(params,YES)==NO) { ircmsg->is_params=YES; aaStringCopyf(ircmsg->params,"%s",params); }
 if(aaStringIsEmpty(trailer,YES)==NO) { ircmsg->is_trailer=YES; aaStringCopyf(ircmsg->trailer,"%s",trailer); }
 if(ircmsg->is_prefix)
  {
  if(aaNetIrcAdrToParts(ircmsg->prefix,&ircmsg->prefix_adr)==YES)
   {
   ircmsg->prefix_is_adr=YES;
   }
  }
 if(ircmsg->is_command)
  {
  hh=0;
  if(aaStringIsNumerical(command,0,0,0)==YES)
   {
   ircmsg->command_is_num=YES;
   if(aaStringToNumber(command,0,&hh,0,0,0)!=YES) { oof; }
   ircmsg->command_code=hh;
   }
  else
   {
   hh=0;
   if(aaStringHashGet(command,0,&hh,NO)!=YES) oof;
   ircmsg->command_code=hh;
   }
  }
 if(aaStringIsEmpty(ircmsg->params,YES)==NO)
  {
  if((ret=aaStringTokerMini(ircmsg->params,0,&toker_mini))!=YES)  {  aaNote(0,"hocket=[%s]",ircmsg->params); oops;  }
  if(ircmsg->command_is_num==YES) { j=1; }
  else                            { j=0; }
  if(ircmsg->command_is_num==YES)
   {
   aaStringNCopy(tok,&ircmsg->params[toker_mini.off[0]],toker_mini.sl[0],YES);
   aaStringCopyf(ircmsg->target,"%s",tok);
   ircmsg->is_target=YES;
   }
  ircmsg->param_count=toker_mini.count-j;
  for(i=0;i<ircmsg->param_count;i++)
   {
   ircmsg->param_offlen[i][0]=toker_mini.off[i+j];
   ircmsg->param_offlen[i][1]=toker_mini.sl[i+j];
   aaStringNCopy(ircmsg->param[i],&ircmsg->params[toker_mini.off[i+j]],toker_mini.sl[i+j],YES);
   if(aaNetIrcAdrToParts(ircmsg->param[i],&ircmsg->param_adr[i])==YES)
    {
    ircmsg->param_is_adr[i+j]=YES;
    }
   }
  if(ircmsg->command_is_num==YES&&aaStringIsEmpty(ircmsg->target,YES)==NO&&ircmsg->param_count!=0)
   {
   pos=ircmsg->param_offlen[0][0];
   aaStringDeleteChars(ircmsg->params,0,0,pos);
   for(i=0;i<ircmsg->param_count;i++)
    {
    ircmsg->param_offlen[i][0]-=pos;
    ircmsg->param_is_adr[i]=ircmsg->param_is_adr[i+1];
    }
   }
  }
 if(ircmsg->is_trailer)
  {
  if(aaNetIrcAdrToParts(ircmsg->trailer,&ircmsg->trailer_adr)==YES) {  ircmsg->trailer_is_adr=YES;   }
  }
 return RET_YES;
 }




 B aaNetIrcMsgToString                 (_ircmsg*ircmsg,VP raw,VP str)
 {
 H i;
 B txt[_8K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str) { aaStringNull(str); }
 if(ircmsg==NULL) { return RET_BADPARM; }
 aaStringNull(txt);
 if(aaStringIsEmpty(raw,YES)==NO)
  {
  aaStringAppendf(txt,"          raw=[%s]\r\n",raw);
  }
 if(ircmsg->is_prefix)
  {
  aaStringAppendf(txt,"       prefix=[%s]\r\n",ircmsg->prefix);
  }
 if(ircmsg->prefix_is_adr)
  {
  aaStringAppendf(txt,"             =[%s] [%s] [%s]\r\n",ircmsg->prefix_adr.nick,ircmsg->prefix_adr.user,ircmsg->prefix_adr.host);
  }
 if(ircmsg->is_command)
  {
  if(ircmsg->command_is_num)
   {
   aaStringAppendf(txt," command_code=%u\r\n",ircmsg->command_code);
   }
  else
   {
   aaStringAppendf(txt,"      command=[%s]\r\n",ircmsg->command);
   aaStringAppendf(txt," command_code=0x%08x\r\n",ircmsg->command_code);
   }
  }
 if(ircmsg->is_target)
  {
  aaStringAppendf(txt,"       target=[%s]\r\n",ircmsg->target);
  }
 if(ircmsg->is_params)
 {
 if(ircmsg->param_count!=0)
  {
  aaStringAppendf(txt,"       params=[%s]\r\n",ircmsg->params);
  }
 for(i=0;i<ircmsg->param_count;i++)
  {
  aaStringAppendf(txt,"    param[%02i]=[%s]\r\n",i,ircmsg->param[i]);
  if(ircmsg->param_is_adr[i])
   {
   aaStringAppendf(txt,"             =[%s] [%s] [%s]\r\n",ircmsg->param_adr[i].nick,ircmsg->param_adr[i].user,ircmsg->param_adr[i].host);
   }
  }
 }
 if(ircmsg->is_trailer)
  {
  aaStringAppendf(txt,"      trailer=[%s]\r\n",ircmsg->trailer);
  if(ircmsg->trailer_is_adr)
   {
   aaStringAppendf(txt,"             =[%s] [%s] [%s]\r\n",ircmsg->trailer_adr.nick,ircmsg->trailer_adr.user,ircmsg->trailer_adr.host);
   }
  }
 aaStringLastCharNonVisibleRemove(txt,0);
 if(str) { aaStringCopyf(str,"%s",txt); }
 return RET_YES;
 }







/*-----------------------------------------------------------------------*/


 B aaNetPortListRead                   (_netportlist*netportlist)
 {
 B ret,flag;
 HINSTANCE mod;
 BP mem;
 MIB_TCPTABLE*TcpTable;
 MIB_UDPTABLE*UdpTable;
 H i,off;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(netportlist==NULL) { return RET_BADPARM; }
 aaMemoryFill(netportlist,sizeof(_netportlist),0);
 if(aa.net_system.port_list.is_open==YES)
  {
  if(aa.net_system.port_list.mem) { aaMemoryRelease(aa.net_system.port_list.mem); }
  aa.net_system.port_list.mem=NULL;
  aa.net_system.port_list.u_len=aa.net_system.port_list.t_len=0;
  aaMemoryFill(&aa.net_system.port_list.list,sizeof(_netportlist),0);
  }
 else
  {
  aaMemoryFill(&aa.net_system.port_list,sizeof(_aa_netportlist),0);
  if((mod=LoadLibrary("iphlpapi.dll"))==NULL) { return RET_FAILED; }
  aa.net_system.port_list.GetTcpTable=(VP)GetProcAddress(mod,"GetTcpTable");
  aa.net_system.port_list.GetUdpTable=(VP)GetProcAddress(mod,"GetUdpTable");
  if(aa.net_system.port_list.GetTcpTable==NULL||aa.net_system.port_list.GetUdpTable==NULL)  { FreeLibrary(mod);  return RET_FAILED;  }
  aa.net_system.port_list.module_handle=mod;
  aa.net_system.port_list.is_open=YES;
  }
 flag=NO;
 while(1)
  {
  ret=RET_FAILED;
  if(aa.net_system.port_list.GetTcpTable(NULL,&aa.net_system.port_list.t_len,TRUE)!=ERROR_INSUFFICIENT_BUFFER) { break; }
  if(aa.net_system.port_list.GetUdpTable(NULL,&aa.net_system.port_list.u_len,TRUE)!=ERROR_INSUFFICIENT_BUFFER) { break; }
  i=aa.net_system.port_list.t_len+aa.net_system.port_list.u_len*4;
  if((ret=aaMemoryAllocate((VP)&mem,i))!=RET_YES) { break; }
  aaMemoryNameSet(mem,"netprtlistent");
  aa.net_system.port_list.mem=mem;
  flag=YES;
  break;
  }
 if(flag==NO)
  {
  if(aa.net_system.port_list.mem) { aaMemoryRelease(aa.net_system.port_list.mem); }
  aa.net_system.port_list.mem=NULL;
  aa.net_system.port_list.u_len=aa.net_system.port_list.t_len=0;
  FreeLibrary(aa.net_system.port_list.module_handle);
  aaMemoryFill(&aa.net_system.port_list.list,sizeof(_netportlist),0);
  aa.net_system.port_list.is_open=NO;
  return ret;
  }
 aaCast(TcpTable,MIB_TCPTABLE*,&aa.net_system.port_list.mem[0]);
 aaCast(UdpTable,MIB_UDPTABLE*,&aa.net_system.port_list.mem[aa.net_system.port_list.t_len]);
 flag=NO;
 while(1)
  {
  if(aa.net_system.port_list.GetTcpTable(TcpTable,&aa.net_system.port_list.t_len,TRUE)) { break; }
  if(aa.net_system.port_list.GetUdpTable(UdpTable,&aa.net_system.port_list.u_len,TRUE)) { break; }
  flag=YES;
  break;
  }
 if(flag==NO)
  {
  if(aa.net_system.port_list.mem) { aaMemoryRelease(aa.net_system.port_list.mem); }
  aa.net_system.port_list.mem=NULL;
  aa.net_system.port_list.u_len=aa.net_system.port_list.t_len=0;
  FreeLibrary(aa.net_system.port_list.module_handle);
  aaMemoryFill(&aa.net_system.port_list.list,sizeof(_netportlist),0);
  aa.net_system.port_list.is_open=NO;
  return RET_FAILED;
  }
 aa.net_system.port_list.list.udp_entries=UdpTable->dwNumEntries;
 aa.net_system.port_list.list.tcp_entries=TcpTable->dwNumEntries;
 aa.net_system.port_list.list.total_entries=aa.net_system.port_list.list.udp_entries+aa.net_system.port_list.list.tcp_entries;
 off=aa.net_system.port_list.t_len+aa.net_system.port_list.u_len;
 aaCast(aa.net_system.port_list.list.tcp_entry,_netportlistentry*,&aa.net_system.port_list.mem[off]);
 off+=aa.net_system.port_list.list.tcp_entries*sizeof(_netportlistentry);
 aaCast(aa.net_system.port_list.list.udp_entry,_netportlistentry*,&aa.net_system.port_list.mem[off]);
 for(i=0;i<aa.net_system.port_list.list.udp_entries;i++)
  {
  aa.net_system.port_list.list.udp_entry[i].state=0;
  aaNetAdrSet(&aa.net_system.port_list.list.udp_entry[i].local_adr,UdpTable->table[i].dwLocalAddr,(W)UdpTable->table[i].dwLocalPort);
  }
 for(i=0;i<aa.net_system.port_list.list.tcp_entries;i++)
  {
  aaNetAdrSet(&aa.net_system.port_list.list.tcp_entry[i].local_adr,TcpTable->table[i].dwLocalAddr,(W)TcpTable->table[i].dwLocalPort);
  aaNetAdrSet(&aa.net_system.port_list.list.tcp_entry[i].remote_adr,TcpTable->table[i].dwRemoteAddr,(W)TcpTable->table[i].dwRemotePort);
  aa.net_system.port_list.list.tcp_entry[i].state=TcpTable->table[i].dwState;
  }
 if(netportlist) { aaMemoryCopy(netportlist,sizeof(_netportlist),&aa.net_system.port_list.list); }
 return RET_YES;
 }





 B aaNetPortListStop                   (V)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aa.net_system.port_list.is_open!=YES) { return RET_NOTOPEN; }
 if(aa.net_system.port_list.mem) { aaMemoryRelease(aa.net_system.port_list.mem); }
 aa.net_system.port_list.mem=NULL;
 aa.net_system.port_list.u_len=aa.net_system.port_list.t_len=0;
 FreeLibrary(aa.net_system.port_list.module_handle);
 aa.net_system.port_list.is_open=NO;
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/


 B aaNetRttInit                        (_netrtt*rtt,H mintimeout,H maxtimeout,H initialtimeout)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rtt==NULL) { return RET_BADPARM; }
 if(mintimeout>maxtimeout) { return RET_BADPARM; }
 if(maxtimeout>aaSecs(60)) { return RET_BOUNDS; }
 if(initialtimeout==0) { initialtimeout=mintimeout+((maxtimeout-mintimeout)/2); }
 initialtimeout=aaNumClamp(initialtimeout,mintimeout,maxtimeout);
 aaMemoryFill(rtt,sizeof(_netrtt),0);
 rtt->magic=aa_RTT_MAGIC;
 rtt->timeout=initialtimeout;
 rtt->min_timeout=mintimeout;
 rtt->max_timeout=maxtimeout;
 return RET_YES;
 }




 B aaNetRttUpdate                      (_netrtt*rtt,H ms,B lost)
 {
 H swap,n;
 H minrtt,maxrtt,prevrtt;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rtt==NULL) { return RET_BADPARM; }
 if(rtt->magic!=aa_RTT_MAGIC) { return RET_NOTSTARTED; }
 minrtt=rtt->min_timeout;
 maxrtt=rtt->max_timeout;
 prevrtt=rtt->timeout;
 if(lost)
  {
  n=(prevrtt+(prevrtt>>2));
  if(minrtt>maxrtt) { swap=minrtt; minrtt=maxrtt; maxrtt=swap; }
  }
 else
  {
  n=(((prevrtt>>3)*7)+(ms>>2));
  if(minrtt>maxrtt) { swap=minrtt; minrtt=maxrtt; maxrtt=swap; }
  }
 n=aaNumClamp(n,minrtt,maxrtt);
 rtt->timeout=n;
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/


 B aaNetChunkReaderNew                 (_chunkreader*chunkreader,H tcpcallhandle)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(chunkreader==NULL) { return RET_BADPARM;  }
 aaMemoryFill(chunkreader,sizeof(_chunkreader),0);
 chunkreader->magic=aaHPP(aaNetChunkReaderNew);
 if((ret=aaNetTcpCallStatus(tcpcallhandle,0))!=YES) { return ret;  }
 chunkreader->call_handle=tcpcallhandle;
 chunkreader->chunk_size=-1;
 chunkreader->chunk_done=-1;
 ret=aaMemoryUnitAllocate(&chunkreader->chunk,_1K);
 if(ret!=RET_YES) { aaMemoryFill(chunkreader,sizeof(_chunkreader),0); return ret; }
 return RET_YES;
 }







 B aaNetChunkReaderDelete              (_chunkreader*chunkreader)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(chunkreader==NULL) { return RET_BADPARM;  }
 if(chunkreader->magic!=aaHPP(aaNetChunkReaderNew)) { return RET_NOTINITIALIZED; }
 if(chunkreader->chunk.bytes!=0)
  {
  aaMemoryUnitRelease(&chunkreader->chunk);
  }
 aaMemoryFill(chunkreader,sizeof(_chunkreader),0);
 return RET_YES;
 }




 B aaNetChunkReaderYield               (_chunkreader*chunkreader)
 {
 B ret;
 H todo;
 _tcpcallstatus cs;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(chunkreader==NULL) { return RET_BADPARM;  }
 if(chunkreader->magic!=aaHPP(aaNetChunkReaderNew)) { return RET_NOTINITIALIZED; }
 if(chunkreader->is_ready!=YES)
  {
  if(chunkreader->chunk_size==-1)
   {
   if(aaNetHttpChunkSizeRead(chunkreader->call_handle,(HP)&chunkreader->chunk_size)==YES)
    {
    if((H)(chunkreader->chunk_size+_2K)>(H)chunkreader->chunk.bytes)
     {
     if((ret=aaMemoryUnitReAllocate(&chunkreader->chunk,chunkreader->chunk_size+_2K))!=YES) { oops; }
     }
    }
   chunkreader->chunk_done=0;
   }
  if(chunkreader->chunk_size!=-1)
   {
   aaNetTcpCallStatus(chunkreader->call_handle,&cs);
   if((todo=chunkreader->chunk_size-chunkreader->chunk_done)!=0)
    {
    todo=aaNumRoof(todo,_8K);
    if((todo=aaNumRoof(todo,cs.rcve_bytes))!=0)
     {
     if(aaNetTcpCallRead(chunkreader->call_handle,todo,&chunkreader->chunk.mem[chunkreader->chunk_done])!=YES) oof;
     chunkreader->chunk_done+=todo;
     }
    }
   if(chunkreader->chunk_done==chunkreader->chunk_size)
    {
    chunkreader->chunk.mem[chunkreader->chunk_size]=0;
    chunkreader->is_ready=YES;
    }
   }
  }
 if(chunkreader->is_ready!=YES) { return RET_NOTREADY; }
 return RET_YES;
 }




 B aaNetChunkReaderDiscard             (_chunkreader*chunkreader)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(chunkreader==NULL) { return RET_BADPARM;  }
 if(chunkreader->magic!=aaHPP(aaNetChunkReaderNew)) { return RET_NOTINITIALIZED; }
 if(chunkreader->is_ready!=YES) { return RET_NOTREADY; }
 chunkreader->chunk_size=-1;
 chunkreader->chunk_done=-1;
 chunkreader->is_ready=NO;
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/

 B aaRedcallNew                        (_redcall*redcall,VP host,W port,VP auth,B(*proc)(_redcall*,Q,B,B,_redcallpkt*))
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(redcall==NULL) { return RET_BADPARM; }
 aaMemoryFill(redcall,sizeof(_redcall),0);
 redcall->magic=aaHPP(aaRedcallNew);
 if(aaStringIsEmpty(host,YES)==NO) { aaStringCopyf(redcall->host,"%s",host); }
 else                              { aaStringCopyf(redcall->host,"127.0.0.1"); }
 if(port!=0) { redcall->port=port; }
 else        { redcall->port=6379; }
 if(aaStringIsEmpty(auth,YES)==NO) { aaStringCopyf(redcall->auth,"%s",auth); }
 if(aaMemoryUnitAllocate(&redcall->rpkt.mu,_64K)!=YES) { oof; }
 redcall->rpkt_seq_prev=F64;
 redcall->stage=100;
 redcall->proc=proc;
 return RET_YES;
 }





 B aaRedcallDelete                     (_redcall*redcall)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(redcall==NULL) { return RET_BADPARM; }
 if(redcall->magic!=aaHPP(aaRedcallNew)) { return RET_NOTINITIALIZED; }
 if(redcall->tcpcall.handle!=0) { aaNetTcpCallDestroy(redcall->tcpcall.handle); }
 if(redcall->rpkt.mu.bytes) { aaMemoryUnitRelease(&redcall->rpkt.mu); }
 aaMemoryFill(redcall,sizeof(_redcall),0);
 return RET_YES;
 }




 B aaRedcallYield                      (_redcall*redcall,QP seq,BP isnew,BP isend)
 {
 B ret;
 B isn,ise;
 Q sq;
 B(*proc)(_redcall*,Q,B,B,_redcallpkt*);

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(redcall==NULL) { return RET_BADPARM; }
 if(redcall->magic!=aaHPP(aaRedcallNew)) { return RET_NOTINITIALIZED; }
 if(seq) { *seq=0; }
 if(isnew) { *isnew=0; }
 if(isend) { *isend=0; }
 switch(redcall->stage)
  {
  case 100:
  aaNetTcpCallCreate(&redcall->tcpcall.handle,0,0,redcall->host,0,redcall->port,0);
  redcall->stage=120;
  break;

  case 120:
  aaNetTcpCallStatus(redcall->tcpcall.handle,&redcall->tcpcall.status);
  if(redcall->tcpcall.status.is_ready!=YES) { break; }
  if(aaStringIsEmpty(redcall->auth,YES)==NO) { redcall->stage=140; break; }
  redcall->stage=200;
  break;


  case 140:
  aaNetRedisPacketWritef(redcall->tcpcall.handle,"auth %s",redcall->auth);
  aaNetTcpCallStatus(redcall->tcpcall.handle,&redcall->tcpcall.status);
  redcall->stage=160;


  case 160:
  ret=aaNetRedisPacketRead(redcall->tcpcall.handle,&redcall->rpkt.type,&redcall->rpkt.arg,&redcall->rpkt.chars,redcall->rpkt.mu.bytes,redcall->rpkt.mu.mem);
  if(ret==RET_NOTREADY) { break; }
  if(ret!=RET_YES)
   {
   }
  switch(redcall->rpkt.type)
   {
   case aa_REDISTYPE_Status:
   if(redcall->rpkt.arg==aa_REDISARG_OK)
    {
    redcall->is_ready=YES;
    redcall->stage=200;
    break;
    }
   break;


   case aa_REDISTYPE_Error:
   redcall->stage=666;
   break;


   default:
   oof;
   break;
   }
  break;



  case 200:
  ret=aaNetRedisPacketRead(redcall->tcpcall.handle,&redcall->rpkt.type,&redcall->rpkt.arg,&redcall->rpkt.chars,redcall->rpkt.mu.bytes,redcall->rpkt.mu.mem);
  if(ret==RET_NOTREADY) { break; }
  if(ret!=RET_YES)
   {
   }
  redcall->rpkt.seq=redcall->rpkt_seq;
  if(redcall->rpkt.type==aa_REDISTYPE_Multi)
   {
   redcall->rpkt_multi_left=redcall->rpkt.arg;
   }
  if(redcall->rpkt_multi_left==0) { redcall->rpkt_seq++; }
  redcall->stage=220;
  break;


  case 220:
  isn=ise=NO;
  if(redcall->rpkt.seq!=redcall->rpkt_seq_prev) { isn=YES; }
  if(redcall->rpkt_multi_left==0) { ise=YES; }
  sq=redcall->rpkt.seq;
  if(redcall->proc)
   {
   proc=redcall->proc;
   ret=proc(redcall,redcall->rpkt.seq,isn,ise,&redcall->rpkt);
   if(ret==RET_YES)    {    aaRedcallPktDiscard(redcall);    }
   }
  if(isnew) { *isnew=isn; }
  if(isend) { *isend=ise; }
  if(seq)   { *seq=sq; }
  break;
  }
 return RET_YES;
 }





 B aaRedcallPktWritef                  (_redcall*redcall,QP seq,VP fmt,...)
 {
 B str[_8K];
 va_list argptr;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(redcall==NULL) { return RET_BADPARM; }
 if(redcall->magic!=aaHPP(aaRedcallNew)) { return RET_NOTINITIALIZED; }
 aaFmt(fmt,argptr,str);
 if(seq) *seq=redcall->xpkt_seq;
 aaNetRedisPacketWritef(redcall->tcpcall.handle,"%s",str);
 redcall->xpkt_seq++;
 return RET_YES;
 }




 B aaRedcallPktPeek                    (_redcall*redcall,QP seq,BP isnew,BP isend)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(redcall==NULL) { return RET_BADPARM; }
 if(redcall->magic!=aaHPP(aaRedcallNew)) { return RET_NOTINITIALIZED; }
 if((ret=aaRedcallYield(redcall,seq,isnew,isend))!=RET_YES) { oops; return ret; }
 if(redcall->stage!=220)  { return RET_NOTREADY; }
 return RET_YES;
 }




 B aaRedcallPktDiscard                 (_redcall*redcall)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(redcall==NULL) { return RET_BADPARM; }
 if(redcall->magic!=aaHPP(aaRedcallNew)) { return RET_NOTINITIALIZED; }
 if(redcall->stage==220||redcall->stage==220)
  {
  if(redcall->stage==220)  {  redcall->stage=200;   }
  redcall->rpkt_seq_prev=redcall->rpkt.seq;
  if(redcall->rpkt_multi_left!=0) { redcall->rpkt_multi_left--; }
  return RET_YES;
  }
 return RET_NOTREADY;
 }




 B aaRedcallPktBug                     (_redcall*redcall)
 {
 B ret;
 B txt[_1K];
 B str[_2K];
 H count;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(redcall==NULL) { return RET_BADPARM; }
 if(redcall->magic!=aaHPP(aaRedcallNew)) { return RET_NOTINITIALIZED; }
 if(redcall->proc==NULL)
  {
  if((ret=aaRedcallPktPeek(redcall,0,0,0))!=RET_YES) { return ret; }
  }
 aaStringNull(txt);
 switch(redcall->rpkt.type)
  {
  case aa_REDISTYPE_Status:  aaStringCopyf(txt,"Status"); break;
  case aa_REDISTYPE_Error:   aaStringCopyf(txt,"Error"); break;
  case aa_REDISTYPE_Integer: aaStringCopyf(txt,"Intger"); break;
  case aa_REDISTYPE_Bulk:    aaStringCopyf(txt,"Bulk"); break;
  case aa_REDISTYPE_Multi:   aaStringCopyf(txt,"Multi"); break;
  }
 aaStringCopyf(str,"%-8I64d %-7s  ",redcall->rpkt.seq,txt);
 if(redcall->rpkt.type!=aa_REDISTYPE_Bulk)
  {
  aaStringAppendf(str,"arg=%-10I64d  ",redcall->rpkt.arg);
  }
 else
  {
  aaStringAppendf(str,"arg=0x%-8I64X  ",redcall->rpkt.arg);
  }
 aaStringAppendf(str,"chars=%-7u ",redcall->rpkt.chars);
 if(redcall->rpkt.chars!=0)
  {
  aaStringCountChars(redcall->rpkt.mu.mem,redcall->rpkt.chars,&count,LF_CHAR,NO,YES);
  if(count>0) { aaStringAppendf(str,"\n"); }
  else        { aaStringAppendf(str," ");  }
  }
 return RET_YES;
 }





 B aaRedcallProc                       (_redcall*redcall,Q seq,B isnew,B isend,_redcallpkt*redcallpkt)
 {
 UNUSE(seq);
 UNUSE(redcallpkt);
 if(isnew)
  {
  }
 aaRedcallPktBug(redcall);
 if(isend)
  {
  }
 return RET_YES;
 }


/*-----------------------------------------------------------------------*/





 B aa_TorSnapshot                      (_tor*tor)
 {
 B ret;
 _processlist proc_list;
 H i,j,state,val;
 _torprocess te;
 _stringtokermini toker;
 B tok[2][_2K];
 N which;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(tor,aaTorNew);

 tor->process_count=0;
 if((ret=aaProcessListGather(&proc_list,"tor*"))!=YES) { oops; return ret; }

 for(i=0;i<proc_list.entries;i++)
  {
  if(aaStringICompare(proc_list.entry[i].exe_file,"tor.exe",0)!=YES) { continue; }
  if((ret=aaStringTokerMini(proc_list.entry[i].cmd_line,0,&toker))!=YES)  { continue; }
  j=0;
  state=0;
  aaMemoryFill(&te,sizeof(te),0);
  while(1) ///==============================
   {
   if(j>=toker.count) { break; }
   if((ret=aaStringTokerMiniStringGet(tok[state],j,sizeof(tok[state]),&toker))!=YES) { oops; break; }
   if(j==0)    {    aaStringCopyf(te.exe_file,"%s",tok[0]);    j++;    continue;    }
   if(state==0)
    {
    aaStringIsIString(tok[state],&which,"--DataDirectory","--SocksPort","--ControlPort",NULL);
    state=1;
    j++;
    continue;
    }
    switch(which)
     {
     case 0:    aaStringCopyf(te.data_path,"%s",tok[1]);    break;
     case 1:    aaStringToNumber(tok[1],0,&val,0,0,0);    te.s_port=(W)val;    break;
     case 2:    aaStringToNumber(tok[1],0,&val,0,0,0);    te.c_port=(W)val;    break;
     default:    break;
     }
   which=-1;
   state=0;
   j++;
   }
  if(te.c_port==0||te.s_port==0)
    {
    continue;
    }
//    appLogf("pe[%i]=%s",i,proc_list.entry[i].cmd_line);
//   if(aaStringNICompare(te.pid_path,tor->path,0xffffffff,0)!=YES)    {    continue;    }
   if(aaStringNICompare(te.data_path,tor->path,0xffffffff,0)!=YES)   {    continue;    }
   //if(aaStringICompare(te.pid_file,"pid.pid",0)!=YES)         {    continue;    }
   //aaStringLower(te.pid_path,0,te.pid_path);
   //aaStringLower(te.data_path,0,te.data_path);
   //aaStringLower(te.pid_file,0,te.pid_file);
   te.pid=proc_list.entry[i].process_id;
   te.secs_running=proc_list.entry[i].ms_running/1000LL;
   //appLogf("proslo=%i proco=%i",tor->process_slots,tor->process_count);
  if(tor->process_slots==0)
   {
   tor->process_slots=16;
   if(aaMemoryAllocate((VP)&tor->process,tor->process_slots*sizeof(_torprocess))!=YES) oof;
   aaMemoryNameSet(tor->process,"torpro");
   }
  else
  if((tor->process_slots-tor->process_count)<2)
   {
   tor->process_slots+=((tor->process_slots/2)+10);
   if(aaMemoryReAllocate((VP)&tor->process,tor->process_slots*sizeof(_torprocess))!=YES) oof;
   }
  aaMemoryCopy(&tor->process[tor->process_count],sizeof(_torprocess),&te);
  tor->process_count++;
  }
 aaProcessListRelease(&proc_list);
 tor->ss_tik=aaMsRunning();
 return RET_YES;
 }








 B aaTorNew                            (_tor*tor,VP path,...)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objInit(tor,aaTorNew);
 aaVargsf4K(path);
 tor->ss_tik=0;
 aaStringCopyf(tor->path,"%s",str4k.buf);
 if((ret=aa_TorSnapshot(tor))!=YES) { oops; }
 return RET_YES;
 }









 B aaTorDelete                         (_tor*tor)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(tor,aaTorNew);
 if(tor->process!=NULL)
  {
  aaMemoryRelease(tor->process);
  tor->process=NULL;
  }
 objClear(tor);
 return RET_YES;
 }




 B aaTorRefresh                        (_tor*tor)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(tor,aaTorNew);
 if((ret=aa_TorSnapshot(tor))!=YES) { oops; }
 return RET_YES;
 }







 B aaTorKill                           (_tor*tor,H index)
 {
 B ret;
 H i,c;
 _torprocess*tep;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(tor,aaTorNew);
 if(index!=0xffffffff&&index>=tor->process_count) { return RET_BOUNDS; }
 if(index!=0xffffffff)
  {
  tep=(_torprocess*)&tor->process[index];
  if(tep->pid==0)    { return RET_NOTFOUND; }
  if(tep->c_port==0) { return RET_NOTFOUND; }
  if(tep->s_port==0) { return RET_NOTFOUND; }
  if(tep->is_killing!=YES)
   {
   tep->is_killing=YES;
   if((ret=aaProcessTerminateByPid(tep->pid,0))!=YES) { }//oops;  return RET_NOTREADY;  }
   }
  }
 else
  {
  c=0;
  for(i=0;i<tor->process_slots;i++)
   {
   if(c>=tor->process_count) { break; }
   tep=(_torprocess*)&tor->process[i];
   if(tep->pid==0)    { continue; }
   if(tep->c_port==0) { continue; }
   if(tep->s_port==0) { continue; }
   c++;
   if(tep->is_killing!=YES)
    {
    tep->is_killing=YES;
    if((ret=aaProcessTerminateByPid(tep->pid,0))!=YES) { }//oops;  return RET_NOTREADY;  }
    }
   }
  }
 //if((ret=aa_TorSnapshot(tor))!=YES) { oops; }
 return RET_YES;
 }








 B aaTorLaunch                         (_tor*tor,W cport,W sport)
 {
 B ret;
 B str[_4K];
 B dat_path[_1K];
 B cmd_line[_1K];
 H i,han,pid,c;
 _fileparts fp;
 //BP kp;
 _torprocess*tep;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(tor,aaTorNew);
 if(sport==0) { return RET_BADPARM; }
 if(cport==0) { return RET_BADPARM; }
 if(cport==sport) { return RET_BADPARM; }
 c=0;
 for(i=0;i<tor->process_slots;i++)
  {
  if(c>=tor->process_count) { break; }
  tep=(_torprocess*)&tor->process[i];
  if(tep->pid==0) { continue; }
  if(tep->c_port==0) { continue; }
  if(tep->s_port==0) { continue; }
  c++;
  if(tep->is_killing) { continue; }
  if(tep->c_port==cport) {  return RET_INUSE; }
  if(tep->s_port==sport) {  return RET_INUSE; }
  }
 aaStringCopyf(str,"%s/tor.exe",tor->path);
 if((ret=aaFileExists("%s",str))!=RET_YES)  {  return RET_NOTFOUND;  }
 if((ret=aaFilePartsGet(str,&fp))!=RET_YES) { oops; return ret; }
 aaStringCopyf(dat_path,"%c:/",fp.drive);
 for(i=0;i<fp.path_count;i++)  {  aaStringAppendf(dat_path,"%s/",fp.path[i]);  }
 aaStringPathSanitize(dat_path,0,0);
 aaStringAppendf(dat_path,"/datafolder"); aaFileFolderCreate("%s",dat_path);
 aaStringAppendf(dat_path,"/%i",cport);   aaFileFolderCreate("%s",dat_path);
 aaStringNull(cmd_line);
 aaStringAppendf(cmd_line,"--SocksPort %u ",sport);
 aaStringAppendf(cmd_line,"--ControlPort %u ",cport);
 aaStringAppendf(cmd_line,"--RunAsDaemon 1 ");
 aaStringAppendf(cmd_line,"--CookieAuthentication 0 ");
 aaStringAppendf(cmd_line,"--HashedControlPassword \"\" ");
 aaStringAppendf(cmd_line,"--PidFile %s/pid.pid ",dat_path);
 aaStringAppendf(cmd_line,"--DataDirectory %s ",dat_path);
 //aaStringAppendf(cmd_line,"--NewCircuitPeriod %u ",360);//maxage);
 //aaStringAppendf(cmd_line,"--MaxCircuitDirtiness %u ",360);
 if(0) { aaStringAppendf(cmd_line,"--hush "); }
// appLogf("prolasunc %s",cmd_line);
 if((ret=aaProcessLaunch(str,cmd_line,dat_path,SW_HIDE,&han,&pid))!=YES) { oops;  }
// if((ret=aaProcessSpawn(str,cmd_line,SW_HIDE,&han,&pid))!=RET_YES) {oops; }
 //if((ret=aa_TorSnapshot(tor))!=YES) { oops; }
 return RET_YES;
 }




 B aaTorFind                           (_tor*tor,W cport,W sport,HP index)
 {
 H j,c;
 _torprocess*tep;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(tor,aaTorNew);
 if(cport==0) { return RET_BADPARM; }
 if(sport==0) { return RET_BADPARM; }
 if(cport==sport) { return RET_BADPARM; }
 c=0;
 for(j=0;j<tor->process_slots;j++)
  {
  if(c>=tor->process_count) { break; }
  tep=(_torprocess*)&tor->process[j];
  if(tep->pid==0) continue;
  if(tep->c_port==0) { continue; }
  if(tep->s_port==0) { continue; }
  c++;
  if(tep->c_port!=cport) { continue; }
  if(tep->s_port!=sport) { continue; }
  if(index)  { *index=j; }
  return RET_YES;
  }
 return RET_NOTFOUND;
 }






/*-----------------------------------------------------------------------*/


/*

 B aaTorControlConnect                 (_torcontrol*torcontrol,_tor*tor,H index)
 {
 B ret;
 _torentry*te;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMissingParm(torcontrol);
 objTest(tor,aaTorNew);
 if(index>=tor->entry_count) { return RET_BOUNDS; }
 aaMemoryFill(torcontrol,sizeof(_torcontrol),0);
 torcontrol->magic=aaHPP(aaTorControlConnect);
 te=(_torentry*)&tor->entry[index];
 if((ret=aaNetTcpCallCreate(&torcontrol->call.handle,0,0,0,aaLoopBack,te->c_port,0))!=RET_YES) { return ret; }
 aaNetTcpCallStatus(torcontrol->call.handle,&torcontrol->call.status);
 torcontrol->stage=100;
 return RET_YES;
 }





 B aaTorControlDestroy                 (_torcontrol*torcontrol)
 {
 aaMissingParm(torcontrol);
 if(torcontrol->magic!=aaHPP(aaTorControlConnect)) { return RET_NOTINITIALIZED; }
 if(torcontrol->call.handle!=0)
  {
  aaNetTcpCallDestroy(torcontrol->call.handle);
  }
 aaMemoryFill(torcontrol,sizeof(_torcontrol),0);
 return RET_YES;
 }




 B aaTorControlRead                    (_torcontrol*torcontrol)
 {
 H go;
 _torresult tr;

 aaMissingParm(torcontrol);
 if(torcontrol->magic!=aaHPP(aaTorControlConnect)) { return RET_NOTINITIALIZED; }
 go=1;
 while(go--)
  {
  switch(torcontrol->stage)
   {
   case 100:
   aaNetTcpCallStatus(torcontrol->call.handle,&torcontrol->call.status);
   if(torcontrol->call.status.is_connected!=YES) { break; }
   aaNetTcpCallWritef(torcontrol->call.handle,"authenticate \"\"\r\n");
   aaNetTcpCallStatus(torcontrol->call.handle,&torcontrol->call.status);
   torcontrol->stage=150;
   break;

   case 150:
   aaNetTcpCallStatus(torcontrol->call.handle,&torcontrol->call.status);
   if(aaNetTorResultRead(torcontrol->call.handle,&tr)!=RET_YES) { break; }
   aaMemoryCopy(&torcontrol->res,sizeof(_torresult),&tr);
   if(tr.is_success&&tr.is_end==0&&tr.is_fold==0&&tr.is_multi==0&&tr.code==250)
    {
    torcontrol->is_ready=YES;
    torcontrol->stage=200;
    aaNetTcpCallStatus(torcontrol->call.handle,&torcontrol->call.status);
    break;
    }
   break;

   case 200:
   aaNetTcpCallStatus(torcontrol->call.handle,&torcontrol->call.status);
   if(torcontrol->call.status.is_closed) { oof; }
   if(aaNetTorResultRead(torcontrol->call.handle,&tr)!=RET_YES) { break; }
   aaMemoryCopy(&torcontrol->res,sizeof(_torresult),&tr);
   return RET_YES;
   }
  }
 return RET_NOTREADY;
 }





*/



/*-----------------------------------------------------------------------*/



/*-----------------------------------------------------------------------






 structure
 {
 H magic;
 H stage;
 H next;
 H reset_count;
 B cmd[_1K];
 _cgiclientunit cgi;
 B is_prompt;
 H chars;
 B txt[_4K];
 _list line;
 }
 _shell;


 B aaShellNew                          (_shell*shell,VP fmt,...);
 B aaShellDelete                       (_shell*shell);
 B aaShellYield                        (_shell*shell,H iterations);
 B aaShellLinePointer                  (_shell*shell,H line,HP chars,PP ptr);
 B aaShellReset                        (_shell*shell);


 B aaShellNew                          (_shell*shell,VP fmt,...)
 {
 B ascii;
 B str[_4K];
 va_list argptr;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMissingParm(shell);
 aaMissingParm(fmt);
 aaFmt(fmt,argptr,str);
 aaMemoryFill(shell,sizeof(_shell),0);
 shell->magic=aaHPP(aaShellNew);
 aaStringCopyf(shell->cmd,"%s",str);
 while(1)
  {
  aaStringLastCharGet(shell->cmd,0,&ascii);
  if(ascii==CR_CHAR||ascii==LF_CHAR)
   {
   aaStringLastCharSet(shell->cmd,0,0,1);
   continue;
   }
  break;
  }
 if(shell->cmd[0]==NULL_CHAR) { return RET_BADPARM; }
 shell->stage=100;
 return RET_YES;
 }






 B aaShellDelete                       (_shell*shell)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMissingParm(shell);
 if(shell->magic!=aaHPP(aaShellNew)) { return RET_NOTINITIALIZED; }
 if(shell->cgi.handle!=0)
  {
  aaNetCgiClientDestroy(shell->cgi.handle);
  }
 if(shell->line.magic)
  {
  aaListDelete(&shell->line);
  }
 aaMemoryFill(shell,sizeof(_shell),0);
 return RET_YES;
 }



 B aaShellYield                        (_shell*shell,H iterations)
 {
 B ret;
 B txt[_64K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMissingParm(shell);
 if(shell->magic!=aaHPP(aaShellNew)) { return RET_NOTINITIALIZED; }
 while(1)
 {
 switch(shell->stage)
  {
  case 100:
  if((ret=aaNetCgiClientCreate(&shell->cgi.handle,1,0,0,"cmd.exe",0))!=YES) { oops; }
  if(aaNetCgiClientStatus(shell->cgi.handle,&shell->cgi.status)!=RET_YES) { return RET_FAILED; }
  aaListNew(&shell->line,YES,0,0,1);
  shell->stage=120;
  shell->next=200;
  break;


  case 120:
  while(1)
   {
   ret=aaNetCgiClientStringReadQuick(shell->cgi.handle,30,&shell->chars,&shell->is_prompt,NULL,_4K,shell->txt);
   if(ret==RET_NOTREADY) { break; }
   //aaDebugf("%i %s",shell->is_prompt,shell->txt);
   if(shell->is_prompt==YES) {  shell->stage=shell->next; break; }
   //if((ret=aaListAppendf(&shell->line,0,0,"%s\r\n",shell->txt))!=YES) { oops; }
   aaStringCopyf(txt,"%s\r\n",shell->txt);
   if((ret=aaListAppend(&shell->line,0,0,0,txt))!=YES) { oops; }
   if(shell->chars==0)      { continue; }
   }
  break;


  case 200:
  if(shell->cmd[0]!=NULL_CHAR)
   {
   if((ret=aaNetCgiClientWritef(shell->cgi.handle,"%s\r\n",shell->cmd))!=YES) { oops; }
   if(aaNetCgiClientStatus(shell->cgi.handle,&shell->cgi.status)!=YES) { return RET_FAILED; }
   shell->stage=120;
   shell->next=300;
   }
  else  {   oof;   shell->stage=300;   }
  break;

  case 300:
  if(aaNetCgiClientStatus(shell->cgi.handle,&shell->cgi.status)!=RET_YES) { return RET_FAILED; }
  return RET_YES;
  }
 if(iterations==0) { break; }
 iterations--;
 }
 return RET_NOTREADY;
 }





 B aaShellLinePointer                  (_shell*shell,H line,HP chars,PP ptr)
 {
 H ch;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMissingParm(shell);
 if(shell->magic!=aaHPP(aaShellNew)) { return RET_NOTINITIALIZED; }
 if(chars) { *chars=0; }
 if(ptr)   { *ptr=NULL; }
 if(line>=shell->line.count) { return RET_BOUNDS; }
 ch=shell->line.entry[line].val_len;
 if(chars) { *chars=ch; }
 if(aaListGet(&shell->line,line,0,ptr)!=YES) { oof; }
 return RET_YES;
 }



 B aaShellReset                        (_shell*shell)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMissingParm(shell);
 if(shell->magic!=aaHPP(aaShellNew)) { return RET_NOTINITIALIZED; }
 if(shell->is_prompt)
  {
  //if((ret=aaListReset(&shell->line))!=YES) { oops; }
  aaListDelete(&shell->line);
  aaListNew(&shell->line,YES,0,0,1);
  }
 shell->is_prompt=NO;
 shell->stage=120;
 shell->next=200;
 return RET_YES;
 }

*/

/*-----------------------------------------------------------------------*/

 B aaColorHalfToneGet                  (_rgba*rgba,B index)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rgba==NULL) { return RET_BADPARM; }
 if(index<216) { aaRgbaCopy(rgba,&aa.color_system.half_pal[index]);  }
 else            { aaRgbaSet(rgba,0,0,0,0); }
 return RET_YES;
 }




 B aaColorHalfToneCalculate            (_rgba*rgba,_cord*cord,BP index,_rgba*orgba)
 {
 N r,g,b,x,y,i;
 N rtmp,gtmp,btmp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(cord==NULL) { return RET_BADPARM; }
 if(rgba==NULL) { return RET_BADPARM; }
 if(index==NULL&&orgba==NULL) { return RET_BADPARM; }
 r=rgba->r;  g=rgba->g;  b=rgba->b;
 x=cord->x;  y=cord->y;
 rtmp=(r/51)+((r%51)>aa_halftone8x8[(x%8)*8+y%8]);
 gtmp=(g/51)+((g%51)>aa_halftone8x8[ (x%8)*8+y%8]);
 btmp=(b/51)+((b%51)>aa_halftone8x8[(x%8)*8+y%8]);
 i=rtmp+(gtmp*6)+(btmp*36);
 if(index) { *index=(B)i; }
 if(orgba) { aaRgbaCopy(orgba,&aa.color_system.half_pal[i]);  }
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/


 B aaFontCreate                        (HP handle,VP facettf,N logw,N logh,B weight,B italic,B underline,B smoothing,H charset)
 {
 B ret;
 _aa_fontobject*fntp;
 HGDIOBJ oldobj=NULL;
 HFONT hfnt;
 HBITMAP hbmp=NULL;
 HDC dc=NULL;
 BITMAPINFO bitmapinfo;
 TEXTMETRIC textmetrics;
 BP dib_data;
 H dib_offset;
 H img_offset;
 H grid_width=0;
 H grid_offset;
 N font_width=0,font_height=0;
 N x_pos,y_pos,dif;
 N i,w1,w2;
 N smallest_x;
 N largest_x;
 N smallest_y;
 N largest_y;
 ABC charABCWidth[256];
 N charWidth[256];
 B fail_state;
 W weyght;
 D wei;
 N res;
 B LOAD_MODE;
 H sl,bytes_loaded;
 B is_folder,found;
 BP file_mem;
 B ot[4];
 _aa_ttfoffsettable     ttf_ofsettable;
 _aa_ttftabledirectory  ttf_tabledir;
 _aa_ttfnametableheader ttf_nametablehdr;
 _aa_ttfnamerecord      ttf_namerecord;
 H cc,npos;
 C facetext[257];
 W v1;
 H h1,fon_off;
 BOOL was_smooth;
 N alpha;
 D luminance;
 BP bp;
 BP facettfptr;
 BP ptr;
 BP optr;
 N newwid,newhit,back,xx,yy;
 N firsty,lasty;
 N firstx,lastx;
 B ch;
 H off,to,ha;
 H on_count;
 H fxi;
 B shad[9];
 N hh,ww,stride;
 HANDLE memfont_resource_handle=0;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle) { *handle=0; }
 if(facettf==NULL) { return RET_BADPARM; }
 aaCast(facettfptr,BP,facettf);

 if(aa_FontSystemFind(&ha,facettf,0,logw,logh,weight,italic,underline,smoothing,charset)==RET_YES)
  {
  if((ret=aa_ObjectCheck(aa.font_system.object_id,ha,(VP)&fntp,0))!=RET_YES) { oops; }
  fntp->instance++;
  if(handle) { *handle=ha; }
  return RET_YES;
  }


 LOAD_MODE=0;
 aaStringLen(facettf,&sl);
 if(sl>=5)
  {
  aaStringIsIString(&facettfptr[sl-4],&dif,".ttf",".fon",NULL);
  if(dif==0||dif==1)
   {
   if((ret=aaFileInfoGet(facettfptr,0,&is_folder,0,0,0))!=YES) {   return ret; }
   if(is_folder==YES) { return RET_FAILED; }
   LOAD_MODE=(B)(dif+1);
   }
  }


 if((ret=aa_ObjectCreate(aa.font_system.object_id,handle,(VP)&fntp))!=RET_YES) { oops; return ret; }
 fntp->self_handle=*handle;
 if(weight==255) { wei=1000.0; }
 else
 if(weight==0)   { wei=0; }
 else            { wei=(D)weight*3.92; }
 weyght=(W)wei;
 //weyght=(W)(weight<<2);
 weyght=(W)aaNumRoof(weyght,1000);
 if(italic)    { fntp->status.is_italic=YES;    }
 if(underline) { fntp->status.is_underline=YES; }
 fntp->status.weight=weight;
 cc=0;
 if(LOAD_MODE==0) ///================================ PRE-INSTALLED FONT
  {
  aaStringLen(facettfptr,&sl);
  if(sl==0||sl>64)
   {
   aa_ObjectDestroy(aa.font_system.object_id,*handle);
   *handle=0;
   return RET_NOTFOUND;
   }
  for(cc=0;cc<sl;cc++)
   {
   if(facettfptr[cc]=='\\'||facettfptr[cc]=='/'||facettfptr[cc]<32||facettfptr[cc]>126)
    {
    aa_ObjectDestroy(aa.font_system.object_id,*handle);
    *handle=0;
    return RET_NOTFOUND;
    }
   }
  aaStringCopy(facetext,facettfptr);
  }
 else
 if(LOAD_MODE==1) ///======================================= TTF FILE
  {
  if((ret=aaFileLoadToMemory(facettfptr,0,0xffffffff,(VP)&file_mem,&bytes_loaded))!=RET_YES)
   {
   aa_ObjectDestroy(aa.font_system.object_id,*handle);
   *handle=0;
   return ret;
   }
  aaMemoryCopy(&ttf_ofsettable,sizeof(ttf_ofsettable),&file_mem[cc]);
  cc+=sizeof(ttf_ofsettable);
  ttf_ofsettable.num_tables =(W)aaNumSwapWord(ttf_ofsettable.num_tables);
  ttf_ofsettable.maj_ver=(W)aaNumSwapWord(ttf_ofsettable.maj_ver);
  ttf_ofsettable.min_ver=(W)aaNumSwapWord(ttf_ofsettable.min_ver);
  if(ttf_ofsettable.maj_ver!=1||ttf_ofsettable.min_ver!=0)
   {
   if((ret=aa_MemoryRelease(file_mem))!=YES) { oops; }
   aa_ObjectDestroy(aa.font_system.object_id,*handle);
   *handle=0;
   return RET_FAILED;
   }
  found=NO;
  for(i=0;i<ttf_ofsettable.num_tables;i++)
   {
   aaMemoryCopy(&ttf_tabledir,sizeof(ttf_tabledir),&file_mem[cc]);
   cc+=sizeof(ttf_tabledir);
   aaStringNICompare(ttf_tabledir.tag,"name",4,&dif);
   if(dif==0)
    {
    found=YES;
    ttf_tabledir.len=aaNumSwapDword(ttf_tabledir.len);
    ttf_tabledir.off=aaNumSwapDword(ttf_tabledir.off);
    break;
    }
   }
  if(found!=YES)
   {
   if((ret=aa_MemoryRelease(file_mem))!=YES) { oops; }
   aa_ObjectDestroy(aa.font_system.object_id,*handle);
   *handle=0;
   return RET_FAILED;
   }
  cc=ttf_tabledir.off;
  aaMemoryCopy(&ttf_nametablehdr,sizeof(ttf_nametablehdr),&file_mem[cc]);
  cc+=sizeof(ttf_nametablehdr);
  ttf_nametablehdr.count=(W)aaNumSwapWord(ttf_nametablehdr.count);
  ttf_nametablehdr.offset=(W)aaNumSwapWord(ttf_nametablehdr.offset);
  found=NO;
  for(i=0;i<ttf_nametablehdr.count;i++)
   {
   aaMemoryCopy(&ttf_namerecord,sizeof(ttf_namerecord),&file_mem[cc]);
   cc+=sizeof(ttf_namerecord);
   ttf_namerecord.name_id= (W)aaNumSwapWord(ttf_namerecord.name_id);
   if(ttf_namerecord.name_id==1)
    {
    ttf_namerecord.str_len=(W)aaNumSwapWord(ttf_namerecord.str_len);
    ttf_namerecord.str_off=(W)aaNumSwapWord(ttf_namerecord.str_off);
    npos=cc;
    cc=ttf_tabledir.off+ttf_namerecord.str_off+ttf_nametablehdr.offset;
    aaStringNull(facetext);
    if(ttf_namerecord.str_len>0&&ttf_namerecord.str_len<64)
     {
     aaMemoryCopy(facetext,ttf_namerecord.str_len,&file_mem[cc]);
     facetext[ttf_namerecord.str_len]=NULL_CHAR;
     aaStringLen(facetext,&sl);

     if(sl>0&&sl<64) { found=YES; break; }
     }
    cc=npos;
    }
   }

  if((ret=aa_MemoryRelease(file_mem))!=YES) { oops; }
  if(found==NO) {  aa_ObjectDestroy(aa.font_system.object_id,*handle); *handle=0; return RET_FAILED;}
  if(AddFontResource((CP)facettfptr)==0)   {  aa_ObjectDestroy(aa.font_system.object_id,*handle); *handle=0; return RET_FAILED;   }

  }
 else
 if(LOAD_MODE==10)
  {
  }
 else
 if(LOAD_MODE==2) ///================================== WTF ????? (fon)
  {
  if((ret=aaFileLoadToMemory(facettfptr,0,0xffffffff,(VP)&file_mem,&bytes_loaded))!=RET_YES)
   {
   aa_ObjectDestroy(aa.font_system.object_id,*handle);
   *handle=0;
   return ret;
   }
  if(bytes_loaded<300)
   {
   if((ret=aa_MemoryRelease(file_mem))!=YES) { oops; }
   aa_ObjectDestroy(aa.font_system.object_id,*handle);
   *handle=0;
   return RET_FAILED;
   }
  fon_off=60;
  aaMemoryPeekWord(&file_mem[fon_off],0,&v1);
  fon_off=(H)v1;
  fon_off+=(22*2);
  aaMemoryPeekDword(&file_mem[fon_off],0,&h1);
  fon_off=h1;
  aaStringFindChar(&file_mem[fon_off],0,&h1,':',YES,0,YES);
  if(h1==0xffffffff)
   {
   if((ret=aa_MemoryRelease(file_mem))!=YES) { oops; }
   aa_ObjectDestroy(aa.font_system.object_id,*handle);
   *handle=0;
   return RET_FAILED;
   }
  fon_off+=(h1+1);
  if(fon_off>=bytes_loaded)
   {
   if((ret=aa_MemoryRelease(file_mem))!=YES) { oops; }
   aa_ObjectDestroy(aa.font_system.object_id,*handle);
   *handle=0;
   return RET_FAILED;
   }
  aaStringLen(&file_mem[fon_off],&sl);
  if(sl==0||sl>64)
   {
   if((ret=aa_MemoryRelease(file_mem))!=YES) { oops; }
   aa_ObjectDestroy(aa.font_system.object_id,*handle);
   *handle=0;
   return RET_FAILED;
   }
  aaStringCopy(facetext,&file_mem[fon_off]);
  if((ret=aa_MemoryRelease(file_mem))!=YES) { oops; }
  if(AddFontResource((CP)facettfptr)==0)   {  aa_ObjectDestroy(aa.font_system.object_id,*handle); *handle=0; return RET_FAILED;   }
  }
 font_width=logw;
 font_height=logh;

 #ifndef SPI_GETCLEARTYPE
 #define SPI_GETCLEARTYPE 0x1048
 #endif


 fail_state=100;
 //smoothing&=1;
 while(1)
  {
  if(SystemParametersInfo(SPI_GETFONTSMOOTHING,0,&was_smooth,0)==0) { oow; }
  if(was_smooth==FALSE&&smoothing)
   {
   if(SystemParametersInfo(SPI_SETFONTSMOOTHING,TRUE,NULL,SPIF_SENDCHANGE)==0) { oow; }
   }
  //MapModePrevious=SetMapMode(aa.core_system.display_dc,MM_TEXT);
  //if(MapModePrevious==0) { oof; }
  if(font_height<0)
   {
   font_height=-MulDiv(aaNumAbs(font_height),GetDeviceCaps(aa.core_system.display_dc,LOGPIXELSY),72);
   }
  if((hfnt=CreateFont(font_height,font_width,0,0,weyght,
                        (italic==YES)?TRUE:FALSE,
                      (underline==YES)?TRUE:FALSE,
                      0,charset,OUT_DEFAULT_PRECIS,CLIP_DEFAULT_PRECIS,    smoothing,
                      (DEFAULT_PITCH|FF_DONTCARE),facetext))==NULL)     {                 fail_state=0;        break;                }
  if((dc=CreateCompatibleDC(aa.core_system.display_dc))==NULL)  { fail_state=2; break; }
  if((oldobj=SelectObject(dc,hfnt))==0)                   { fail_state=3; break; }
  if(GetTextFace(dc,64,fntp->status.face_name)==0)        { fail_state=4; break; }
  aaStringICompare(facetext,fntp->status.face_name,&res);
  if(res!=0)                                              { fail_state=4; break; }


  if(GetCharABCWidths(dc,0,255,charABCWidth)==FALSE)
   {
   if(GetCharWidth(dc,0,255,(LPINT)charWidth)==0) {   fail_state=5;   break; }
   for(i=0;i<256;i++)
    {
    fntp->status.char_lead[i]=fntp->status.char_gap[i]=0;
    fntp->status.char_width[i]=(B)charWidth[i];
    }
   }
  else
   {
   for(i=0;i<256;i++)
    {
    fntp->status.char_lead[i]=(I)charABCWidth[i].abcA;
    fntp->status.char_width[i]=(I)charABCWidth[i].abcB;
    fntp->status.char_gap[i]=(I)charABCWidth[i].abcC;
    }
   }
  if(GetTextMetrics(dc,&textmetrics)==0)     { fail_state=6; break; }
  fntp->size.w=textmetrics.tmMaxCharWidth;
  fntp->size.h=textmetrics.tmHeight;
  fntp->status.is_smoothed=smoothing;
  WinBmpInfoSet(&bitmapinfo,(fntp->size.w)*16,((fntp->size.h)*16),24,YES);
  if((hbmp=CreateDIBSection(NULL,(LPBITMAPINFO)&bitmapinfo,DIB_RGB_COLORS,(PP)&dib_data,NULL,0))==NULL) { fail_state=7; break; }
  if(SelectObject(dc,hbmp)==0) { fail_state=8; break; }
  grid_width=16*(fntp->size.w);
  for(i=0;i<128;i++)  // was 256
   {
   y_pos=(i/16)*(fntp->size.h);
   x_pos=(i%16)*(fntp->size.w);
   ot[0]=i;
   ot[1]=32;
   if(TextOut(dc,x_pos+0,y_pos,(CP)ot,2)==FALSE) { fail_state=9; break; }
   }
  break;
  }

 if(fail_state!=100)
  {
  //aaNote(0,"fs=%i",fail_state);
  if(fail_state>=4) SelectObject(dc,oldobj);
  if(fail_state>=1) DeleteObject(hfnt);
  if(fail_state>=8) DeleteObject(hbmp);
  if(fail_state>=3) {}
  aa_ObjectDestroy(aa.font_system.object_id,*handle);
  if(LOAD_MODE!=0)
   {
   if(LOAD_MODE==10) { RemoveFontMemResourceEx(memfont_resource_handle); }
   else              { RemoveFontResource((CP)facettfptr);  }
   }
  if(was_smooth==FALSE&&smoothing) { if(SystemParametersInfo(SPI_SETFONTSMOOTHING,FALSE,NULL,0)==0) { oow; } }
  *handle=0;
  return RET_FAILED;
  }


 w1=fntp->status.char_lead['.']+fntp->status.char_width['.']+fntp->status.char_gap['.'];
 for(i=0;i<256;i++)
  {
  w2=fntp->status.char_lead[i]+fntp->status.char_width[i]+fntp->status.char_gap[i];
  if(i>32&&w1!=w2)   {   break;   }
  }
 if(i>=127) fntp->status.is_mono_width=YES;
 fntp->status.charset=charset;

 if((ret=aa_MemoryAllocate((VP)&fntp->status.outline,(((fntp->size.w)*16)*(fntp->size.h))*16,"FontOutline",NO))!=RET_YES)
  {
  SelectObject(dc,oldobj);
  DeleteObject(hfnt);
  DeleteObject(hbmp);
  aa_ObjectDestroy(aa.font_system.object_id,*handle);
  if(LOAD_MODE!=0)
   {
   if(LOAD_MODE==10) { RemoveFontMemResourceEx(memfont_resource_handle);  }
   else              { RemoveFontResource((CP)facettfptr); }
   }
  if(was_smooth==FALSE&&smoothing) { if(SystemParametersInfo(SPI_SETFONTSMOOTHING,FALSE,NULL,0)==0) { oow; }  }
  *handle=0;
  return ret;
  }


 if((ret=aa_MemoryAllocate((VP)&fntp->status.img,(((fntp->size.w)*16)*(fntp->size.h))*16,"FontImg",NO))!=RET_YES)
  {
  SelectObject(dc,oldobj);
  DeleteObject(hfnt);
  DeleteObject(hbmp);
  aa_ObjectDestroy(aa.font_system.object_id,*handle);
  if(LOAD_MODE!=0)
   {
   if(LOAD_MODE==10) { RemoveFontMemResourceEx(memfont_resource_handle);  }
   else              { RemoveFontResource((CP)facettfptr); }
   }
  if(was_smooth==FALSE&&smoothing) { if(SystemParametersInfo(SPI_SETFONTSMOOTHING,FALSE,NULL,0)==0) { oow; }  }
  aaMemoryRelease(fntp->status.outline);
  *handle=0;
  return ret;
  }

 for(i=0;i<128;i++) //was 255
  {
  grid_offset=(i/16)*(grid_width*(fntp->size.h));
  grid_offset+=((i%16)*(fntp->size.w));
  for(y_pos=0;y_pos<(N)fntp->size.h;y_pos++)
   {
   img_offset=grid_offset+(grid_width*y_pos);
   aaCast(bp,BP,&fntp->status.img[img_offset]);
   dib_offset=(grid_offset*3)+(y_pos*(((fntp->size.w)*16)*3));
   for(x_pos=0;x_pos<(N)fntp->size.w;x_pos++)
    {
    //luminance=0.0;
    luminance=(D)(0.299*(D)dib_data[dib_offset+0]);
    luminance+=(D)(0.587*(D)dib_data[dib_offset+1]);
    luminance+=(D)(0.114*(D)dib_data[dib_offset+2]);
    luminance=aaNumClamp(luminance,0.0,255.0);
    alpha=(N)luminance;
    alpha=255-alpha;
    *bp++=(B)alpha;
    dib_offset+=3;
    }
   }
  }

 SelectObject(dc,oldobj);
 DeleteObject(hfnt);
 DeleteObject(hbmp);
 if(LOAD_MODE!=0)
  {
  if(LOAD_MODE==10) { RemoveFontMemResourceEx(memfont_resource_handle); }
  else              { RemoveFontResource((CP)facettfptr); }
  }
 if(was_smooth==FALSE&&smoothing) { if(SystemParametersInfo(SPI_SETFONTSMOOTHING,FALSE,NULL,0)==0) { oow; }  }
 fntp->status.curr_mono_size.w=0;
 for(i=0;i<127;i++)
  {
  w1=fntp->status.char_lead[i]+fntp->status.char_width[i]+fntp->status.char_gap[i];
  if(w1>=(W)fntp->status.curr_mono_size.w) { fntp->status.curr_mono_size.w=w1; fntp->status.mono_char=(B)i; }
  }
 fntp->status.curr_mono_size.h=fntp->size.h;
 fntp->status.logw=logw;
 fntp->status.logh=logh;
 aaSizeCopy(&fntp->status.init_mono_size,&fntp->status.curr_mono_size);

 smallest_x=1000000000;
 largest_x=-1000000;
 smallest_y=1000000000;
 largest_y=-1000000;

 newhit=fntp->size.h;
 for(ch=32;ch<128;ch++)
  {
  off=((ch>>4)*((fntp->size.w<<4)*fntp->size.h))+((ch&15)*(fntp->size.w));
  newwid=0;
  back=0;
  newwid+=((fntp->status.char_width[ch]));
  newwid+=((fntp->status.char_gap[ch]));
  newwid+=((fntp->status.char_lead[ch]));
  back=+0;
  if(fntp->status.is_italic) { newwid+=3; back=+3; }
  firstx=lastx=-1;
  firsty=lasty=-1;
  for(yy=0;yy<newhit;yy++)
   {
   to=off+((fntp->size.w<<4)*yy);
   to+=back;
   for(xx=0;xx<newwid;xx++)
    {
    alpha=fntp->status.img[to+xx];
    if(alpha==0)                { continue; }
    if(firsty==-1) { firsty=yy; }
    if(firstx==-1) { firstx=xx; }
    lasty=yy;
    lastx=xx;
    }
   }
  if(firstx!=-1&&lastx!=-1&&firsty!=-1&&lasty!=-1)
   {
   if(firstx<smallest_x) { smallest_x=firstx;  }
   if(firsty<smallest_y) { smallest_y=firsty;  }
   if(lastx>largest_x) { largest_x=lastx;  }
   if(lasty>largest_y) { largest_y=lasty;  }
   }
  }
 fntp->status.size.w=(largest_x)+1; // was+1
 fntp->status.size.h=(largest_y)+1; // was+1

 for(fxi=32;fxi<128;fxi++)
  {
  ch=fxi;
  off=((ch>>4)*((fntp->size.w<<4)*fntp->size.h))+((ch&15)*(fntp->size.w));
  back=0;
  newhit=fntp->status.size.h;
  newwid=0;
  newwid+=((fntp->status.char_width[ch]));
  newwid+=((fntp->status.char_gap[ch]));
  newwid+=((fntp->status.char_lead[ch]));
  back=+0;
  if(fntp->status.is_italic) { newwid+=3; back=+3; }
  to=off+((fntp->size.w<<4)*0)+back;
  ww=newwid;
  hh=newhit;
  stride=(fntp->size.w<<4);
  for(yy=0;yy<hh;yy++)
   {
   for(xx=0;xx<ww;xx++)
    {
    ptr=&fntp->status.img[to];
    optr=&fntp->status.outline[to];
    alpha=ptr[(yy*stride)+xx];
    on_count=0;
    while(1)
     {
     if(yy>0&&xx>0          )  { shad[0]=ptr[((yy-1)*stride)+(xx-1)]; if(shad[0]) {   on_count++; } else break; }
     if(yy>0                )  { shad[1]=ptr[((yy-1)*stride)+(xx+0)]; if(shad[1]) {   on_count++; } else break; }
     if(yy>0&&(xx+1)<ww     )  { shad[2]=ptr[((yy-1)*stride)+(xx+1)]; if(shad[2]) {   on_count++; } else break; }
     if(xx>0                )  { shad[3]=ptr[((yy-0)*stride)+(xx-1)]; if(shad[3]) {   on_count++; } else break; }
     if(1                   )  { shad[4]=ptr[((yy-0)*stride)+(xx+0)]; if(shad[4]) {   on_count++; } else break; } //
     if((xx+1)<ww           )  { shad[5]=ptr[((yy-0)*stride)+(xx+1)]; if(shad[5]) {   on_count++; } else break; }
     if(xx>0&&(yy+1)<hh     )  { shad[6]=ptr[((yy+1)*stride)+(xx-1)]; if(shad[6]) {   on_count++; } else break; }
     if((yy+1)<hh           )  { shad[7]=ptr[((yy+1)*stride)+(xx+0)]; if(shad[7]) {   on_count++; } else break; }
     if((xx+1)<ww&&(yy+1)<hh)  { shad[8]=ptr[((yy+1)*stride)+(xx+1)]; if(shad[8]) {   on_count++; } else break; }
     break;
     }
    if(on_count==9) { alpha=0; }
    optr[(yy*stride)+xx]=alpha;
    }
   }
  }


 fntp->instance++;
 return RET_YES;
 }






 B aaFontCreateUsingResource           (HP handle,H resnum,N logw,N logh,B weight,B italic,B underline,B smoothing,H charset)
 {
 B ret;
 B path[MAX_PATH];
 B file[33];
 B filename[MAX_PATH];
 H bytes,ha;
 _aa_fontobject*fntp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==NULL) { return RET_BADPARM; }
 *handle=0;
 if(aa_FontSystemFind(&ha,0,resnum,logw,logh,weight,italic,underline,smoothing,charset)==RET_YES)
  {
  if((ret=aa_ObjectCheck(aa.font_system.object_id,ha,(VP)&fntp,0))!=RET_YES) { oops; }
  fntp->instance++;
  if(handle) { *handle=ha; }
  return RET_YES;
  }

 GetTempPath(MAX_PATH,(CP)path);
 while(1)
  {
  aaStringRandomSet(file,8,YES,NO,YES,YES);
  aaStringCopyf(filename,"%s%s.ttf",path,file);
  if(aaFileInfoGet(filename,NULL,NULL,NULL,NULL,NULL)==RET_NOTFOUND) { break; }
  break;
  }
 if((ret=aaResourceToFile(resnum,&bytes,filename))!=RET_YES) {  return ret; }
 ret=aaFontCreate(handle,filename,logw,logh,weight,italic,underline,smoothing,charset);
 if(ret!=RET_YES) { return ret; }
 if((ret=aa_ObjectCheck(aa.font_system.object_id,*handle,(VP)&fntp,NULL))!=RET_YES) { oops; }
 fntp->status.res_num=resnum;
 return RET_YES;
 }









 B aaFontDestroy                       (H handle)
 {
 B ret;
 _aa_fontobject*fntp;
 B isprot;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.font_system.object_id,handle,(VP)&fntp,&isprot))!=RET_YES) { return ret; }
 if(isprot==YES) { return RET_FORBIDDEN; }
 fntp->instance--;
 if(fntp->instance!=0) { return RET_YES; }
 if((ret=aa_MemoryRelease(fntp->status.img))!=YES) { oops; }
 if(fntp->status.outline) { if((ret=aa_MemoryRelease(fntp->status.outline))!=YES) { oops; } }
 aa_ObjectDestroy(aa.font_system.object_id,handle);
 return RET_YES;
 }




 B aaFontMonoForceSet                  (H handle,B state)
 {
 B ret;
 _aa_fontobject*fntp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==0) {  handle=aa.font_system.font_8x8;  }
 if((ret=aa_ObjectCheck(aa.font_system.object_id,handle,(VP)&fntp,NULL))!=RET_YES) { return ret; }
 if(state==YES) { fntp->status.is_mono_forced=YES; }
 else           { fntp->status.is_mono_forced=NO; }
 return RET_YES;
 }




 B aaFontMonoForceSizeSet              (H handle,_size*size)
 {
 B ret;
 _aa_fontobject*fntp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==0) {  handle=aa.font_system.font_8x8;  }
 if((ret=aa_ObjectCheck(aa.font_system.object_id,handle,(VP)&fntp,NULL))!=RET_YES) { return ret; }
 if(size==NULL)
  {
  aaSizeCopy(&fntp->status.curr_mono_size,&fntp->status.init_mono_size);
  }
 else
  {
  if(size->w!=0) fntp->status.curr_mono_size.w=size->w;
  if(size->h!=0) fntp->status.curr_mono_size.h=size->h;
  fntp->status.curr_mono_size.w=aaNumFloor(fntp->status.curr_mono_size.w,1);
  fntp->status.curr_mono_size.h=aaNumFloor(fntp->status.curr_mono_size.h,1);
  }
 return RET_YES;
 }




 B aaFontStatus                        (H handle,_fontstatus*fontstatus)
 {
 B ret;
 _aa_fontobject*fntp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==0) {  handle=aa.font_system.font_8x8;  }
 if((ret=aa_ObjectCheck(aa.font_system.object_id,handle,(VP)&fntp,NULL))!=RET_YES) { return ret; }
 if(fontstatus) { aaMemoryCopy(fontstatus,sizeof(_fontstatus),&fntp->status); }
 return RET_YES;
 }






 B aaFontStringSizeGet                 (H handle,_size*size,H maxchars,VP fmt,...)
 {
 B ret;
 _aa_fontobject*fntp;
 va_list argptr;
 B ch,txt[_64K];
 H sl;
 N s,newwid,wid;
 H lines;
 H bigwid;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,txt);
 if(handle==0) {  handle=aa.font_system.font_8x8;  }
 if((ret=aa_ObjectCheck(aa.font_system.object_id,handle,(VP)&fntp,NULL))!=RET_YES) { return ret; }
 if((ret=aaFontStatus(handle,0))!=RET_YES) { oops; }
 if(size==NULL) { return RET_BADPARM; }
 aaStringLen(txt,&sl);
 if(maxchars==0) { maxchars=sl; }
 if(maxchars>sl) { maxchars=sl; }
 sl=maxchars;
 if(sl==0)   {   aaSizeSet(size,0,0); return RET_YES;   }
 wid=0;
 lines=1;
 bigwid=0;
 for(s=0;s<(N)sl;s++)
  {
  ch=(B)txt[s];
  if(ch==10) { lines++; wid=0; }
  else
  if(ch>=32)
   {
   if(fntp->status.is_mono_forced==NO)    {    newwid=(fntp->status.char_lead[ch]+fntp->status.char_width[ch])+fntp->status.char_gap[ch];    }
   else                                   {    newwid=fntp->status.curr_mono_size.w;    }
   wid+=newwid;
   if(wid>(N)bigwid) { bigwid=wid; }
   }
  }
 aaSizeSet(size,bigwid,(fntp->status.size.h+0)*lines);
 return RET_YES;
 }




 B aaFontStringSizeFit                 (H handle,_size*size,_size*rsize,VP rstr,VP fmt,...)
 {
 B ret;
 _aa_fontobject*fntp;
 B str[_32K];
 B linstr[_32K];
 va_list argptr;
 H fh,lines,off,li;
 H sc,tc,ok,pos,sl;
 _size sz1;
 _rect rc1;
 _fontstatus fs;
 _size szreq;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,str);
 if((ret=aa_ObjectCheck(aa.font_system.object_id,handle,(VP)&fntp,NULL))!=RET_YES) { return ret; }
 if(size) { aaSizeCopy(&szreq,size); }
 else     { return RET_BADPARM; }
 if(szreq.w==0) { return RET_BADPARM; }
 if(szreq.h==0) { return RET_BADPARM; }
 if(rstr!=NULL) { aaStringNull(rstr); }
 fh=handle;
 aaFontStatus(fh,&fs);
 rego:
  while(1)
   {
   aaFontStringSizeGet(fh,&sz1,0,"%s",str);
   aaRectSet(&rc1,0,0,szreq.w,szreq.h);
   if(rc1.w>=sz1.w) { break; }
   aaStringLineCountGet(str,0,&lines);
   lines++;
   off=0;
   for(li=0;li<lines;li++)
    {
    if(aaStringLineGet(&str[off],0,&sc,0,&tc,0)!=YES) { break; }
    if(tc==0) { break; }
    if(sc==0) { off+=tc; continue; }
    aaStringNCopy(linstr,&str[off],sc,YES);
    ok=0;
    while(1)
     {
     if((ret=aaFontStringSizeGet(fh,&sz1,0,"%s",linstr))!=YES) { oops; }
     aaRectSet(&rc1,0,0,szreq.w,szreq.h);
     if(rc1.w>=sz1.w) { break; }
     if(aaStringFindCharVisible(linstr,0,&pos,NO,0,NO)!=YES)
      {
      aaStringLen(linstr,&sl);
      pos=sl/2;
      }
     ok++;
     linstr[pos]=NULL_CHAR;
     }
    if(ok) { str[off+pos]=LF_CHAR; goto rego; }
    off+=tc;
    }
   break;
   }
 if(rsize==NULL) { aaSizeSet(size,szreq.w,sz1.h); }
 else            { aaSizeSet(rsize,szreq.w,sz1.h); }
 if(rstr) { aaStringCopy(rstr,str); }
 return RET_YES;
 }





 B aaFontCharRectGet                   (H handle,_rect*rect,B ch)
 {
 B ret;
 _aa_fontobject*fntp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==0) {  handle=aa.font_system.font_8x8;  }
 if((ret=aa_ObjectCheck(aa.font_system.object_id,handle,(VP)&fntp,NULL))!=RET_YES) { return ret; }
 if(rect==NULL) { return RET_BADPARM; }
 aaRectSet(rect,0,0,0,fntp->status.size.h+0);
 if(fntp->status.is_mono_forced) { rect->w=fntp->status.curr_mono_size.w;   }
 else                            { rect->w=(fntp->status.char_lead[ch]+fntp->status.char_width[ch])+fntp->status.char_gap[ch];   }
 return RET_YES;
 }






 B aaFontStringCharRectsGet            (H handle,H maxrects,_rect*rects,H maxchars,VP fmt,...)
 {
 B ret;
 _aa_fontobject*fntp;
 va_list argptr;
 B ch,txt[_64K];
 H sl;
 N x,s,newwid;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,txt);
 if(handle==0) {  handle=aa.font_system.font_8x8;  }
 if((ret=aa_ObjectCheck(aa.font_system.object_id,handle,(VP)&fntp,NULL))!=RET_YES) { return ret; }
 if(rects==NULL) { return RET_BADPARM; }
 aaStringLen(txt,&sl);
 if(maxchars==0)  { maxchars=sl; }
 if(maxchars>sl)  { maxchars=sl; }
 sl=maxchars;
 aaRectSet(&rects[0],0,0,0,fntp->status.size.h+0);
 if(sl==0)   {    return RET_YES;   }
 x=0;
 for(s=0;s<(N)sl;s++)
  {
  ch=(B)txt[s];
  if(fntp->status.is_mono_forced) { newwid=fntp->status.curr_mono_size.w;   }
  else                            { newwid=(fntp->status.char_lead[ch]+fntp->status.char_width[ch])+fntp->status.char_gap[ch];   }
  aaRectSet(&rects[s],x,0,newwid,fntp->status.size.h+0);
  if((H)s>=maxrects) { break; }
  x+=newwid;
  }
 aaRectSet(&rects[s],x,0,0,fntp->status.size.h+0);
 return RET_YES;
 }






 B aaFontStringCharRectGet             (H handle,_rect*rect,H pos,H maxchars,VP fmt,...)
 {
 B ret;
 _aa_fontobject*fntp;
 va_list argptr;
 B ch,txt[_64K];
 H sl;
 N x,s,newwid;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,txt);
 if(handle==0) {  handle=aa.font_system.font_8x8;  }
 if((ret=aa_ObjectCheck(aa.font_system.object_id,handle,(VP)&fntp,NULL))!=RET_YES) { return ret; }
 if(rect==NULL) { return RET_BADPARM; }
 aaStringLen(txt,&sl);
 if(maxchars==0)  { maxchars=sl; }
 if(maxchars>sl)  { maxchars=sl; }
 sl=maxchars;
 if(pos>sl) { pos=sl; }
 aaRectSet(rect,0,0,1,fntp->status.size.h+0);
 if(sl==0)   {    return RET_YES;   }
 x=0;
 newwid=fntp->status.curr_mono_size.w;
 for(s=0;s<(N)sl;s++)
  {
  ch=(B)txt[s];
  if(fntp->status.is_mono_forced==NO)
   {
   newwid=(fntp->status.char_lead[ch]+fntp->status.char_width[ch])+fntp->status.char_gap[ch];
   }
  else
   {
   newwid=fntp->status.curr_mono_size.w;
   }
  if(s==(N)pos) { break; }
  x+=newwid;
  }
 aaRectSet(rect,x,0,newwid,fntp->status.size.h+0);
 if(pos==sl) rect->w=1;
 return RET_YES;
 }







 B aaFontStringPixelsGet               (H handle,_fontpixel**fontpixel,HP entries,H maxchars,VP fmt,...)
 {
 B ret;
 _aa_fontobject*fntp;
 va_list argptr;
 B txt[_64K];
 H sl,off,back,to;
 N newwid,newhit,s;
 B ch;
 _cord ccc,cz;
 _fontpixel*fpxp;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.font_system.object_id,handle,(VP)&fntp,NULL))!=RET_YES) { return ret; }
 aaFmt(fmt,argptr,txt);
 if(entries) { *entries=0; }
 aaStringLen(txt,&sl);
 if(sl==0)   {   return RET_YES;   }
 if(maxchars==0) maxchars=sl;
 if(sl>maxchars) sl=maxchars;

 newhit=fntp->status.size.h;

 aaCordSet(&cz,0,0);
 ccc.x=cz.x;
 ccc.y=cz.y;
 aa.font_system.font_pixel.count=0;

 for(s=0;s<(N)sl;s++)
  {
  ch=(B)txt[s];
  off=((ch>>4)*((fntp->size.w<<4)*fntp->size.h))+((ch&15)*(fntp->size.w));
  back=0;
  newwid=0;
  newwid+=((fntp->status.char_width[ch]));
  newwid+=((fntp->status.char_gap[ch]));
  newwid+=((fntp->status.char_lead[ch]));
  back=+0;
  if(fntp->status.is_italic) { newwid+=3; back=+3; }
  to=off+((fntp->size.w<<4)*0)+back;

  if(s>=(N)aa.font_system.font_pixel.slots)
   {
   aa_FontSystemPixelSlotsExpand();
   }
  fpxp=(_fontpixel*)aa.font_system.font_pixel.mem;

  if(fontpixel)
   {
   fpxp[s].ch=ch;
   fpxp[s].rect.x=ccc.x;
   fpxp[s].rect.y=ccc.y;
   fpxp[s].rect.w=newwid;
   fpxp[s].rect.h=newhit;
   fpxp[s].stride=(fntp->size.w<<4);
   fpxp[s].ptr=&fntp->status.img[to];
   fpxp[s].optr=&fntp->status.outline[to];
   }
  ccc.x+=newwid;
  if(fntp->status.is_mono_forced==YES)
   {
   ccc.x-=newwid;
   if(newwid<(N)fntp->status.init_mono_size.w) {   ccc.x+=(fntp->status.curr_mono_size.w*.7);      }
   else                                        {   ccc.x+=(fntp->status.curr_mono_size.w);      }
   }
  }

 aa.font_system.font_pixel.count=s;
 if(fontpixel) {  fpxp[s].ptr=NULL; }
 if(fontpixel) {  *fontpixel=aa.font_system.font_pixel.mem; }
 if(entries) { *entries=s; }
 return RET_YES;
 }





 B aaFontStringPixelsRectGet           (H handle,_fontpixel*fontpixel,H entries,H start,H chars,_rect*rect)
 {
 B ret;
 _aa_fontobject*fntp;
 H j,k;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.font_system.object_id,handle,(VP)&fntp,NULL))!=RET_YES) { return ret; }
 if(fontpixel==NULL) { return RET_BADPARM; }
 if(entries==0xffffffff) { entries=aa.font_system.font_pixel.count; }
 if(entries>aa.font_system.font_pixel.count) { return RET_BOUNDS; }
 if(start>=entries) { return RET_BOUNDS; }
 if(chars==0) { chars=entries-start; }
 if((start+chars)>entries) { return RET_BOUNDS; }
 if(rect)
  {
  rect->x=0;
  rect->y=0;
  rect->w=fntp->status.curr_mono_size.w;
  rect->h=fntp->status.curr_mono_size.h;
  }
 if(chars==0)
  {
  return RET_YES;
  }
 j=start;
 k=(start+chars)-1;
 if(rect)
  {
  rect->x=fontpixel[j].rect.x;
  rect->y=fontpixel[j].rect.y;
  rect->w=(fontpixel[k].rect.x+fontpixel[k].rect.w)-(fontpixel[j].rect.x);
  rect->h=(fontpixel[k].rect.y+fontpixel[k].rect.h)-(fontpixel[j].rect.y);
  }
 return RET_YES;
 }






 B aaFontFamilyList                    (_data*data)
 {
 B ret;
 HDC dc;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(data==NULL) { return RET_BADPARM; }
 if((ret=aaDataAllocate(data))!=YES) { oops; }
 dc=GetDC(GetDesktopWindow());
 EnumFontFamilies(dc,NULL,(FONTENUMPROC)aa_FontCallBack,(LPARAM)data);
 ReleaseDC(GetDesktopWindow(),dc);
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/




 B aaPixelStyleInit                    (_pixelstyle*pixelstyle)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 aaMissingParm(pixelstyle);
 aaMemoryFill(pixelstyle,sizeof(_pixelstyle),0);
 return RET_YES;
 }




 B aaPixelStyleSet                     (_pixelstyle*pixelstyle,H setbit,B mode,N np0,N np1,N np2,N np3,D dp0,D dp1,H applyhandle)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 aaMissingParm(pixelstyle);
 if(aaBitGet(setbit,0)) { pixelstyle->mode=mode;  }
 if(aaBitGet(setbit,1)) { pixelstyle->nparm0=np0; }
 if(aaBitGet(setbit,2)) { pixelstyle->nparm1=np1; }
 if(aaBitGet(setbit,3)) { pixelstyle->nparm2=np2; }
 if(aaBitGet(setbit,4)) { pixelstyle->nparm3=np3; }
 if(aaBitGet(setbit,5)) { pixelstyle->dparm0=dp0; }
 if(aaBitGet(setbit,6)) { pixelstyle->dparm1=dp1; }
 if(applyhandle)
  {
  if((ret=aa_ObjectCheck(aa.surface_system.object_id,applyhandle,(VP)&surp,NULL))!=RET_YES) { oops; return ret; }
  if((ret=aaSurfacePixelStyleSet(applyhandle,pixelstyle))!=YES) { oops; }
  }
 return RET_YES;
 }



 B aaSurfacePixelStyleThickSet         (H handle,_pixelstyle*pixelstylesave,N wid,N hit)
 {
 B ret;
 _aa_surfaceobject*surp;
 _pixelstyle pstyle;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(wid<=0||hit<=0) { return RET_BADPARM; }
 if(pixelstylesave) { aaSurfacePixelStyleGet(handle,pixelstylesave); }
 aaPixelStyleInit(&pstyle);
 aaPixelStyleSet(&pstyle,7,1,(wid),(hit),0,0,0,0,handle);
 //aaPixelStyleSet(&pstyle,31,5,1,1,2,2,0,0,handle);
 return RET_YES;
 }


/*-----------------------------------------------------------------------*/




 B aaSurfaceCreate                     (HP handle,_size*size)
 {
 B ret;
 _aa_surfaceobject*surp;
 H bytes;
 BP mem;
 BP memb;
 //BP rmem;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aaSizeIsValid(size)!=RET_YES) { return RET_BADPARM; }
 logg("Creating a surface %ix%i",size->w,size->h);
 bytes=(size->w*sizeof(_rgba)*size->h);
 if((ret=aa_MemoryAllocate((VP)&mem,bytes,"Surface",NO))!=RET_YES) { oops; return ret; }

 //if((ret=aa_MemoryAllocate((VP)&rmem,bytes,"Surface-Ret",NO))!=RET_YES) { aa_MemoryRelease(mem); oops; return ret; }
 if((ret=aa_ObjectCreate(aa.surface_system.object_id,handle,(VP)&surp))!=RET_YES) { oops; aa_MemoryRelease(mem); return ret;  }
 surp->self_handle=*handle;
 surp->status.self_handle=*handle;
 surp->spot_id_counter=100;
 aaSizeCopy(&surp->status.initial_size,size);
 aaSizeCopy(&surp->status.size,size);
 aaSizeCopy(&surp->status.initial_size,size);
 aaRectSet(&surp->status.rect,0,0,size->w,size->h);
 aaRectCopy(&surp->status.viewport_rect,&surp->status.rect);
 aaRectToCornerCords(&surp->status.rect,&surp->status.corner[0],&surp->status.corner[1],&surp->status.corner[2],&surp->status.corner[3]);
 surp->status.pixel_count=size->w*size->h;
 surp->status.real_pixel_count=surp->status.initial_size.w*surp->status.initial_size.h;
// aaCast(surp->status.pixel_mem,_rgba*,mem);
// surp->status.mem=surp->status.pixel_mem;
 surp->status.mem=(_rgba*)mem;
 surp->rgba_mem=surp->status.mem;

 if((ret=aa_MemoryAllocate((VP)&memb,bytes,"Surfaceb",NO))!=RET_YES) { oops; return ret; }
 surp->memb=(_rgba*)memb;

 //surp->status.overlay[0].mmm=surp->rgba_mem[0];
 //surp->status.overlay[0].state=1;
 //aaRectSet(&surp->status.overlay[0].rect,0,0,surp->status.size.w,surp->status.size.h);
 ///surp->status.overlay[0].alpha=255;


 aaSurfaceBlendSet(*handle,YES);
 aaSurfaceAlphaSet(*handle,0);
 aaSurfaceUpdateAreaReset(*handle);
 aaSurfaceMinMaxSizeSet(*handle,size,size);
// aaSizeCopy(&surp->base_size,size);
// aaSizeCopy(&surp->base_min_size,size);
// aaSizeCopy(&surp->base_max_size,size);

 return RET_YES;
 }



 B aaSurfaceMinMaxCreate               (HP handle,_size*size,_size*minsize,_size*maxsize)
 {
 B ret;
 //_aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==NULL) { return RET_BADPARM; }
 if(size==NULL) { return RET_BADPARM; }
 if(minsize==NULL) { return RET_BADPARM; }
 if(maxsize==NULL) { return RET_BADPARM; }
 if(aaSizeIsValid(size)!=YES) { return RET_BADPARM; }
 if(aaSizeIsValid(minsize)!=YES) { return RET_BADPARM; }
 if(aaSizeIsValid(maxsize)!=YES) { return RET_BADPARM; }
 if(minsize->w>maxsize->w) { return RET_BOUNDS; }
 if(minsize->h>maxsize->h) { return RET_BOUNDS; }
 if(size->w>maxsize->w) { return RET_BOUNDS; }
 if(size->h>maxsize->h) { return RET_BOUNDS; }
 if(minsize->w>size->w) { return RET_BOUNDS; }
 if(minsize->h>size->h) { return RET_BOUNDS; }
 if((ret=aaSurfaceCreate(handle,maxsize))!=YES) { return ret; }
 if(aaSurfaceMinMaxSizeSet(*handle,minsize,maxsize)!=YES) oof;

// if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
// aaSizeCopy(&surp->base_size,size);
 //aaSizeCopy(&surp->base_min_size,minsize);
 //aaSizeCopy(&surp->base_max_size,maxsize);

 if(aaSurfaceSizeSet(*handle,size)!=YES) oof;
 return RET_YES;
 }





 B aaSurfaceMake                       (HP handle,_size*size,VP mem)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aaSizeIsValid(size)!=RET_YES) { return RET_BADPARM; }
 if(mem==NULL) { return RET_BADPARM; }
 if((ret=aa_ObjectCreate(aa.surface_system.object_id,handle,(VP)&surp))!=RET_YES)  { oops; return ret;  }
 surp->self_handle=*handle;
 surp->status.self_handle=*handle;
 surp->spot_id_counter=100;
 aaSizeCopy(&surp->status.initial_size,size);
 aaSizeCopy(&surp->status.size,size);
 aaRectSet(&surp->status.rect,0,0,size->w,size->h);
 aaRectToCornerCords(&surp->status.rect,&surp->status.corner[0],&surp->status.corner[1],&surp->status.corner[2],&surp->status.corner[3]);
 aaCast(surp->status.mem,_rgba*,mem);
 surp->rgba_mem=surp->status.mem;

// surp->status.overlay[0].mmm=surp->rgba_mem[0];
// surp->status.overlay[0].state=1;
// aaRectSet(&surp->status.overlay[0].rect,0,0,surp->status.size.w,surp->status.size.h);
// surp->status.overlay[0].alpha=255;

 //surp->main_mem=surp->status.mem;
 surp->status.pixel_count=size->w*size->h;
 surp->status.real_pixel_count=surp->status.initial_size.w*surp->status.initial_size.h;
 surp->status.is_made=YES;

// aaSizeCopy(&surp->base_size,size);
 //aaSizeCopy(&surp->base_min_size,size);
 //aaSizeCopy(&surp->base_max_size,size);


 aaSurfaceBlendSet(*handle,YES);
 aaSurfaceAlphaSet(*handle,0);
 aaSurfaceUpdateAreaReset(*handle);
 return RET_YES;
 }




 B aaSurfaceReMake                     (H handle,_size*size,VP mem)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aaSizeIsValid(size)!=RET_YES) { return RET_BADPARM; }
 if(mem==NULL) { return RET_BADPARM; }
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(surp->status.is_made==NO) { return RET_FAILED; }
 aaSizeCopy(&surp->status.size,size);
 aaSizeCopy(&surp->status.initial_size,size);
 aaRectSet(&surp->status.rect,0,0,size->w,size->h);
 aaRectToCornerCords(&surp->status.rect,&surp->status.corner[0],&surp->status.corner[1],&surp->status.corner[2],&surp->status.corner[3]);
 surp->status.pixel_count=size->w*size->h;
 surp->status.real_pixel_count=surp->status.initial_size.w*surp->status.initial_size.h;
 aaCast(surp->status.mem,_rgba*,mem);
 //surp->main_mem=surp->status.mem;
 surp->rgba_mem=surp->status.mem;
 //surp->status.overlay[0].mmm=surp->rgba_mem[0];
 //surp->status.overlay[0].state=1;
 //aaRectSet(&surp->status.overlay[0].rect,0,0,surp->status.size.w,surp->status.size.h);
 //surp->status.overlay[0].alpha=255;

// aaSizeCopy(&surp->base_size,size);
 //aaSizeCopy(&surp->base_min_size,size);
 //aaSizeCopy(&surp->base_max_size,size);


 aaSurfaceUpdateAreaReset(handle);
 return RET_YES;
 }





 B aaSurfaceLoadFromMemory             (HP handle,H bytes,VP mem,VP useextension)
 {
 B ret;
 H filebytes;
 BP filemem;
 BP bp;
 H off,len;
 _aa_surfacebmpfilehdr bmpfilehdr;
 _aa_surfacebmpinfohdr bmpinfohdr;
 _aa_surfacewinbmpinfohdr winbmpinfohdr;
 _aa_surfaceos2bmpinfohdr os2bmpinfohdr;
 H bisize;
 register N i;
 N b,ncol,y,nbytes;
 _size sz;
 _rgba pal[256];
 H ih;
 _surfacestatus surface_status;
 BP imem;
 H dw,temp;
 B bit_state[32];
 _aa_pen16*p16;
 _aa_pen24*p24;
 _rgba*p32=0;
 B txt[_1K];
 N type;
 _cord cd;
 _rgba p1;
 _aa_surfacetgahdr tgahdr;
 B is_bottom_up;
 B interlace_type;
 B is_rle;
 B source_pixel_size;
 N block_count,x;
 N dup_pixel_count;
 H zerocount;
 upng_t*upng;
 _jpegdecctx jpg;




 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==NULL) { return RET_BADPARM; }
 *handle=0;

 if(useextension)
  {
  if(aaStringIsIString(useextension,&type,"bmp","jpg","tga","ico","png",NULL)!=YES)
   {
   if(aaStringIsIString(useextension,&type,".bmp",".jpg",".tga","ico","png",NULL)!=YES) { return RET_FAILED; }
   }
  }
 else
  {
  if(aaStringIsIString(txt,&type,"bmp","jpg","tga","ico","png",NULL)!=YES) { return RET_FAILED; }
  }

 filemem=mem;
 filebytes=bytes;
 aaCast(bp,BP,filemem);
 off=0;

 if(type==0) //////// BMP
  {
  len=sizeof(_aa_surfacebmpfilehdr);
  aaMemoryCopy(&bmpfilehdr,len,&bp[off]);
  off+=len;
  if(bmpfilehdr.type!=19778)  {   return RET_FAILED;  }
  len=sizeof(H);
  aaMemoryCopy(&bisize,len,&bp[off]);
  off+=len;
  if(bisize==40)
   {
   len=sizeof(_aa_surfacewinbmpinfohdr);
   aaMemoryCopy(&winbmpinfohdr,len,&bp[off]);
   off+=len;
   bmpinfohdr.width=winbmpinfohdr.width;
   bmpinfohdr.height=winbmpinfohdr.height;
   bmpinfohdr.bits=winbmpinfohdr.bits;
   bmpinfohdr.compression=winbmpinfohdr.compression;
   ncol=(bmpfilehdr.off_bits-54)/4;
   for(i=0;i<ncol;i++)
    {
    len=sizeof(_rgba);
    aaMemoryCopy(&pal[i],len,&bp[off]);
    off+=len;
    pal[i].a=0;
    }
   }
  else
  if(bisize==12)
   {
   len=sizeof(_aa_surfaceos2bmpinfohdr);
   aaMemoryCopy(&os2bmpinfohdr,len,&bp[off]);
   off+=len;
   bmpinfohdr.width=os2bmpinfohdr.width;
   bmpinfohdr.height=os2bmpinfohdr.height;
   bmpinfohdr.bits=os2bmpinfohdr.bits;
   bmpinfohdr.compression=0;
   ncol=(bmpfilehdr.off_bits-26)/3;
   for(i=0;i<ncol;i++)
    {
    len=sizeof(_rgba)-1;
    aaMemoryCopy(&pal[i],len,&bp[off]);
    off+=len;
    pal[i].a=0;
    }
   }
  else {  return RET_FAILED;  }
  aaSizeSet(&sz,bmpinfohdr.width,bmpinfohdr.height);
  if((ret=aaSurfaceCreate(&ih,&sz))!=RET_YES)
   {
   return ret;
   }
  aaSurfaceStatus(ih,&surface_status);
  aaCast(imem,BP,surface_status.mem);
  switch (bmpinfohdr.compression)
  {
  case 0:
  zerocount=0;
  for(y=0;y<(N)bmpinfohdr.height;y++)
   {
   if(bmpinfohdr.bits==1)
   {
   for(i=0;i<(N)bmpinfohdr.width;i++)
    {
    if((i%32)==0)
     {
     aaMemoryCopy(&dw,sizeof(H),&bp[off]);
     dw=aaNumSwapDword(dw);
     off+=4;
     for(b=0;b<32;b++)
      {
      bit_state[31-b]=(B)(dw&1);
      dw=dw>>1;
      }
     }
    if(bit_state[i%32]==YES)
     {
     aaMemoryCopy(&imem[(((bmpinfohdr.height-y)-1)*bmpinfohdr.width*4)+(i*4)],sizeof(_rgba),&col_black);
     }
    else
     {
     aaMemoryCopy(&imem[(((bmpinfohdr.height-y)-1)*bmpinfohdr.width*4)+(i*4)],sizeof(_rgba),&col_white);
     }
    }
   }
  else
  if(bmpinfohdr.bits==4)
   {
   for(i=0;i<(N)bmpinfohdr.width;i++)
    {
    if((i%8)==0)
     {
     aaMemoryCopy(&dw,sizeof(H),&bp[off]);
     off+=4;
     for(b=0;b<4;b++)
      {
      temp=dw&255;
      bit_state[b*2+1]=(B)(temp&15);
      temp=temp>>4;
      bit_state[b*2]=(B)(temp&15);
      dw=dw>>8;
      }
     }
    aaMemoryCopy(&imem[(((bmpinfohdr.height-y)-1)*bmpinfohdr.width*4)+(i*4)],sizeof(_rgba),&pal[bit_state[i%8]]);
    }
   }
  else
  if(bmpinfohdr.bits==8)
   {
   nbytes=0;
   for(i=0;i<(N)bmpinfohdr.width;i++)
    {
    aaMemoryCopy(&imem[(((bmpinfohdr.height-y)-1)*bmpinfohdr.width*4)+(i*4)],sizeof(_rgba),&pal[bp[off]]);
    off++;
    nbytes+=1;
    }
   nbytes=nbytes%4;
   if(nbytes!=0)
    {
    for(i=nbytes;i<4;i++)
     {
     off++;
     }
    }
   }
  else
  if(bmpinfohdr.bits==16)
   {
   nbytes=0;
   for(i=0;i<(N)bmpinfohdr.width;i++)
    {
    len=2;
    aaCast(p16,_aa_pen16*,&bp[off]);
    aaCast(p32,_rgba*,&imem[(((bmpinfohdr.height-y)-1)*bmpinfohdr.width*4)+(i*4)]);
    p32->r=(B)(p16->r<<3);
    p32->g=(B)(p16->g<<3);
    p32->b=(B)(p16->b<<3);
    off+=len;
    p32->a=255;
    nbytes+=2;
    }
   nbytes=nbytes%4;
   if(nbytes!=0)
    {
    for(i=nbytes;i<4;i++)
     {
     off++;
     }
    }
   }
  else
  if(bmpinfohdr.bits==24)
   {
   nbytes=0;
   for(i=0;i<(N)bmpinfohdr.width;i++)
    {
    len=3;
    aaCast(p32,_rgba*,&imem[(((bmpinfohdr.height-y)-1)*bmpinfohdr.width*4)+(i*4)]);
    p32->r=bp[off+2];
    p32->g=bp[off+1];
    p32->b=bp[off+0];
    p32->a=255;
    off+=len;
    nbytes+=3;
    }
   nbytes=nbytes%4;
   if(nbytes!=0)
    {
    for(i=nbytes;i<4;i++)
     {
     off++;
     }
    }
   }
  else
  if(bmpinfohdr.bits==32)
   {
   nbytes=0;
   for(i=0;i<(N)bmpinfohdr.width;i++)
    {
    len=4;
    aaCast(p32,_rgba*,&imem[(((bmpinfohdr.height-y)-1)*bmpinfohdr.width*4)+(i*4)]);
    p32->r=bp[off+2];
    p32->g=bp[off+1];
    p32->b=bp[off+0];
    p32->a=bp[off+3];
    if(p32->a==0) zerocount++;
    off+=len;
    nbytes+=4;
    }
   nbytes=nbytes%4;
   if(nbytes!=0)
    {
    for(i=nbytes;i<4;i++)
     {
     off++;
     }
    }
   }
  }
  if(bmpinfohdr.bits==32)
   {
   if(zerocount==(bmpinfohdr.width*bmpinfohdr.height))
    {
    for(y=0;y<(N)bmpinfohdr.height;y++)
     {
     for(i=0;i<(N)bmpinfohdr.width;i++)
      {
      aaCast(p32,_rgba*,&imem[(((bmpinfohdr.height-y)-1)*bmpinfohdr.width*4)+(i*4)]);
      p32->a=255;
      }
     }
    }
   }
  break;

  case 1: // rle8
  logg("Bitmap is rle8");
  aaSurfaceDestroy(ih);
  return RET_FAILED;

  case 2: // rle4
  logg("Bitmap is rle4");
  aaSurfaceDestroy(ih);
  return RET_FAILED;

  default:
  logg("Bitmap is other compression=%i",bmpinfohdr.compression);
  aaSurfaceDestroy(ih);
  return RET_FAILED;
  }
 *handle=ih;
 }
else
 if(type==1) ///////// jpeg
  {
  aa_JpegDecNew(&jpg,0);
  if((ret=aa_JpegDecDecompress(&jpg,filemem,(H)filebytes))!=YES) { oops; }
  aaSizeSet(&sz,jpg.width,jpg.height);
  if((ret=aaSurfaceCreate(&ih,&sz))!=RET_YES)
   {
   aa_JpegDecDelete(&jpg);
   return ret;
   }
  aaSurfaceStatus(ih,&surface_status);
  aaMemoryCopy(surface_status.mem,sz.w*sz.h*4,jpg.rgb);
  aa_JpegDecDelete(&jpg);
  *handle=ih;
  }
 else
 if(type==2) ///////// tga
  {
  if(filebytes<sizeof(tgahdr)) {  return RET_FAILED; }
  off=0;
  aaMemoryCopy(&tgahdr,sizeof(_aa_surfacetgahdr),&filemem[off]);
  if(tgahdr.bpp==15) tgahdr.bpp=16;
  source_pixel_size=(B)(tgahdr.bpp/7);
  off=sizeof(_aa_surfacetgahdr);
  is_bottom_up=(B)((tgahdr.flags&0x20)==0);
  interlace_type=(B)(tgahdr.flags>>6);
  if(tgahdr.pal_type>1||source_pixel_size<1||source_pixel_size>4||((tgahdr.flags&7)!=0)||interlace_type!=0)
   {
   return RET_FAILED;
   }
  block_count=dup_pixel_count=0;
  if(tgahdr.img_type>8) { is_rle=YES; tgahdr.img_type-=(B)8; }
  else                  { is_rle=NO; }
  switch (tgahdr.img_type)
   {
   case 1:   // Colormapped image
   logg("tga image type=%i",tgahdr.img_type);
   return RET_FAILED;

   case 2:   // RGB image
   switch (source_pixel_size)
    {
    case 2: // source->get_pixel_rows=get_16bit_row;
    case 3: // source->get_pixel_rows=get_24bit_row;
    case 4: // source->get_pixel_rows=get_32bit_row;
    break;
    default:
    logg("tga image type=2 ,pixel size=%i",source_pixel_size);
    return RET_FAILED;
    }
   break;
   case 3:   // Grayscale image
   logg("tga image type=%i",tgahdr.img_type);
   return RET_FAILED;
   default:
   logg("tga image type=%i",tgahdr.img_type);
   return RET_FAILED;
   }
  while(tgahdr.id_length--)
   {
   off++;
   }
 if(tgahdr.pal_colors>0)
  {
  if(tgahdr.pal_colors>256||tgahdr.first_color!=0)
   {
   return RET_FAILED;
   }
  }
 else
  {
  if(tgahdr.pal_type)
   {
   return RET_FAILED;
   }
  }
 aaSizeSet(&sz,tgahdr.width,tgahdr.height);
  if((ret=aaSurfaceCreate(&ih,&sz))!=RET_YES)
   {
   return ret;
   }
  aaSurfaceStatus(ih,&surface_status);
  aaCast(imem,BP,surface_status.mem);
 if(is_rle==NO)
  {
  if(source_pixel_size==2)
   {
   oof;
   Boop;
   aaCast(p16,_aa_pen16*,&filemem[off]);
   for(y=0;y<(N)sz.h;y++)
    {
    if(is_bottom_up) cd.y=(sz.h-y)-1;
    else               cd.y=y;
    cd.x=0;
    for(x=0;x<(N)sz.w;x++)
     {
     p32->r=(B)(p16->r<<3);
     p32->g=(B)(p16->g<<3);
     p32->b=(B)(p16->b<<3);
     p32->a=255;
     p16++;
     cd.x++;
     }
    }
   }
  else
  if(source_pixel_size==3)
   {
   Boop;
   aaCast(p24,_aa_pen24*,&filemem[off]);
   for(y=0;y<(N)sz.h;y++)
    {
    if(is_bottom_up) cd.y=(sz.h-y)-1;
    else             cd.y=y;
    cd.x=0;
    for(x=0;x<(N)sz.w;x++)
     {
     p32->r=p24->r;
     p32->g=p24->g;
     p32->b=p24->b;
     p32->a=255;
     p24++;
     cd.x++;
     }
    }
   }
  else
  if(source_pixel_size==4)
   {
   for(y=0;y<(N)sz.h;y++)
    {
    if(is_bottom_up) cd.y=(sz.h-y)-1;
    else             cd.y=y;
    aaCast(p32,_rgba*,&imem[(cd.y*sz.w*4)]);
    for(x=0;x<(N)sz.w;x++)
     {
     p32->r=bp[off+2];
     p32->g=bp[off+1];
     p32->b=bp[off+0];
     p32->a=255;
     p32++;
     off+=4;
     }
    }
   }
  }
 else /// handle rle
  {
  Boop;
  for(y=0;y<(N)sz.h;y++)
   {
   if(is_bottom_up) cd.y=(sz.h-y)-1;
   else             cd.y=y;
   aaCast(p32,_rgba*,&imem[(cd.y*sz.w*4)]);
   for(x=0;x<(N)sz.w;x++)
    {
    aa_SurfaceDecodeTgaRle(&dup_pixel_count,&block_count,&off,filemem,tgahdr.bpp,&p1);
    p32->r=p1.r;
    p32->g=p1.g;
    p32->b=p1.b;
    p32->a=255;
    p32++;
    off+=4;
    }
   }
  }
  *handle=ih;
  }
 else
 if(type==3) ///////// ico
  {
  oof;
  }
 else
 if(type==4) /// png
  {
  upng=aa_PngNewFromBytes(mem,bytes);
  if(upng==NULL) {  return RET_FAILED; }
  aaSizeSet(&sz,upng->width,upng->height);
  if((ret=aaSurfaceCreate(&ih,&sz))!=RET_YES)  {   aa_PngFree(upng);  return ret;   }
  aaSurfaceStatus(ih,&surface_status);
  aaCast(imem,BP,surface_status.mem);
  if(upng->color_type==PNG_RGBA&&upng->components==4&&upng->bpp==32&&upng->color_depth==8&&upng->format==PNG_RGBA8)
   {
   off=0;
   for(y=0;y<(N)sz.h;y++)
    {
    cd.y=sz.h-y-1;
//  cd.y=y; // ???
    off=(cd.y*sz.w*4);
    off=(sz.h-y-1)*sz.w*4;
    aaCast(p32,_rgba*,&imem[(cd.y*sz.w*4)]);
    for(x=0;x<(N)sz.w;x++)
     {
     p32->r=upng->buffer[off+0];
     p32->g=upng->buffer[off+1];
     p32->b=upng->buffer[off+2];
     p32->a=upng->buffer[off+3];
     off+=4;
     p32++;
     }
    }
   }
  else
  if(upng->color_type==PNG_RGB&&upng->components==3&&upng->bpp==24&&upng->color_depth==8&&upng->format==PNG_RGB8)
   {
   off=0;
   for(y=0;y<(N)sz.h;y++)
    {
    cd.y=sz.h-y-1;
//   cd.y=y;
    off=(cd.y*sz.w*3);
    off=(sz.h-y-1)*sz.w*3;
    aaCast(p32,_rgba*,&imem[(cd.y*sz.w*4)]);
    for(x=0;x<(N)sz.w;x++)
     {
     p32->r=upng->buffer[off+0];
     p32->g=upng->buffer[off+1];
     p32->b=upng->buffer[off+2];
     p32->a=255;
     off+=3;
     p32++;
     }
    }
   }
  else
   {
   aaSurfaceDestroy(ih);
   aa_PngFree(upng);
   return RET_NOTSUPPORTED;
   }
  aa_PngFree(upng);
  *handle=ih;
  return RET_YES;
  }
 return RET_YES;
 }





 B aaSurfaceLoad                       (HP handle,VP filename,VP useextension)
 {
 B ret;
 H filebytes;
 BP filemem;
 H sl,off;
 B txt[_1K];
 N type;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==NULL) { return RET_BADPARM; }
 *handle=0;
 if((ret=aaStringLen(filename,&sl))!=RET_YES) {  return ret; }
 if(sl>_1K) { return RET_BADPARM; }
 if(useextension)
  {
  if(aaStringIsIString(useextension,&type,"bmp","jpg","tga","ico","png",NULL)!=YES)
   {
   if(aaStringIsIString(useextension,&type,".bmp",".jpg",".tga","ico","png",NULL)!=YES) { return RET_FAILED; }
   }
  switch(type)
   {
   default: oof; break;
   case 0:   aaStringCopy(txt,"bmp"); break;
   case 1:   aaStringCopy(txt,"jpg"); break;
   case 2:   aaStringCopy(txt,"tga"); break;
   case 3:   aaStringCopy(txt,"ico"); break;
   case 4:   aaStringCopy(txt,"png"); break;
   }
  }
 else
  {
  aaStringCopy(txt,filename);
  aaStringReverse(txt,0,0,0);
  aaStringLower(txt,0,0);
  if(aaStringFindChar(txt,0,&off,'.',YES,0,YES)!=YES) {  return RET_FAILED; }
  aaStringReverse(txt,off,0,YES);
  if(aaStringIsIString(txt,&type,"bmp","jpg","tga","ico","png",NULL)!=YES) { return RET_FAILED; }
  }
 if((ret=aaFileLoadToMemory(filename,0,0xffffffff,(VP)&filemem,&filebytes))!=RET_YES) { return ret; }
 ret=aaSurfaceLoadFromMemory(handle,filebytes,filemem,txt);
 aaMemoryRelease(filemem);
 return ret;
 }






 B aaSurfaceLoadUsingResource          (HP handle,H resnum,VP useextension)
 {
 B ret;
 BP mem;
 H bytes;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==NULL) { return RET_BADPARM; }
 *handle=0;
 if((ret=aaResourceToMemory(resnum,&bytes,(VP)&mem))!=RET_YES) { return ret; }
 if((ret=aaSurfaceLoadFromMemory(handle,bytes,mem,useextension))!=RET_YES) { oops; }
 if((ret=aaMemoryRelease(mem))!=RET_YES) { oops; }
 return ret;
 }







 B aaSurfaceDuplicate                  (HP handle,H shandle)
 {
 B ret;
 _aa_surfaceobject*surp;
 _aa_surfaceobject*psurp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,shandle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if((ret=aaSurfaceCreate(handle,&surp->status.initial_size))!=RET_YES) { return ret; }
 if((ret=aaSurfaceSizeSet(*handle,&surp->status.size))!=RET_YES) { return ret; }
 if((ret=aaSurfaceViewportSet(*handle,&surp->status.viewport_rect))!=RET_YES) { return ret; }
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,*handle,(VP)&psurp,NULL))!=RET_YES) { return ret; }
 aaMemoryCopy(psurp->status.mem,psurp->status.pixel_count*sizeof(_rgba),surp->status.mem);
 return RET_YES;
 }




 B aaSurfaceFindByHwnd                 (HP handle,HWND hwnd)
 {
 _aa_surfaceobject*surp;
 H han;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle) { *handle=0; }
 if(hwnd==NULL) { return RET_BADPARM; }
 if(aa_SurfaceSystemFindSurfaceByHwnd(&han,(VP)&surp,hwnd)==YES)
  {
  if(handle) { *handle=han; }
  return RET_YES;
  }
 return RET_NOTFOUND;
 }




 B aaSurfaceSave                       (H handle,_rect*r1,B flip,B quality,VP filename)
 {
 B ret;
 _aa_surfaceobject*surp;
 _jpegctx jpegctx;
 N type;
 H file_handle;
 H outbytes,off;
 H y,c;
 B block[_16K];
 H sl;
 BP fnp;
 _memoryunit men;
 _rect rc;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(filename==NULL) { return RET_BADPARM; }
 aaCast(fnp,BP,filename);
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }

 if(r1==NULL) { aaRectSet(&rc,0,0,surp->status.size.w,surp->status.size.h); }
 else         { aaRectCopy(&rc,r1); }

 aaStringLen(fnp,&sl);
 if(aaStringIsIString(&fnp[sl-3],&type,"bmp","jpg","ico","png",NULL)!=YES)
  {
  if(aaStringIsIString(&fnp[sl-4],&type,".bmp",".jpg",".ico",".png",NULL)!=YES)
   {
   type=-1;
   }
  }
 file_handle=0;
 if(type!=1&&type!=2&&type!=3)  {  oof;  return RET_NOTSUPPORTED;  }

 if(type==1)
  {
  if((ret=aa_JpegNew(&jpegctx))!=YES) { oops; }
  if((ret=aa_JpegCompress(&jpegctx,quality,surp->status.size.w,surp->status.size.h,surp->status.mem))!=YES) { oops; }
  if((ret=aaFileSaveFromMemory(filename,(H)jpegctx.out_len,jpegctx.out.mem))!=YES) { oops; }
  if((ret=aa_JpegDelete(&jpegctx))!=YES) { oops; }
  return RET_YES;
  }

 if(type==2) //===ico
  {
  if(r1!=NULL) { oof; }
  if((ret=aaFileStreamCreate(&file_handle,fnp,YES,3,3,0,NO))!=RET_YES) {   return ret; }
  sl=0;
  *(WP)&block[sl]=0; sl+=2;
  *(WP)&block[sl]=1; sl+=2;
  *(WP)&block[sl]=1; sl+=2;
  *(BP)&block[sl]=(B)surp->status.size.w; sl++;
  *(BP)&block[sl]=(B)surp->status.size.h; sl++;
  *(BP)&block[sl]=0; sl++;
  *(BP)&block[sl]=0; sl++;
  *(WP)&block[sl]=1; sl+=2;
  *(WP)&block[sl]=32;   sl+=2;
  *(HP)&block[sl]=(surp->status.size.w*surp->status.size.h*4)+40; sl+=4;
  *(HP)&block[sl]=22; sl+=4;
  *(HP)&block[sl]=40; sl+=4;
  *(HP)&block[sl]=surp->status.size.w;   sl+=4;
  *(HP)&block[sl]=surp->status.size.h*2; sl+=4;
  *(WP)&block[sl]=1;  sl+=2;
  *(WP)&block[sl]=32; sl+=2;
  *(HP)&block[sl]=0; sl+=4;
  *(HP)&block[sl]=0; sl+=4;
  *(HP)&block[sl]=0; sl+=4;
  *(HP)&block[sl]=0; sl+=4;
  *(HP)&block[sl]=0; sl+=4;
  *(HP)&block[sl]=0; sl+=4;
  aaFileStreamWrite(file_handle,sl,block);
  if(flip!=YES) {  c=0; }
  else          {  c=surp->status.size.h-1; }
  for(y=0;y<surp->status.size.h;y++)
   {
   aaFileStreamWrite(file_handle,surp->status.size.w*4,&surp->status.mem[c*surp->status.size.w]);
   if(flip!=YES) { c++; }
   else          { c--; }
   }
  aaFileStreamDestroy(file_handle);
  return RET_YES;
  }
 if(type==3) //====png
  {
  off=(rc.y*surp->status.size.w)+rc.x;
  if((ret=aaMemoryUnitAllocate(&men,(sizeof(aa_png_header)+(((N)surp->status.size.w*4+6)*(N)surp->status.size.h)+8+sizeof(aa_png_trailer))))!=YES) { oops; }
  //if((ret=aa_PngFromImage(&surp->status.mem[off],surp->status.size.w,surp->status.size.h,surp->status.size.w,men.mem,men.bytes,&outbytes))!=YES) { oops; }
  if((ret=aa_PngFromImage(&surp->status.mem[off],rc.w,rc.h,surp->status.size.w,men.mem,men.bytes,&outbytes))!=YES) { oops; }
  if((ret=aaFileSaveFromMemory(filename,outbytes,men.mem))!=YES) { oops; }
  aaMemoryUnitRelease(&men);
  return RET_YES;
  }
 oof;
 return RET_YES;
 }








 B aaSurfaceSaveToMemory               (H handle,_rect*r1,B flip,B quality,VP useextension,HP bytes,H maxbytes,VP mem)
 {
 B ret;
 _aa_surfaceobject*surp;
 _aa_surfacebmpfilehdr bmpfilehdr;
 _aa_surfacewinbmpinfohdr winbmpinfohdr;
 _jpegctx jpegctx;
 N type;
 H y,c,sl;
 B block[_16K];
 _dynbufunit du;
 _memoryunit men;
 H outbytes;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bytes==NULL) { return RET_BADPARM; }
 *bytes=0;
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(useextension==NULL) {return RET_BADPARM; }
 if(maxbytes!=0&&mem==NULL) { return RET_BADPARM; }

 if(aaStringIsIString(useextension,&type,"bmp","jpg","ico","png",NULL)!=YES)
  {
  if(aaStringIsIString(useextension,&type,".bmp",".jpg",".ico",".png",NULL)!=YES) { return RET_FAILED; }
  }

 if(type==2)
  {
  return RET_NOTSUPPORTED;
  }

 if(type==1)
  {
  if((ret=aa_JpegNew(&jpegctx))!=YES) { oops; }
  if((ret=aa_JpegCompress(&jpegctx,quality,surp->status.size.w,surp->status.size.h,surp->status.mem))!=YES) { oops; }
  if(bytes) { *bytes=(H)jpegctx.out_len; }
  if((H)jpegctx.out_len>maxbytes)
   {
   if((ret=aa_JpegDelete(&jpegctx))!=YES) { oops; }
   return RET_BOUNDS;
   }
  if(mem!=NULL) { aaMemoryCopy(mem,(H)jpegctx.out_len,jpegctx.out.mem); }
  if((ret=aa_JpegDelete(&jpegctx))!=YES) { oops; }
  return RET_YES;
  }
 if(type==3)
  {
  ret=aaMemoryUnitAllocate(&men,(sizeof(aa_png_header)+(((N)surp->status.size.w*4+6)*(N)surp->status.size.h)+8+sizeof(aa_png_trailer)));
  if(ret!=YES) { oops; }
  ret=aa_PngFromImage(surp->status.mem,surp->status.size.w,surp->status.size.h,surp->status.size.w,men.mem,men.bytes,&outbytes);
  if(ret!=YES) { oops; }
  if(bytes) { *bytes=outbytes; }
  if(outbytes>maxbytes)
   {
   aaMemoryUnitRelease(&men);
   return RET_BOUNDS;
   }
  if(mem!=NULL) { aaMemoryCopy(mem,outbytes,men.mem); }
  aaMemoryUnitRelease(&men);
  return RET_YES;
  }




 if(type==2)
  {
  if(r1!=NULL) { oof; }
  aaDynbufCreate(&du.handle);
  sl=0;
  *(WP)&block[sl]=0; sl+=2;
  *(WP)&block[sl]=1; sl+=2;
  *(WP)&block[sl]=1; sl+=2;
  *(BP)&block[sl]=(B)surp->status.size.w; sl++;
  *(BP)&block[sl]=(B)surp->status.size.h; sl++;
  *(BP)&block[sl]=0; sl++;
  *(BP)&block[sl]=0; sl++;
  *(WP)&block[sl]=1; sl+=2;
  *(WP)&block[sl]=32;   sl+=2;
  *(HP)&block[sl]=(surp->status.size.w*surp->status.size.h*4)+40; sl+=4;
  *(HP)&block[sl]=22; sl+=4;
  *(HP)&block[sl]=40; sl+=4;
  *(HP)&block[sl]=surp->status.size.w;   sl+=4;
  *(HP)&block[sl]=surp->status.size.h*2; sl+=4;
  *(WP)&block[sl]=1;  sl+=2;
  *(WP)&block[sl]=32; sl+=2;
  *(HP)&block[sl]=0; sl+=4;
  *(HP)&block[sl]=0; sl+=4;
  *(HP)&block[sl]=0; sl+=4;
  *(HP)&block[sl]=0; sl+=4;
  *(HP)&block[sl]=0; sl+=4;
  *(HP)&block[sl]=0; sl+=4;
  aaDynbufAppend(du.handle,sl,block);
  if(flip!=YES) {  c=0; }
  else          {  c=surp->status.size.h-1; }
  for(y=0;y<surp->status.size.h;y++)
   {
   aaDynbufAppend(du.handle,surp->status.size.w*4,&surp->status.mem[c*surp->status.size.w]);
   if(flip!=YES) { c++; }
   else          { c--; }
   }
  aaDynbufStatus(du.handle,&du.status);
  if(bytes) { *bytes=du.status.bytes_used; }
  if(du.status.bytes_used>maxbytes) { aaDynbufDestroy(du.handle); return RET_BOUNDS; }
  if(mem!=NULL) { aaMemoryCopy(mem,du.status.bytes_used,du.status.mem); }
  aaDynbufDestroy(du.handle);
  return RET_YES;
  }

 aaDynbufCreate(&du.handle);
 aaMemoryFill(&bmpfilehdr,sizeof(bmpfilehdr),0);
 aaMemoryFill(&winbmpinfohdr,sizeof(winbmpinfohdr),0);
 if(r1==NULL)
  {
  bmpfilehdr.type=19778;
  bmpfilehdr.size=54+(surp->status.size.w*surp->status.size.h*4);
  bmpfilehdr.off_bits=54;
  winbmpinfohdr.width=surp->status.size.w;
  winbmpinfohdr.height=surp->status.size.h;
  winbmpinfohdr.planes=1;
  winbmpinfohdr.bits=32;
  winbmpinfohdr.compression=BI_RGB;
  winbmpinfohdr.imgsize=surp->status.size.w*surp->status.size.h*4;
  aaDynbufAppend(du.handle,sizeof(bmpfilehdr),&bmpfilehdr);
  c=40;
  aaDynbufAppend(du.handle,sizeof(H),&c);
  aaDynbufAppend(du.handle,sizeof(winbmpinfohdr),&winbmpinfohdr);
  if(flip==YES) {  c=0; }
  else          {  c=surp->status.size.h-1; }
  for(y=0;y<surp->status.size.h;y++)
   {
   aaMemoryCopy(block,surp->status.size.w*4,&surp->status.mem[c*surp->status.size.w]);
   aaDynbufAppend(du.handle,surp->status.size.w*4,block);
   if(flip==YES) { c++; }
   else          { c--; }
   }
  }
 else
  {
  if(r1->w==0||r1->h==0) { aaDynbufDestroy(du.handle); return RET_FAILED; }
  bmpfilehdr.type=19778;
  bmpfilehdr.size=54+(r1->w*r1->h*4);
  bmpfilehdr.off_bits=54;
  winbmpinfohdr.width=r1->w;
  winbmpinfohdr.height=r1->h;
  winbmpinfohdr.planes=1;
  winbmpinfohdr.bits=32;
  winbmpinfohdr.compression=BI_RGB;
  winbmpinfohdr.imgsize=r1->w*r1->h*4;
  aaDynbufAppend(du.handle,sizeof(bmpfilehdr),&bmpfilehdr);
  c=40;
  aaDynbufAppend(du.handle,sizeof(H),&c);
  aaDynbufAppend(du.handle,sizeof(winbmpinfohdr),&winbmpinfohdr);
  if(flip==YES) {  c=r1->y; }
  else          {  c=(r1->y+r1->h)-1; }
  for(y=0;y<r1->h;y++)
   {
   aaMemoryCopy(block,r1->w*4,&surp->status.mem[(c*surp->status.size.w)+(r1->x)]);
   aaDynbufAppend(du.handle,r1->w*4,block);
   if(flip==YES) { c++; }
   else          {  c--; }
   }
  }

 aaDynbufStatus(du.handle,&du.status);
 if(bytes) { *bytes=du.status.bytes_used; }
 if(du.status.bytes_used>maxbytes) { aaDynbufDestroy(du.handle);  return RET_BOUNDS; }
 if(mem!=NULL) { aaMemoryCopy(mem,du.status.bytes_used,du.status.mem); }
 aaDynbufDestroy(du.handle);
 return RET_YES;
 }




 B aaSurfaceDestroy                    (H handle)
 {
 B ret;
 _aa_surfaceobject*surp;
 _aa_surfaceobject*psurp;
 B isprot,loopfull;
 _aa_surfaceobject*csurp;
 H it,han;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,&isprot))!=RET_YES) { return ret; }
 if(isprot==YES) { return RET_FORBIDDEN; }
 if(surp->status.is_visual==YES)
  {
  if(surp->status.is_systray==YES) {  aaSurfaceTraySet(handle,0,NULL); surp->status.is_systray=NO; }
  if(surp->status.is_rounded!=0)
   {
   if(SetWindowRgn(surp->status.hwnd,NULL,YES)==0)  { oof; }
   DeleteObject(surp->status.region);
   surp->status.region=NULL;
   surp->status.is_rounded=NO;
   }
  }
 if(surp->status.is_child==YES)
  {
  if((ret=aa_ObjectCheck(aa.surface_system.object_id,surp->status.parent_handle,(VP)&psurp,0))!=RET_YES) { oops; }
  if(psurp->status.is_parent!=YES) { oof; }
  if(psurp->status.child_count==0) { oof; }
  SetParent(surp->status.hwnd,NULL);
  psurp->status.child_count--;
  if(psurp->status.child_count==0) { psurp->status.is_parent=NO; }
  }
 if(surp->status.is_parent==YES)
  {
  it=0;
  loopfull=0;
  while(1)
   {
   ret=aa_ObjectNext(aa.surface_system.object_id,&han,(VP)&csurp,&it);
   if(ret==RET_NOTFOUND) { aaNote(0,"cc=%i",surp->status.child_count); break; }
   if(ret!=YES) { oops; }
   if(handle==han)
    {
    loopfull++;
    if(loopfull==2) { break; }
    continue;
    }
   if(csurp->status.parent_handle!=handle) { oof; }
   if(csurp->status.parent_hwnd!=surp->status.hwnd)
    {
    aaNote(0,"cphw=%x chw=%x chan=%x",csurp->status.parent_hwnd,surp->status.hwnd,han);
    }
   if(csurp->status.is_visual==YES)
    {
    if(csurp->status.is_systray==YES) { aaSurfaceTraySet(han,0,NULL); csurp->status.is_systray=NO; }
    if(csurp->status.is_rounded!=0)
     {
     if(SetWindowRgn(csurp->status.hwnd,NULL,YES)==0)  { oof; }
     DeleteObject(csurp->status.region);
     csurp->status.region=NULL;
     csurp->status.is_rounded=NO;
     }
    }
   SetParent(csurp->status.hwnd,NULL);
   if(surp->status.child_count==0) { oof; }
   surp->status.child_count--;
   csurp->status.parent_handle=0;
   csurp->status.parent_hwnd=0;
   csurp->status.is_child=NO;
   surp->status.is_parent=NO;
   if(csurp->status.is_visual==YES) {  DestroyWindow(csurp->status.hwnd);  csurp->status.hwnd=NULL;  }
   if(csurp->status.icon_mem!=NULL) {  aaMemoryRelease(csurp->status.icon_mem);  csurp->status.icon_mem=0;  }

   //if(csurp->status.pixel_mem!=NULL)
   if(csurp->status.mem!=NULL)
    {
    if(csurp->status.is_made==NO)
     {
     if((ret=aa_MemoryRelease(csurp->status.mem))!=YES) { oops; }
     csurp->status.mem=NULL;
     }
    }


   if(csurp->memb!=NULL)
    {
    if((ret=aa_MemoryRelease(csurp->memb))!=YES) { oops; }
    csurp->memb=NULL;
    }


   if(csurp->status.spot_slots!=0)
    {
    aaMemoryRelease(csurp->status.spot);
    aaMemoryRelease(csurp->status.spot_id_order);
    aaMemoryRelease(csurp->status.spot_index_order);
    csurp->status.spot=0;
    }
   aaSurfaceExtraDataSet(han,0);
   aa_ObjectDestroy(aa.surface_system.object_id,han);
   it=0;
   loopfull=0;
   }
  }
 if(surp->status.is_visual==YES) {  DestroyWindow(surp->status.hwnd);  surp->status.hwnd=NULL;  }
 if(surp->status.icon_mem!=NULL) {  aaMemoryRelease(surp->status.icon_mem);  surp->status.icon_mem=0;  }
 if(surp->status.mem!=NULL)
  {
  if(surp->status.is_made==NO)
   {
   if((ret=aa_MemoryRelease(surp->status.mem))!=YES) { oops; }   surp->status.mem=NULL;
   }
  }


 if(surp->memb!=NULL)
  {
  if((ret=aa_MemoryRelease(surp->memb))!=YES) { oops; }   surp->memb=NULL;
  }

 //for(i=0;i<aaElementCount(surp->status.overlay);i++)  {  aaSurfaceOverlayReset(handle,i);  }
 if(surp->status.spot_slots!=0)
  {
  aaMemoryRelease(surp->status.spot);
  aaMemoryRelease(surp->status.spot_index_order);
  aaMemoryRelease(surp->status.spot_id_order);
  surp->status.spot=NULL_POINTR;
  surp->status.spot_index_order=NULL_POINTR;
  surp->status.spot_id_order=NULL_POINTR;
  surp->status.spot=0;
  }
 if(surp->status.spot_depth_map!=NULL)
  {
  aaMemoryRelease(surp->status.spot_depth_map);
  surp->status.spot_depth_map=NULL_POINTR;
  }
 if(surp->status.spot_id_map!=NULL)
  {
  aaMemoryRelease(surp->status.spot_id_map);
  surp->status.spot_id_map=NULL_POINTR;
  }
 if(surp->status.drop_list.magic)
  {
  aaListDelete(&surp->status.drop_list);
  }
 //if(surp->mix_mem!=NULL)  {  aaMemoryRelease(surp->mix_mem);  }
 aaSurfaceExtraDataSet(handle,0);
 aa_ObjectDestroy(aa.surface_system.object_id,handle);
 return RET_YES;
 }






 B aaSurfaceBlitProcSet                (H handle,V(*proc)(H,_rect*))
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 surp->status.blit_proc=proc;
 return RET_YES;
 }






 B aaSurfaceIgnoreWMPaint              (H handle,B state)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(state==YES) {  surp->status.is_ignore_wmpaint=YES; }
 else           { surp->status.is_ignore_wmpaint=NO; }
 return RET_YES;
 }





 B aaSurfaceMinMaxSizeSet              (H handle,_size*minsize,_size*maxsize)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(minsize) { aaSizeCopy(&surp->status.min_size,minsize); }
 if(maxsize) { aaSizeCopy(&surp->status.max_size,maxsize); }
 if(aaSizeEqualsSize(&surp->status.min_size,&surp->status.max_size)==YES)
  {
  surp->status.is_sizeable=NO;
  }
 return RET_YES;
 }




 B aaSurfaceMaximize                   (H handle,B state)
 {
 B ret;
 _aa_surfaceobject*surp;
 _displayinfo di;
 _cord cd1;
 B mi;
 //_size sz1;
 _rect rc1;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(aaSizeEqualsSize(&surp->status.min_size,&surp->status.max_size)==YES)
  {
  // allow surface maximize even if min_size and max_size are the same,,
  // the reason I did this, is so that aaSurfaceRequiresResize will work on no resizable surfaces...
 ///  return RET_FAILED;
  }



 if(state==TOGGLE)
  {
  if(surp->status.is_maximized) { state=NO; }
  else                          { state=YES; }
  }
 if(state==YES)
  {
  if(surp->status.is_maximized==YES) { return RET_FAILED; }
  aaRectCopy(&surp->status.last_rect,&surp->status.rect);
  aaMemoryCopy(&di,sizeof(_displayinfo),&aa.display_system.di);
  //aa.display_system.di
//  aaDisplayInfoGet(&di,F8);
  cd1.x=surp->status.rect.x;
  cd1.y=surp->status.rect.y;
  aaDisplayMonitorFromCord(&di,&cd1,&mi);
//  aaDebugf("cd=%i,%i mi=%i",cd1.x,cd1.y,mi);
  aaRectCopy(&rc1,&di.monitor_rect[mi]);
  if(rc1.w>=surp->status.max_size.w) { rc1.w=surp->status.max_size.w; }
  if(rc1.h>=surp->status.max_size.h) { rc1.h=surp->status.max_size.h; }
//  aaDebugf("%i,%i,%i,%i",aaRectParts(rc1));
  aaRectCopy(&surp->status.last_rect_max,&rc1);
  //aaRectCopy(&rc1,&surp->status.last_rect_max);
  /*
  if(rc1.w==0||rc1.h==0)
   {
   aaSizeCopy(&sz1,&surp->status.max_size);
   aaRectSet(&rc1,0,0,sz1.w,sz1.h);
   aaRectCopy(&surp->status.last_rect_max,&rc1);
   aaSurfaceRectSet(handle,&rc1);
   aaSurfaceCenter(handle,0);
   }
  else
   {
   aaSurfaceRectSet(handle,&rc1);
   }
   */
  //aaDebugf("abouto rect set %i,%i,%i,%i",aaRectParts(rc1));
  aaSurfaceRectSet(handle,&rc1);
  surp->status.is_maximized=YES;
  }
 else
 if(state==NO)
  {
  if(surp->status.is_maximized!=YES) { return RET_FAILED; }
  aaRectCopy(&surp->status.last_rect_max,&surp->status.rect);
  aaSurfaceRectSet(handle,&surp->status.last_rect);
  //aaDebugf("%i,%i,%i,%i",aaRectParts(surp->status.last_rect));
  surp->status.is_maximized=NO;
  }
 return RET_YES;
 }










 B aaSurfaceRequiresResize             (H handle,_rect*rect)
 {
 B ret;
 _aa_surfaceobject*surp;
 _displayinfo di;
 _cord cd1;
 N dim;
 B mi;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(surp->status.is_shown!=YES) { return RET_NO; }
 if(surp->status.is_maximized!=YES) { return RET_NO; }

 aaMemoryCopy(&di,sizeof(_displayinfo),&aa.display_system.di);
 //if((ret=aaDisplayInfoGet(&di,F8))!=YES) { oops; } // was 0

/// aaSurfaceStatus(handle,&surp->status);

 cd1.x=surp->status.rect.x;
 cd1.y=surp->status.rect.y;
 aaDisplayMonitorFromCord(&di,&cd1,&mi);

 if(di.taskbar_orientation==aa_DIRECTION_S)
  {
  dim=di.monitor_rect[mi].h-di.taskbar_rect.h;
  if((N)surp->status.size.h>=(N)(dim))//di.monitor_rect[mi].h-dim))
   {
   if(rect)
    {
    aaRectSet(rect,di.monitor_rect[mi].x,di.monitor_rect[mi].y,di.monitor_rect[mi].w,dim);//di.monitor_rect[mi].h-dim);
    }
   return RET_YES;
   }
  }
 else
 if(di.taskbar_orientation==aa_DIRECTION_W)
  {
  if((N)surp->status.size.w>(N)((di.screen_size.w-di.taskbar_rect.w)-1))
   {
   if(rect)
    {
    aaRectSet(rect,di.taskbar_rect.w,0,(di.screen_size.w-di.taskbar_rect.w)-1,di.screen_size.h);
    }
   return RET_YES;
   }
  }
 return RET_NO;
 }








 B aaSurfaceElseProcSet                (H handle,N(*Proc)(HWND hWindow,H uiMessage,H uiParam,N ulParam,BP isseproc))
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 surp->status.ElseProc=Proc;
 return RET_YES;
 }







 B aaSurfaceStatus                     (H handle,_surfacestatus*surfacestatus)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(surp->status.spot_order_ok!=YES)
  {
  aa_SurfaceSortSpots((VP)&surp);
  if(surp->status.spot_order_ok!=YES)   { oof; }
  }
 if(surfacestatus) { aaMemoryCopy(surfacestatus,sizeof(_surfacestatus),&surp->status); }
 return RET_YES;
 }








 B aaSurfaceCursorCapture              (H handle,B state)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(surp->status.is_visual!=YES) { return RET_FAILED; }
 if(state)
  {
  SetCapture(surp->status.hwnd);
  surp->status.is_cursor_captured=YES;
  }
 else
  {
  ReleaseCapture();
  surp->status.is_cursor_captured=NO;
  }
 return RET_YES;
 }










 B aaSurfaceSizeableSet                (H handle,B state)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 state&=1;
 if(state)
  {
  if(aaSizeEqualsSize(&surp->status.min_size,&surp->status.max_size)==YES) { return RET_FAILED; }
  surp->status.is_sizeable=state;
  }
 else
  {
  surp->status.is_sizeable=NO;
  }
 return RET_YES;
 }



 B aaSurfaceResizeCounterGet           (H handle,HP counter)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(counter==NULL) { return RET_BADPARM; }
 *counter=surp->status.resize_counter;
 return RET_YES;
 }




 B aaSurfaceResizeCounterSet           (H handle)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 surp->status.resize_counter++;
 return RET_YES;
 }


 B aaSurfaceResizeCounterReset         (H handle)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 surp->status.resize_counter=0;
 return RET_YES;
 }





 B aaSurfaceDisableRect                (H handle,_rect*r1)
 {
 B ret;
 _aa_surfaceobject*surp;
 _rect r2;
 Z r;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(surp->status.is_visual!=YES) { return RET_FAILED; }
 if(r1==NULL)
  {
  r=SelectClipRgn(surp->status.dc,NULL);
  if(r==ERROR) { return RET_FAILED; }
  surp->status.is_disabled=NO;
  return RET_YES;
  }
 aaRectCopy(&r2,r1);
 if(r2.w==0) { r2.w=surp->status.size.w-r2.x; }
 if(r2.h==0) { r2.h=surp->status.size.h-r2.y; }
 r=ExcludeClipRect(surp->status.dc,r2.x,r2.y,r2.x+r2.w,r2.y+r2.h);
 if(r==ERROR) { return RET_FAILED; }
 surp->status.is_disabled=YES;
 return RET_YES;
 }






 B aaSurfaceClipperGet                 (H handle,_rect*r1)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(r1==NULL) { return RET_BADPARM;  }
 aaRectSet(r1,0,0,0,0);
 if(surp->status.is_clipper!=YES) { return RET_NO; }
 aaRectCopy(r1,&surp->status.clipper_rect);
 return RET_YES;
 }




 B aaSurfaceClipperSet                 (H handle,_rect*r1)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(r1==NULL)           { aaRectNull(&surp->status.clipper_rect);   surp->status.is_clipper=NO; return RET_YES; }
 if(r1->w==0||r1->h==0) { aaRectNull(&surp->status.clipper_rect);   surp->status.is_clipper=NO; return RET_YES; }
 if(aaRectIsValid(r1)!=YES) { return RET_BADPARM; }
 aaRectCopy(&surp->status.clipper_rect,r1);
 surp->status.is_clipper=YES;
 return RET_YES;
 }




 B aaSurfaceFlipSet                    (H handle,B hflipstate,B vflipstate)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(hflipstate)  {  surp->status.is_hflip=YES;  }
 else            {  surp->status.is_hflip=NO;   }
 if(vflipstate)  {  surp->status.is_vflip=YES;  }
 else            {  surp->status.is_vflip=NO;   }
 return RET_YES;
 }




 B aaSurfaceBlendSet                   (H handle,B state)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(state==surp->status.is_blend) { return RET_YES; }
 if(state==YES)
  {
  surp->PixelGet=aaSurfacePixelGetProc;
  surp->PixelSet=aaSurfacePixelSetProc;
  surp->PixelPut=aaSurfacePixelPutProc;
  surp->status.is_blend=YES;
  }
 else
  {
  surp->PixelGet=aaSurfacePixelGetProc;
  surp->PixelSet=aaSurfacePixelSetProc;
  surp->PixelPut=aaSurfacePixelSetProc;
  surp->status.is_blend=NO;
  }
 return RET_YES;
 }





 B aaSurfaceAlphaSet                   (H handle,B alpha)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 surp->status.alpha=alpha;
 return RET_YES;
 }





 B aaSurfaceVisualize                  (H handle,B tool,H parent)
 {
 B ret;
 _aa_surfaceobject*surp;
 _aa_surfaceobject*psurp;
 DWORD style,ex;
 //_rect r1;
 //N attr;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(surp->status.is_visual==NO)
  {
  if(parent==0)
   {
   style=WS_POPUP|WS_VISIBLE|WS_CLIPCHILDREN|WS_CLIPSIBLINGS;
   if(tool) {  ex=WS_EX_TOOLWINDOW; }
   else     {  ex=0;}
   ex=((tool)?WS_EX_TOOLWINDOW:0);
   surp->status.hwnd=CreateWindowEx(ex,(LPCTSTR)aa.core_system.class_name,surp->status.title,style,surp->status.rect.x,surp->status.rect.y,surp->status.rect.w,surp->status.rect.h,NULL,NULL,aa.core_system.this_instance,NULL);
   }
  else
   {
   style=WS_POPUP|WS_VISIBLE|WS_CHILD|WS_CLIPSIBLINGS;//|WS_CLIPCHILDREN;
   ex=((tool)?WS_EX_TOOLWINDOW:0);
   if((ret=aa_ObjectCheck(aa.surface_system.object_id,parent,(VP)&psurp,NULL))!=RET_YES) { return ret; }
   surp->status.hwnd=CreateWindowEx(ex,(LPCTSTR)aa.core_system.class_name,surp->status.title,style,surp->status.rect.x,surp->status.rect.y,surp->status.rect.w,surp->status.rect.h,psurp->status.hwnd,NULL,aa.core_system.this_instance,NULL);
   }
  if(surp->status.hwnd==NULL) { oow; }
  surp->status.dc=GetWindowDC(surp->status.hwnd);
  if(surp->status.hwnd==NULL||surp->status.dc==NULL) { oof; }
  surp->status.is_visual=YES;
  surp->status.resize_counter=1;
  if(tool) surp->status.is_tool=YES;
  else     surp->status.is_tool=NO;
  if(parent)
   {
   surp->status.is_child=YES;
   surp->status.parent_hwnd=psurp->status.hwnd;
   surp->status.parent_handle=parent;
   psurp->status.is_parent=YES;
   psurp->status.child_count++;

   //attr=GetWindowLong(surp->status.hwnd,GWL_STYLE);
   //SetWindowLong(surp->status.hwnd,GWL_STYLE,attr|WS_CHILD);
   //attr=GetWindowLong(psurp->status.hwnd,GWL_STYLE);
   SetParent(surp->status.hwnd,psurp->status.hwnd);

   // hack to fix child windows
   //aaRectCopy(&r1,&psurp->status.rect);   r1.x+=1;
   //aaSurfaceRectSet(parent,&r1);   r1.x-=1;   aaSurfaceRectSet(parent,&r1);


   }
  if(SetStretchBltMode(surp->status.dc,COLORONCOLOR)==0) oof;
  ///if(SetStretchBltMode(surp->status.dc,0)==0) oof;
  }
 return RET_YES;
 }






 /*
   #define LWA_COLORKEY 0x00000001
   #define LWA_ALPHA 0x00000002
 */



 B aaSurfaceTransparencySet            (H handle,B alpha,_rgba*key)
 {
 B ret;
 _aa_surfaceobject*surp;
 H flags;
 N attr;
 COLORREF pix;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 ///if(surp->status.is_child) { return RET_FAILED; }
 attr=GetWindowLong(surp->status.hwnd,GWL_EXSTYLE);
 flags=0x02;
 if(key) {  pix=RGB(key->r,key->g,key->b);  flags|=0x01;  }
 ///aaLog(-555,"%s alpha=%i ",__func__,alpha);
 if(key==NULL&&alpha==255)
  {
  //aaLog(-555,"key and alpha null, so doing");
  SetWindowLong(surp->status.hwnd,GWL_EXSTYLE,GetWindowLong(surp->status.hwnd,GWL_EXSTYLE)&~WS_EX_LAYERED);
  return RET_YES;
  }
 if(!(attr&WS_EX_LAYERED))
  {
  SetWindowLong(surp->status.hwnd, GWL_EXSTYLE,attr|WS_EX_LAYERED);
  //aaLog(-555,"was not layered so setting");
  }
 SetLayeredWindowAttributes(surp->status.hwnd,pix,alpha,flags);
 return RET_YES;
 }





 B aaSurfaceRoundedSet                 (H handle,B state,Z rwid,Z rhit)
 {
 B ret;
 _aa_surfaceobject*surp;
 HRGN rgn;
 Z hit,wid;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(surp->status.is_visual!=YES) { return RET_FAILED; }
 if(state!=NO)
  {
  if(surp->status.is_rounded==0)
   {
   hit=rhit;
   wid=rwid;
   if(hit<=0) { hit=0; }
   if(wid<=0) { wid=0; }
   hit=aaNumRoof(hit,(Z)surp->status.size.h);
   wid=aaNumRoof(wid,(Z)surp->status.size.w);
   if((rgn=CreateRoundRectRgn(0,0,surp->status.size.w-1,surp->status.size.h-1,hit,wid))==NULL) oof;
   if(SetWindowRgn(surp->status.hwnd,rgn,TRUE)==0) { oof; }
   surp->status.region=rgn;
   surp->status.is_rounded=state;
   }
  }
 else
  {
  if(surp->status.is_rounded!=0)
   {
   if(SetWindowRgn(surp->status.hwnd,NULL,YES)==0)  { oof; }
   DeleteObject(surp->status.region);
   surp->status.region=NULL;
   surp->status.is_rounded=0;
   }
  }
 return RET_YES;
 }






 B aaSurfaceShow                       (H handle,B state)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(state==YES||state==2)
  {
  if(surp->status.is_visual==NO)
   {
   logg("%s:%i",__func__,__LINE__);
   if((ret=aaSurfaceVisualize(handle,NO,surp->status.parent_handle))!=YES) { oops; }
   logg("%s:%i",__func__,__LINE__);
   }
 if(state==YES)
   {
   if(surp->status.is_shown==YES)  { return RET_YES; }
   ShowWindow(surp->status.hwnd,SW_SHOW);
   }
  else
   {
   if(surp->status.is_minimized==YES)  { return RET_YES; }
   ShowWindow(surp->status.hwnd,SW_SHOWMINIMIZED);
   surp->status.is_minimized=YES;
   }
  surp->status.is_shown=YES;
  }
 else
  {
  if(surp->status.is_shown!=YES)  { return RET_YES; }
  ShowWindow(surp->status.hwnd,SW_HIDE);
  surp->status.is_shown=NO;
  }
 return RET_YES;
 }




 B aaSurfaceTraySet                    (H handle,H iconresnum,VP fmt,...)
 {
 B ret;
 _aa_surfaceobject*surp;
 va_list argptr;
 B str[_4K];
 H sl;
 NOTIFYICONDATA nid;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,str);
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(surp->status.is_visual==NO) { return RET_FAILED; }

 if(surp->status.is_systray==YES)
  {
  if(fmt==NULL)
   {
   SetLastError(0);
   if(surp->status.is_tool)  {  SetWindowLong(surp->status.hwnd,GWL_EXSTYLE,GetWindowLong(surp->status.hwnd,GWL_EXSTYLE)&~WS_EX_TOOLWINDOW);    }
   else                      {  SetWindowLong(surp->status.hwnd,GWL_EXSTYLE,GetWindowLong(surp->status.hwnd,GWL_EXSTYLE)&~WS_EX_APPWINDOW);     }
   if(GetLastError()) { oof; }
   nid.cbSize=sizeof(nid);
   nid.hWnd=surp->status.hwnd;
   nid.uID=1;
   nid.uFlags=NIF_ICON|NIF_MESSAGE|NIF_TIP;
   nid.uCallbackMessage=WM_SURFACE_SYSTRAY_MSG;
   if(Shell_NotifyIcon(NIM_DELETE,&nid)==0) { return RET_FAILED; }
   surp->status.is_systray=NO;
   ShowWindow(surp->status.hwnd,SW_SHOW);
   surp->status.is_systray=NO;
   ///surp->status.is_shown=YES;
   surp->status.tray_icon_resnum=iconresnum;
   }
  else
   {
   nid.cbSize=sizeof(nid);
   nid.hWnd=surp->status.hwnd;
   nid.uID=1;
   nid.uFlags=NIF_ICON|NIF_MESSAGE|NIF_TIP;
   nid.uCallbackMessage=WM_SURFACE_SYSTRAY_MSG;
   if(iconresnum!=0) {  nid.hIcon=(HICON)LoadIcon(aa.core_system.this_instance,MAKEINTRESOURCE(iconresnum));  }
   else              {  nid.hIcon=(HICON)LoadIcon(NULL,IDI_APPLICATION);    }
   aaStringLen(str,&sl);
   if(sl>1023) { str[1023]=0; }
   aaStringCopy(nid.szTip,str);
   if(Shell_NotifyIcon(NIM_MODIFY,&nid)==0) { return RET_FAILED; }
   surp->status.is_systray=YES;
   ///surp->status.is_shown=YES;
   surp->status.tray_icon_resnum=iconresnum;
   aaSurfaceUpdateAreaAdd(handle,0,NO);
   return YES;
   }
  }
 else
  {
  if(fmt==NULL) { return RET_BADPARM; }
  SetLastError(0);
  if(surp->status.is_tool)   {   SetWindowLong(surp->status.hwnd,GWL_EXSTYLE,GetWindowLong(surp->status.hwnd,GWL_EXSTYLE)|WS_EX_TOOLWINDOW);   }
  else                       {   SetWindowLong(surp->status.hwnd,GWL_EXSTYLE,GetWindowLong(surp->status.hwnd,GWL_EXSTYLE)|WS_EX_APPWINDOW);    }
  if(GetLastError()) { oow; aaNote(0,"ss=%s",str); }
  aaMemoryFill(&nid,9,sizeof(nid));
  nid.cbSize=sizeof(nid);
  nid.hWnd=surp->status.hwnd;
  nid.uID=1;
  nid.uFlags=NIF_ICON|NIF_MESSAGE|NIF_TIP;
  nid.uCallbackMessage=WM_SURFACE_SYSTRAY_MSG;
  if(iconresnum!=0) {  nid.hIcon=(HICON)LoadIcon(aa.core_system.this_instance,MAKEINTRESOURCE(iconresnum));  }
  else {   nid.hIcon=(HICON)LoadIcon(NULL,IDI_APPLICATION);   }
  aaStringLen(str,&sl);
  if(sl>1023) { str[1023]=0; }
  aaStringCopy(nid.szTip,str);
  if(Shell_NotifyIcon(NIM_ADD,&nid)==0) {}
  surp->status.is_systray=YES;
  surp->status.tray_icon_resnum=iconresnum;
  }
 aaSurfaceUpdateAreaAdd(handle,0,NO);
 return RET_YES;
 }






 B aaSurfaceTrayClickClear             (H handle)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 surp->status.is_systray_clicked=NO;
 surp->status.is_systray_right_clicked=NO;
 return RET_YES;
 }



 B aaSurfaceIsTrayClicked              (H handle,_cord*cord,BP isright)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(surp->status.is_systray_clicked==NO) { return RET_NO; }
 if(cord) { aaCordCopy(cord,&surp->status.systray_click_cord); }
 if(isright) { *isright=surp->status.is_systray_right_clicked; }
 return RET_YES;
 }





 B aaSurfaceTitleSet                   (H handle,VP fmt,...)
 {
 B ret;
 _aa_surfaceobject*surp;
 va_list argptr;
 B txt[_4K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,txt);
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 txt[63]=NULL_CHAR;
 aaStringCopy(surp->status.title,txt);
 if(surp->status.is_visual==YES)
  {
  if(SetWindowText(surp->status.hwnd,surp->status.title)==0) { return RET_FAILED; }
  }
 return RET_YES;
 }




 B aaSurfaceTitleAppendf               (H handle,VP fmt,...)
 {
 B ret;
 _aa_surfaceobject*surp;
 va_list argptr;
 B txt[_4K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,txt);
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 txt[63]=NULL_CHAR;
 aaStringAppendf(surp->status.title,txt);
 if(surp->status.is_visual==YES)
  {
  if(SetWindowText(surp->status.hwnd,surp->status.title)==0) { return RET_FAILED; }
  }
 return RET_YES;
 }





 B aaSurfaceIconSetUsingResource       (H handle,H resnum,H index)
 {
 B ret;
 _aa_surfaceobject*surp;
 HRSRC rsca,rscb;
 HRSRC mema,memb;
 BP bufa,bufb;
 _size sz;
 H nid,i,zo,pzo,mode;
 BITMAPINFOHEADER bih;
 B px,ama;
 BP andp;
 W numi;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(surp->status.is_visual==NO) {  return RET_FAILED; }
 if((surp->status.icon=LoadIcon(aa.core_system.this_instance,MAKEINTRESOURCE(resnum)))==NULL)  {  return RET_FAILED; }
 SetClassLong(surp->status.hwnd,GCL_HICON,(LONG)surp->status.icon);
 aaSizeSet(&surp->status.icon_size,0,0);
 if(index>1000) index=1000;
 surp->status.icon_mem=NULL;
 mode=0;
 while(1)
  {
  if((rsca=FindResource(0,MAKEINTRESOURCE(resnum),RT_GROUP_ICON))==NULL) { break; }
  if((mema=LoadResource(0,rsca))==NULL) { break; }
  if((bufa=LockResource(mema))==NULL) { break; }
  numi=*(WP)&bufa[4];
  nid=*(WP)&bufa[18];
  if((index+1)>=(H)numi) { nid=numi; if(numi>1) nid=numi-(numi-2); }
  else {   nid=numi-index; }
  if((rscb=FindResource(0,MAKEINTRESOURCE(nid),RT_ICON))==NULL) { break; }
  if((memb=LoadResource(0,rscb))==NULL) { break; }
  if((bufb=LockResource(memb))==NULL) { break; }
  zo=0;
  aaMemoryCopy(&bih,sizeof(bih),&bufb[zo]);
  zo+=sizeof(bih);
  pzo=zo;
  bih.biHeight/=2;
  if(bih.biCompression==BI_RGB&&bih.biClrUsed==0&&bih.biBitCount==8)   {   mode=1;   }
  else
  if(bih.biCompression==BI_RGB&&bih.biClrUsed==256&&bih.biBitCount==8)   {   mode=2;   }
  else
  if(bih.biCompression==BI_RGB&&bih.biClrUsed==0&&bih.biBitCount==32)   {   mode=3;   }
  else
  if(bih.biCompression==BI_RGB&&bih.biClrUsed==0&&bih.biBitCount==4)   {   mode=4;   }
  else
  if(bih.biCompression==BI_RGB&&bih.biClrUsed==16&&bih.biBitCount==4)   {   mode=5;   }
  aaSizeSet(&sz,bih.biWidth,bih.biHeight);
  if(mode==0) { break; }
  if(mode==1)   {   zo+=(256*4);   }
  else
  if(mode==2)   {   zo+=(256*4);   }
  else
  if(mode==3)   {   }
  else
  if(mode==4)   {   zo+=(16*4);  }
  else
  if(mode==5)   {   zo+=(16*4); }
  aaCast(andp,BP,&bufb[zo+bih.biSizeImage]);
  aaSizeCopy(&surp->status.icon_size,&sz);
  aaMemoryAllocate((VP)&surp->status.icon_mem,sz.w*sz.h*4);
  aaMemoryNameSet(surp->status.icon_mem,"surficon");
  if(mode==1)
   {
   for(i=0;i<(sz.w*sz.h);i++)
    {
    px=bufb[zo];
    if(bufb[pzo+(px*4)+0]==0&&bufb[pzo+(px*4)+1]==0&&bufb[pzo+(px*4)+2]==0&&bufb[pzo+(px*4)+3]==0) { ama=0; }
    else { ama=255; }
    surp->status.icon_mem[(i<<2)+0]=bufb[pzo+(px*4)+0];
    surp->status.icon_mem[(i<<2)+1]=bufb[pzo+(px*4)+1];
    surp->status.icon_mem[(i<<2)+2]=bufb[pzo+(px*4)+2];
    surp->status.icon_mem[(i<<2)+3]=ama;
    zo+=1;
    }
   }
  else
  if(mode==2)
   {
   for(i=0;i<((sz.w+0)*(sz.h+0));i++)
    {
    px=bufb[zo];
    ama=255;
    surp->status.icon_mem[(i<<2)+0]=bufb[pzo+(px*4)+0];
    surp->status.icon_mem[(i<<2)+1]=bufb[pzo+(px*4)+1];
    surp->status.icon_mem[(i<<2)+2]=bufb[pzo+(px*4)+2];
    surp->status.icon_mem[(i<<2)+3]=ama;
    zo+=1;
    }
   }
  else
  if(mode==3)
   {
   for(i=0;i<(sz.w*sz.h);i++)
    {
    surp->status.icon_mem[(i<<2)+0]=bufb[zo+0];
    surp->status.icon_mem[(i<<2)+1]=bufb[zo+1];
    surp->status.icon_mem[(i<<2)+2]=bufb[zo+2];
    surp->status.icon_mem[(i<<2)+3]=bufb[zo+3];
    zo+=4;
    }
   }
  else
  if(mode==4)
   {
   for(i=0;i<(sz.w*sz.h);i++)
    {
    ama=(B)(aaBitGet(andp[i/8],(i%8)));
    if(ama) {}
    ama=255;
    if(aaNumIsMod(i,2))
     {
     px=(B)(bufb[zo]/16);
     surp->status.icon_mem[(i<<2)+0]=bufb[pzo+(px*4)+0];
     surp->status.icon_mem[(i<<2)+1]=bufb[pzo+(px*4)+1];
     surp->status.icon_mem[(i<<2)+2]=bufb[pzo+(px*4)+2];
     surp->status.icon_mem[(i<<2)+3]=ama;
     }
    else
     {
     px=(B)(bufb[zo]%16);
     surp->status.icon_mem[(i<<2)+0]=bufb[pzo+(px*4)+0];
     surp->status.icon_mem[(i<<2)+1]=bufb[pzo+(px*4)+1];
     surp->status.icon_mem[(i<<2)+2]=bufb[pzo+(px*4)+2];
     surp->status.icon_mem[(i<<2)+3]=ama;
     zo+=1;
     }
    }
   }
  else
  if(mode==5)
   {
   for(i=0;i<(sz.w*sz.h);i++)
    {
    ama=255;
    if(aaNumIsMod(i,2))
     {
     px=(B)(bufb[zo]/16);
     surp->status.icon_mem[(i<<2)+0]=bufb[pzo+(px*4)+0];
     surp->status.icon_mem[(i<<2)+1]=bufb[pzo+(px*4)+1];
     surp->status.icon_mem[(i<<2)+2]=bufb[pzo+(px*4)+2];
     surp->status.icon_mem[(i<<2)+3]=ama;
     }
    else
     {
     px=(B)(bufb[zo]%16);
     surp->status.icon_mem[(i<<2)+0]=bufb[pzo+(px*4)+0];
     surp->status.icon_mem[(i<<2)+1]=bufb[pzo+(px*4)+1];
     surp->status.icon_mem[(i<<2)+2]=bufb[pzo+(px*4)+2];
     surp->status.icon_mem[(i<<2)+3]=ama;
     zo+=1;
     }
    }
   }
  break;
  }
 if(mode==0||surp->status.icon_mem==NULL)
  {
  aaNote(0,"line=%i mode=%i  %i x %i  %i,%i,%i",__LINE__,mode,sz.w,sz.h,bih.biCompression,bih.biClrUsed,bih.biBitCount);
  return RET_FAILED;
  }
 surp->status.icon_resnum=resnum;
 surp->status.icon_index=index;
 return RET_YES;
 }





 B aaSurfaceFocus                      (H handle)
 {
 B ret;
 _aa_surfaceobject*surp;
 H time_out;
 HWND fg_hwnd;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(surp->status.is_visual==NO) { return RET_FORBIDDEN; }
 if(surp->status.is_shown==NO) { return RET_FAILED; }
 SystemParametersInfo(0x2000,0,&time_out,0);
 SystemParametersInfo(0x2001,0,(VP)0,0);
 fg_hwnd=GetForegroundWindow();
 AttachThreadInput(GetWindowThreadProcessId(fg_hwnd,NULL),GetCurrentThreadId(),TRUE);
 SetForegroundWindow(surp->status.hwnd);
 SetActiveWindow(surp->status.hwnd);
 BringWindowToTop(surp->status.hwnd);
 SetFocus(surp->status.hwnd);
 AttachThreadInput(GetWindowThreadProcessId(fg_hwnd,NULL),GetCurrentThreadId(),FALSE);
 SystemParametersInfo(0x2001,0,(VP)time_out,0);
 return RET_YES;
 }





 B aaSurfaceMinimize                   (H handle)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(surp->status.is_visual==NO) { return RET_FORBIDDEN; }
 if(surp->status.is_shown==NO) { return RET_FAILED; }
 surp->status.is_minimized=YES;
 ShowWindow(surp->status.hwnd,SW_MINIMIZE);
 return RET_YES;
 }




 B aaSurfaceRestore                    (H handle)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(surp->status.is_visual==NO) {  return RET_FORBIDDEN; }
 if(surp->status.is_shown==NO) {  return RET_FAILED; }
 if(surp->status.is_minimized==YES)
  {
  surp->status.is_minimized=NO;
  ShowWindow(surp->status.hwnd,SW_RESTORE);
  }
 else
  {
  return(aaSurfaceMinimize(handle));
  }
 return RET_YES;
 }







 B aaSurfaceCordSet                    (H handle,_cord*cord)
 {
 B ret;
 _aa_surfaceobject*surp;
 _rect r1;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(cord==NULL) { return RET_BADPARM; }
 aaRectCopy(&r1,&surp->status.rect);
 aaRectCordSet(&r1,cord->x,cord->y);
 return(aaSurfaceRectSet(handle,&r1));
 }





 B aaSurfaceSizeSet                    (H handle,_size*size)
 {
 B ret;
 _aa_surfaceobject*surp;
 _rect r1;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) {  return ret; }
 if(size==NULL) {  return RET_BADPARM; }
 if(size->w==0) { return RET_BADPARM; }
 if(size->h==0) {  return RET_BADPARM; }

 if((size->w*size->h)>surp->status.real_pixel_count) { return RET_BOUNDS; }
 aaRectCopy(&r1,&surp->status.rect);
 aaRectSizeSet(&r1,size->w,size->h);
 ret=aaSurfaceRectSet(handle,&r1);
 if(ret!=RET_YES) { oops; return ret; }
// aaDebugf("surp=%i,%i  %i,%i,%i,%i",aaSizeParts(surp->status.size),aaRectParts(surp->status.rect));
 aaSizeSet(&surp->status.size,surp->status.rect.w,surp->status.rect.h);
 return RET_YES;
 }







 B aaSurfaceRectSet                    (H handle,_rect*rect)
 {
 B ret;
 _aa_surfaceobject*surp;
 _aa_surfaceobject*psurp;
 B cord_changed;
 B size_changed;
 RECT rr;
 W flags;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aaRectIsValid(rect)!=RET_YES) { return RET_BADPARM; }
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if((rect->w*rect->h)>surp->status.real_pixel_count) {  return RET_BOUNDS; }//aaNote(0,"%ix%i=%i rpc=%i",rect->w,rect->h,rect->w*rect->h,surp->status.real_pixel_count);

 //if(surp->status.is_sizeable==YES) { aaSurfaceSizeableSet(handle,YES); }
 if(surp->status.is_visual==NO)
  {
  aaRectCopy(&surp->status.rect,rect);
  aaSizeSet(&surp->status.size,rect->w,rect->h);
  aaRectToCornerCords(&surp->status.rect,&surp->status.corner[0],&surp->status.corner[1],&surp->status.corner[2],&surp->status.corner[3]);
  return RET_YES;
  }
 cord_changed=NO;
 size_changed=NO;
 if(rect->x!=surp->status.rect.x||rect->y!=surp->status.rect.y)  {  cord_changed=YES;   }
 if(rect->w!=surp->status.rect.w||rect->h!=surp->status.rect.h)  {  size_changed=YES;  }
 psurp=NULL;
 flags=SWP_NOACTIVATE;
 if(cord_changed==NO) { flags|=SWP_NOMOVE; }
 if(size_changed==NO) { flags|=SWP_NOSIZE; }
 if(surp->status.parent_handle!=0)
  {
  if((ret=aa_ObjectCheck(aa.surface_system.object_id,surp->status.parent_handle,(VP)&psurp,NULL))!=RET_YES) { oops; }
  SendMessage(psurp->status.hwnd,WM_SETREDRAW,FALSE,0);
  flags|=SWP_NOOWNERZORDER;
  flags|=SWP_NOZORDER;
  }
 else
  {
  SendMessage(surp->status.hwnd,WM_SETREDRAW,FALSE,0);
//  flags|=SWP_NOOWNERZORDER;
  flags|=SWP_NOZORDER;
  }
  //aaDebugf("... %i,%i,%i,%i",rect->x,rect->y,rect->w,rect->h);
 WinRectSet(&rr,rect->x,rect->y,rect->w,rect->h);
 flags|=SWP_NOSENDCHANGING;
 flags|=SWP_NOCOPYBITS;
 flags|=SWP_DEFERERASE;

 InvalidateRect(surp->status.hwnd, NULL, FALSE);
 if(SetWindowPos(surp->status.hwnd,0,rr.left,rr.top,(rr.right-rr.left)+0,(rr.bottom-rr.top)+0,flags)==FALSE)  {  return RET_FAILED;  }
 aaRectCopy(&surp->status.rect,rect);
 //aaDebugf("++ %i,%i,%i,%i",
 aaSizeSet(&surp->status.size,rect->w,rect->h);
 aaRectToCornerCords(&surp->status.rect,&surp->status.corner[0],&surp->status.corner[1],&surp->status.corner[2],&surp->status.corner[3]);
 surp->status.pixel_count=surp->status.size.w*surp->status.size.h;
 surp->status.real_pixel_count=surp->status.initial_size.w*surp->status.initial_size.h;
 if(size_changed) { surp->status.resize_counter++; }

 if(size_changed)
  {
  if(surp->status.resize_border_pixels!=0)
   {
   aaSurfaceResizeBorderSet(handle,surp->status.resize_border_pixels);
   }
  }
 if(surp->status.move_pixels!=0)
  {
  aaSurfaceMoveAreaSet(handle,surp->status.move_pixels);
  }
 return RET_YES;
 }




 B aaSurfaceCordGet                    (H handle,_cord*cord)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 return(aaCordSet(cord,surp->status.rect.x,surp->status.rect.y));
 }




 B aaSurfaceViewportSet                (H handle,_rect*rect)
 {
 B ret;
 _aa_surfaceobject*surp;
 _rect rr;
 H flags;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) {  return ret; }
 if(rect==NULL) { aaRectSet(&rr,0,0,surp->status.size.w,surp->status.size.h); }
 else           { aaRectSet(&rr,rect->x,rect->y,rect->w,rect->h); }
 aaRectSet(&surp->status.viewport_rect,rr.x,rr.y,rr.w,rr.h);
 if(surp->status.hwnd==0) { oof; }
    flags=0;
    flags|=SWP_FRAMECHANGED;
    flags|=SWP_NOACTIVATE;
    flags|=SWP_NOZORDER;
    flags|=SWP_NOMOVE;
    flags|=SWP_NOOWNERZORDER;
    flags|=SWP_NOSENDCHANGING;
    flags|=SWP_NOCOPYBITS;
    flags|=SWP_DEFERERASE;
    if(SetWindowPos(surp->status.hwnd,0,0,0,surp->status.viewport_rect.w,surp->status.viewport_rect.h,flags)==FALSE)  { oow; }
 return RET_YES;
 }




 B aaSurfaceSizeGet                    (H handle,_size*size)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) {  return ret; }
 return(aaSizeCopy(size,&surp->status.size));
 }





 B aaSurfaceRectGet                    (H handle,_rect*rect)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 return(aaRectCopy(rect,&surp->status.rect));
 }




 B aaSurfaceCordAdjust                 (H handle,N xamnt,N yamnt)
 {
 B ret;
 _aa_surfaceobject*surp;
 _cord c1;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 aaCordCopy(&c1,&surp->status.corner[0]);
 aaCordAdjust(&c1,xamnt,yamnt);
 return(aaSurfaceCordSet(handle,&c1));
 }





 B aaSurfaceCenter                     (H handle,_rect*rect)
 {
 B ret;
 _aa_surfaceobject*surp;
 _size s2;
 _rect r1,r2;
 _displayinfo dsi;
 _cord c1;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 aaSizeSet(&s2,surp->status.rect.w,surp->status.rect.h);
 if(rect!=NULL)
  {
  if((ret=aaRectIsValid(rect))!=RET_YES) { return ret; }
  aaRectCopy(&r2,rect);

  aaRectSet(&r1,r2.x+((r2.w/2)-(s2.w/2)),r2.y+((r2.h/2)-(s2.h/2)),s2.w,s2.h);
  aaCordSet(&c1,r1.x,r1.y);
  if((ret=aaSurfaceCordSet(handle,&c1))!=RET_YES) { oops; return ret; }
  }
 else
  {
  aaMemoryCopy(&dsi,sizeof(_displayinfo),&aa.display_system.di);
  //if((ret=aaDisplayInfoGet(&dsi,2))!=YES) { oops; } // was 3
  //aaLog(-555,"%s(%i)",__func__,__LINE__);
  aaRectCopy(&r2,&dsi.monitor_rect[dsi.monitor_primary_index]);
  aaRectSet(&r1,(r2.w/2)-(s2.w/2),(r2.h/2)-(s2.h/2),s2.w,s2.h);
  aaRectAdjust(&r1,r2.x,r2.y,0,0);
  if((ret=aaSurfaceRectSet(handle,&r1))!=RET_YES) { oops; return ret; }
  }
 return RET_YES;
 }




 B aaSurfaceRectAlign                  (H handle,_rect*rect,B ha,B va)
 {
 B ret;
 _aa_surfaceobject*surp;
 _size s2;
 _rect r1,r2;
 _displayinfo dsi;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 aaSizeSet(&s2,surp->status.rect.w,surp->status.rect.h);

 if(rect!=NULL)
  {
  if((ret=aaRectIsValid(rect))!=RET_YES) { return ret; }
  aaRectCopy(&r2,rect);
  r1.w=s2.w;
  r1.h=s2.h;
  r1.x=surp->status.rect.x;
  r1.y=surp->status.rect.y;
  switch(ha)
   {
   case aa_ALIGN_LEFT:     r1.x=r2.x;                      break;
   case aa_ALIGN_MIDDLE:   r1.x=r2.x+((r2.w/2)-(s2.w/2));   break;
   case aa_ALIGN_RIGHT:    r1.x=r2.x+(r2.w-r1.w);          break;
   }
  switch(va)
   {
   case aa_ALIGN_TOP:     r1.y=r2.y;                   break;
   case aa_ALIGN_MIDDLE:  r1.y=r2.y+((r2.h/2)-(s2.h/2));   break;
   case aa_ALIGN_BOTTOM:  r1.y=r2.y+(r2.h-r1.h);           break;
   }
  }
 else
  {
  aaMemoryCopy(&dsi,sizeof(_displayinfo),&aa.display_system.di);
  //if((ret=aaDisplayInfoGet(&dsi,6))!=YES) { oops; }
  ///aaLog(-555,"%s(%i)",__func__,__LINE__);
  aaRectCopy(&r2,&dsi.monitor_rect[dsi.monitor_primary_index]);
  r1.w=s2.w;
  r1.h=s2.h;
  r1.x=surp->status.rect.x;
  r1.y=surp->status.rect.y;
  switch(ha)
   {
   case aa_ALIGN_LEFT:     r1.x=r2.x;                      break;
   case aa_ALIGN_MIDDLE:   r1.x=r2.x+((r2.w/2)-(s2.w/2));   break;
   case aa_ALIGN_RIGHT:    r1.x=r2.x+(r2.w-r1.w);          break;
   }
  switch(va)
   {
   case aa_ALIGN_TOP:     r1.y=r2.y;                   break;
   case aa_ALIGN_MIDDLE:  r1.y=r2.y+((r2.h/2)-(s2.h/2));   break;
   case aa_ALIGN_BOTTOM:  r1.y=r2.y+(r2.h-r1.h);           break;
   }
  }
 if((ret=aaSurfaceRectSet(handle,&r1))!=RET_YES) { oops; return ret; }
 return RET_YES;
 }






 B aaSurfaceMonitorAlign               (H handle,B mid,B ha,B va,N xa,N ya)
 {
 B ret;
 _aa_surfaceobject*surp;
 _size s2;
 _rect r1,r2;
 _displayinfo dsi;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 aaSizeSet(&s2,surp->status.rect.w,surp->status.rect.h);
 aaMemoryCopy(&dsi,sizeof(_displayinfo),&aa.display_system.di);
 //if((ret=aaDisplayInfoGet(&dsi,6))!=YES) { oops; }
 //aaLog(-555,"%s(%i)",__func__,__LINE__);
 if(mid>=dsi.monitor_count) { return RET_BOUNDS; }
 aaRectCopy(&r2,&dsi.monitor_rect[mid]);
 r1.w=s2.w;
 r1.h=s2.h;
 r1.x=r2.x;
 r1.y=r2.y;
 switch(ha)
  {
  case aa_ALIGN_LEFT:     r1.x=r2.x;                      break;
  case aa_ALIGN_MIDDLE:   r1.x=r2.x+((r2.w/2)-(s2.w/2));  break;
  case aa_ALIGN_RIGHT:    r1.x=r2.x+(r2.w-r1.w);          break;
  }
 switch(va)
  {
  case aa_ALIGN_TOP:     r1.y=r2.y;                   break;
  case aa_ALIGN_MIDDLE:  r1.y=r2.y+((r2.h/2)-(s2.h/2));  break;
  case aa_ALIGN_BOTTOM:  r1.y=r2.y+(r2.h-r1.h);           break;
  }
 r1.x+=xa;
 r1.y+=ya;
 if((ret=aaSurfaceRectSet(handle,&r1))!=RET_YES) { oops; return ret; }
 return RET_YES;
 }





 B aaSurfaceOnTop                      (H handle,B state)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(surp->status.is_visual==NO) { return RET_FAILED; }
 if(state==YES)
  {
  if(surp->status.is_top==YES) { return RET_YES; }
  if(SetWindowPos(surp->status.hwnd,HWND_TOPMOST,0,0,0,0,SWP_NOSIZE|SWP_NOMOVE)==0) { return RET_FAILED;  }
  surp->status.is_top=YES;
  }
 else
  {
  if(surp->status.is_top==NO) { return RET_YES; }
  if(SetWindowPos(surp->status.hwnd,HWND_NOTOPMOST,0,0,0,0,SWP_NOSIZE|SWP_NOMOVE)==0) { return RET_FAILED; }
  surp->status.is_top=NO;
  }
 return RET_YES;
 }






 B aaSurfaceCordToVisualCord           (H handle,_cord*cord,_cord*vcord)
 {
 B ret;
 _aa_surfaceobject*surp;
 POINT pt;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(cord==NULL) { return RET_BADPARM; }
 if(vcord==NULL) { return RET_BADPARM; }
 if(surp->status.is_visual==NO) { return RET_FAILED; }
 WinPointSet(&pt,cord->x,cord->y);
 if(ClientToScreen(surp->status.hwnd,&pt)==0) { oow; }
 WinPointToCord(&pt,vcord);
 return RET_YES;
 }






 B aaSurfaceVisualCordToCord           (H handle,_cord*vcord,_cord*cord)
 {
 B ret;
 _aa_surfaceobject*surp;
 POINT pt;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(cord==NULL) { return RET_BADPARM; }
 if(vcord==NULL) { return RET_BADPARM; }
 if(surp->status.is_visual==NO) { return RET_FAILED; }
 WinPointSet(&pt,vcord->x,vcord->y);
 ScreenToClient(surp->status.hwnd,&pt);
 WinPointToCord(&pt,cord);
 return RET_YES;
 }








///http://www.programering.com/a/MDO5EzNwATA.html

 B aaSurfaceBlit                       (H handle,_rect*rect)
 {
 B ret;
 _aa_surfaceobject*srce_surp;
 _rect srce_rect;
 _rect dest_rect;
 BITMAPINFO bmi;
 H off;
 N sx,sy,sw,sh;
 N dx,dy,dw,dh;
 N sb_add;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&srce_surp,NULL))!=RET_YES) { return ret; }
 if(srce_surp->in_blit==YES) { return RET_INUSE; }
 srce_surp->in_blit=YES;
 sb_add=1;
   if(srce_surp->status.is_visual==NO) { return RET_FAILED; }
   aaRectSet(&srce_rect,0,0,srce_surp->status.viewport_rect.w,srce_surp->status.viewport_rect.h);
   if(rect!=NULL) { aaRectCopy(&srce_rect,rect);  }
   aaRectCopy(&dest_rect,&srce_rect);
   WinBmpInfoSet(&bmi,srce_surp->status.size.w,srce_surp->status.size.h,32,1);
   off=srce_surp->status.viewport_rect.x;
   if(srce_surp->status.viewport_rect.y!=0) { oof; }
   sx=(N)srce_rect.x;   sy=(N)srce_rect.y;
   sw=(N)srce_rect.w;   sh=(N)srce_rect.h;
   dx=(N)dest_rect.x;   dy=(N)dest_rect.y;
   dw=(N)dest_rect.w;   dh=(N)dest_rect.h;

 if(srce_surp->status.blit_proc)
  {
  aaMemoryCopy(srce_surp->memb,srce_surp->status.pixel_count*4,srce_surp->status.mem);
  srce_surp->status.blit_proc(handle,rect);
  if(StretchDIBits(srce_surp->status.dc,dx,dh+dy-sb_add,dw,-dh,sx,srce_surp->status.size.h-sy+sb_add,sw,-sh,&srce_surp->status.mem[off],(BITMAPINFO*)&bmi,DIB_RGB_COLORS,SRCCOPY)==(Z)GDI_ERROR) { oow; }
  aaMemoryCopy(srce_surp->status.mem,srce_surp->status.pixel_count*4,srce_surp->memb);
  }
 else
  {
  if(StretchDIBits(srce_surp->status.dc,dx,dh+dy-sb_add,dw,-dh,sx,srce_surp->status.size.h-sy+sb_add,sw,-sh,&srce_surp->status.mem[off],(BITMAPINFO*)&bmi,DIB_RGB_COLORS,SRCCOPY)==(Z)GDI_ERROR) { oow; }
  }




//   aaLog(-555,"%x %i %i %i %i",handle,aaRectParts(srce_rect));
 srce_surp->in_blit=NO;
 return RET_YES;
 }







 B aaSurfaceImageDrawUsingSurface      (H handle,_rect*imagerect,H dhandle,_rect*drect,B hflip,B vflip,B xalpha)
 {
 B ret;
 _aa_surfaceobject*surp;
 _aa_surfaceobject*dsurp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,dhandle,(VP)&dsurp,NULL))!=RET_YES) { return ret; }
 return(aaSurfaceImageDraw(handle,&dsurp->status.size,imagerect,dsurp->status.mem,drect,hflip,vflip,xalpha));
 }








 B aaSurfaceImageDraw                  (H handle,_size*imgsize,_rect*imgrect,VP img,_rect*drect,B hflip,B vflip,B xalpha)
 {
 B ret;
 _aa_surfaceobject*surp;
 _rect r1,r2;
 _aaDiv xdiv,ydiv;
 H y_off;
 register N x,y;
 register N z,dx,dy;
 N dx_tmp,dx_inc,dy_inc;
 _rgba*pn;
 _rgba*dpn;
 B ov;
 H WWW,HHH;
 H pre_stepx[4000];
 H pre_stepy[4000];
 H fulls,mods;
 _pixelstyle*pstylep;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(img==NULL) { return RET_BADPARM; }
 if((ret=aaSizeIsValid(imgsize))!=RET_YES) { return ret; }
 if(imgrect==NULL) { aaRectSet(&r1,0,0,imgsize->w,imgsize->h); }
 else              { aaRectCopy(&r1,imgrect);                  }
 if((ret=aaRectIsValid(&r1))!=RET_YES) { return ret; }
 if(drect==NULL) { aaRectSet(&r2,0,0,imgsize->w,imgsize->h); }
 else            { aaRectCopy(&r2,drect);                    }
 if((ret=aaRectIsValid(&r2))!=RET_YES) { return ret; }

 pstylep=(_pixelstyle*)&surp->status.pixl_style;
 UNUSE(pstylep);


 WWW=surp->status.size.w;
 HHH=surp->status.size.h;

 #if 1
 if(r2.w<r1.w&&r1.w%2!=0) {  r1.w+=1; }
 if(r2.h<r1.h&&r1.h%2!=0) {  r1.h+=1; }
 #endif

 aaNumDivInit(xdiv,r1.w,r2.w);
 aaNumDivInit(ydiv,r1.h,r2.h);
 aaNumDivReset(ydiv,r1.y);
 if(vflip==YES) { dy=(r2.y+r2.h)-1; dy_inc=-1; }
 else             { dy=r2.y; dy_inc=+1; }
 if(hflip==YES) { dx=(r2.x+r2.w)-1; dx_inc=-1; }
 else             { dx=r2.x; dx_inc=+1; }
 dx_tmp=dx;
 if(r1.w==r2.w&&r1.h==r2.h&&xalpha==255)  {   goto noscale;  }
 if  (xalpha==0)
  {
  for(y=0;y<(N)r2.h;y++)
   {
   aaNumDivReset(xdiv,r1.x);
   y_off=(ydiv.result*imgsize->w);
   aaCast(pn,_rgba*,img);
   pn+=y_off;
   dx=dx_tmp;
   for(x=0;x<(N)r2.w;x++)
    {
    surp->PixelPut(surp,dx,dy,&pn[xdiv.result]);
    aaNumDivStepInc(xdiv);
    dx+=dx_inc;
    }
   aaNumDivStepInc(ydiv);   dy+=dy_inc;
   }
  }
 else
  if(xalpha==255)
   {
   if(r2.w>=aaElementCount(pre_stepx)) { aaNote(0,"prestepx fail, w=%i",r2.w); }
   if(r2.h>=aaElementCount(pre_stepy)) { aaNote(0,"prestepy fail, h=%i",r2.h); }
   aaNumDivReset(xdiv,r1.x);
   for(x=0;x<(N)r2.w;x++) {  pre_stepx[x]=xdiv.result;             aaNumDivStepInc(xdiv);   }
   aaNumDivReset(ydiv,r1.y);
   for(y=0;y<(N)r2.h;y++) {  pre_stepy[y]=ydiv.result*imgsize->w;  aaNumDivStepInc(ydiv);   }
   fulls=r2.w/16;
   mods=r2.w%16;
   for(y=0;y<(N)r2.h;y++)
    {
    aaCast(pn,_rgba*,img);
    pn+=pre_stepy[y];
    dx=dx_tmp;
    aaCast(dpn,_rgba*,&surp->status.mem[(dy*WWW)]);
    if(dy<(N)HHH)
     {
     z=0;
     for(x=0;x<(N)fulls;x++)
      {
      dpn[dx]=pn[pre_stepx[z+ 0]];   dx+=dx_inc;      dpn[dx]=pn[pre_stepx[z+ 1]];   dx+=dx_inc;
      dpn[dx]=pn[pre_stepx[z+ 2]];   dx+=dx_inc;      dpn[dx]=pn[pre_stepx[z+ 3]];   dx+=dx_inc;
      dpn[dx]=pn[pre_stepx[z+ 4]];   dx+=dx_inc;      dpn[dx]=pn[pre_stepx[z+ 5]];   dx+=dx_inc;
      dpn[dx]=pn[pre_stepx[z+ 6]];   dx+=dx_inc;      dpn[dx]=pn[pre_stepx[z+ 7]];   dx+=dx_inc;
      dpn[dx]=pn[pre_stepx[z+ 8]];   dx+=dx_inc;      dpn[dx]=pn[pre_stepx[z+ 9]];   dx+=dx_inc;
      dpn[dx]=pn[pre_stepx[z+10]];   dx+=dx_inc;      dpn[dx]=pn[pre_stepx[z+11]];   dx+=dx_inc;
      dpn[dx]=pn[pre_stepx[z+12]];   dx+=dx_inc;      dpn[dx]=pn[pre_stepx[z+13]];   dx+=dx_inc;
      dpn[dx]=pn[pre_stepx[z+14]];   dx+=dx_inc;      dpn[dx]=pn[pre_stepx[z+15]];   dx+=dx_inc;
      z+=16;
      }

     z=fulls*16;
     for(x=0;x<(N)mods;x++)
      {
      dpn[dx]=pn[pre_stepx[z]];
      dx+=dx_inc;
      z++;
      }
     }

    dy+=dy_inc;
    }
   }
 else
  {
  for(y=0;y<(N)r2.h;y++)
   {
   aaNumDivReset(xdiv,r1.x);
   y_off=(ydiv.result*imgsize->w);
   aaCast(pn,_rgba*,img);
   pn+=y_off;
   dx=dx_tmp;
   for(x=0;x<(N)r2.w;x++)
    {
    if(pn[xdiv.result].a!=0)
     {
     ov=pn[xdiv.result].a;
     pn[xdiv.result].a=xalpha;
     surp->PixelPut(surp,dx,dy,&pn[xdiv.result]);
     pn[xdiv.result].a=ov;
     }
    aaNumDivStepInc(xdiv);
    dx+=dx_inc;
    }
   aaNumDivStepInc(ydiv);   dy+=dy_inc;
   }
  }
 return RET_YES;

noscale:

  y_off=r1.y;
   fulls=r2.w/16;
   mods=r2.w%16;
   for(y=0;y<(N)r2.h;y++)
    {
    aaCast(pn,_rgba*,img);
    pn+=(y_off*imgsize->w)+r1.x;
    aaCast(dpn,_rgba*,surp->status.mem);
    dpn+=(dy*WWW);
    dx=dx_tmp;
    if(dy<(N)HHH)
     {
     z=0;
     for(x=0;x<(N)fulls;x++)
      {
      dpn[dx]=pn[z+ 0];  dx+=dx_inc;      dpn[dx]=pn[z+ 1];  dx+=dx_inc;
      dpn[dx]=pn[z+ 2];  dx+=dx_inc;      dpn[dx]=pn[z+ 3];  dx+=dx_inc;
      dpn[dx]=pn[z+ 4];  dx+=dx_inc;      dpn[dx]=pn[z+ 5];  dx+=dx_inc;
      dpn[dx]=pn[z+ 6];  dx+=dx_inc;      dpn[dx]=pn[z+ 7];  dx+=dx_inc;
      dpn[dx]=pn[z+ 8];  dx+=dx_inc;      dpn[dx]=pn[z+ 9];  dx+=dx_inc;
      dpn[dx]=pn[z+10];  dx+=dx_inc;      dpn[dx]=pn[z+11];  dx+=dx_inc;
      dpn[dx]=pn[z+12];  dx+=dx_inc;      dpn[dx]=pn[z+13];  dx+=dx_inc;
      dpn[dx]=pn[z+14];  dx+=dx_inc;      dpn[dx]=pn[z+15];  dx+=dx_inc;
      z+=16;
      }
     z=fulls*16;
     for(x=0;x<(N)mods;x++)  {  dpn[dx]=pn[z];   dx+=dx_inc;      z++;      }
     }
    y_off++;
    dy+=dy_inc;
    }
 return RET_YES;
 }




 B aaSurfaceImageGrab                  (H handle,_rect*rect,_cord*imgcord,_size*imgsize,VP img)
 {
 B ret;
 _aa_surfaceobject*surp;
 H x,y;
 _rgba*simg;
 _rgba*dimg;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 for(y=0;y<rect->h;y++)
  {
  simg=&surp->status.mem[((rect->y+y)*surp->status.size.w)+rect->x];
  dimg=(_rgba*)img;
  dimg+=((imgcord->y+y)*imgsize->w);
  dimg+=(imgcord->x);
  for(x=0;x<rect->w;x++) {   *dimg=*simg;   dimg++;   simg++;   }
  }
 return RET_YES;
 }




 B aaSurfaceImageTile                  (H handle,_size*imgsize,_rect*imgrect,VP img,_rect*drect,B hflip,B vflip,B xalpha)
 {
 B ret;
 _aa_surfaceobject*surp;
 _rect r1,r2;
 N xc,yc,xm,ym,y,x=0;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 xc=drect->w/imgrect->w;
 yc=drect->h/imgrect->h;
 xm=drect->w%imgrect->w;
 ym=drect->h%imgrect->h;
 for(y=0;y<yc;y++)
  {
  for(x=0;x<xc;x++)
   {
   aaRectSet(&r1,imgrect->x,imgrect->y,imgrect->w,imgrect->h);
   aaRectSet(&r2,0,0,imgrect->w,imgrect->h);
   aaRectAdjust(&r2,drect->x+(x*imgrect->w),drect->y+(y*imgrect->h),0,0);
   aaSurfaceImageDraw(handle,imgsize,&r1,img,&r2,hflip,vflip,xalpha);
   }
  }
 if(xm)
  {
  for(y=0;y<yc;y++)
   {
   aaRectSet(&r1,imgrect->x,imgrect->y,xm,imgrect->h);
   aaRectSet(&r2,0,0,xm,imgrect->h);
   aaRectAdjust(&r2,drect->x+(x*imgrect->w),drect->y+(y*imgrect->h),0,0);
   aaSurfaceImageDraw(handle,imgsize,&r1,img,&r2,hflip,vflip,xalpha);
   }
  }
 if(ym)
  {
  for(x=0;x<xc;x++)
   {
   aaRectSet(&r1,imgrect->x,imgrect->y,imgrect->w,ym);
   aaRectSet(&r2,0,0,imgrect->w,ym);
   aaRectAdjust(&r2,drect->x+(x*imgrect->w),drect->y+(y*imgrect->h),0,0);
   aaSurfaceImageDraw(handle,imgsize,&r1,img,&r2,hflip,vflip,xalpha);
   oof;
   }
  }
 if(xm&&ym)
  {
  aaRectSet(&r1,imgrect->x,imgrect->y,xm,ym);
  aaRectSet(&r2,0,0,xm,ym);
  aaRectAdjust(&r2,drect->x+(x*imgrect->w),drect->y+(y*imgrect->h),0,0);
  aaSurfaceImageDraw(handle,imgsize,&r1,img,&r2,hflip,vflip,xalpha);
  }
 return RET_YES;
 }




 V aa_SurfaceWarpProc                  (_aa_surfaceobject*surp,_rgba*dst,_size*dsize,_size*ssize,POINT ul,POINT ur,POINT lr,POINT ll,_rgba*src,N x1,N y1,N x2,N y2,B xalpha)
 {
 POINT tm,lm,rm,bm,m;
 LONG mx,my;
 _rgba temp_rgba;
 H soff;
 _cord cd;


 if((aaNumAbs(ul.x-ur.x)<aa_WARP_THRESH)&&(aaNumAbs(ul.x-lr.x)<aa_WARP_THRESH)&&(aaNumAbs(ul.x-ll.x)<aa_WARP_THRESH)&&(aaNumAbs(ul.y-ur.y)<aa_WARP_THRESH)&&(aaNumAbs(ul.y-lr.y)<aa_WARP_THRESH)&&(aaNumAbs(ul.y-ll.y)<aa_WARP_THRESH))
  {
  soff=((y1>>aa_WARP_SHIFTS)*ssize->w)+(x1>>aa_WARP_SHIFTS);
   {
   cd.x=(ul.x>>aa_WARP_SHIFTS);
   cd.y=(ul.y>>aa_WARP_SHIFTS);
   temp_rgba=src[soff];
   temp_rgba.a=xalpha;
   surp->PixelPut(surp,cd.x,cd.y,&temp_rgba);
   }
  }
 else
  {
  tm.x=(ul.x+ur.x)>>1; tm.y=(ul.y+ur.y)>>1;
  bm.x=(ll.x+lr.x)>>1; bm.y=(ll.y+lr.y)>>1;
  lm.x=(ul.x+ll.x)>>1; lm.y=(ul.y+ll.y)>>1;
  rm.x=(ur.x+lr.x)>>1; rm.y=(ur.y+lr.y)>>1;
   m.x=(tm.x+bm.x)>>1;  m.y=(tm.y+bm.y)>>1;
    mx=(x1+x2)>>1;       my=(y1+y2)>>1;
  aa_SurfaceWarpProc(surp,dst,dsize,ssize,ul,tm,m,lm,src,x1,y1,mx,my,xalpha);
  aa_SurfaceWarpProc(surp,dst,dsize,ssize,tm,ur,rm,m,src,mx,y1,x2,my,xalpha);
  aa_SurfaceWarpProc(surp,dst,dsize,ssize,m,rm,lr,bm,src,mx,my,x2,y2,xalpha);
  aa_SurfaceWarpProc(surp,dst,dsize,ssize,lm,m,bm,ll,src,x1,my,mx,y2,xalpha);
  }
 }




 B aaSurfaceImageWarp                  (H handle,_size*imgsize,_rect*imgrect,VP img,_cord*c1,_cord*c2,_cord*c3,_cord*c4,B hflip,B vflip,B xalpha)
 {
 B ret;
 _aa_surfaceobject*surp;
 POINT ul,ur,lr,ll;
 N x1,y1,x2,y2;
 _size ds,ss;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }

 ul.x=c1->x; ul.y=c1->y;
 ur.x=c2->x; ur.y=c2->y;
 lr.x=c3->x; lr.y=c3->y;
 ll.x=c4->x; ll.y=c4->y;
 x1=imgrect->x; y1=imgrect->y;
 x2=imgrect->w; y2=imgrect->h;
 x1<<=aa_WARP_SHIFTS; y1<<=aa_WARP_SHIFTS;
 x2<<=aa_WARP_SHIFTS; y2<<=aa_WARP_SHIFTS;
 ul.x<<=aa_WARP_SHIFTS; ul.y<<=aa_WARP_SHIFTS;
 ur.x<<=aa_WARP_SHIFTS; ur.y<<=aa_WARP_SHIFTS;
 lr.x<<=aa_WARP_SHIFTS; lr.y<<=aa_WARP_SHIFTS;
 ll.x<<=aa_WARP_SHIFTS; ll.y<<=aa_WARP_SHIFTS;
 aaSizeSet(&ds,surp->status.size.w,surp->status.size.h);
 aaSizeSet(&ss,imgsize->w,imgsize->h);
 if(hflip!=YES&&vflip!=YES) { aa_SurfaceWarpProc(surp,surp->status.mem,&ds,&ss,ul,ur,lr,ll,img,x1,y1,x2,y2,xalpha); }
 else
 if(hflip!=YES&&vflip==YES) { aa_SurfaceWarpProc(surp,surp->status.mem,&ds,&ss,ul,ur,lr,ll,img,x1,y2,x2,y1,xalpha); }
 else
 if(hflip==YES&&vflip!=YES) { aa_SurfaceWarpProc(surp,surp->status.mem,&ds,&ss,ul,ur,lr,ll,img,x2,y1,x1,y2,xalpha); }
 else
 if(hflip==YES&&vflip==YES) { aa_SurfaceWarpProc(surp,surp->status.mem,&ds,&ss,ul,ur,lr,ll,img,x2,y2,x1,y1,xalpha); }
 return RET_YES;
 }






 B aaSurfaceImageRgbaReplace           (H handle,_rect*rect,_rgba*p1,_rgba*p2,B logic,B checkalpha)
 {
 B ret;
 _aa_surfaceobject*surp;
 _rect mr;
 N x,y;
 _rgba vp1,vp2;
 _cord cd;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(rect==NULL) { aaRectSet(&mr,0,0,surp->status.size.w,surp->status.size.h); }
 else           { aaRectCopy(&mr,rect); }
 if(aaRectIsValid(&mr)!=RET_YES) { return RET_BADPARM; }
 if(p1==NULL) { return RET_BADPARM; }
 if(p2==NULL) { aaRgbaSet(&vp2,0,0,0,0); }
 else         { aaRgbaCopy(&vp2,p2); }

 for(y=0;y<(N)mr.h;y++)
  {
  for(x=0;x<(N)mr.w;x++)
   {
   cd.x=mr.x+x;
   cd.y=mr.y+y;
   surp->PixelGet(surp,cd.x,cd.y,&vp1);
   if(logic==YES)
    {
    if(vp1.r==p1->r&&vp1.g==p1->g&&vp1.b==p1->b)
     {
     if((checkalpha==YES&&vp1.a==p1->a)||(checkalpha!=YES))
      {
      surp->PixelSet(surp,cd.x,cd.y,&vp2);
      }
     }
    }
   else
    {
    if(vp1.r!=p1->r||vp1.g!=p1->g||vp1.b!=p1->b)
     {
     surp->PixelSet(surp,cd.x,cd.y,&vp2);
     }
    }
   }
  }
 return RET_YES;
 }




 B aaSurfacePixelStyleSet              (H handle,_pixelstyle*pixelstyle)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(pixelstyle==NULL) { return RET_BADPARM; }
 aaMemoryCopy(&surp->status.pixl_style,sizeof(_pixelstyle),pixelstyle);
 return RET_YES;
 }



 B aaSurfacePixelStyleGet              (H handle,_pixelstyle*pixelstyle)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(pixelstyle==NULL) { return RET_BADPARM; }
 aaMemoryCopy(pixelstyle,sizeof(_pixelstyle),&surp->status.pixl_style);
 return RET_YES;
 }




 B aaSurfacePixelPutProcGet            (H handle,PP proc)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(proc) { *proc=surp->PixelPut; }
 return RET_YES;
 }




 B aaSurfacePixelSetProcGet            (H handle,PP proc)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(proc) { *proc=surp->PixelSet; }
 return RET_YES;
 }



 B aaSurfacePixelGetProcGet            (H handle,PP proc)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(proc) { *proc=surp->PixelGet; }
 return RET_YES;
 }



 B aaSurfacePixelPutProcSet            (H handle,B(*Proc)(VP sobj,N,N,_rgba*))
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(Proc==NULL) { surp->PixelPut=aaSurfacePixelPutProc; }
 else           { surp->PixelPut=Proc; }
 return RET_YES;
 }



 B aaSurfacePixelSetProcSet            (H handle,B(*Proc)(VP,N,N,_rgba*))
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(Proc==NULL) { surp->PixelSet=aaSurfacePixelSetProc; }
 else           { surp->PixelSet=Proc; }
 return RET_YES;
 }


 B aaSurfacePixelGetProcSet            (H handle,B(*Proc)(VP,N,N,_rgba*))
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(Proc==NULL) { surp->PixelGet=aaSurfacePixelGetProc; }
 else           { surp->PixelGet=Proc; }
 return RET_YES;
 }




 B aaSurfacePixelPut                   (H handle,_cord*c1,_rgba*p1)
 {
 B ret;
 _aa_surfaceobject*surp;

 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(c1==NULL) { return RET_BADPARM; }
 if(p1==NULL) { return RET_BADPARM; }
 surp->PixelPut(surp,c1->x,c1->y,p1);
 return RET_YES;
 }




 B aaSurfacePixelSet                   (H handle,_cord*c1,_rgba*p1)
 {
 B ret;
 _aa_surfaceobject*surp;

 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(c1==NULL) { return RET_BADPARM; }
 if(p1==NULL) { return RET_BADPARM; }
 surp->PixelSet(surp,c1->x,c1->y,p1);
 return RET_YES;
 }



 B aaSurfacePixelGet                   (H handle,_cord*c1,_rgba*p1)
 {
 B ret;
 _aa_surfaceobject*surp;

 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(c1==NULL) { return RET_BADPARM; }
 if(p1==NULL) { return RET_BADPARM; }
 surp->PixelGet(surp,c1->x,c1->y,p1);
 return RET_YES;
 }






 B aaSurfaceMaskSet                    (H handle,_rgba*p1)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(p1==NULL) { surp->status.is_mask=NO; }
 else         { surp->status.is_mask=YES; aaRgbaCopy(&surp->status.mask,p1); }
 return RET_YES;
 }


 B aaSurfaceMaskGet                    (H handle,_rgba*p1)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(p1==NULL) { return RET_BADPARM; }
 aaRgbaCopy(p1,&surp->status.mask);
 return RET_YES;
 }




 B aaSurfaceMaskNotSet                 (H handle,_rgba*p1)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(p1==NULL) { surp->status.is_masknot=NO; }
 else         { surp->status.is_masknot=YES; aaRgbaCopy(&surp->status.mask_not,p1); }
 return RET_YES;
 }


 B aaSurfaceMaskNotGet                 (H handle,_rgba*p1)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(p1==NULL) { return RET_BADPARM; }
 aaRgbaCopy(p1,&surp->status.mask_not);
 return RET_YES;
 }





 B aaSurfaceLine                       (H handle,_cord*c1,_cord*c2,_rgba*p1)
 {
 B ret;
 _aa_surfaceobject*surp;
 _cord df;
 N numpixels,i,x,y;
 N d,dinc1,dinc2;
 N xinc1,xinc2;
 N yinc1,yinc2;
 B(*PixelFunc)(VP surfobj,N x,N y,_rgba*p1);
 _pixelstyle*pstylep;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(p1==NULL) { return RET_BADPARM; }
 if(c1==NULL) { return RET_BADPARM; }
 if(c2==NULL) { return RET_BADPARM; }
 aaCordSubtract(c1,c2,&df);
 df.x=aaNumAbs(df.x);
 df.y=aaNumAbs(df.y);
 pstylep=(_pixelstyle*)&surp->status.pixl_style;
 UNUSE(pstylep);
 PixelFunc=surp->PixelPut;

 if(df.x==0&&df.y==0)
  {
  PixelFunc(surp,c1->x,c1->y,p1);
  return RET_YES;
  }

 if(df.x>=df.y)
  {
  numpixels=df.x;
  d=2*df.y-df.x;
  dinc1=df.y*2;
  dinc2=(df.y-df.x)*2;
  xinc1=xinc2=yinc2=1;
  yinc1=0;
  }
 else
  {
  numpixels=df.y;
  d=2*df.x-df.y;
  dinc1=df.x*2;
  dinc2=(df.x-df.y)*2;
  xinc1=0;
  xinc2=yinc1=yinc2=1;
  }
 numpixels++;
 if(c1->x>c2->x)  {  xinc1=-xinc1;  xinc2=-xinc2;  }
 if(c1->y>c2->y)  {  yinc1=-yinc1;  yinc2=-yinc2;  }
 x=c1->x;
 y=c1->y;
 for(i=0;i<numpixels; i++)
  {
  PixelFunc(surp,x,y,p1);
  if(d<0)   {   d+=dinc1;   x+=xinc1;   y+=yinc1;   }
  else      {   d+=dinc2;   x+=xinc2;   y+=yinc2;   }
  }

 return RET_YES;
 }





 B aaSurfaceGradientLine               (H handle,_cord*c1,_cord*c2,_rgba*p1,_rgba*p2)
 {
 B ret;
 _aa_surfaceobject*surp;
 _cord df;
 _rgba pn;
 D rr,gg,bb,xa;
 D rd,gd,bd,ad;
 N numpixels,i,x,y;
 N d,dinc1,dinc2;
 N xinc1,xinc2;
 N yinc1,yinc2;
 B(*PixelFunc)(VP,N,N,_rgba*);
 _pixelstyle*pstylep;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(p1==NULL) { return RET_BADPARM; }
 if(p2==NULL) { return RET_BADPARM; }
 if(c1==NULL) { return RET_BADPARM; }
 if(c2==NULL) { return RET_BADPARM; }
 aaCordSubtract(c1,c2,&df);
 df.x=aaNumAbs(df.x);
 df.y=aaNumAbs(df.y);
 pstylep=(_pixelstyle*)&surp->status.pixl_style;
 UNUSE(pstylep);
 PixelFunc=surp->PixelPut;

 if(df.x==0&&df.y==0)
  {
  PixelFunc(surp,c1->x,c1->y,p1);
  return RET_YES;
  }

 if(df.x>=df.y)
  {
  numpixels=df.x;
  d=2*df.y-df.x;
  dinc1=df.y*2;
  dinc2=(df.y-df.x)*2;
  xinc1=xinc2=yinc2=1;
  yinc1=0;
  }
 else
  {
  numpixels=df.y;
  d=2*df.x-df.y;
  dinc1=df.x*2;
  dinc2=(df.x-df.y)*2;
  xinc1=0;
  xinc2=yinc1=yinc2=1;
  }
 numpixels++;
 aaRgbaCopy(&pn,p1);
 rd=p2->r-p1->r;
 gd=p2->g-p1->g;
 bd=p2->b-p1->b;
 ad=p2->a-p1->a;
 rd=rd/(D)numpixels;
 gd=gd/(D)numpixels;
 bd=bd/(D)numpixels;
 ad=ad/(D)numpixels;
 rr=p1->r;
 gg=p1->g;
 bb=p1->b;
 xa=p1->a;


 if(c1->x>c2->x)  {  xinc1=-xinc1;  xinc2=-xinc2;  }
 if(c1->y>c2->y)  {  yinc1=-yinc1;  yinc2=-yinc2;  }
 x=c1->x;
 y=c1->y;
 for(i=0;i<numpixels; i++)
  {
  rr=aaNumClamp(rr,0,255);
  gg=aaNumClamp(gg,0,255);
  bb=aaNumClamp(bb,0,255);
  xa=aaNumClamp(xa,0,255);
  pn.r=(B)rr;
  pn.g=(B)gg;
  pn.b=(B)bb;
  pn.a=(B)xa;
  PixelFunc(surp,x,y,&pn);
  rr+=rd;
  gg+=gd;
  bb+=bd;
  xa+=ad;
  if(d<0)   {   d+=dinc1;   x+=xinc1;   y+=yinc1;   }
  else      {   d+=dinc2;   x+=xinc2;   y+=yinc2;   }
  }

 return RET_YES;
 }





 B aaSurfaceDottedLine                 (H handle,_cord*c1,_cord*c2,N mx,N my,_rgba*p1)
 {
 B ret;
 _pixelstyle pstyle_save;
 _pixelstyle pstyle_data;
 _pixelstyle*pstylep;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(c1==NULL) { return RET_BADPARM; }
 if(c2==NULL) { return RET_BADPARM; }
 if(p1==NULL) { return RET_BADPARM; }
 if((ret=aaSurfacePixelStyleGet(handle,&pstyle_save))!=YES) { return ret; }
 aaPixelStyleInit(&pstyle_data);
 pstylep=(_pixelstyle*)&pstyle_data;
 pstylep->mode=5;   // dotted
 pstylep->nparm0=1; // sizew1
 pstylep->nparm1=1;
 pstylep->nparm2=mx; // only on 4th mod pix
 pstylep->nparm3=my;
 if(aaSurfacePixelStyleSet(handle,&pstyle_data)!=YES) oof;
 aaSurfaceLine(handle,c1,c2,p1);
 aaSurfacePixelStyleSet(handle,&pstyle_save);
 return RET_YES;
 }






 B aaSurfaceClear                      (H handle,_rgba*p1)
 {
 B ret;
 _aa_surfaceobject*surp;
 register H i;
 register QP qp;
 _rgba pn;
 H p,dwrd;
 Q quad;
 H eights,rems;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(p1==NULL) { aaRgbaSet(&pn,0,0,0,0); }
 else         { aaRgbaCopy(&pn,p1); }
 //p=surp->status.max_size.w*surp->status.max_size.h;
 p=surp->status.size.w*surp->status.size.h;
 dwrd=*(HP)&pn;
 quad=(Q)dwrd;
 quad=quad<<32LL;
 quad=quad+(Q)dwrd;
 eights=p/2;
   rems=p%2;
 qp=(QP)surp->status.mem;
 for(i=0;i<eights;i++)  {  qp[i]=quad;  }
 if(rems!=0)            {  surp->status.mem[i*2]=pn;  }
 return RET_YES;
 }








 B aaSurfaceErase                      (H handle,_rect*rect,_rgba*p1)
 {
 B ret;
 _aa_surfaceobject*surp;
 register H i,j;
 register QP qp;
 register _rgba*mm;
 _rgba pn;
 Q quad;
 H dwrd,eights,rems,w,h;
 N x,y;
 //_rect r1;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(p1==NULL) { aaRgbaSet(&pn,0,0,0,0); }
 else         { aaRgbaCopy(&pn,p1); }
 if(rect==NULL) { x=0;       y=0;       w=surp->status.size.w; h=surp->status.size.h; }
 else           { x=rect->x; y=rect->y; w=rect->w;             h=rect->h;             }

 /*
 if(x!=0||((w-x)!=surp->status.size.w))
  {
  aaRectSet(&r1,x,y,w,h);
  aaDebugf("%i,%i,%i,%i ",aaRectParts(r1));
  return(aaSurfaceFill(handle,&r1,&pn));
  }
 */

 dwrd=*(HP)&pn;
 quad=(Q)dwrd;
 quad=quad<<32LL;
 quad=quad+(Q)dwrd;

 eights=w/2;
   rems=w%2;
 mm=surp->status.mem;
 //mm+=((y*surp->status.max_size.w)+x);
 mm+=((y*surp->status.size.w)+x);

 qp=(QP)mm;
 for(i=0;i<h;i++)
  {
  for(j=0;j<eights;j++)  {  qp[j]=quad;   }
  if(rems)               {  mm+=(j*2);  *(HP)mm=dwrd;  }
  mm=(_rgba*)qp;
  //mm+=surp->status.max_size.w;
  mm+=surp->status.size.w;
  qp=(QP)mm;
  }
 return RET_YES;
 }








 B aaSurfaceFill                       (H handle,_rect*rect,_rgba*p1)
 {
 B ret;
 _aa_surfaceobject*surp;
 register N x,y;
 register H off;
 N minx,miny;
 N maxx,maxy;
 _rect mr;
 _cord cd;
 B(*PixelFunc)(VP surfobj,N x,N y,_rgba*p1);
 _pixelstyle*pstylep;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(rect==NULL) { aaRectSet(&mr,0,0,surp->status.size.w,surp->status.size.h); }
 else           { aaRectCopy(&mr,rect); }
 if(aaRectIsValid(&mr)!=RET_YES) { return RET_BADPARM; }
 if(p1==NULL)                    { return RET_BADPARM; }
 pstylep=(_pixelstyle*)&surp->status.pixl_style;
 PixelFunc=surp->PixelPut;
 if(pstylep->mode==0&&p1->a==255&&surp->PixelPut==aaSurfacePixelPutProc&&surp->PixelSet==aaSurfacePixelSetProc)
  {
  if(surp->status.is_mask==NO&&surp->status.is_masknot==NO)
   {
   if(mr.x>=0&&mr.y>=0&&mr.w>0&&mr.h>0)
    {
    if((mr.x+mr.w)<=surp->status.size.w&&(mr.y+mr.h)<=surp->status.size.h)
     {
     if(surp->status.is_clipper==NO&&surp->status.is_vflip==NO)
      {
      for(y=0;y<(N)mr.h;y++)
       {
       off=((mr.y+y)*surp->status.size.w)+mr.x;
       for(x=0;x<(N)mr.w;x++) {    *(_rgba*)&surp->status.mem[off++]=*p1;       }
       }
      return RET_YES;
      }
     }
    }
   }
  }
 if(pstylep->mode==0&&p1->a==255&&surp->PixelPut==aaSurfacePixelPutProc&&surp->PixelSet==aaSurfacePixelSetProc)
  {
  if(surp->status.is_mask==NO&&surp->status.is_masknot==NO)
   {
   if(mr.x>=0&&mr.y>=0&&mr.w>0&&mr.h>0)
    {
    if((mr.x+mr.w)<=surp->status.size.w&&(mr.y+mr.h)<=surp->status.size.h)
     {
     if(surp->status.is_clipper==YES&&surp->status.is_vflip==NO)
      {
      minx=surp->status.clipper_rect.x;
      miny=surp->status.clipper_rect.y;
      maxx=surp->status.clipper_rect.x+surp->status.clipper_rect.w;
      maxy=surp->status.clipper_rect.y+surp->status.clipper_rect.h;
      for(y=0;y<(N)mr.h;y++)
       {
       if((mr.y+y)>=miny&&(mr.y+y)<maxy)
        {
        off=((mr.y+y)*surp->status.size.w)+minx;
        for(x=0;x<(N)mr.w;x++)
         {
         if((mr.x+x)<minx)  { continue; }
         if((mr.x+x)>=maxx) { break;    }
         //if((mr.x+x)>=minx&&(mr.x+x)<maxx)
          {
          off=((mr.y+y)*surp->status.size.w)+mr.x+x;
          *(_rgba*)&surp->status.mem[off++]=*p1;
          }
         }
        }
       }
      return RET_YES;
      }
     }
    }
   }
  }
 cd.y=mr.y;
  for(y=0;y<(N)mr.h;y++)
   {
   cd.x=mr.x;
   for(x=0;x<(N)mr.w;x++)
    {
    PixelFunc(surp,cd.x,cd.y,p1);
    cd.x++;
    }
   cd.y++;
   }
 return RET_YES;
 }









 B aaSurfaceFrame                      (H handle,_rect*rect,_rgba*p1)
 {
 B ret;
 _aa_surfaceobject*surp;
 _cord c1,c2;
 _rect rr;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(rect==NULL) { aaRectSet(&rr,0,0,surp->status.size.w,surp->status.size.h); }
 else           { aaRectCopy(&rr,rect); }
 if(p1==NULL) { return RET_BADPARM; }
 if(aaRectIsValid(&rr)!=YES) { return RET_BADPARM; }
 aaCordSet(&c1,rr.x,rr.y);  aaCordSet(&c2,(rr.x+rr.w)-1,c1.y);  aaSurfaceLine(handle,&c1,&c2,p1);
 aaCordSet(&c1,rr.x,rr.y);  aaCordSet(&c2,c1.x,(rr.y+rr.h)-1);  aaSurfaceLine(handle,&c1,&c2,p1);
 aaCordSet(&c1,(rr.x+rr.w)-1,rr.y);  aaCordSet(&c2,c1.x,(rr.y+rr.h)-1);  aaSurfaceLine(handle,&c1,&c2,p1);
 aaCordSet(&c1,rr.x,(rr.y+rr.h)-1);  aaCordSet(&c2,(rr.x+rr.w)-1,c1.y);  aaSurfaceLine(handle,&c1,&c2,p1);
 return RET_YES;
 }



 B aaSurfaceFramePart                  (H handle,_rect*rect,_rgba*p1,B dol,B dot,B dor,B dob,B dotlbr,B dotrbl)
 {
 B ret;
 _aa_surfaceobject*surp;
 _cord c1,c2;
 _rect rr;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(rect==NULL) { aaRectSet(&rr,0,0,surp->status.size.w,surp->status.size.h); }
 else           { aaRectCopy(&rr,rect); }
 if(p1==NULL) { return RET_BADPARM; }
 if(aaRectIsValid(&rr)!=YES) { return RET_BADPARM; }
 if(dot) { aaCordSet(&c1,rr.x,rr.y);  aaCordSet(&c2,(rr.x+rr.w)-1,c1.y);  aaSurfaceLine(handle,&c1,&c2,p1); }
 if(dol) { aaCordSet(&c1,rr.x,rr.y);  aaCordSet(&c2,c1.x,(rr.y+rr.h)-1);  aaSurfaceLine(handle,&c1,&c2,p1); }
 if(dor) { aaCordSet(&c1,(rr.x+rr.w)-1,rr.y);  aaCordSet(&c2,c1.x,(rr.y+rr.h)-1);  aaSurfaceLine(handle,&c1,&c2,p1); }
 if(dob) { aaCordSet(&c1,rr.x,(rr.y+rr.h)-1);  aaCordSet(&c2,(rr.x+rr.w)-1,c1.y);  aaSurfaceLine(handle,&c1,&c2,p1); }
 if(dotlbr) { aaCordSet(&c1,rr.x,rr.y); aaCordSet(&c2,(rr.x+rr.w)-1,(rr.y+rr.h)-1); aaSurfaceLine(handle,&c1,&c2,p1); }
 if(dotrbl) { aaCordSet(&c1,(rr.x+rr.w)-1,rr.y); aaCordSet(&c2,rr.x,(rr.y+rr.h)-1); aaSurfaceLine(handle,&c1,&c2,p1); }
 return RET_YES;
 }


 B aaSurfaceFillFrame                  (H handle,_rect*rect,B thickness,_rgba*p1,_rgba*p2)
 {
 B ret;
 N z;
 _rect rr;
 _aa_surfaceobject*surp;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(rect==NULL) { aaRectSet(&rr,0,0,surp->status.size.w,surp->status.size.h); }
 else           { aaRectCopy(&rr,rect); }
 if(aaRectIsValid(&rr)!=YES) { return RET_BADPARM; }
 if(p2) {  aaSurfaceFill(handle,&rr,p2);    }
 if(thickness==0) { return RET_YES; }
 if(p1)
  {
  for(z=0;z<(N)thickness;z++)
   {
   aaSurfaceFrame(handle,&rr,p1);
   aaRectExpand(&rr,-1,-1);
   }
  }
 return RET_YES;
 }









 B aaSurfacePoly                       (H handle,_cord**cords,_rgba*p1,_rgba*p2)
 {
 B ret;
 _aa_surfaceobject*surp;
 H i,j,flag;
 _cord c1,c2;
 N hx,hy,lx,ly;
 _rect rc1;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(cords==NULL) { return RET_BADPARM; }
 if(p1==NULL&&p2==NULL) { return RET_BADPARM; }
 i=flag=0;
 while(1)
  {
  j=i+1;
  if(cords[i]==NULL) { break; }
  if(cords[j]==NULL) { j=0; flag=1; }
  c1.x=cords[i]->x;
  c1.y=cords[i]->y;
  c2.x=cords[j]->x;
  c2.y=cords[j]->y;
  if(p1!=NULL) { aaSurfaceLine(handle,&c1,&c2,p1);   }
  else         { aaSurfaceLine(handle,&c1,&c2,p2);   }
  if(flag)     { break; }
  i++;
  }
 if(p2)
  {
  lx=ly=+100000;
  hx=hy=-100000;
  for(j=0;j<i;j++)
   {
   if(cords[j]->x<lx) { lx=cords[j]->x; }
   if(cords[j]->y<ly) { ly=cords[j]->y; }
   if(cords[j]->x>hx) { hx=cords[j]->x; }
   if(cords[j]->y>hy) { hy=cords[j]->y; }
   }
  aaRectSet(&rc1,lx,ly,hx-lx,hy-ly);
  c1.x=rc1.x+(rc1.w/2);
  c1.y=rc1.y+(rc1.h/2);
  aaSurfaceFloodFill(handle,&rc1,&c1,p2);
  }
 return RET_YES;
 }






 B aaSurfaceBar                        (H handle,_rect*rect,_rgba*p1,_rgba*p2,H hsk,H vsk)
 {
 B ret;
 _aa_surfaceobject*surp;
 _rgba pn[3];
 _cord c1,c2,c3,c4;
 _rect rc1,rc3;
 N xsl,ysl;
 _cord*cordl[10];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }

 aaMemoryFill(cordl,sizeof(cordl),0);
 cordl[0]=&c1; cordl[1]=&c2;
 cordl[2]=&c3; cordl[3]=&c4;

 aaRectSet(&rc3,rect->x,rect->y,rect->w,rect->h);
 aaRectCopy(&rc1,&rc3);
 xsl=hsk;
 ysl=vsk;
 aaRectAdjust(&rc1,0,0,-xsl,-ysl);

 aaRgbaCopy(&pn[0],p2);
 aaRgbaCopy(&pn[1],p2);
 aaRgbaCopy(&pn[2],p2);
 aaRgbaAdjustUsingHsla(&pn[1],0,0,-40,0,0);
 aaRgbaAdjustUsingHsla(&pn[2],0,0,-70,0,0);

 aaCordSet(&c1,rc1.x,rc1.y);
 aaCordSet(&c2,rc1.x+rc1.w,rc1.y);
 aaCordSet(&c3,rc1.x+rc1.w+xsl,rc1.y+ysl);
 aaCordSet(&c4,rc1.x+xsl,rc1.y+ysl);
 aaSurfacePoly(handle,cordl,p1,&pn[0]);

 aaCordSet(&c1,rc1.x,rc1.y);
 aaCordSet(&c2,rc1.x+xsl,rc1.y+ysl);
 aaCordSet(&c3,rc1.x+xsl,rc1.y+rc1.h+ysl);
 aaCordSet(&c4,rc1.x,rc1.y+rc1.h);
 aaSurfacePoly(handle,cordl,p1,&pn[2]);

 aaCordSet(&c1,rc1.x+xsl,rc1.y+ysl);
 aaCordSet(&c2,rc1.x+rc1.w+xsl,rc1.y+ysl);
 aaCordSet(&c3,rc1.x+rc1.w+xsl,rc1.y+rc1.h+ysl);
 aaCordSet(&c4,rc1.x+xsl,rc1.y+rc1.h+ysl);
 aaSurfacePoly(handle,cordl,p1,&pn[1]);
 return RET_YES;
 }





 B aaSurfaceTriangle                   (H handle,_cord*c1,_cord*c2,_cord*c3,_rgba*p1)
 {
 B ret;
 _aa_surfaceobject*surp;
 _cord cd1,cd2;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(c1==NULL||c2==NULL||c3==NULL) { return RET_BADPARM; }
 aaCordsSet(&cd1,&cd2,c1->x,c1->y,c2->x,c2->y);
 if((ret=aaSurfaceLine(handle,&cd1,&cd2,p1))!=YES) { return ret; }
 aaCordsSet(&cd1,&cd2,c2->x,c2->y,c3->x,c3->y);
 if((ret=aaSurfaceLine(handle,&cd1,&cd2,p1))!=YES) { return ret; }
 aaCordsSet(&cd1,&cd2,c3->x,c3->y,c1->x,c1->y);
 if((ret=aaSurfaceLine(handle,&cd1,&cd2,p1))!=YES) { return ret; }
 return RET_YES;
 }




 B aaSurfaceTriangleFill               (H handle,_cord*c1,_cord*c2,_cord*c3,_rgba*p1)
 {
 B ret;
 _aa_surfaceobject*surp;
 _cord cd1,cd2;
 N tmp;
 N startx[_2K],endx[_2K];
 N xa,ya,xb,yb;
 N miny,maxy;
 N x,m,i,y;
 N x1,y1,x2,y2,x3,y3;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(c1==NULL||c2==NULL||c3==NULL) { return RET_BADPARM; }
 x1=c1->x; y1=c1->y;
 x2=c2->x; y2=c2->y;
 x3=c3->x; y3=c3->y;

 miny=16000;
 maxy=-16000;
 if(y1<miny) miny=y1;
 if(y1>maxy) maxy=y1;
 if(y2<miny) miny=y2;
 if(y2>maxy) maxy=y2;
 if(y3<miny) miny=y3;
 if(y3>maxy) maxy=y3;
 if(miny<0||maxy>2000) return RET_FAILED;
 for(i=miny;i<=maxy;i++)
  {
  startx[i]=endx[i]=-16000;
  }
 xa=x1; ya=y1; xb=x2; yb=y2;

 if(yb!=ya)
  {
  if(yb<ya)   {    tmp=ya;    ya=yb;    yb=tmp;    tmp=xa;    xa=xb;    xb=tmp;   }
  x=(N)xa<<8;
  m=((N)(xb-xa)<<8)/((N)(yb-ya));
  x+=m;
  ya++;
  for(y=ya;y<=yb;y++)
   {
   if((y>=0)&(y<2000))
    {
    if(startx[y]==-16000)  startx[y]=(I)(x>>8);
    else                     endx[y]=(I)(x>>8);
    }
   x+=m;
   }
  }
 xa=x2; ya=y2; xb=x3; yb=y3;
 if(yb!=ya)
  {
  if(yb<ya)   {    tmp=ya;    ya=yb;    yb=tmp;    tmp=xa;    xa=xb;    xb=tmp;   }
  x=(N)xa<<8;
  m=((N)(xb-xa)<<8)/((N)(yb-ya));
  x+=m;
  ya++;
  for(y=ya;y<=yb;y++)
   {
   if((y>=0)&(y<2000))
    {
    if(startx[y]==-16000)  startx[y]=(I)(x>>8);
    else                     endx[y]=(I)(x>>8);
    }
   x+=m;
   }
  }
 xa=x3; ya=y3; xb=x1; yb=y1;
 if(yb!=ya)
  {
  if(yb<ya)   {    tmp=ya;    ya=yb;    yb=tmp;    tmp=xa;    xa=xb;    xb=tmp;   }
  x=(N)xa<<8;
  m=((N)(xb-xa)<<8)/((N)(yb-ya));
  x+=m;
  ya++;
  for(y=ya;y<=yb;y++)
   {
   if((y>=0)&(y<2000))
    {
    if(startx[y]==-16000)  startx[y]=(I)(x>>8);
    else                     endx[y]=(I)(x>>8);
    }
   x+=m;
   }
  }
 for(i=miny;i<=maxy;i++)
  {
  if(startx[i]!=-16000)
   {
   if(endx[i]== -16000) endx[i]=startx[i];
   aaCordsSet(&cd1,&cd2,startx[i],i,endx[i],i);
   aaSurfaceLine(handle,&cd1,&cd2,p1);
   }
  }
 return RET_YES;
 }




 B aaSurfaceEllipse                    (H handle,_rect*rect,_rgba*p1)
 {
 N xoff,yoff;
 Z w2,h2,s,t;
 B ret;
 _aa_surfaceobject*surp;
 _rect rr;
 N x,y,w,h;
 B(*PixelFunc)(VP surfobj,N x,N y,_rgba*p1);

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(rect==NULL) { aaRectSet(&rr,0,0,surp->status.size.w,surp->status.size.h); }
 else           { aaRectCopy(&rr,rect); }
 if(p1==NULL) { return RET_BADPARM; }
 if(aaRectIsValid(&rr)!=YES) { return RET_BADPARM; }
 PixelFunc=surp->PixelPut;
 if(p1->a==255&&surp->PixelPut==aaSurfacePixelPutProc&&surp->PixelSet==aaSurfacePixelSetProc&&surp->status.pixl_style.mode==0)
  {
  PixelFunc=aaSurfacePixelSetProc;
  }
 w=rr.w; h=rr.h; x=rr.x; y=rr.y;
 w=w-1;  w=w>>1;  h=h-1;  h=h>>1;
  w2=w*w;  h2=h*h;
  w2--; h2--;
  s=w2*(1-(h<<1))+(h2<<1);
  t=h2-(w2*((h<<1)-1)<<1);
  xoff=x+w;  yoff=y+h;
  x=0;
  y=h;
  do
   {
   if(s<0)    {    s+=h2*((x<<1)+3)<<1;    t+=h2*(x+1)<<2;    x++;    }
   else
   if(t<0)
    {
    s+=(h2*((x<<1)+3)<<1)-(w2*(y-1)<<2);
    t+=(h2*(x+1)<<2)-(w2*((y<<1)-3)<<1);
    x++;
    y--;
    }
   else    {    s-=w2*(y-1)<<2;    t-=w2*((y<<1)-3)<<1;    y--;    }
   PixelFunc(surp,xoff+x,yoff+y,p1);
   PixelFunc(surp,xoff-x,yoff+y,p1);
   PixelFunc(surp,xoff+x,yoff-y,p1);
   PixelFunc(surp,xoff-x,yoff-y,p1);
   }
  while(y>0);
 y=rr.y;
 PixelFunc(surp,xoff-1,y,p1);  PixelFunc(surp,xoff+0,y,p1);  PixelFunc(surp,xoff+1,y,p1);
 if(aaNumIsMod(rr.h,2))
 y=(rr.y+rr.h)-2;    else
 y=(rr.y+rr.h)-1;
 PixelFunc(surp,xoff-1,y,p1);  PixelFunc(surp,xoff+0,y,p1);  PixelFunc(surp,xoff+1,y,p1);
 x=rr.x;
 PixelFunc(surp,x,yoff-1,p1);  PixelFunc(surp,x,yoff+0,p1);  PixelFunc(surp,x,yoff+1,p1);
 if(aaNumIsMod(rr.w,2))
 x=(rr.x+rr.w)-2;     else
 x=(rr.x+rr.w)-1;
 PixelFunc(surp,x,yoff-1,p1);  PixelFunc(surp,x,yoff+0,p1);  PixelFunc(surp,x,yoff+1,p1);
 return RET_YES;
 }







 B aaSurfaceTriangleFillFrame          (H handle,_cord*c1,_cord*c2,_cord*c3,N thick,_rgba*p1,_rgba*p2)
 {
 B ret;
 _aa_surfaceobject*surp;
 _pixelstyle pstyle_save;
 _pixelstyle pstyle_data;
 //_rect rc1;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 //aaRectCopy(&rc1,rect);
 if(p2)
  {
  //aaRectCopy(&rc1,rect);
  //aaRectExpand(&rc1,-((thick/4)+1),-((thick/4)+1));
  aaSurfaceTriangleFill(handle,c1,c2,c3,p2);//&rc1,p2);
  }
 if(p1)
  {
  //aaRectCopy(&rc1,rect);
  //aaRectExpand(&rc1,-(thick/2),-(thick/2));
  //if((rect->w%2)==1) aaRectExpand(&rc1,-1,0);
  //if((rect->h%2)==1) aaRectExpand(&rc1,0,-1);
  aaSurfacePixelStyleGet(handle,&pstyle_save);
  aaPixelStyleInit(&pstyle_data);
  //aaPixelStyleSet(&pstyle_data,7,1,(thick/2)+1,(thick/2)+1,0,0,0,0,handle);
  aaPixelStyleSet(&pstyle_data,7,1,(thick),(thick),0,0,0,0,handle);
  ///aaSurfaceEllipse(handle,&rc1,p1);
  aaSurfaceTriangle(handle,c1,c2,c3,p1);
  aaSurfacePixelStyleSet(handle,&pstyle_save);
  }
 return RET_YES;
 }




 B aaSurfaceEllipseFill                (H handle,_rect*rect,_rgba*p1)
 {
 _aa_surfaceobject*surp;
 B ret;
 _rect rr;
 N rx,ry;
 N x,y,dc,dd,ix,iy;
 N na,nb,nc,nd;
 N a,b,c,d,da,db;
 _cord cc,ee;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(rect==NULL) { aaRectSet(&rr,0,0,surp->status.size.w,surp->status.size.h); }
 else           { aaRectCopy(&rr,rect); }
 if(p1==NULL) { return RET_BADPARM; }
 if(aaRectIsValid(&rr)!=YES) { return RET_BADPARM; }
 rx=((rr.x+rr.w-1)-rr.x)/2;
 ry=((rr.y+rr.h-1)-rr.y)/2;
 x=rr.x+(rx);
 y=rr.y+(ry);
 if(rx<1)  rx=1;
 if(ry<1)  ry=1;
 if(rx>ry)
  {
  dc=-1;
  dd=0xFFFF;
  ix=0;
  iy=rx*64;
  na=0;
  nb=(iy+32)>>6;
  nc=0;
  nd=(nb*ry)/rx;
  do
   {
   a=na;
   b=nb;
   c=nc;
   d=nd;
   ix=ix+(iy/rx);
   iy=iy-(ix/rx);
   na=(ix+32)>>6;
   nb=(iy+32)>>6;
   nc=(na*ry)/rx;
   nd=(nb*ry)/rx;
   if((c>dc)&&(c<dd))
    {
    cc.x=x-b; cc.y=y+c; ee.x=x+b; ee.y=cc.y;
    aaSurfaceLine(handle,&cc,&ee,p1);
    if(c)
     {
     cc.x=x-b; cc.y=y-c; ee.x=x+b; ee.y=cc.y;
     aaSurfaceLine(handle,&cc,&ee,p1);
     }
    dc=c;
    }
   if((d<dd)&&(d>dc))
    {
    cc.x=x-a; cc.y=y+d; ee.x=x+a; ee.y=cc.y;
    aaSurfaceLine(handle,&cc,&ee,p1);
    cc.x=x-a; cc.y=y-d; ee.x=x+a; ee.y=cc.y;
    aaSurfaceLine(handle,&cc,&ee,p1);
    dd=d;
    }
   }
   while(b>a);
   }
  else
   {
   da=-1;
   db=0xFFFF;
   ix=0;
   iy=ry*64;
   na=0;
   nb=(iy+32)>>6;
   nc=0;
   nd=(nb*rx)/ry;
   do
    {
    a=na;
    b=nb;
    c=nc;
    d=nd;
    ix=ix+(iy/ry);
    iy=iy-(ix/ry);
    na=(ix+32)>>6;
    nb=(iy+32)>>6;
    nc=(na*rx)/ry;
    nd=(nb*rx)/ry;
    if((a>da)&&(a<db))
     {
     cc.x=x-d; cc.y=y+a; ee.x=x+d; ee.y=cc.y;
     aaSurfaceLine(handle,&cc,&ee,p1);
     if(a)
      {
      cc.x=x-d; cc.y=y-a; ee.x=x+d; ee.y=cc.y;
      aaSurfaceLine(handle,&cc,&ee,p1);
      }
     da=a;
     }
    if((b<db)&&(b>da))
     {
     cc.x=x-c; cc.y=y+b; ee.x=x+c; ee.y=cc.y;
     aaSurfaceLine(handle,&cc,&ee,p1);
     cc.x=x-c; cc.y=y-b; ee.x=x+c; ee.y=cc.y;
     aaSurfaceLine(handle,&cc,&ee,p1);
     db=b;
     }
    }
    while(b>a);
    }
 return RET_YES;
 }






 B aaSurfaceEllipseFillFrame           (H handle,_rect*rect,N thick,_rgba*p1,_rgba*p2)
 {
 B ret;
 _aa_surfaceobject*surp;
 _pixelstyle pstyle_save;
 _pixelstyle pstyle_data;
 _rect rc1;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 aaRectCopy(&rc1,rect);
 if(p2)
  {
  aaRectCopy(&rc1,rect);
  aaRectExpand(&rc1,-((thick/4)+1),-((thick/4)+1));
  aaSurfaceEllipseFill(handle,&rc1,p2);
  }
 if(p1)
  {
  aaRectCopy(&rc1,rect);
  aaRectExpand(&rc1,-(thick/2),-(thick/2));
  if((rect->w%2)==1) aaRectExpand(&rc1,-1,0);
  if((rect->h%2)==1) aaRectExpand(&rc1,0,-1);
  aaSurfacePixelStyleGet(handle,&pstyle_save);
  aaPixelStyleInit(&pstyle_data);
  //aaPixelStyleSet(&pstyle_data,7,1,(thick/2)+1,(thick/2)+1,0,0,0,0,handle);
  aaPixelStyleSet(&pstyle_data,7,1,(thick),(thick),0,0,0,0,handle);
  aaSurfaceEllipse(handle,&rc1,p1);
  aaSurfacePixelStyleSet(handle,&pstyle_save);
  }
 return RET_YES;
 }



 B aaSurfaceFloodFill                  (H handle,_rect*r1,_cord*c1,_rgba*p1)
 {
 B ret;
 _aa_surfaceobject*surp;
 _ministack ms;
 _cord cc,cd;
 H val,ww;
 N y1,spanLeft,spanRight;
 N x,y;
 _rect rc;
 _rgba nc,oc;
 _rgba*mem;
 B r,g,b;
 H old_mode;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 aaMiniStackNew(&ms);
 if(p1==NULL) { return RET_BADPARM; }
 if(r1==NULL) { aaRectSet(&rc,0,0,surp->status.size.w,surp->status.size.h); }
 else         { aaRectCopy(&rc,r1);  }
 if(c1==NULL) { aaCordSet(&cc,rc.w/2,rc.h/2); }
 else         { aaCordCopy(&cc,c1); }
 if(cc.x<rc.x) { return RET_BOUNDS; }
 if(cc.x>=(N)(rc.x+rc.w)) { return RET_BOUNDS; }
 if(cc.y<rc.y) { return RET_BOUNDS; }
 if(cc.y>=(N)(rc.y+rc.h)) { return RET_BOUNDS; }
 old_mode=*(HP)&surp->status.pixl_style;
 surp->status.pixl_style.mode=0;
 aaCordSet(&cd,cc.x,cc.y);
 ww=surp->status.size.w;
 aaMiniStackPushDword(&ms,(cd.y*ww)+cd.x);
 mem=(_rgba*)&surp->status.mem[0];
 aaRgbaCopy(&nc,p1);
 x=cd.x; y=cd.y;

 aaSurfacePixelGet(handle,&cd,&oc);
 r=oc.r; g=oc.g; b=oc.b;
 while(1)
  {
  if(ms.height==0) { break; }
  if(aaMiniStackPopDword(&ms,&val)!=YES) break;
  y=val/ww;
  x=val%ww;
  y1=y;
  while(y1>=rc.x&&(mem[(y1*ww)+x].r==r&&mem[(y1*ww)+x].g==g&&mem[(y1*ww)+x].b==b))   {   y1--;   }
  y1++;
  spanLeft=spanRight=0;
  while(y1<(N)(rc.y+rc.h)&&(mem[(y1*ww)+x].r==r&&mem[(y1*ww)+x].g==g&&mem[(y1*ww)+x].b==b))
   {
   surp->PixelPut(surp,x,y1,&nc);
   if(!spanLeft&&x>rc.x&&(mem[(y1*ww)+(x-1)].r==r&&mem[(y1*ww)+(x-1)].g==g&&mem[(y1*ww)+(x-1)].b==b))
    {
    aaMiniStackPushDword(&ms,(y1*ww)+(x-1));
    spanLeft=1;
    }
   else
   if(spanLeft&&x>rc.x&&(mem[(y1*ww)+(x-1)].r!=r||mem[(y1*ww)+(x-1)].g!=g||mem[(y1*ww)+(x-1)].b!=b))
    {
    spanLeft=0;
    }
   if(!spanRight&&x<(N)(rc.x+rc.w-1)&&(mem[(y1*ww)+(x+1)].r==r&&mem[(y1*ww)+(x+1)].g==g&&mem[(y1*ww)+(x+1)].b==b))
    {
    aaMiniStackPushDword(&ms,(y1*ww)+x+1);
    spanRight=1;
    }
   else
   if(spanRight&&x<(N)(rc.x+rc.w-1)&&(mem[(y1*ww)+x+1].r!=r||mem[(y1*ww)+x+1].g!=g||mem[(y1*ww)+x+1].b!=b))
    {
    spanRight=0;
    }
   y1++;
   }
  }
 surp->status.pixl_style.mode=old_mode;
 return RET_YES;
 }







 B aaSurfaceArc                        (H handle,_rect*rect,N astart,N astop,N arot,_rgba*p1)
 {
 D rad_start,rad_stop,rad_rot;
 D rot_cos,rot_sin;
 D aStep=0.05;
 D a;
 N xc,yc,radius1,radius2,x_last,x_tmp,x_next,y_last,y_tmp,y_next;
 _cord c1,c2;
 _rect rr;
 B ret;
 _aa_surfaceobject*surp;
 N x,y,w,h;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(rect==NULL) { aaRectSet(&rr,0,0,surp->status.size.w,surp->status.size.h); }
 else           { aaRectCopy(&rr,rect); }
 if(p1==NULL) { return RET_BADPARM; }
 if(aaRectIsValid(&rr)!=YES) { return RET_BADPARM; }
 x=rr.x; y=rr.y;
 w=rr.w; h=rr.h;
    xc=x+w/2;
    yc=y+h/2;
    radius1=w/2;
    radius2=h/2;
    rad_start=astart*aaPi/180;
    rad_stop=astop*aaPi/180;
    rad_rot=-arot*aaPi/180;
    rot_cos=cos(rad_rot);
    rot_sin=sin(rad_rot);
    if(radius1<2.0) { radius1=2.0; aStep=0.05; }
    if(radius2<2.0) { radius2=2.0; aStep=0.05; }
    if(radius1>2.0&&radius2>2.0)
     {
     if(radius1<radius2)
      {
      if(radius1<1.0e-4) { aStep=1.0; }
      else               { aStep=asin(2.0/radius1);     }
      }
     else
      {
      if(radius2<1.0e-4) { aStep=1.0; }
      else               { aStep=asin(2.0/radius2);   }
      }
     }
    if(aStep<0.05)       { aStep=0.05;  }
    x_tmp=cos(rad_start)*radius1;
    y_tmp=sin(rad_start)*radius2;
    x_next=xc+(rot_cos*x_tmp)-(rot_sin*y_tmp);
    y_next=yc+(rot_cos*y_tmp)+(rot_sin*x_tmp);
    x_last=x_next;
    y_last=y_next;
    for(a=rad_start+aStep;a<=rad_stop;a+=aStep)
     {
     x_tmp=cos(a)*radius1;
     y_tmp=sin(a)*radius2;
     x_next=xc+(rot_cos*x_tmp)-(rot_sin*y_tmp);
     y_next=yc+(rot_cos*y_tmp)+(rot_sin*x_tmp);
     aaCordsSet(&c1,&c2,x_last,y_last,x_next,y_next);
     c1.x=aaNumRoof(c1.x,((x+w)-1));
     c2.x=aaNumRoof(c2.x,((x+w)-1));
     c1.y=aaNumRoof(c1.y,((y+h)-1));
     c2.y=aaNumRoof(c2.y,((y+h)-1));
     aaSurfaceLine(handle,&c1,&c2,p1);
     x_last=x_next;
     y_last=y_next;
    }
 return RET_YES;
 }





 B aaSurfaceRoundedFrame               (H handle,_rect*rect,N r,_rgba*p1)
 {
 B ret;
 _aa_surfaceobject*surp;
 _rect rc1;
 _cord cd1,cd2,cd3,cd4;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(r<0) { return RET_BOUNDS; }
 aaRectToCornerCords(rect,&cd1,&cd2,&cd3,&cd4);
 cd1.x+=r;  cd2.x-=r;                         aaSurfaceLine(handle,&cd1,&cd2,p1);
 cd1.x-=r;  cd2.x+=r;   cd2.y+=r;  cd3.y-=r;  aaSurfaceLine(handle,&cd2,&cd3,p1);
 cd2.y-=r;  cd3.y+=r;   cd3.x-=r;  cd4.x+=r;  aaSurfaceLine(handle,&cd3,&cd4,p1);
 cd3.x+=r;  cd4.x-=r;   cd4.y-=r;  cd1.y+=r;  aaSurfaceLine(handle,&cd4,&cd1,p1);
 aaRectSet(&rc1,rect->x,rect->y,r*2,r*2);                 aaSurfaceArc(handle,&rc1,270,360,90,p1);
 aaRectSet(&rc1,((rect->x+rect->w)-(r*2))-1,rect->y,(r*2)+1,r*2); aaSurfaceArc(handle,&rc1,0,90,90,p1);
 aaRectSet(&rc1,rect->x,(rect->y+rect->h)-(r*2),r*2,r*2); aaSurfaceArc(handle,&rc1,180,270,90,p1);
 aaRectSet(&rc1,((rect->x+rect->w)-(r*2))-1,(rect->y+rect->h)-(r*2),(r*2)+1,r*2);
 aaSurfaceArc(handle,&rc1,90,180,90,p1);
 return RET_YES;
 }








 B aaSurfaceRoundedFill                (H handle,_rect*rect,N r,_rgba*p1)
 {
 B ret;
 _aa_surfaceobject*surp;
 _rect rc1;
 _rect clip;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(r<0) { return RET_BOUNDS; }

 aaSurfaceClipperGet(handle,&clip);
 aaRectCopy(&rc1,rect);

 aaRectAdjust(&rc1,0,r,0,-(r*2));
 aaSurfaceFill(handle,&rc1,p1);

 aaRectAdjust(&rc1,r,-r,-(r*2),0);
 rc1.h=r;
 aaSurfaceFill(handle,&rc1,p1);

 aaRectAdjust(&rc1,0,rect->h-(r),0,0);
 aaSurfaceFill(handle,&rc1,p1);

 aaRectSet(&rc1,rect->x,rect->y,r*1,r*1);
 aaSurfaceClipperSet(handle,&rc1);
 aaRectAdjust(&rc1,0,0,r,r);
 aaSurfaceEllipseFill(handle,&rc1,p1);

 aaSurfaceClipperSet(handle,rect);
 aaRectSet(&rc1,(rect->x+rect->w)-(r*2),rect->y,r*2,r*2);
 aaRectAdjust(&rc1,r,0,-r,-r);
 aaSurfaceClipperSet(handle,&rc1);
 aaRectAdjust(&rc1,-r,0,+r,+r);
 aaSurfaceEllipseFill(handle,&rc1,p1);

 aaRectSet(&rc1,rect->x,(rect->y+rect->h)-(r*1),r*1,r*1);
 aaSurfaceClipperSet(handle,&rc1);
 aaRectAdjust(&rc1,0,-r,r,r);
 aaSurfaceEllipseFill(handle,&rc1,p1);

 aaSurfaceClipperSet(handle,rect);
 aaRectSet(&rc1,(rect->x+rect->w)-(r*2),(rect->y+rect->h)-(r*2),r*2,r*2);
 aaRectAdjust(&rc1,r,r,-r,-r);
 aaSurfaceClipperSet(handle,&rc1);
 aaRectAdjust(&rc1,-r,-r,+r,+r);
 aaSurfaceEllipseFill(handle,&rc1,p1);


 aaSurfaceClipperSet(handle,&clip);
 return RET_YES;
 }




 B aaSurfaceChamfer                    (H handle,_rect*rect,B state,_rgba*p1,N rad)
 {
 B ret;
 _aa_surfaceobject*surp;
 N v,e,u,x,y,i;
 _rgba lpen,rpen,bcol;
 _rect rr;
 _rect r1;
 _cord c1,c2;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(rect==NULL) { aaRectSet(&rr,0,0,surp->status.size.w,surp->status.size.h); }
 else           { aaRectCopy(&rr,rect); }
 if(p1==NULL) { return RET_BADPARM; }
 if(aaRectIsValid(&rr)!=YES) { return RET_BADPARM; }


 aaRgbaCopy(&bcol,p1);
 if(state==NO) {  aaRgbaAdjust(&bcol,-60,-60,-60,0);  }
 else          {  aaRgbaAdjust(&bcol,+60,+60,+60,0);  }
 aaRgbaCopy(&lpen,&bcol);

 aaRgbaCopy(&bcol,p1);
 if(state==NO) {  aaRgbaAdjust(&bcol,+60,+60,+60,0);  }
 else          {  aaRgbaAdjust(&bcol,-60,-60,-60,0);  }
 aaRgbaCopy(&rpen,&bcol);

 aaRectSet(&r1,rr.x+rad,rr.y+rad,rr.w-rad*2,rr.h-rad);
 aaSurfaceFill(handle,&r1,&bcol);
 aaRectSet(&r1,rr.x+rad,rr.y,rr.w-rad*2,rr.h);
 aaSurfaceFill(handle,&r1,&bcol);
 aaRectSet(&r1,rr.x,rr.y+rad,rad,rr.h-rad);
 aaSurfaceFill(handle,&r1,&bcol);
 aaRectSet(&r1,rr.x+rr.w-rad,rr.y+rad,rad,rr.h-rad);
 aaSurfaceFill(handle,&r1,&bcol);
 aaCordsSet(&c1,&c2,rr.x+rad,rr.y,rr.x+rr.w-rad,rr.y);
 aaSurfaceLine(handle,&c1,&c2,&bcol);
 aaCordsSet(&c1,&c2,rr.x,rr.y+rad,rr.x,rr.y+rr.h);
 aaSurfaceLine(handle,&c1,&c2,&lpen);
 aaCordsSet(&c1,&c2,rr.x+rr.w-1,rr.y+rad,rr.x+rr.w-1,rr.y+rr.h);
 aaSurfaceLine(handle,&c1,&c2,&rpen);
 v=2*rad-1;
 e=0;
 u=0;
 x=0;
 y=rad;
 while(x<=y)
     {
     aaCordSet(&c1,rr.x+rad-x,rr.y+rad-y);
     aaSurfacePixelPut(handle,&c1,&lpen);
     aaCordSet(&c1,rr.x+rad-y,rr.y+rad-x);
     aaSurfacePixelPut(handle,&c1,&lpen);
     aaCordSet(&c1,rr.x-rad+(rr.w-1)+x,rr.y+rad-y);
     aaSurfacePixelPut(handle,&c1,&rpen);
     aaCordSet(&c1,rr.x-rad+(rr.w-1)+y,rr.y+rad-x);
     aaSurfacePixelPut(handle,&c1,&rpen);
  for(i=0;i<x;i++)
      {
      aaCordSet(&c1,rr.x+rad-i,rr.y+rad-y);
      aaSurfacePixelPut(handle,&c1,&bcol);
      aaCordSet(&c1,rr.x-rad+(rr.w-1)+i,rr.y+rad-y);
      aaSurfacePixelPut(handle,&c1,&bcol);
      }
  for(i=0;i<y;i++)
      {
      aaCordSet(&c1,rr.x+rad-i,rr.y+rad-x);
      aaSurfacePixelPut(handle,&c1,&bcol);
      aaCordSet(&c1,rr.x-rad+(rr.w-1)+i,rr.y+rad-x);
      aaSurfacePixelPut(handle,&c1,&bcol);
     }
     e+=u;
  u+=2;
  if(v<2*e) { y--; e-=v; v-=2;}
  x++;
  }
 return RET_YES;
 }





 B aaSurfaceGimpTile                   (H handle,_rect*rect,N sz,_rgba*p1,_rgba*p2)
 {
 B ret;
 _aa_surfaceobject*surp;
 N alt1,alt2,x,y;
 _rect r1,rr;
 _rect cc;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(sz<1) { return RET_BOUNDS; }
 alt1=alt2=0;
 if(rect==NULL) { aaRectSet(&rr,0,0,surp->status.size.w,surp->status.size.h); }
 else           { aaRectCopy(&rr,rect); }
 if(aaSurfaceClipperGet(handle,&cc)==YES)
  {
  aaSurfaceClipperSet(handle,&rr);
  }
 for(y=0;y<(N)rr.h;y+=sz)
  {
  for(x=0;x<(N)rr.w;x+=sz)
   {
   aaRectSet(&r1,rr.x+x,rr.y+y,sz,sz);
   if(alt1++==1) {  aaSurfaceFill(handle,&r1,p1); alt1=0; }
   else          {  aaSurfaceFill(handle,&r1,p2); }
   }
  if(alt2++==1) { alt2=0; } alt1=alt2;
  }
 if((ret=aaSurfaceClipperSet(handle,&cc))!=YES) { oops; }
 return RET_YES;
 }








 B aaSurfaceDragBar                    (H handle,_rect*rect,_rgba*p1,_rgba*p2)
 {
 B ret;
 _aa_surfaceobject*surp;
 _cord c1,c2;
 N xx,zz;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 zz=rect->w;
 for(xx=0;xx<zz;xx++)
  {
  aaCordsSet(&c1,&c2,((rect->x+rect->w)-zz)+xx,(rect->y+rect->h)-1,(rect->x+rect->w)-1,((rect->y+rect->h)-zz)+xx);
  aaSurfaceLine(handle,&c1,&c2,(xx%3)?p1:p2);
  }
 return RET_YES;
 }





 B aaSurfaceLabel                      (H handle,_rect*rect,_rgba*p1,H fhandle,_rgba*p2,N xadj,N yadj,N ha,N va,H maxchars,VP fmt,...)
 {
 B ret;
 _aa_surfaceobject*surp;
 _aa_fontobject*fntp;
 _rect mr;
 _cord c1;
 va_list argptr;
 B txt[_64K];
 _rgba*pn;
 _parser pa,pb;
 H pos,sl,li;
 _size sz;
 _size se;
 B line_type;
 N y_pad;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,txt);

 if(fhandle==0) {  fhandle=aa.font_system.font_8x8; }
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if((ret=aa_ObjectCheck(aa.font_system.object_id,fhandle,(VP)&fntp,NULL))!=RET_YES) { return ret; }

 y_pad=0;
 if(rect==NULL) { aaRectSet(&mr,0,0,surp->status.size.w,fntp->status.size.h+y_pad); }
 else           { aaRectCopy(&mr,rect); }

 aaStringLen(txt,&sl);
 if(maxchars==0) { maxchars=sl; }
 if(maxchars<sl&&maxchars!=0) { txt[maxchars]=0; }

 if(p1)
  {
  if(p1->a!=0) {  aaSurfaceFill(handle,&mr,p1);  }
  }
 if(p2==NULL) { aaCast(pn,_rgba*,&col_white); }
 else         { aaCast(pn,_rgba*,p2); }

 aaCordSet(&c1,mr.x,mr.y);
 aaFontStringSizeGet(fhandle,&se,0,"%s",txt);

 if(va==YES)
  {
  aaCordAdjust(&c1,0,(mr.h/2));
  aaCordAdjust(&c1,0,-(N)(se.h/2));
  }
 else
 if(va==-YES)
  {
  aaCordAdjust(&c1,0,(mr.h-1));
  aaCordAdjust(&c1,0,-(N)(se.h));
  }
 if(c1.y<mr.y) { c1.y=mr.y; }
 aaParserInit(&pa,txt,0);

 li=0;
 while(1)
  {
  aaStringFindCharList(pa.bp,0,&pos,"\r\n",YES,0,YES);
  if(pos!=0xffffffff)
   {
   line_type=pa.bp[pos];
   if(line_type==CR_CHAR) { line_type=aa_STRINGMODE_CR; }
   else
   if(line_type==LF_CHAR) { line_type=aa_STRINGMODE_LF; }
   if(line_type==aa_STRINGMODE_CR)  {    if(pa.bp[pos+1]==LF_CHAR) { line_type=aa_STRINGMODE_CRLF; }    }
   aaParserCopy(&pb,&pa,NO);
   pb.bp[pos]=NULL_CHAR;
   if(ha==YES)
    {
    aaFontStringSizeGet(fhandle,&sz,pos,"%s",pb.bp);
    if(sz.w<mr.w)  {   c1.x=mr.x+((mr.w/2)-(sz.w/2));  }
    }
   if(li==0) {    aaCordAdjust(&c1,xadj,yadj); }
   else      {    aaCordAdjust(&c1,xadj,0); }
   aaSurfacePrintf(handle,&c1,fhandle,pn,pos,"%s",pb.bp);
   li++;
   aaParserSeek(&pa,pos+1);
   if(line_type==aa_STRINGMODE_CRLF) {  aaParserSeek(&pa,1); }
   c1.y+=fntp->status.size.h+y_pad;
   c1.x=mr.x;
   continue;
   }
  if(ha==YES)
   {
   aaFontStringSizeGet(fhandle,&sz,0,"%s",pa.bp);
   if(sz.w<mr.w)  {   c1.x=mr.x+((mr.w/2)-(sz.w/2));  }
   }
  else
  if(ha==-YES)
   {
   aaFontStringSizeGet(fhandle,&sz,0,"%s",pa.bp);
   if(sz.w<mr.w)   {   c1.x=mr.x+mr.w-(sz.w); }
   }
  if(li==0) {    aaCordAdjust(&c1,xadj,yadj); }
  else      {    aaCordAdjust(&c1,xadj,0); }
  aaSurfacePrintf(handle,&c1,fhandle,pn,0,"%s",pa.bp);
  break;
  }
 return RET_YES;
 }





 B aaSurfaceFuzz                       (H handle,_rect*rect,_rgba*p1,B level,H xmod,H ymod)
 {
 B ret;
 _aa_surfaceobject*surp;
 _rect rr;
 _rect*mr;
 _rgba*pn;
 Y x,y;
 H noise,carry;
 static H seed=0x123456;
 B r,g,b,a;
 _rgba p2;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(rect==NULL) { aaCast(mr,_rect*,&rr); aaRectSet(mr,0,0,surp->status.size.w,surp->status.size.h); }
 else           { aaCast(mr,_rect*,rect); }
 if(aaRectIsValid(mr)!=RET_YES) { return RET_BADPARM; }
 if(p1==NULL)   { aaCast(pn,_rgba*,&col_white); }
 else           { aaCast(pn,_rgba*,p1); }
 if(level==0) { level=1; }
 p2.r=r=pn->r;
 p2.b=g=pn->g;
 p2.g=b=pn->b;
 p2.a=a=pn->a;
 for(y=0;y<mr->h;y++)
  {
  for(x=0;x<mr->w;x++)
   {
   if(((x%(xmod+1))==0)&&((y%(ymod+1))==0))
    {
    noise=seed;
    noise>>=3;
    noise^=seed;
    carry=noise&3;
    noise>>=1;
    seed>>=1;
    seed|=(carry<<30);
    noise%=level;
    p2.r=(B)((r-(noise&r)));
    p2.g=(B)((g-(noise&g)));
    p2.b=(B)((b-(noise&b)));
    p2.a=a;
    }
   surp->PixelPut(surp,mr->x+x,mr->y+y,&p2);
   }
  }
 return RET_YES;
 }





 B aaSurfacePrintf                     (H handle,_cord*cord,H fhandle,_rgba*p1,H maxchars,VP fmt,...)
 {
 B ret;
 _aa_surfaceobject*surp;
 _aa_fontobject*fntp;
 register N off,xx,yy;
 register N rxx,ryy;
 _cord ccc,cz;
 N s;
 H sl;
 B ch,alpha;
 H to,o;
 _rgba pp;
 F adiv;
 H fpa,v;
 N newhit,newwid,back;
 va_list argptr;
 B txt[_64K];
 N minx,miny;
 N maxx,maxy;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,txt);
 if(fhandle==0) {  fhandle=aa.font_system.font_8x8; }

 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if((ret=aa_ObjectCheck(aa.font_system.object_id,fhandle,(VP)&fntp,NULL))!=RET_YES) { return ret; }
 if(cord==NULL) { return RET_BADPARM; }
 if(p1==NULL)   { return RET_BADPARM; }
 newhit=fntp->status.size.h;

 aaCordCopy(&cz,cord);
 ccc.x=cz.x;
 aaStringLen(txt,&sl);
 if(sl==0)   {   return RET_YES;   }
 if(maxchars==0) maxchars=sl;
 if(sl>maxchars) sl=maxchars;
 aaRgbaCopy(&pp,p1);
 adiv=(F)(pp.a)/255.0;
 fpa=(adiv*65536);
 if(p1->a==255&&surp->PixelPut==aaSurfacePixelPutProc&&surp->PixelSet==aaSurfacePixelSetProc)
  {
  if(surp->status.is_vflip==NO)
   {
   minx=0;
   miny=0;
   maxx=surp->status.size.w;
   maxy=surp->status.size.h;
   if(surp->status.is_clipper)
    {
    minx=surp->status.clipper_rect.x;
    miny=surp->status.clipper_rect.y;
    maxx=surp->status.clipper_rect.x+surp->status.clipper_rect.w;
    maxy=surp->status.clipper_rect.y+surp->status.clipper_rect.h;
    }
   for(s=0;s<(N)sl;s++)
    {
    ch=(B)txt[s];
    off=((ch>>4)*((fntp->size.w<<4)*fntp->size.h))+((ch&15)*(fntp->size.w));
    newwid=0;
    back=0;
    newwid+=((fntp->status.char_width[ch]));
    newwid+=((fntp->status.char_gap[ch]));
    newwid+=((fntp->status.char_lead[ch]));
    back=+0;
    if(fntp->status.is_italic) { newwid+=3; back=+3; }
    ccc.y=cz.y;
    for(yy=0;yy<newhit;yy++)
     {
     to=off+((fntp->size.w<<4)*yy);
     to+=back;
     if(ccc.y<miny||ccc.y>=maxy) { ccc.y++;   continue; }

     if(surp->status.is_vflip==YES) { o=(((surp->status.size.h-ccc.y)-1)*surp->status.size.w)+ccc.x; } // added jan2017
     else                           { o=(ccc.y*surp->status.size.w)+ccc.x; }  // added jan2017

     for(xx=0;xx<newwid;xx++)
      {
      if(ccc.x<minx||ccc.x>=maxx) { o++; ccc.x++; continue; } // added o++; jan2017
      alpha=fntp->status.img[to+xx];
      if(alpha==0)                { o++; ccc.x++; continue; } // added o++; jan2017
      pp.a=(B)((alpha*fpa)>>16);
      rxx=ccc.x;
      ryy=ccc.y;
      if(pp.a!=255)
       {
       surp->PixelPut(surp,rxx,ryy,&pp);
       }
      else
       {
       //if(surp->status.is_vflip==YES) { o=(((surp->status.size.h-ryy)-1)*surp->status.size.w)+rxx; } // removed jan2017
       //else                           { o=(ryy*surp->status.size.w)+rxx; } // removed jan2017
       *(_rgba*)&surp->status.mem[o]=pp;
       }
      ccc.x++;
      o++; // added jan2017
      }
     ccc.x-=(newwid);
     ccc.y++;
     xx=0;
     }
    ccc.x+=newwid;
    if(fntp->status.is_mono_forced==YES)
     {
     ccc.x-=newwid;
     if(newwid<(N)fntp->status.init_mono_size.w) {   ccc.x+=(fntp->status.curr_mono_size.w*.7);      }
     else                                        {   ccc.x+=(fntp->status.curr_mono_size.w);      }
     }
    }
   return RET_YES;
   }
  }

 if(surp->PixelPut!=aaSurfacePixelPutProc)
  {
  for(s=0;s<(N)sl;s++)
   {
   ch=(B)txt[s];
   off=((ch/16)*(fntp->size.w*16*fntp->size.h))+((ch%16)*(fntp->size.w));
   newwid=(fntp->status.char_width[ch]+fntp->status.char_gap[ch]+fntp->status.char_lead[ch]);
   if(fntp->status.is_italic) { newwid+=1; }
   ccc.y=cz.y;
   for(yy=0;yy<newhit;yy++)
    {
    to=off+(fntp->size.w*16*yy);
    for(xx=0;xx<newwid;xx++)
     {
     alpha=fntp->status.img[to+xx];
     v=(alpha*fpa)>>16;
     if(v!=0)
      {
      pp.a=(B)(v);
      surp->PixelPut(surp,ccc.x,ccc.y,&pp);
      }
     ccc.x++;
     }
    ccc.x-=(newwid);
    ccc.y++;
    }
   ccc.x+=newwid;
   if(fntp->status.is_mono_forced==YES)  {   ccc.x+=(fntp->status.curr_mono_size.w)-newwid;   }
   }
  }
 else
  {
  for(s=0;s<(N)sl;s++)
   {
   ch=(B)txt[s];
   off=((ch>>4)*((fntp->size.w<<4)*fntp->size.h))+((ch&15)*(fntp->size.w));
   newwid=(fntp->status.char_width[ch]+fntp->status.char_gap[ch]+fntp->status.char_lead[ch]);
   if(fntp->status.is_italic) { newwid+=1; }
   ccc.y=cz.y;
   for(yy=0;yy<newhit;yy++)
    {
    to=off+((fntp->size.w<<4)*yy);
    for(xx=0;xx<newwid;xx++)
     {
     alpha=fntp->status.img[to+xx];
     v=(alpha*fpa)>>16;
     pp.a=(B)(v);
     if(surp->status.is_clipper)
      {
      if(pp.a!=0) {    surp->PixelPut(surp,ccc.x,ccc.y,&pp); }
      }
     else
      {
      if(v==255)
       {
       if(surp->status.is_vflip==YES) { o=(((surp->status.size.h-ccc.y)-1)*surp->status.size.w)+ccc.x; }
       else                           { o=(ccc.y*surp->status.size.w)+ccc.x; }
       if(o<surp->status.real_pixel_count) {     surp->status.mem[o]=pp; }
       }
      else
      if(v!=0)
       {
       surp->PixelPut(surp,ccc.x,ccc.y,&pp);
       }
      }
     ccc.x++;
     }
    ccc.x-=(newwid);
    ccc.y++;
    }
   ccc.x+=newwid;
   if(fntp->status.is_mono_forced==YES)
    {
    ccc.x+=(fntp->status.curr_mono_size.w)-newwid;
    }
   }
  }
 return RET_YES;
 }






 B aaSurfaceTextf                      (H handle,_cord*cord,H fhandle,VP parm,B(*proc)(VP,N,N,BP,_rgba*,_rgba*),H maxchars,VP fmt,...)
 {
 B ret;
 _aa_surfaceobject*surp;
 _aa_fontobject*fntp;
 register N off,xx,yy;
 register N rxx,ryy;
 _cord ccc,cz;
 N s;
 H sl;
 B ch,alpha;
 H to,o;
 _rgba pp;
 F adiv;
 H fpa;
 N newhit,newwid,back;
 va_list argptr;
 B txt[_64K];
 N minx,miny;
 N maxx,maxy;
 _rgba bg;
 _rgba fg;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,txt);
 if(fhandle==0) {  fhandle=aa.font_system.font_8x8; }

 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if((ret=aa_ObjectCheck(aa.font_system.object_id,fhandle,(VP)&fntp,NULL))!=RET_YES) { return ret; }
 if(cord==NULL) { return RET_BADPARM; }
 newhit=fntp->status.size.h;

 aaCordCopy(&cz,cord);
 ccc.x=cz.x;

 aaStringLen(txt,&sl);
 if(sl==0)   {   return RET_YES;   }
 if(maxchars==0) maxchars=sl;
 if(sl>maxchars) sl=maxchars;
 if(surp->PixelPut==aaSurfacePixelPutProc&&surp->PixelSet==aaSurfacePixelSetProc)
  {
  if(surp->status.is_vflip==NO)
   {
   minx=0;
   miny=0;
   maxx=surp->status.size.w;
   maxy=surp->status.size.h;
   if(surp->status.is_clipper)
    {
    minx=surp->status.clipper_rect.x;
    miny=surp->status.clipper_rect.y;
    maxx=surp->status.clipper_rect.x+surp->status.clipper_rect.w;
    maxy=surp->status.clipper_rect.y+surp->status.clipper_rect.h;
    }
   for(s=0;s<(N)sl;s++)
    {
    proc(parm,s,sl,txt,&bg,&fg);
     aaRgbaCopy(&pp,&fg);
     adiv=(F)(pp.a)/255.0;
     fpa=(adiv*65536);
    ch=(B)txt[s];
    off=((ch>>4)*((fntp->size.w<<4)*fntp->size.h))+((ch&15)*(fntp->size.w));
    newwid=0;
    back=0;
    newwid+=((fntp->status.char_width[ch]));
    newwid+=((fntp->status.char_gap[ch]));
    newwid+=((fntp->status.char_lead[ch]));
    back=+0;
    if(fntp->status.is_italic) { newwid+=3; back=+3; }
    ccc.y=cz.y;
    for(yy=0;yy<newhit;yy++)
     {
     to=off+((fntp->size.w<<4)*yy);
     to+=back;
     if(ccc.y<miny||ccc.y>=maxy) { ccc.y++;   continue; }
     for(xx=0;xx<newwid;xx++)
      {
      if(ccc.x<minx||ccc.x>=maxx) { ccc.x++; continue; }
      rxx=ccc.x;
      ryy=ccc.y;

      if(bg.a!=0)
        {
        surp->PixelPut(surp,rxx,ryy,&bg);
        }
       if(fg.a!=0)
        {
        alpha=fntp->status.img[to+xx];
        if(alpha==0)                { ccc.x++; continue; }
        pp.r=fg.r;
        pp.g=fg.g;
        pp.b=fg.b;
        pp.a=(B)((alpha*fpa)>>16);
        if(pp.a!=255)
         {
         surp->PixelPut(surp,rxx,ryy,&pp);
         }
        else
         {
         if(surp->status.is_vflip==YES) { o=(((surp->status.size.h-ryy)-1)*surp->status.size.w)+rxx; }
         else                           { o=(ryy*surp->status.size.w)+rxx; }
         *(_rgba*)&surp->status.mem[o]=pp;
         }
        }
      ccc.x++;
      }
     ccc.x-=(newwid);
     ccc.y++;
     xx=0;
     }
    ccc.x+=newwid;
    if(fntp->status.is_mono_forced==YES)
     {
     ccc.x-=newwid;
     if(newwid<(N)fntp->status.init_mono_size.w) {   ccc.x+=(fntp->status.curr_mono_size.w*.7);      }
     else                                        {   ccc.x+=(fntp->status.curr_mono_size.w);      }
     }
    }
   return RET_YES;
   }
  }


 return RET_YES;
 }




 B aaSurfaceScroll                     (H handle,_rect*rect,N xpixels,N ypixels,_rgba*pn)
 {
 B ret;
 _aa_surfaceobject*surp;
 BP tmp=NULL_POINTR;
 N xx,yy;
 N tx,ty;
 N x,y,left;
 _rect r1,r2,r3;
 _rect mr;
 _size s1;
 H tmp_handle;
 H soff,doff;
 B alpha=255;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(xpixels==0&&ypixels==0) { return RET_YES; }

 if(rect==NULL) { aaSizeToRect(&surp->status.size,&mr); }
 else
  {
  if((ret=aaRectIsValid(rect))!=RET_YES) { return ret; }
  aaRectCopy(&mr,rect);
  }
 aaSizeSet(&s1,mr.w,mr.h);

 xx=aaNumAbs(xpixels);
 yy=aaNumAbs(ypixels);

 if(xpixels==0&&ypixels<0)
  {
  if(surp->PixelPut==aaSurfacePixelPutProc&&surp->PixelSet==aaSurfacePixelSetProc)
   {
   if(mr.x>=0&&mr.y>=0&&mr.w>0&&mr.h>0)
    {
    if((mr.x+mr.w)<=surp->status.size.w&&(mr.y+mr.h)<=surp->status.size.h)
     {
     if(surp->status.is_clipper==NO&&surp->status.is_vflip==NO)
      {
      ty=(N)mr.h-yy;
      tx=(N)mr.w;
      for(y=0;y<ty;y++)
       {
       soff=((mr.y+y+yy)*surp->status.size.w)+mr.x;
       doff=((mr.y+y)*surp->status.size.w)+mr.x;
       x=0;
       left=tx-x;
       do
        {
        if(left<8) { break; }
        *(_rgba*)&surp->status.mem[doff+0]=*(_rgba*)&surp->status.mem[soff+0];
        *(_rgba*)&surp->status.mem[doff+1]=*(_rgba*)&surp->status.mem[soff+1];
        *(_rgba*)&surp->status.mem[doff+2]=*(_rgba*)&surp->status.mem[soff+2];
        *(_rgba*)&surp->status.mem[doff+3]=*(_rgba*)&surp->status.mem[soff+3];
        *(_rgba*)&surp->status.mem[doff+4]=*(_rgba*)&surp->status.mem[soff+4];
        *(_rgba*)&surp->status.mem[doff+5]=*(_rgba*)&surp->status.mem[soff+5];
        *(_rgba*)&surp->status.mem[doff+6]=*(_rgba*)&surp->status.mem[soff+6];
        *(_rgba*)&surp->status.mem[doff+7]=*(_rgba*)&surp->status.mem[soff+7];
        doff+=8;
        soff+=8;
        left-=8;
        }
        while(1);
       do
        {
        if(left==0) { break; }
        *(_rgba*)&surp->status.mem[doff++]=  *(_rgba*)&surp->status.mem[soff++];
        left--;
        }
       while(1);
       }
      if(pn==NULL) { return RET_YES; }
      if(pn->a==0) { return RET_YES; }
      aaRectSet(&r1,mr.x,(mr.y+mr.h)-yy,mr.w,yy);
      aaSurfaceFill(handle,&r1,pn);
      return RET_YES;
      }
     }
    }
   }
  }
 if((ret=aa_MemoryTemp((VP)&tmp,((rect->w+xx)*4)*(rect->h+yy),aa_MEMORYTEMP_SurfaceScroll))!=RET_YES) { return ret; }
 if((ret=aaSurfaceMake(&tmp_handle,&s1,tmp))!=RET_YES) { oops; }
 if(xpixels>=0&&ypixels<0)
  {
  ypixels=aaNumAbs(ypixels);
  xpixels=aaNumAbs(xpixels);
  aaRectSet(&r1,mr.x,mr.y+ypixels,mr.w-xpixels,mr.h-ypixels);
  aaRectSet(&r2,0,0,mr.w-xpixels,mr.h-ypixels);
  aaRectSet(&r3,mr.x+xpixels,mr.y,mr.w-xpixels,mr.h-ypixels);
  aaSurfaceImageDraw(tmp_handle,&surp->status.size,&r1,surp->status.mem,&r2,0,0,alpha);
  aaSurfaceImageDraw(handle,&s1,&r2,tmp,&r3,0,0,alpha);
  if(pn)
   {
   if(ypixels!=0) { aaRectSet(&r1,mr.x,(mr.y+mr.h)-ypixels,mr.w,ypixels); aaSurfaceFill(handle,&r1,pn); }
   if(xpixels!=0) { aaRectSet(&r1,mr.x,mr.y,xpixels,mr.h); aaSurfaceFill(handle,&r1,pn); }
   }
  }
 else
 if(xpixels>=0&&ypixels>=0)
  {
  ypixels=aaNumAbs(ypixels);
  xpixels=aaNumAbs(xpixels);
  aaRectSet(&r1,mr.x,mr.y,mr.w-xpixels,mr.h-ypixels);
  aaRectSet(&r2,0,0,mr.w-xpixels,mr.h-ypixels);
  aaRectSet(&r3,mr.x+xpixels,mr.y+ypixels,mr.w-xpixels,mr.h-ypixels);
  aaSurfaceImageDraw(tmp_handle,&surp->status.size,&r1,surp->status.mem,&r2,0,0,alpha);
  aaSurfaceImageDraw(handle,&s1,&r2,tmp,&r3,0,0,alpha);
  if(pn)
   {
   if(ypixels!=0) { aaRectSet(&r1,mr.x,mr.y,mr.w,ypixels); aaSurfaceFill(handle,&r1,pn); }
   if(xpixels!=0) { aaRectSet(&r1,mr.x,mr.y,xpixels,mr.h); aaSurfaceFill(handle,&r1,pn); }
   }
  }
 else
 if(xpixels<0&&ypixels<0)
  {
  ypixels=aaNumAbs(ypixels);
  xpixels=aaNumAbs(xpixels);
  aaRectSet(&r1,mr.x+xpixels,mr.y+ypixels,mr.w-xpixels,mr.h-ypixels);
  aaRectSet(&r2,0,0,mr.w-xpixels,mr.h-ypixels);
  aaRectSet(&r3,mr.x,mr.y,mr.w-xpixels,mr.h-ypixels);
  aaSurfaceImageDraw(tmp_handle,&surp->status.size,&r1,surp->status.mem,&r2,0,0,alpha);
  aaSurfaceImageDraw(handle,&s1,&r2,tmp,&r3,0,0,alpha);
  if(pn)
   {
   if(ypixels!=0) { aaRectSet(&r1,mr.x,(mr.y+mr.w)-ypixels,mr.w,ypixels); aaSurfaceFill(handle,&r1,pn); }
   if(xpixels!=0) { aaRectSet(&r1,(mr.x+mr.w)-xpixels,mr.y,xpixels,mr.h); aaSurfaceFill(handle,&r1,pn); }
   }
  }
 else
 if(xpixels<0&&ypixels>=0)
  {
  ypixels=aaNumAbs(ypixels);
  xpixels=aaNumAbs(xpixels);
  aaRectSet(&r1,mr.x+xpixels,mr.y,mr.w-xpixels,mr.h-ypixels);
  aaRectSet(&r2,0,0,mr.w-xpixels,mr.h-ypixels);
  aaRectSet(&r3,mr.x,mr.y+ypixels,mr.w-xpixels,mr.h-ypixels);
  aaSurfaceImageDraw(tmp_handle,&surp->status.size,&r1,surp->status.mem,&r2,0,0,alpha);
  aaSurfaceImageDraw(handle,&s1,&r2,tmp,&r3,0,0,alpha);
  if(pn)
   {
   if(ypixels!=0) { aaRectSet(&r1,mr.x,mr.y,mr.w,ypixels); aaSurfaceFill(handle,&r1,pn); }
   if(xpixels!=0) { aaRectSet(&r1,(mr.x+mr.w)-xpixels,mr.y,xpixels,mr.h); aaSurfaceFill(handle,&r1,pn); }
   }
  }
 aaSurfaceDestroy(tmp_handle);
 return RET_YES;
 }





 B aaSurfaceBevel                      (H handle,_rect*rect,_rgba*p1,B state)
 {
 B ret;
 _aa_surfaceobject*surp;
 _rgba mr;
 _rgba pna,pnb,pnc,pnd;
 _rect r1;
 _cord c1,c2;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(p1==NULL) { aaRgbaCopy(&mr,&col_gray[20]); }
 else         { aaRgbaCopy(&mr,p1); }
 if(rect==NULL) { aaRectSet(&r1,0,0,surp->status.size.w,surp->status.size.h); }
 else           { aaRectCopy(&r1,rect); }

 if(mr.a!=0)
  {
  aaSurfaceFill(handle,&r1,&mr);
  }
 else
  {
  aaRgbaCopy(&mr,&col_gray[20]);
  }
 if(state)
  {
  aaRgbaSet(&pnb,0,0,0,120);
  aaRgbaSet(&pna,80,80,80,140);
  aaRgbaSet(&pnd,160,160,160,160);
  aaRgbaSet(&pnc,215,215,215,170);
  }
 else
  {
  aaRgbaSet(&pnc,0,0,0,120);
  aaRgbaSet(&pnd,80,80,80,140);
  aaRgbaSet(&pna,180,180,180,160);
  aaRgbaSet(&pnb,215,215,215,170);
  }
  // top line
  aaCordsSet(&c1,&c2,r1.x,r1.y,(r1.x+r1.w)-1,r1.y); aaSurfaceLine(handle,&c1,&c2,&pna);
  // left line
  aaCordsSet(&c1,&c2,r1.x,r1.y,r1.x,(r1.y+r1.h)-1); aaSurfaceLine(handle,&c1,&c2,&pna);
  // top line 1 down
  aaCordsSet(&c1,&c2,r1.x+1,r1.y+1,(r1.x+r1.w)-2,r1.y+1); aaSurfaceLine(handle,&c1,&c2,&pnb);
  // left line 1 right
  aaCordsSet(&c1,&c2,r1.x+1,r1.y+1,r1.x+1,(r1.y+r1.h)-2); aaSurfaceLine(handle,&c1,&c2,&pnb);
  // right line
  aaCordsSet(&c1,&c2,(r1.x+r1.w)-1,r1.y,(r1.x+r1.w)-1,(r1.y+r1.h)-1); aaSurfaceLine(handle,&c1,&c2,&pnc);
  // bottom line
  aaCordsSet(&c1,&c2,r1.x,(r1.y+r1.h)-1,(r1.x+r1.w)-1,(r1.y+r1.h)-1); aaSurfaceLine(handle,&c1,&c2,&pnc);
  // right line 1 left
  aaCordsSet(&c1,&c2,(r1.x+r1.w)-2,r1.y+1,(r1.x+r1.w)-2,(r1.y+r1.h)-2); aaSurfaceLine(handle,&c1,&c2,&pnd);
  // botom line 1 up
  aaCordsSet(&c1,&c2,r1.x+1,(r1.y+r1.h)-2,(r1.x+r1.w)-2,(r1.y+r1.h)-2); aaSurfaceLine(handle,&c1,&c2,&pnd);
 return RET_YES;
 }






 B aaSurfaceBlur                       (H handle,_rect*rect,B hstrength,B vstrength)
 {
 B ret;
 N i,j;
 N r1,r2,r3;
 N g1,g2,g3;
 N b1,b2,b3;
 H imgw,imgh;
 N x,y;
 H w,h;
 H off;
 _aa_surfaceobject*surp;
 _rect rr,rx;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(rect==NULL) { aaRectSet(&rr,0,0,surp->status.size.w,surp->status.size.h); }
 else           { aaRectCopy(&rr,rect); }
 if(vstrength==0&&hstrength==0) { return RET_YES; }
 imgw=surp->status.size.w;
 imgh=surp->status.size.h;
 x=rr.x;
 y=rr.y;
 w=rr.w;
 h=rr.h;
 if(x<=0) x=1;
 if(h<=0) y=1;
 if(x+w>=imgw) w=imgw-x-1;
 if(y+h>=imgh) h=imgh-y-1;

 aaRectSet(&rx,x,y,w,h);
 if(rx.x<0) { rx.x=0; }
 if(rx.y<0) { rx.y=0; }
 if((rx.x+rx.w)>=surp->status.size.w) { rx.w=surp->status.size.w-rx.x; }
 if((rx.y+rx.h)>=surp->status.size.h) { rx.h=surp->status.size.h-rx.y; }
 while(hstrength--)
  {
  for(j=0;j<(N)h;j++)
   {
   if((x+0)<(rx.x)) { continue; }
   if((y+j)<(rx.y)) { continue; }
   if((H)(x+0)>=(rx.x+rx.w)) { continue; }
   if((H)(y+j)>=(rx.y+rx.h)) { continue; }

   off=((y+j)*imgw)+x;
   r2=surp->status.mem[off].r;
   g2=surp->status.mem[off].g;
   b2=surp->status.mem[off].b;
   r3=r2; g3=g2; b3=b2;
   if((H)(x+1)<(rx.x+rx.w))
    {
    r3=surp->status.mem[off+1].r;
    g3=surp->status.mem[off+1].g;
    b3=surp->status.mem[off+1].b;
    }
   for(i=0;i<(N)w;i++)
    {
    if((H)(x+i)<(rx.x+rx.w))
     {
     r1=r2;    r2=r3;    r3=surp->status.mem[off+1+i].r;
     g1=g2;    g2=g3;    g3=surp->status.mem[off+1+i].g;
     b1=b2;    b2=b3;    b3=surp->status.mem[off+1+i].b;
     surp->status.mem[(off+1+i)].r=(B)((r1+r2+r3)/3);
     surp->status.mem[(off+1+i)].g=(B)((g1+g2+g3)/3);
     surp->status.mem[(off+1+i)].b=(B)((b1+b2+b3)/3);
     }
    }
   }
  }
 while(vstrength--)
  {
  for(i=0;i<(N)w;i++)
   {
   if((x+i)<(rx.x)) { continue; }
   if((y+0)<(rx.y)) { continue; }
   if((H)(x+i)>=(rx.x+rx.w)) { continue; }
   if((H)(y+0)>=(rx.y+rx.h)) { continue; }
   off=(y*imgw)+(x+i);
   r2=surp->status.mem[off].r;
   g2=surp->status.mem[off].g;
   b2=surp->status.mem[off].b;
   r3=r2; g3=g2; b3=b2;
   if((H)(y+1)<=(rx.y+rx.h))
    {
    r3=surp->status.mem[off+imgw].r;
    g3=surp->status.mem[off+imgw].g;
    b3=surp->status.mem[off+imgw].b;
    }
   for(j=0;j<(N)h;j++)
    {
    if((H)(y+j)<(rx.y+rx.h))
     {
     r1=r2;    r2=r3;    r3=surp->status.mem[off+(imgw*j)].r;
     g1=g2;    g2=g3;    g3=surp->status.mem[off+(imgw*j)].g;
     b1=b2;    b2=b3;    b3=surp->status.mem[off+(imgw*j)].b;
     surp->status.mem[off+(imgw*j)].r=(B)((r1+r2+r3)/3);
     surp->status.mem[off+(imgw*j)].g=(B)((g1+g2+g3)/3);
     surp->status.mem[off+(imgw*j)].b=(B)((b1+b2+b3)/3);
     }
    }
   }
  }
 return RET_YES;
 }



 // output_handle ,, needs to be integrated back to input handle

//F mat[9]= {-1, -2, -1,-2, 20, -2,	-1, -2, -1    }; // sharpen
//F mat[9]={-1, -2, 0,	-2, 0, 2,	0, 2, 1 }; // edge
//F mat[9]={-1, -2, 0,	-2, 0, 2,	0, 2, 1 }; // base ( neeed to use p1 arg )
//F mat[9]={ 0, -1, 0,	-1, 5,-1,	0,-1, 0 }; // sharpen
//F mat[9]={ 1,  2, 1,	 2, 4, 2,	1, 2, 1 }; // gausian blur

/*
 F mat[9]={-1, -2, -1,   -2, 20, -2,	-1, -2, -1 }; // sharpen
 F mat[9]={14, 15,16,	24,25,26,	34,35,36   }; // smooth
 F mat[9]={ 0,  0, 0,	-1, 1, 0, 	 0, 0, 0   }; // edgeenhance
 F mat[9]={ 0,  1, 0,	 1,-4, 1, 	 0, 1, 0   }; // edgedetect
 F mat[9]={-1, -2, 0,	-2, 0, 2, 	 0, 2, 1   }; // edge
 F mat[9]={-1, -2, 0,	-2, 0, 2,	 0, 2, 1   }; // base ( neeed to use p1 arg )
 F mat[9]={ 0, -1, 0,	-1, 5,-1,	 0,-1, 0   }; // sharpen
 F mat[9]={ 1,  1, 1,	 1,  2, 1,	 1, 1, 1   }; // smudge
 F mat[9]={ 2,  2, 1,	 2, 4, 4,	-1, 4, 3   }; // smudge
 F mat[9]={ 1,  2, 1,	 2, 4, 2,	 1, 2, 1   }; // gausian blur
 F mat[9]={-2, -1, 0,	-1, 1, 1,	 0, 1, 2   }; // emboss

*/

 B aaSurfaceConvolve                   (H handle,_rect*rect,FP matrix,N n,_rgba*p1,B absflag)
 {
 B ret;
 Z x,y,xx,yy,xv,yv,ir,ig,ib,ia;
 N xy,ye,xe,hh,ww;
 F r,g,b,sum;
 BP p,op;
 _aa_surfaceobject*surp;
 _size s1;
 BP tmp;

 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }

 xy=-n/2;
 ye=rect->h+xy;
 xe=rect->w+xy;
 hh=rect->h+rect->h;
 ww=rect->w+rect->w;
 aaSizeSet(&s1,rect->w,rect->h);
 if((ret=aa_MemoryTemp((VP)&tmp,s1.w*s1.h*4,aa_MEMORYTEMP_SurfaceConvolve))!=RET_YES) { oops; }
 sum=0;
 for(yy=0;yy<n;yy++)
  {
  for(xx=0;xx<n;xx++)  {   sum+=matrix[xx+n*yy];   }
  }
 if(sum<=0) { sum=1; }
 for(y=xy;y<ye;y++)
  {
  for(x=xy;x<xe;x++)
   {
   r=g=b=0;
   for(yy=0;yy<n;yy++)
    {
    for(xx=0;xx<n;xx++)
     {
     xv=x+xx+rect->x;
     yv=y+yy+rect->y;
     if(xv<0) {  xv=-xv; }
     if(yv<0) {  yv=-yv; }
     if(xv>=(Z)surp->status.rect.w)  {  xv=xv%ww;  if(xv>=(Z)surp->status.rect.w)  {  xv=ww-xv-1; }      }
     if(yv>(Z)surp->status.rect.h)   {  yv=yv%hh;  if(yv>=(Z)surp->status.rect.h)  {  yv=hh-yv-1; }      }
     aaCast(p,BP,&surp->status.mem[0]);
     p+=(yv*surp->status.rect.w*4)+(xv*4);
     b+=(F)*p++*matrix[xx+n*yy];
     g+=(F)*p++*matrix[xx+n*yy];
     r+=(F)*p  *matrix[xx+n*yy];
     }
    }
   if(absflag) { if(r<0)   {   r=-r; }  if(g<0)   {   g=-g; }    if(b<0)   {   b=-b; }    }
   ir=r/sum;
   ig=g/sum;
   ib=b/sum;
   ia=255;
   if(p1) {  ir+=p1->r; ig+=p1->g;  ib+=p1->b;  ia=p1->a;  }
   ir=aaNumClamp(ir,0,255);
   ig=aaNumClamp(ig,0,255);
   ib=aaNumClamp(ib,0,255);
   ia=aaNumClamp(ia,0,255);
   if(x>=0&&y>=0&&x<(Z)s1.w&&y<(Z)s1.h)
    {
    aaCast(op,BP,&tmp[0]);
    op+=(y*s1.w*4)+(x*4);
    *op++=(B)ib;
    *op++=(B)ig;
    *op++=(B)ir;
    *op++=(B)ia;
    }
   }
  }
 aaSurfaceImageDraw(handle,&s1,0,tmp,rect,0,0,0);
 return RET_YES;
 }



 B aaSurfaceButtonFrame                (H handle,_rect*r1,B state,B depth)
 {
 B ret;
 _aa_surfaceobject*surp;
 _rgba pn[4];
 _rect ra,r2;
 _cord c1,c2,c3,c4;
 B d,pa,pb;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 aaRectCopy(&ra,r1);
 if(state==0)
  {
  aaRgbaCopy(&pn[0],&col_gray[0]);  aaRgbaCopy(&pn[1],&col_gray[16]);
  aaRgbaCopy(&pn[2],&col_gray[24]); aaRgbaCopy(&pn[3],&col_gray[31]);
  }
 else
 if(state==1)
  {
  aaRgbaCopy(&pn[0],&col_gray[31]); aaRgbaCopy(&pn[1],&col_gray[24]);
  aaRgbaCopy(&pn[2],&col_gray[0]);  aaRgbaCopy(&pn[3],&col_gray[16]);
  }
 aaRectCopy(&r2,&ra);
 pa=2;
 pb=0;
 for(d=0;d<depth;d++)
  {
  aaRectToCornerCords(&ra,&c1,&c2,&c3,&c4);
  aaSurfaceLine(handle,&c1,&c2,&pn[pa]);
  aaSurfaceLine(handle,&c1,&c4,&pn[pa]);
  aaSurfaceLine(handle,&c2,&c3,&pn[pb]);
  aaSurfaceLine(handle,&c3,&c4,&pn[pb]);
  aaRectExpand(&ra,-1,-1);
  pa=3;
  pb=1;
  }
 return RET_YES;
 }


 /*
 gradient rules:
 type 0=linear   scale=(-5.0 to +0.5=spread )                            tilt=tilt (0-90 )
 type 1=radial   scale=(-5.0 to +0.5=spread )                            tilt=tilt
 type 2=square   scale=(-5.0 to +0.5=spread, >+0.5 is reversed )         tilt=tilt
 type 3=conict   scale=(-5.0 to +0.5=spread, >+0.5 is reversed )         tilt=( not used )
 */




 B aaSurfaceGradientFill               (H handle,_rect*rect,_cord*c1,_rgba*p1,_rgba*p2,B type,F tilt)
 {
 B ret;
 H wid,hit,ok,off;
 N x,y,dx,dy,ox,oy,xx,yy;
 F f1,f2,dv,s,ang,sn,cs;
 _rgba p3;
 N maxdist;
 F scale,om;
 //D deg;
 _aa_surfaceobject*surp;
 _rect rr;
 _pixelstyle*pstylep;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(rect==NULL) { aaRectSet(&rr,0,0,surp->status.size.w,surp->status.size.h); }
 else           { aaRectCopy(&rr,rect); }
 scale=0.5;

 wid=rr.w;
 hit=rr.h;
 ox=oy=0;
 if(c1!=NULL)
  {
  ox=c1->x;
  oy=c1->y;
  }

 maxdist=aaNumMax(ox,(N)wid-ox);
 maxdist=aaNumMax(maxdist,oy);
 maxdist=aaNumMax(maxdist,(N)hit-oy);
 dv=(1.0-2*scale);
 if(type==aa_GRADIENT_Linear)
  {

  if(tilt==90) { s=wid; }
  else
   {
   ang=tan(tilt*(aaPi/180.0));
   s=aaNumAbs(ang*wid+(ang<0?(-(N)hit):(N)hit))/sqrt(ang*ang+1);
   }
  cs=cos(tilt*(aaPi/180.0)); /* For rotation of coords */
  sn=sin(tilt*(aaPi/180.0));


 /*
  if(tilt==90) { s=wid; }
  else
   {
   ang=tan(tilt*(aaPi/180.0));
   s=aaNumAbs(ang*wid+(ang<0?(-(N)hit):(N)hit))/sqrt(ang*ang+1);
   }
  ang=tan(tilt*(aaPi/180.0));
  s=aaNumAbs(ang*wid+(N)hit)/sqrt(ang*ang+1);
  //tilt=ang;
  cs=cos(tilt*(aaPi/180.0));
  sn=sin(tilt*(aaPi/180.0));
  */

/*
  deg=tilt*aaPi/180.0;
  s=aaNumAbs(deg*(wid/2)+(N)(hit/2))/(sqrt(deg*deg)+1.0);
  cs=cos(tilt*(aaPi/180.0));
  sn=sin(tilt*(aaPi/180.0));
  */

//  cs=cos(deg);//
//  sn=sin(deg);//


  ok=0;
  pstylep=(_pixelstyle*)&surp->status.pixl_style;
  if(pstylep->mode==0&&p1->a==255&&surp->PixelPut==aaSurfacePixelPutProc&&surp->PixelSet==aaSurfacePixelSetProc)
   {
   if(rr.x>=0&&rr.y>=0&&rr.w>0&&rr.h>0)
    {
    if((rr.x+rr.w)<=surp->status.size.w&&(rr.y+rr.h)<=surp->status.size.h)
     {
     if(surp->status.is_clipper==NO&&surp->status.is_vflip==NO)
      {
      if(surp->status.is_mask==NO&&surp->status.is_masknot==NO)
       {
       ok=1;
       for(y=0;y<(N)hit;y++)
        {
        off=((rr.y+y)*surp->status.size.w)+rr.x;
        for(x=0;x<(N)wid;x++)
         {
         yy=x*sn+y*cs;
         f1=(((F)yy)/s-dv);
         if(dv!=0) { f1=f1/dv; }
         f1=aaNumClamp(f1,0.0,1.0);
         om=1-f1;
         p3.r=(om)*p1->r+f1*p2->r;
         p3.g=(om)*p1->g+f1*p2->g;
         p3.b=(om)*p1->b+f1*p2->b;
         p3.a=(om)*p1->a+f1*p2->a;
         *(_rgba*)&surp->status.mem[off++]=p3;
         }
        }
       }
      }
     }
    }
   }
  if(ok==0)
   {
   for(y=0;y<(N)hit;y++)
    {
    for(x=0;x<(N)wid;x++)
     {
     yy=x*sn+y*cs;
     f1=(((F)yy)/s-dv);
     if(dv!=0) { f1=f1/dv; }
     f1=aaNumClamp(f1,0.0,1.0);
     om=1-f1;
     p3.r=(om)*p1->r+f1*p2->r;
     p3.g=(om)*p1->g+f1*p2->g;
     p3.b=(om)*p1->b+f1*p2->b;
     p3.a=(om)*p1->a+f1*p2->a;
     surp->PixelPut(surp,rr.x+x,rr.y+y,&p3);
     }
    }
   }
  }
 else
 if(type==aa_GRADIENT_Radial)
  {
  for(y=0;y<(N)hit;y++)
   {
   for(x=0;x<(N)wid;x++)
    {
    dx=x-ox;
    dy=y-oy;
    f2=dx*dx+dy*dy;
    f1=sqrt(f2);
    f2=maxdist-scale;
    f1=f1/f2;
    if(dv!=0)  {        f1=f1/dv;          }
    f1=aaNumClamp(f1,0.0,1.0);
    p3.r=(1-f1)*p1->r+f1*p2->r;
    p3.g=(1-f1)*p1->g+f1*p2->g;
    p3.b=(1-f1)*p1->b+f1*p2->b;
    p3.a=(1-f1)*p1->a+f1*p2->a;
    surp->PixelPut(surp,rr.x+x,rr.y+y,&p3);
    }
   }
  }
 else
 if(type==aa_GRADIENT_Square)
  {
  cs=cos(tilt*(aaPi/180.0));
  sn=sin(tilt*(aaPi/180.0));
  for(y=0;y<(N)hit;y++)
   {
   for(x=0;x<(N)wid;x++)
    {
    dx=x-ox;
    dy=y-oy;
    xx=dx*cs-dy*sn;
    if(xx<0) xx=-xx;
    yy=dx*sn+dy*cs;
    if(yy<0) yy=-yy;
    if(xx<yy) s=yy;
    else     s=xx;
    f1=(((F)s)/maxdist-scale);
    if(dv!=0) { f1=f1/dv; }
    f1=aaNumClamp(f1,0.0,1.0);
    p3.r=(1-f1)*p1->r+f1*p2->r;
    p3.g=(1-f1)*p1->g+f1*p2->g;
    p3.b=(1-f1)*p1->b+f1*p2->b;
    p3.a=(1-f1)*p1->a+f1*p2->a;
    surp->PixelPut(surp,rr.x+x,rr.y+y,&p3);
    }
   }
  }
 else
 if(type==aa_GRADIENT_Cone)
  {
  for(y=0;y<(N)hit;y++)
   {
   for(x=0;x<(N)wid;x++)
    {
    dx=x-ox;
    dy=y-oy;
    if(dx==0) ang=dy>0?270:90;
    else
     {
     ang=atan(((F)dy)/((F)dx));
     ang*=1.0/(aaPi/180.0);
     if(dx>0) ang=ang+180.0;
     while(ang<0) ang+=360.0;
     }
    ang+=tilt;
    while(ang>360.0)  ang-=360.0;
   if(ang>180.0) ang=360.0-ang;
   f1=(ang/180.0-scale);
   if(dv!=0) { f1=f1/dv; }
   f1=aaNumClamp(f1,0.0,1.0);
   p3.r=(1-f1)*p1->r+f1*p2->r;
   p3.g=(1-f1)*p1->g+f1*p2->g;
   p3.b=(1-f1)*p1->b+f1*p2->b;
   p3.a=(1-f1)*p1->a+f1*p2->a;
    surp->PixelPut(surp,rr.x+x,rr.y+y,&p3);
    }
   }
  }
 return RET_YES;
 }






 B aaSurfaceLog                        (H handle,_rect*rect,_rgba*p1,H fhandle,_rgba*p2,VP fmt,...)
 {
 B ret;
 _aa_surfaceobject*surp;
 _rect r1,r2;
 _size s1;
 _aa_fontobject*fntp;
 va_list argptr;
 B txt[_64K];
 N pixels;
 _parser pa,pb;
 H pos;
 B line_type;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,txt);
 if(fhandle==0) { fhandle=aa.font_system.font_8x8; }
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if((ret=aa_ObjectCheck(aa.font_system.object_id,fhandle,(VP)&fntp,NULL))!=RET_YES) { return ret; }
 if(rect==NULL) { aaRectSet(&r1,0,0,surp->status.rect.w,surp->status.rect.h); }
 else           { aaRectCopy(&r1,rect); }
 pixels=fntp->status.size.h+4;
 aaRectToSize(&r1,&s1);
 aaParserInit(&pa,txt,0);
 while(1)
  {
  //aaStringCopyf(aa_last_executed,".%s:#%u %s pix=%i r1=%i,%i,%i,%i",__FILE__,__LINE__,__func__,pixels,r1.x,r1.y,r1.w,r1.h);
  aaSurfaceScroll(handle,&r1,0,aaNumNeg(pixels),p1);
  aaRectSet(&r2,r1.x,((r1.y+r1.h)-pixels),r1.w,pixels);
  aaStringFindCharList(pa.bp,0,&pos,"\r\n",YES,0,YES);
  if(pos!=0xffffffff)
   {
   line_type=pa.bp[pos];
   if(line_type==CR_CHAR) { line_type=aa_STRINGMODE_CR; }
   else
   if(line_type==LF_CHAR) { line_type=aa_STRINGMODE_LF; }
   if(line_type==aa_STRINGMODE_CR)  {    if(pa.bp[pos+1]==LF_CHAR) { line_type=aa_STRINGMODE_CRLF; }    }

   aaParserCopy(&pb,&pa,NO);
   pb.bp[pos]=NULL_CHAR;
   aaSurfaceLabel(handle,&r2,(p1==NULL)?&col_gray[4]:p1,fhandle,(p2==NULL)?&col_gray[23]:p2,1,0,0,1,0,"%s",pb.bp);
   aaParserSeek(&pa,pos+1);
   if(line_type==aa_STRINGMODE_CRLF) { aaParserSeek(&pa,1); }
   continue;
   }
  aaSurfaceLabel(handle,&r2,(p1==NULL)?&col_gray[4]:p1,fhandle,(p2==NULL)?&col_gray[23]:p2,1,0,0,1,0,"%s",pa.bp);
  break;
  }
 if(surp->status.is_log_write) { aaLog(-777,"%s",txt); }
 return RET_YES;
 }






 B aaSurfaceLogWriteSet                (H handle,B state)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(state==YES) { surp->status.is_log_write=YES; }
 else           { surp->status.is_log_write=NO;  }
 return RET_YES;
 }





 B aaSurfaceUpdateAreaAdd              (H handle,_rect*rect,B update)
 {
 B ret;
 _aa_surfaceobject*surp;
 _rect rr;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 /*
 if(surp->status.is_visual!=YES)
  {
  if(surp->status.overlayed_by==0) {  return RET_FAILED;  }
  handle=surp->status.overlayed_by;
  if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
  }
  */
 if(surp->status.is_visual!=YES) { return RET_FAILED; }
 if(rect==NULL) { aaRectSet(&rr,0,0,surp->status.size.w,surp->status.size.h); }
 else           { aaRectCopy(&rr,rect); }
 rr.x=aaNumClamp(rr.x,0,(N)surp->status.size.w);
 rr.y=aaNumClamp(rr.y,0,(N)surp->status.size.h);
 rr.w=aaNumRoof(rr.w,(surp->status.size.w-rr.x));
 rr.h=aaNumRoof(rr.h,(surp->status.size.h-rr.y));
 if(rr.w==0||rr.h==0) {  return RET_BADPARM;  /*aaNote(0,"line=%i rr.w=%i rr.h=%i",__LINE__,rr.w,rr.h); */}
 if((ret=aaUpdateAreaAdd(&surp->status.update_area,&rr))!=YES) oops;
 if(update) {  if((ret=aaSurfaceUpdate(handle))!=YES) oops; }
 return RET_YES;
 }


 B aaSurfaceUpdateAreaRemove           (H handle,_rect*rect,B update)
 {
 B ret;
 _aa_surfaceobject*surp;
 _rect rr;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 /*
 if(surp->status.is_visual!=YES)
  {
  if(surp->status.overlayed_by==0) {  return RET_FAILED;  }
  handle=surp->status.overlayed_by;
  if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
  }
  */
 if(surp->status.is_visual!=YES) { return RET_FAILED; }
 if(rect==NULL) { aaRectSet(&rr,0,0,surp->status.size.w,surp->status.size.h); }
 else           { aaRectCopy(&rr,rect); }
 rr.x=aaNumClamp(rr.x,0,(N)surp->status.size.w);
 rr.y=aaNumClamp(rr.y,0,(N)surp->status.size.h);
 rr.w =aaNumRoof(rr.w,(surp->status.size.w-rr.x));
 rr.h =aaNumRoof(rr.h,(surp->status.size.h-rr.y));
 if(rr.w==0||rr.h==0) {  return RET_BADPARM; }
 if((ret=aaUpdateAreaRemove(&surp->status.update_area,&rr))!=YES) oops;
 if(update) {  aaSurfaceUpdate(handle); }
 return RET_YES;
 }


 B aaSurfaceUpdateAreaReset            (H handle)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 /*
 if(surp->status.is_visual!=YES)
  {
  if(surp->status.overlayed_by==0) {  return RET_FAILED;  }
  handle=surp->status.overlayed_by;
  if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
  }
  */
 //if(surp->status.is_visual!=YES) { return RET_FAILED; }
 if((ret=aaUpdateAreaReset(&surp->status.update_area))!=RET_YES) { oops; }
 return RET_YES;
 }




 B aaSurfaceUpdate                     (H handle)
 {
 B ret;
 _aa_surfaceobject*surp;
 _aa_surfaceobject*csurp;
 H it,first,han;
 RECT r1;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 /*
 if(surp->status.is_visual!=YES)
  {
  if(surp->status.overlayed_by==0) {  return RET_FAILED;  }
  handle=surp->status.overlayed_by;
  if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
  }
  */
 if(surp->status.is_visual!=YES) { return RET_FAILED; }
 if(surp->status.update_area.state==YES)
  {
  r1.left=surp->status.update_area.rect.x;
  r1.top=surp->status.update_area.rect.y;
  r1.right=(r1.left+surp->status.update_area.rect.w)-0;
  r1.bottom=(r1.top+surp->status.update_area.rect.h)-0;
  aaSurfaceBlit(handle,&surp->status.update_area.rect);//,0,&surp->status.update_area.rect,NO);
  }
 if((ret=aaSurfaceUpdateAreaReset(handle))!=RET_YES) { oops; }


 if(surp->status.is_parent==YES)
  {
  it=0;
  first=0xffffffff;
  while(1)
   {
   ret=aa_ObjectNext(aa.surface_system.object_id,&han,(VP)&csurp,&it);
   if(ret==RET_NOTFOUND) { aaNote(0,"cc=%i",surp->status.child_count); break; }
   if(ret!=YES) { oops; }
   if(first==0xffffffff) { first=han; }
   else
   if(han==first) { break; }
   if(csurp->status.is_child!=YES) { continue; }
   aaSurfaceCordAdjust(han,0,0);
   aaSurfaceStatus(han,0);
   }
  }
 return RET_YES;
 }



 B aaSurfaceUpdateAndStatus            (H handle,_surfacestatus*status)
 {
 B ret;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaSurfaceUpdate(handle))!=YES) { return ret; }
 if(status)
  {
  aaSurfaceStatus(handle,status);
  }
 return RET_YES;
 }



 B aaSurfaceExtraDataSet               (H handle,H bytes)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 logg("%s bytes=%i cur.eb=%i cur.ptr=%p",__func__,bytes,surp->status.extra_bytes,surp->status.extra_data);
 if(bytes==0)
  {
  if(surp->status.extra_bytes!=0)
   {
   logg("releasing");
   if((ret=aaMemoryRelease(surp->status.extra_data))!=RET_YES) { oops; }
   }
  surp->status.extra_data=NULL;
  surp->status.extra_bytes=bytes;
  }
 else
  {
  if(surp->status.extra_bytes==0)
   {
   surp->status.extra_data=NULL;
   }
  if(surp->status.extra_bytes!=bytes)
   {
     logg("making");
   if((ret=aaMemoryMake((VP)&surp->status.extra_data,bytes))!=RET_YES) { oops; }
   }
  surp->status.extra_bytes=bytes;
  }
 return RET_YES;
 }





 B aaSurfaceExtraDataGet               (H handle,HP bytes,PP ptr)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif if(bytes) { *bytes=0; }
 if(ptr)  { *ptr=NULL; }
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(bytes) { *bytes=surp->status.extra_bytes; }
 if(ptr)   { *ptr=surp->status.extra_data; }
 return RET_YES;
 }




 B aaSurfaceDropClear                  (H handle)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(surp->status.is_drop_accept!=YES)
  {
  return RET_FAILED;
  }
 if(surp->status.drop_count!=0)
  {
  aaListReset(&surp->status.drop_list);
  surp->status.drop_count=0;
  }
 return RET_YES;
 }




 B aaSurfaceDropAccept                 (H handle,B state)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(state)
  {
  if(surp->status.is_drop_accept!=YES)
   {
   DragAcceptFiles(surp->status.hwnd,YES);
   surp->status.is_drop_accept=YES;
   }
  }
 else
  {
  if(surp->status.is_drop_accept==YES)
   {
   DragAcceptFiles(surp->status.hwnd,NO);
   surp->status.is_drop_accept=NO;
   }
  }
 return RET_YES;
 }







///=====================================================



 B aaSurfaceSpotIdRangeReserve         (H handle,HP firstid,H count)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(firstid==NULL) { return RET_BADPARM; }
 *firstid=0;
 if(count==0) { return RET_BADPARM; }
 surp->spot_id_counter++;
 *firstid=surp->spot_id_counter;
 surp->spot_id_counter+=count;
 return RET_YES;
 }









 B aaSurfaceSpotFindByNumber           (H handle,H sn,_surfacespot**surfacespot)
 {
 B ret;
 _aa_surfaceobject*surp;
 H i,mx,sc,checked;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(surfacespot) { *surfacespot=NULL; }
 sc=surp->status.spot_count;
 if(sn>=sc) { return RET_BOUNDS; }
 mx=surp->status.spot_slots;
 checked=0;
 for(i=0;i<mx;i++)
  {
  if(checked>=sc) { break; }
  if(surp->status.spot[i].id==0) { continue; }
  if(sn==checked)
   {
   if(surfacespot) { *surfacespot=(_surfacespot*)&surp->status.spot[i]; }
   return RET_YES;
   }
  checked++;
  }
 oof;
 return RET_FAILED;
 }



 B aaSurfaceSpotFindById               (H handle,H id,_surfacespot**surfacespot)
 {
 H i,mx,checked;
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(surfacespot) { *surfacespot=NULL; }
 if(id==0) { return RET_BADPARM; }
 mx=surp->status.spot_slots;
 checked=0;
 for(i=0;i<mx;i++)
  {
  if(checked>=surp->status.spot_count) { break; }
  if(surp->status.spot[i].id==0) { continue; }
  checked++;
  if(surp->status.spot[i].id!=id) { continue; }
  if(surfacespot) { *surfacespot=(_surfacespot*)&surp->status.spot[i]; }
  return RET_YES;
  }
 return RET_NOTFOUND;
 }







 B aaSurfaceSpotAdd                    (H handle,H id,_surfacespot**surfacespot)
 {
 H i,ix,mx,f,left,add,by;
 B ret;
 _aa_surfaceobject*surp;
 _surfacespot*ss;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(surfacespot) { *surfacespot=NULL; }
 if(id==0) { return RET_BADPARM; }
 if((ret=aaSurfaceSpotFindById(handle,id,&ss))==RET_YES)
   {
   ix=ss->index;
   surp->status.spot[ix].id=id;
   if(surfacespot) { *surfacespot=(_surfacespot*)ss; }
   return RET_YES;
   }
 if(ret!=RET_NOTFOUND) { oops; }
 by=sizeof(_surfacespot);
 left=surp->status.spot_slots-surp->status.spot_count;
 if(left<5)
  {
  add=surp->status.spot_slots+10;
  if(surp->status.spot_slots==0)
   {
   if((ret=aaMemoryAllocate((VP)&surp->status.spot,add*by))!=RET_YES) { oops; }
   aaMemoryNameSet(surp->status.spot,"spott");
   if((ret=aaMemoryAllocate((VP)&surp->status.spot_id_order,add*sizeof(H)))!=RET_YES) { oops; }
   aaMemoryNameSet(surp->status.spot_id_order,"spotidord");
   if((ret=aaMemoryAllocate((VP)&surp->status.spot_index_order,add*sizeof(H)))!=RET_YES) { oops; }
   }
  else
   {
   if((ret=aaMemoryReAllocate((VP)&surp->status.spot,add*by))!=RET_YES) { oops; }
   if((ret=aaMemoryReAllocate((VP)&surp->status.spot_id_order,add*sizeof(H)))!=RET_YES) { oops; }
   if((ret=aaMemoryReAllocate((VP)&surp->status.spot_index_order,add*sizeof(H)))!=RET_YES) { oops; }
   }
  if(ret!=RET_YES) { oops; return ret; }
  surp->status.spot_slots=add;
  left=surp->status.spot_slots-surp->status.spot_count;
  }
 f=0xffffffff;
 mx=surp->status.spot_slots;
 for(i=0;i<mx;i++)
  {
  if(surp->status.spot[i].id==0&&f==0xffffffff) { f=i; break; }
  }
 if(f==0xffffffff) { oof; }
 i=f;
 aaMemoryFill(&surp->status.spot[i],by,0);
 surp->status.spot[i].id=id;
 surp->status.spot[i].index=i;
 surp->status.spot_count++;
 if(surp->status.spot[i].rect.w==0) { surp->status.spot[i].rect.w=1; }
 if(surp->status.spot[i].rect.h==0) { surp->status.spot[i].rect.h=1; }
 if(surfacespot) { *surfacespot=(_surfacespot*)&surp->status.spot[i]; }
 surp->status.spot_order_ok=NO;
 return RET_YES;
 }





 B aaSurfaceSpotRemove                 (H handle,H id)
 {
 B ret;
 _aa_surfaceobject*surp;
 H mx,i,checked;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(id==0) { return RET_BADPARM; }
 mx=surp->status.spot_slots;
 checked=0;
 for(i=0;i<mx;i++)
  {
  if(checked>=surp->status.spot_count) { break; }
  if(surp->status.spot[i].id==0) { continue; }
  checked++;
  if(surp->status.spot[i].id!=id) { continue; }
  aaMemoryFill(&surp->status.spot[i],sizeof(_surfacespot),0);
  surp->status.spot[i].id=0;
  surp->status.spot[i].index=0;
  surp->status.spot_count--;
  surp->status.spot_order_ok=NO;
  return RET_YES;
  }
 return RET_NOTFOUND;
 }








 B aaSurfaceSpotPurge                  (H handle)
 {
 B ret;
 _aa_surfaceobject*surp;
 H mx,i,checked,count;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 mx=surp->status.spot_slots;
 count=surp->status.spot_count;
 checked=0;
 for(i=0;i<mx;i++)
  {
  if(checked>=count) { break; }
  if(surp->status.spot[i].id==0) { continue; }
  aaMemoryFill(&surp->status.spot[i],sizeof(_surfacespot),0);
  surp->status.spot[i].id=0;
  surp->status.spot[i].index=0;
  surp->status.spot_count--;
  checked++;
  }
 if(surp->status.spot_count!=0) { oof; }
 surp->status.spot_order_ok=NO;
 return RET_YES;
 }





 B aaSurfaceSpotSet                    (H handle,H id,H type,Z depth,N x,N y,H w,H h,_surfacespot**surfacespot)
 {
 B ret;
 _aa_surfaceobject*surp;
 _surfacespot*sspot;
 H old_type;
 Z old_depth;
 N old_x,old_y;
 H old_w,old_h;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(surfacespot) { *surfacespot=NULL; }
 if((ret=aaSurfaceSpotAdd(handle,id,&sspot))!=YES) { oops; return ret; }
 old_type=sspot->type;
 old_depth=sspot->depth;
 old_x=sspot->rect.x;
 old_y=sspot->rect.y;
 old_w=sspot->rect.w;
 old_h=sspot->rect.h;

 if((old_type!=type)||(old_depth!=depth)||(old_x!=x)||(old_y!=y)||(old_w!=w)||(old_h!=h))
  {
  sspot->type=type;
  sspot->depth=depth;
  aaRectSet(&sspot->rect,x,y,w,h);
  surp->status.spot_order_ok=NO;
  }
 if(surfacespot) { *surfacespot=(_surfacespot*)sspot; }
 return RET_YES;
 }





 B aaSurfaceSpotStateSet               (H handle,H id,B isover,B ispress,B isfocus,B ispaint,_surfacespot**surfacespot)
 {
 B ret;
 _aa_surfaceobject*surp;
 _surfacespot*sspot;
 B prev_is_over;
 B prev_is_press;
 B prev_is_focus;
 B prev_is_paint;
 H prev_foc_id;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if((ret=aaSurfaceSpotFindById(handle,id,&sspot))!=YES) { return ret; }
 if(isover>TOGGLE) { return RET_BADPARM; }
 if(ispress>TOGGLE) { return RET_BADPARM; }
 if(isfocus>TOGGLE) { return RET_BADPARM; }
 if(ispaint>TOGGLE) { return RET_BADPARM; }
 prev_is_over=sspot->is_over;
 prev_is_press=sspot->is_press;
 prev_is_focus=sspot->is_focus;
 prev_is_paint=sspot->is_paint;

 prev_foc_id=surp->status.spot_focus_id;

 if(isover!=NEITHER)
  {
  if(isover==TOGGLE) { sspot->is_over^=1; } else
  if(isover<=YES)    { sspot->is_over=isover; }
  }
 if(ispress!=NEITHER)
  {
  if(ispress==TOGGLE) { sspot->is_press^=1; } else
  if(ispress<=YES)    { sspot->is_press=ispress; }
  }
 if(isfocus!=NEITHER)
  {
  if(isfocus==TOGGLE) { sspot->is_focus^=1; } else
  if(isfocus<=YES)    { sspot->is_focus=isfocus; }
  }
 if(ispaint!=NEITHER)
  {
  if(ispaint==TOGGLE) { sspot->is_paint^=1; } else
  if(ispaint<=YES)    { sspot->is_paint=ispaint; }
  }
 if(prev_is_over!=sspot->is_over)
  {
  if(sspot->is_over==YES) { surp->status.spot_over_count++; }
  else                    { surp->status.spot_over_count--; }
  }
 if(prev_is_press!=sspot->is_press)
  {
  if(sspot->is_press==YES) { surp->status.spot_press_count++; }
  else                     { surp->status.spot_press_count--; }
  }
 if(prev_is_focus!=sspot->is_focus)
  {
  if(sspot->is_focus==YES) { surp->status.spot_focus_count++; }
  else                     { surp->status.spot_focus_count--; }
  }
 if(prev_is_paint!=sspot->is_paint)
  {
  if(sspot->is_paint==YES) { surp->status.spot_paint_count++; }
  else                     { surp->status.spot_paint_count--; }
  }

 if(sspot->is_focus==YES)
  {
  if(prev_foc_id!=sspot->id)
   {
   surp->status.spot_focus_id=sspot->id;
   if(prev_foc_id!=0)
    {
    if((ret=aaSurfaceSpotFindById(handle,id,&sspot))!=YES) { return ret; }
    sspot->is_focus=NO;
    }
   }
  }

 if(surfacespot) { *surfacespot=(_surfacespot*)sspot; }
 return RET_YES;
 }





 #define SPOT_SizerT                   2000
 #define SPOT_SizerTR                  2010
 #define SPOT_SizerR                   2020
 #define SPOT_SizerBR                  2030
 #define SPOT_SizerB                   2040
 #define SPOT_SizerBL                  2050
 #define SPOT_SizerL                   2060
 #define SPOT_SizerTL                  2070
 #define SPOT_Caption                  2080




 B aaSurfaceResizeBorderSet            (H handle,H pixels)
 {
 B ret;
 _aa_surfaceobject*surp;
 _surfacespot*sspot;
 _rect rc1;
 H i,ew,eh;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }

 if(surp->status.resize_border_pixels!=0)
  {
  if(pixels==0)
   {
   i=4; aaSurfaceSpotRemove(handle,i);
   i=5; aaSurfaceSpotRemove(handle,i);
   i=6; aaSurfaceSpotRemove(handle,i);
   i=7; aaSurfaceSpotRemove(handle,i);
   i=8; aaSurfaceSpotRemove(handle,i);
   i=9; aaSurfaceSpotRemove(handle,i);
   i=10; aaSurfaceSpotRemove(handle,i);
   i=11; aaSurfaceSpotRemove(handle,i);
   surp->status.resize_border_pixels=0;
   return RET_YES;
   }
  //if(surp->status.is_sizeable!=YES) { return RET_FAILED; }
  aaRectSet(&rc1,0,0,surp->status.size.w,surp->status.size.h);
  ew=pixels;
  eh=pixels;
  i=4; aaSurfaceSpotSet(handle,i,SPOT_SizerTL,3000,0,0,ew,eh,&sspot);
  i=5; aaSurfaceSpotSet(handle,i,SPOT_SizerT,3000,ew,0,rc1.w-(ew*2),eh,&sspot);
  i=6; aaSurfaceSpotSet(handle,i,SPOT_SizerTR,3000,rc1.w-ew,0,ew,eh,&sspot);
  i=7; aaSurfaceSpotSet(handle,i,SPOT_SizerBL,3000,0,rc1.h-eh,ew,eh,&sspot);
  i=8; aaSurfaceSpotSet(handle,i,SPOT_SizerB,3000,ew,rc1.h-eh,rc1.w-(ew*2),eh,&sspot);
  i=9; aaSurfaceSpotSet(handle,i,SPOT_SizerBR,3000,rc1.w-ew,rc1.h-eh,ew,eh,&sspot);
  i=10; aaSurfaceSpotSet(handle,i,SPOT_SizerL,3000,0,eh,ew,rc1.h-(eh*2),&sspot);
  i=11; aaSurfaceSpotSet(handle,i,SPOT_SizerR,3000,rc1.w-ew,eh,ew,rc1.h-(eh*2),&sspot);
  surp->status.resize_border_pixels=pixels;
  }
 else
  {
  //if(surp->status.is_sizeable!=YES) { return RET_FAILED; }
  if(pixels==0) { return RET_YES;  }
  aaRectSet(&rc1,0,0,surp->status.size.w,surp->status.size.h);
  ew=pixels;
  eh=pixels;
  i=4; aaSurfaceSpotSet(handle,i,SPOT_SizerTL,3000,0,0,ew,eh,&sspot);
  i=5; aaSurfaceSpotSet(handle,i,SPOT_SizerT,3000,ew,0,rc1.w-(ew*2),eh,&sspot);
  i=6; aaSurfaceSpotSet(handle,i,SPOT_SizerTR,3000,rc1.w-ew,0,ew,eh,&sspot);
  i=7; aaSurfaceSpotSet(handle,i,SPOT_SizerBL,3000,0,rc1.h-eh,ew,eh,&sspot);
  i=8; aaSurfaceSpotSet(handle,i,SPOT_SizerB,3000,ew,rc1.h-eh,rc1.w-(ew*2),eh,&sspot);
  i=9; aaSurfaceSpotSet(handle,i,SPOT_SizerBR,3000,rc1.w-ew,rc1.h-eh,ew,eh,&sspot);
  i=10; aaSurfaceSpotSet(handle,i,SPOT_SizerL,3000,0,eh,ew,rc1.h-(eh*2),&sspot);
  i=11; aaSurfaceSpotSet(handle,i,SPOT_SizerR,3000,rc1.w-ew,eh,ew,rc1.h-(eh*2),&sspot);
  surp->status.resize_border_pixels=pixels;
  }
 return RET_YES;
 }




 B aaSurfaceMoveAreaSet                (H handle,H pixels)
 {
 B ret;
 _aa_surfaceobject*surp;
 _surfacespot*sspot;
 H i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }

 if(surp->status.move_pixels!=0)
  {
  if(pixels!=surp->status.move_pixels)
   {
   i=1; aaSurfaceSpotRemove(handle,i);
   surp->status.move_pixels=0;
   }
  if(pixels!=0)
   {
   //if(surp->status.is_sizeable!=YES) { return RET_FAILED; }
   i=1; aaSurfaceSpotSet(handle,i,SPOT_Caption,2990,0,0,surp->status.rect.w,pixels,&sspot);
   surp->status.move_pixels=pixels;
   }
  }
 else
  {
  if(pixels!=0)
   {
   //if(surp->status.is_sizeable!=YES) { return RET_FAILED; }
   i=1; aaSurfaceSpotSet(handle,i,SPOT_Caption,2990,0,0,surp->status.rect.w,pixels,&sspot);
   surp->status.move_pixels=pixels;
   }
  }

/*
 if(surp->status.move_pixels!=0)
  {
  i=1; aaSurfaceSpotRemove(handle,i);
  surp->status.move_pixels=0;
  }
 if(pixels!=0)
  {
  if(surp->status.is_sizeable!=YES) { return RET_FAILED; }
  i=1; aaSurfaceSpotSet(handle,i,SPOT_Caption,2990,0,0,surp->status.rect.w,pixels,&sspot);
  surp->status.move_pixels=pixels;
  }
  */
 return RET_YES;
 }


//=====================================================

 H aa_surfacearrow_cord_count=0;
 _cord aa_surfacearrow_cord_list[5000];




 B aa_SurfaceArrowCordGrabber          (VP handle,N x,N y,_rgba*pn)
 {
 _aa_surfaceobject*surp;

 aaCast(surp,_aa_surfaceobject*,handle);
 if(surp) {}
 if(pn)   {}
 if(aa_surfacearrow_cord_count>=aaElementCount(aa_surfacearrow_cord_list)) { oof; }
 aaCordSet(&aa_surfacearrow_cord_list[aa_surfacearrow_cord_count],x,y);
 aa_surfacearrow_cord_count++;
 return RET_YES;
 }



 B aaSurfaceArrow                      (H handle,_cord*cd1,_cord*cd2,N which,N thick,N hang,D ang,_rgba*pn1,_rgba*pn2,D pxi1,D pxi2)
 {
 B ret;
 _aa_surfaceobject*surp;
 _cord c0,c1,c2,c3;
 _cord ccc1,ccc2;
 _pixelstyle pstyle_save;
 _pixelstyle pstyle_data;
 N arrowlength,dx,dy;
 H flag;
 D theta,rad,phi2,x2,y2,x1,y1,ang1,ang2;
 N xi1,xi2;
 _cord*cd1p;
 _cord*cd2p;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }

 aaCordCopy(&ccc1,cd1);
 aaCordCopy(&ccc2,cd2);

 if(which==1)  {  cd1p=&ccc2;  cd2p=&ccc1;  }
 else          {  cd1p=&ccc1;  cd2p=&ccc2;  }

 if(pxi1<0.0&&pxi2<0.0) { return RET_BOUNDS; }
 if(pxi1>1.0&&pxi2>1.0) { return RET_BOUNDS; }

 if(pxi1!=0.0||pxi2!=1.0)
  {
  aa_surfacearrow_cord_count=0;
  aaSurfacePixelPutProcSet(handle,aa_SurfaceArrowCordGrabber);
  aaSurfaceLine(handle,cd1p,cd2p,&col_red[31]);
  aaSurfacePixelPutProcSet(handle,NULL);
  xi1=(D)aa_surfacearrow_cord_count*pxi1;
  xi2=(D)aa_surfacearrow_cord_count*pxi2;
  if(xi1>=(N)aa_surfacearrow_cord_count) { xi1=aa_surfacearrow_cord_count-1; }
  if(xi2>=(N)aa_surfacearrow_cord_count) { xi2=aa_surfacearrow_cord_count-1; }
  cd1p->x=aa_surfacearrow_cord_list[(N)xi1].x;
  cd1p->y=aa_surfacearrow_cord_list[(N)xi1].y;
  cd2p->x=aa_surfacearrow_cord_list[(N)xi2].x;
  cd2p->y=aa_surfacearrow_cord_list[(N)xi2].y;
  }

 ang1=+ang;
 ang2=-ang;
 arrowlength=hang;
 dx=cd2p->x-cd1p->x;
 dy=cd2p->y-cd1p->y;
 theta=atan2(dy,dx);
 rad=(ang1*aaPi/180.0);
 x1=cd2p->x-arrowlength*cos(theta+rad);
 y1=cd2p->y-arrowlength*sin(theta+rad);
 phi2=(ang2*aaPi/180.0);
 x2=cd2p->x-arrowlength*cos(theta+phi2);
 y2=cd2p->y-arrowlength*sin(theta+phi2);
 aaCordSet(&c0,cd1p->x,cd1p->y);
 aaCordSet(&c1,cd2p->x,cd2p->y);
 aaCordSet(&c2,(N)x1,(N)y1);
 aaCordSet(&c3,(N)x2,(N)y2);



 if(thick>1)
  {
  aaSurfacePixelStyleGet(handle,&pstyle_save);
  aaPixelStyleInit(&pstyle_data);
  aaPixelStyleSet(&pstyle_data,7,1,(thick/1),(thick/1),0,0,0,0,handle); aaSurfaceLine(handle,&c1,&c2,pn1);
  aaPixelStyleSet(&pstyle_data,7,1,(thick/1),(thick/1),0,0,0,0,handle); aaSurfaceLine(handle,&c1,&c3,pn1);
  aaPixelStyleSet(&pstyle_data,7,1,(thick/1),(thick/1),0,0,0,0,handle); aaSurfaceLine(handle,&c1,&c0,pn1);
  aaPixelStyleSet(&pstyle_data,7,1,(thick/2),(thick/2),0,0,0,0,handle); aaSurfaceLine(handle,&c1,&c2,pn2);
  aaPixelStyleSet(&pstyle_data,7,1,(thick/2),(thick/2),0,0,0,0,handle); aaSurfaceLine(handle,&c1,&c3,pn2);
  aaPixelStyleSet(&pstyle_data,7,1,(thick/2),(thick/2),0,0,0,0,handle); aaSurfaceLine(handle,&c1,&c0,pn2);
  aaSurfacePixelStyleSet(handle,&pstyle_save);
  }
 else
  {
  flag=0;
  if(surp->status.pixl_style.mode!=0)
   {
   aaSurfacePixelStyleGet(handle,&pstyle_save);
   aaPixelStyleInit(&pstyle_data);
   aaPixelStyleSet(&pstyle_data,7,0,0,0,0,0,0,0,handle);
   flag=1;
   }
  aaSurfaceLine(handle,&c1,&c2,pn1);
  aaSurfaceLine(handle,&c1,&c3,pn1);
  aaSurfaceLine(handle,&c1,&c0,pn1);
  if(flag)
   {
   aaSurfacePixelStyleSet(handle,&pstyle_save);
   }
  }


 return RET_YES;
 }










 B aaSurfaceCheckMark                  (H handle,_rect*r1,_rgba*p1,_rgba*p2,_rgba*p3)
 {
 B ret;
 _aa_surfaceobject*surp;
 _rect ra,r2;
 _cord c1,c2,c3,c4;
 _cord c5,c6,c7;
 _rgba pn1,pn2,pn3;
 _pixelstyle pstyle_save;
 _pixelstyle pstyle_data;
 _pixelstyle*pstylep;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }

 aaRectCopy(&ra,r1);
 aaRectSet(&r2,ra.x,ra.y,ra.w,ra.h);
 aaRectExpand(&r2,-4,-4);
 aaRectToCornerCords(&r2,&c1,&c2,&c3,&c4);
 aaCordSet(&c5,c1.x+((c2.x-c1.x)*0.00),c1.y+((c4.y-c1.y)*0.50));
 aaCordSet(&c6,c1.x+((c2.x-c1.x)*0.30),c1.y+((c4.y-c1.y)*1.00));
 aaCordSet(&c7,c1.x+((c2.x-c1.x)*1.00),c1.y+((c4.y-c1.y)*0.00));
 if(p1) { aaRgbaCopy(&pn1,p1); } else { aaRgbaSet(&pn1,0,100,0,255); }
 if(p2) { aaRgbaCopy(&pn2,p2); } else { aaRgbaSet(&pn2,0,255,0,192);  }
 if(p3) { aaRgbaCopy(&pn3,p3); } else { aaRgbaSet(&pn3,255,255,0,128); }

 aaSurfacePixelStyleGet(handle,&pstyle_save);
 aaPixelStyleInit(&pstyle_data);
 pstylep=(_pixelstyle*)&pstyle_data;

 pstylep->mode=1; pstylep->nparm0=2; pstylep->nparm1=2;
 if(aaSurfacePixelStyleSet(handle,&pstyle_data)!=YES) oof;
 aaSurfaceLine(handle,&c5,&c6,&pn1);
 aaSurfaceLine(handle,&c6,&c7,&pn1);


 pstylep->mode=1; pstylep->nparm0=1; pstylep->nparm1=1;
 aaSurfacePixelStyleSet(handle,&pstyle_data);
 aaSurfaceLine(handle,&c5,&c6,&pn2);
 aaSurfaceLine(handle,&c6,&c7,&pn2);

 pstylep->mode=0;
 aaSurfacePixelStyleSet(handle,&pstyle_data);
 aaSurfaceLine(handle,&c5,&c6,&pn3);
 aaSurfaceLine(handle,&c6,&c7,&pn3);

 aaSurfacePixelStyleSet(handle,&pstyle_save);
 return RET_YES;
 }








 B aaSurfaceCrossMark                  (H handle,_rect*r1,_rgba*p1,_rgba*p2,_rgba*p3)
 {
 B ret;
 _aa_surfaceobject*surp;
 _rect ra,r2;
 _cord c1,c2,c3,c4;
 _cord c5,c6,c7,c8;
 _rgba pn1,pn2,pn3;
 _pixelstyle pstyle_save;
 _pixelstyle pstyle_data;
 _pixelstyle*pstylep;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 aaRectCopy(&ra,r1);
 aaRectSet(&r2,ra.x,ra.y,ra.w,ra.h);
 aaRectExpand(&r2,-4,-4);
 aaRectToCornerCords(&r2,&c1,&c2,&c3,&c4);
 aaCordSet(&c5,c1.x,c1.y);
 aaCordSet(&c6,c3.x,c3.y);
 aaCordSet(&c7,c2.x,c2.y);
 aaCordSet(&c8,c4.x,c4.y);
 if(p1) { aaRgbaCopy(&pn1,p1); } else {  aaRgbaSet(&pn1,100,0,0,255); }
 if(p2) { aaRgbaCopy(&pn2,p2); } else { aaRgbaSet(&pn2,255,0,0,192);  }
 if(p3) { aaRgbaCopy(&pn3,p3); } else { aaRgbaSet(&pn3,255,255,0,128); }

 aaSurfacePixelStyleGet(handle,&pstyle_save);
 aaPixelStyleInit(&pstyle_data);
 pstylep=(_pixelstyle*)&pstyle_data;

 pstylep->mode=1; pstylep->nparm0=2;  pstylep->nparm1=2;
 aaSurfacePixelStyleSet(handle,&pstyle_data);
 aaSurfaceLine(handle,&c5,&c6,&pn1);
 aaSurfaceLine(handle,&c7,&c8,&pn1);

 pstylep->mode=1; pstylep->nparm0=1; pstylep->nparm1=1;
 aaSurfacePixelStyleSet(handle,&pstyle_data);
 aaSurfaceLine(handle,&c5,&c6,&pn2);
 aaSurfaceLine(handle,&c7,&c8,&pn2);
 pstylep->mode=0;
 aaSurfacePixelStyleSet(handle,&pstyle_data);
 aaSurfaceLine(handle,&c5,&c6,&pn3);
 aaSurfaceLine(handle,&c7,&c8,&pn3);
 aaSurfacePixelStyleSet(handle,&pstyle_save);
 return RET_YES;
 }








 B aaSurfaceRadioButton                (H handle,_rect*r1,B state,N thick,_rgba*p1,_rgba*p2,_rgba*p3,_rgba*p4)
 {
 B ret;
 _aa_surfaceobject*surp;
 _rect ra,r2;
 _rgba pn1,pn2,pn3,pn4;
 _pixelstyle pstyle_save;
 _pixelstyle pstyle_data;
 _pixelstyle*pstylep;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 aaRectCopy(&ra,r1);
 aaRectSet(&r2,ra.x,ra.y,ra.w,ra.h);
 aaRectExpand(&r2,-1,-1);
 if(p1) { aaRgbaCopy(&pn1,p1); } else {  aaRgbaSet(&pn1,192,192,192,255); }
 if(p2) { aaRgbaCopy(&pn2,p2); } else { aaRgbaSet(&pn2,100,100,100,195);  }
 if(p3) { aaRgbaCopy(&pn3,p3); } else { aaRgbaSet(&pn3,80,80,80,255); }
 if(p4) { aaRgbaCopy(&pn4,p4); } else { aaRgbaSet(&pn4,120,120,120,128); }
 aaSurfacePixelStyleGet(handle,&pstyle_save);
 aaPixelStyleInit(&pstyle_data);
 pstylep=(_pixelstyle*)&pstyle_data;
 aaSurfaceEllipseFill(handle,&r2,&pn1);


 aaPixelStyleInit(&pstyle_data);
 aaSurfacePixelStyleSet(handle,&pstyle_data);
  aaRectCopy(&r2,r1);
  aaRectExpand(&r2,-(ra.w*.2),-(ra.h*.2));
  if(state) { aaSurfaceEllipseFill(handle,&r2,&pn3); }

  if(state)
   {
   pstylep->mode=1;   pstylep->nparm0=1; pstylep->nparm1=1;
   aaSurfacePixelStyleSet(handle,&pstyle_data);
   aaPixelStyleSet(&pstyle_data,7,1,thick,thick,0,0,0,0,handle);
   aaSurfaceEllipse(handle,&r2,&pn2);
   }
  else
   {
   aaPixelStyleInit(&pstyle_data);
   aaPixelStyleSet(&pstyle_data,7,1,thick,thick,0,0,0,0,handle);
   aaSurfacePixelStyleSet(handle,&pstyle_data);
   aaSurfaceEllipse(handle,&r2,&pn2);
   }

 aaRectCopy(&r2,r1);
   aaPixelStyleInit(&pstyle_data);
   aaPixelStyleSet(&pstyle_data,7,1,thick,thick,0,0,0,0,handle);
   aaSurfacePixelStyleSet(handle,&pstyle_data);
   aaSurfaceEllipse(handle,&r2,&pn4);

 aaSurfacePixelStyleSet(handle,&pstyle_save);
 return RET_YES;
 }








 B aaSurfaceCloseIcon                  (H handle,_rect*r1,_rgba*p1)
 {
 B ret;
 _aa_surfaceobject*surp;
 _pixelstyle pstyle_save;
 _pixelstyle pstyle_data;
 _pixelstyle*pstylep;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(r1==NULL) { return RET_BADPARM; }
 if(r1->w==0||r1->h==0) { return RET_BADPARM; }
 if(p1==NULL) { return RET_BADPARM; }
 if(p1->a==0) { return RET_YES; }

 aaSurfacePixelStyleGet(handle,&pstyle_save);
 aaPixelStyleInit(&pstyle_data);
 pstylep=(_pixelstyle*)&pstyle_data;
 pstylep->mode=1; pstylep->nparm0=1; pstylep->nparm1=1;
 aaSurfacePixelStyleSet(handle,&pstyle_data);
 aaSurfaceFramePart(handle,r1,p1,0,0,0,0,1,1);
 aaSurfacePixelStyleSet(handle,&pstyle_save);
 return RET_YES;
 }









 B aaSurfaceMaximizeIcon               (H handle,_rect*r1,_rgba*p1)
 {
 B ret;
 _aa_surfaceobject*surp;
 _pixelstyle pstyle_save;
 _pixelstyle pstyle_data;
 _pixelstyle*pstylep;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(r1==NULL) { return RET_BADPARM; }
 if(r1->w==0||r1->h==0) { return RET_BADPARM; }
 if(p1==NULL) { return RET_BADPARM; }
 if(p1->a==0) { return RET_YES; }
 aaSurfacePixelStyleGet(handle,&pstyle_save);
 aaPixelStyleInit(&pstyle_data);
 pstylep=(_pixelstyle*)&pstyle_data;
 pstylep->mode=1; pstylep->nparm0=1; pstylep->nparm1=1;
 aaSurfacePixelStyleSet(handle,&pstyle_data);
 aaSurfaceFramePart(handle,r1,p1,1,1,1,1,0,0);
 aaSurfacePixelStyleSet(handle,&pstyle_save);
 return RET_YES;
 }







 B aaSurfaceRestoreIcon                (H handle,_rect*r1,_rgba*p1)
 {
 B ret;
 _rect rc1;
 _aa_surfaceobject*surp;
 _pixelstyle pstyle_save;
 _pixelstyle pstyle_data;
 _pixelstyle*pstylep;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(r1==NULL) { return RET_BADPARM; }
 if(r1->w==0||r1->h==0) { return RET_BADPARM; }
 if(p1==NULL) { return RET_BADPARM; }
 if(p1->a==0) { return RET_YES; }
 aaSurfacePixelStyleGet(handle,&pstyle_save);
 aaPixelStyleInit(&pstyle_data);
 pstylep=(_pixelstyle*)&pstyle_data;
 pstylep->mode=1; pstylep->nparm0=1; pstylep->nparm1=1;
 aaSurfacePixelStyleSet(handle,&pstyle_data);
 aaRectCopy(&rc1,r1);
 aaRectExpand(&rc1,-1,-2);
 aaRectAdjust(&rc1,-1,2,0,0); aaSurfaceFramePart(handle,&rc1,p1,1,1,1,1,0,0);
 aaRectAdjust(&rc1,3,-3,0,0); aaSurfaceFramePart(handle,&rc1,p1,1,1,1,1,0,0);
 aaRectExpand(&rc1,+1,+2);
 aaSurfacePixelStyleSet(handle,&pstyle_save);
 return RET_YES;
 }







 B aaSurfaceMinimizeIcon               (H handle,_rect*r1,_rgba*p1)
 {
 B ret;
 _aa_surfaceobject*surp;
 _pixelstyle pstyle_save;
 _pixelstyle pstyle_data;
 _pixelstyle*pstylep;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(r1==NULL) { return RET_BADPARM; }
 if(r1->w==0||r1->h==0) { return RET_BADPARM; }
 if(p1==NULL) { return RET_BADPARM; }
 if(p1->a==0) { return RET_YES; }
 aaSurfacePixelStyleGet(handle,&pstyle_save);
 aaPixelStyleInit(&pstyle_data);
 pstylep=(_pixelstyle*)&pstyle_data;
 pstylep->mode=1; pstylep->nparm0=1; pstylep->nparm1=1;
 aaSurfacePixelStyleSet(handle,&pstyle_data);
 aaSurfaceFramePart(handle,r1,p1,0,0,0,1,0,0);
 aaSurfacePixelStyleSet(handle,&pstyle_save);
 return RET_YES;
 }







 B aaSurfaceCloseButton                (H handle,_rect*r1,B state,_rgba*bg,_rgba*fg)
 {
 B ret;
 _aa_surfaceobject*surp;
 _rect rc1;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 state&=1;
 aaRectCopy(&rc1,r1);
 aaSurfaceFill(handle,&rc1,bg);
 aaSurfaceButtonFrame(handle,&rc1,state,2);
 aaRectAdjust(&rc1,+6,+5,-10,-10);
 if(state) { aaRectAdjust(&rc1,1,1,0,0); }
 aaSurfaceCloseIcon(handle,&rc1,fg);
 if(state) { aaRectAdjust(&rc1,-1,-1,0,0); }
 aaRectAdjust(&rc1,-6,-5,+10,+10);
 return RET_YES;
 }








 B aaSurfaceMaximizeButton             (H handle,_rect*r1,B state,_rgba*bg,_rgba*fg)
 {
 B ret;
 _aa_surfaceobject*surp;
 _rect rc1;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 state&=1;
 aaRectCopy(&rc1,r1);
 aaSurfaceFill(handle,&rc1,bg);
 aaSurfaceButtonFrame(handle,&rc1,state,2);
 aaRectAdjust(&rc1,+6,+5,-10,-10);
 if(state) { aaRectAdjust(&rc1,1,1,0,0); }
 aaSurfaceMaximizeIcon(handle,&rc1,fg);
 if(state) { aaRectAdjust(&rc1,-1,-1,0,0); }
 aaRectAdjust(&rc1,-6,-5,+10,+10);
 return RET_YES;
 }







 B aaSurfaceRestoreButton              (H handle,_rect*r1,B state,_rgba*bg,_rgba*fg)
 {
 B ret;
 _aa_surfaceobject*surp;
 _rect rc1;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 state&=1;
 aaRectCopy(&rc1,r1);
 aaSurfaceFill(handle,&rc1,bg);
 aaSurfaceButtonFrame(handle,&rc1,state,2);
 aaRectAdjust(&rc1,+6,+5,-10,-10);
 if(state) { aaRectAdjust(&rc1,1,1,0,0); }
 aaSurfaceRestoreIcon(handle,&rc1,fg);
 if(state) { aaRectAdjust(&rc1,-1,-1,0,0); }
 aaRectAdjust(&rc1,-6,-5,+10,+10);
 return RET_YES;
 }






 B aaSurfaceMinimizeButton             (H handle,_rect*r1,B state,_rgba*bg,_rgba*fg)
 {
 B ret;
 _aa_surfaceobject*surp;
 _rect rc1;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 state&=1;
 aaRectCopy(&rc1,r1);
 aaSurfaceFill(handle,&rc1,bg);
 aaSurfaceButtonFrame(handle,&rc1,state,2);
 aaRectAdjust(&rc1,+6,+5,-10,-10);
 if(state) { aaRectAdjust(&rc1,1,1,0,0); }
 aaSurfaceMinimizeIcon(handle,&rc1,fg);
 if(state) { aaRectAdjust(&rc1,-1,-1,0,0); }
 aaRectAdjust(&rc1,-6,-5,+10,+10);
 return RET_YES;
 }





 B aaSurfaceCaption                    (H handle,_rect*r1,H fonthandle,_rgba*p1,_rgba*p2,_rgba*p3,B isfocused,VP fmt,...)
 {
 B ret;
 _aa_surfaceobject*surp;
 _size sz1;
 _cord cd1,cd2;
 _rect rc1,rc2,rc3;//,rc4;
 va_list argptr;
 B str[_4K];
 H sl;
 N x;
 _rgba pn1,pn2,pn3,pn4;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 aaFmt(fmt,argptr,str);
 aaStringLen(str,&sl);
 if(p1==NULL) { aaRgbaCopyWithAlpha(&pn1,&col_pastelblue[28],255); }
 else         { aaRgbaCopy(&pn1,p1); }
 if(p2==NULL) { aaRgbaCopyWithAlpha(&pn2,&col_pastelblue[14],255); }
 else         { aaRgbaCopy(&pn2,p2); }
 if(p3==NULL) { aaRgbaCopyWithAlpha(&pn3,&col_gray[31],255); }
 else         { aaRgbaCopy(&pn3,p3); }

 if(isfocused!=YES)
  {
  aaRgbaShadeSet(&pn1,&pn1,0.5);
  aaRgbaShadeSet(&pn2,&pn2,0.4);
  aaRgbaShadeSet(&pn3,&pn3,0.5);
  }


 if(r1==NULL)
  {
  aaSizeSet(&sz1,surp->status.size.w,surp->status.size.h);
  aaRectSet(&rc1,0,0,sz1.w,45);
  }
 else
  {
  aaRectCopy(&rc1,r1);
  }
 //aaRectSet(&rc4,(rc1.x+rc1.w)-30,rc1.y+6,20,20);
 aaCordSet(&cd1,10,10);
 aaSurfaceGradientFill(handle,&rc1,&cd1,&pn1,&pn2,0,90);
 aaRectToCornerCords(&rc1,0,0,&cd1,&cd2);
 aaSurfaceLine(handle,&cd1,&cd2,&col_red[31]);
 aaCordsAdjust(&cd1,&cd2,0,+1,0,+1);
 aaSurfaceLine(handle,&cd1,&cd2,&col_blue[0]);
 aaRectAdjust(&rc1,0,0,-100,0);
 if(sl!=0)
  {
  if(surp->status.icon_mem!=NULL) { x=52; }
  else                            { x=10; }
  aaSurfaceLabel(handle,&rc1,&col_null,fonthandle,&col_gray[9],x,0,0,1,0,"%s",str);
  aaRectAdjust(&rc1,-1,-1,0,0);
  aaSurfaceLabel(handle,&rc1,&col_null,fonthandle,&pn3,x,0,0,1,0,"%s",str);
  aaRectAdjust(&rc1,+1,+1,0,0);
  }
 if(surp->status.icon_mem!=NULL)
  {
  aaSizeCopy(&sz1,&surp->status.icon_size);
  aaRectSet(&rc3,0,0,sz1.w,sz1.h);
  aaRectSet(&rc2,10,6,34,34);
  aaRectSet(&rc2,rc2.x,(rc1.h/2)-(rc2.h/2),rc2.w,rc2.h);
  if(isfocused==YES)   {   if((ret=aaSurfaceImageDraw(handle,&sz1,&rc3,surp->status.icon_mem,&rc2,0,1,0))!=YES)  { oops; }   }
  else                 {   if((ret=aaSurfaceImageDraw(handle,&sz1,&rc3,surp->status.icon_mem,&rc2,0,1,96))!=YES) { oops; }   }
  aaRgbaSet(&pn4,40,40,40,80);
  aaSurfaceFillFrame(handle,&rc2,2,&pn4,0);
  }

 return RET_YES;
 }







 B aaSurfaceEditorPaint                (H handle,_rect*r0,N row,_rgba*tbg,_rgba*tfg,_rgba*sbg,_rgba*cfg,H fh,N sf,N st,N co,B cs,_rect*rc1,_rect*rc2,_rect*rc3,_rect*rc4,HP visible,VP fmt,...)
 {
 B ret;
 _rect r1;//,r2;
 _cord c1,c2;
 _cord cord;
 _fontpixel*fx;
 H fxi,fxc,off,vis;
 B in_select,in_caret,in_r_edge;
 B alpha,flag;
 N a1,a2,dif;
 N xx,yy,ww,hh;
 _rect rct;
 _rgba pna,pnb,pnc,pnd,pne,pnx;
 _fontpixel*fxp;
 _aa_surfaceobject*surp;
 B single_line;
 S H prev_font_handle=0;
 S _fontstatus prev_font_status;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 aaVargsf4K(fmt);
 if(tfg==NULL) { aaRgbaCopy(&pna,&col_gray[31]); }        else          { aaRgbaCopy(&pna,tfg); }
 if(tbg==NULL) { aaRgbaCopy(&pnb,&col_pastelblue[16]); }  else          { aaRgbaCopy(&pnb,tbg); }
 if(sbg==NULL) { aaRgbaCopy(&pnc,&col_red[17]); }         else          { aaRgbaCopy(&pnc,sbg); }
 if(cfg==NULL) { aaRgbaCopy(&pnd,&col_cyan[31]); }        else          { aaRgbaCopy(&pnd,cfg); }
 aaRgbaCopy(&pne,&pnd);
 pne.a=pnd.a/2;
 if(pne.a==0) { pne.a=32; }
 if(visible) { *visible=0; }
 single_line=NO;
 if(row<0) { row=0; single_line=YES; }
 if(fh==0) { fh=font_8x8; }
 if(prev_font_handle!=fh)
  {
  if((ret=aaFontStatus(fh,&prev_font_status))!=YES) { oops; }
  prev_font_handle=fh;
  }
 //aaSurfaceStatus(handle,&ss);
 if((ret=aaFontStringPixelsGet(prev_font_handle,&fx,&fxc,0,"%s.",str4k.buf))!=YES) { oops; }
 aaRectSet(&rct,0,row*prev_font_status.size.h,surp->status.size.w,prev_font_status.size.h);
 if(r0)  {  rct.x=r0->x;  rct.w=r0->w;  rct.y+=r0->y;  }
 if(r0&&single_line==YES) { rct.h=r0->h; }
 aaRectCopy(&r1,&rct);
 aaCordSet(&c1,r1.x,r1.y);
 aaCordCopy(&cord,&c1);
 aaSurfaceErase(handle,&r1,&pnb);
 //aaSurfaceFill(handle,&r1,&pnb);
 if(single_line==YES)
  {
  r1.y+=(r1.h/2);//-(prev_font_status.size.h/2);
  r1.y-=(prev_font_status.size.h/2);
  r1.h=prev_font_status.size.h;
  aaCordSet(&c1,r1.x,r1.y);
  aaCordCopy(&cord,&c1);
  }
 //aaSurfaceFill(handle,&r1,&pnb);
 if(rc1) { aaRectCopy(rc1,&r1); }
 if(rc2) { aaRectSet(rc2,0,0,0,0); }
 if(rc3) { aaRectSet(rc3,0,0,0,0); }
 if(rc4) { aaRectSet(rc4,0,0,0,0); }
 //aaSurfaceUpdateAreaAdd(handle,&r1,NO);
 vis=0;

 for(fxi=0;fxi<fxc;fxi++)
  {
  in_select=NO;
  in_caret=NO;
  in_r_edge=NO;
  fxp=(_fontpixel*)&fx[fxi];
  ww=fxp->rect.w;
  hh=fxp->rect.h;
  if((fxi+1)==fxc)  {  in_r_edge=1;   }
  if(sf>=0&&st<0)
   {
   if((N)fxi>=sf&&(N)fxi<=((N)fxc+st)) { in_select=1; }
   }
  if(sf>=0&&st>=0)
   {
   if((N)fxi>=sf&&(N)fxi<=st) { in_select=1; }
   }
  if((N)fxi==co) { in_caret=1;   }
  //------------
  c2.y=cord.y;
  for(yy=0;yy<hh;yy++)
   {
   c2.x=cord.x;
   for(xx=0;xx<ww;xx++)
    {
    if((c2.x+8)>=(N)(r1.x+r1.w))  {  break;     }
    if(fxi>=vis) { vis=fxi; }
    off=(c2.y*surp->status.size.w)+c2.x;

    if(in_select)
     {
     if(rc2)
      {
      if(rc2->w==0) {  rc2->x=c2.x; rc2->y=c2.y; rc2->w=rc2->h=1; }
      if(c2.x>rc2->x) { rc2->w=(c2.x-rc2->x)+1; }
      if(c2.y>rc2->y) { rc2->h=(c2.y-rc2->y)+1; }
      }
     surp->status.mem[off]=pnc;
     }
    alpha=fxp->ptr[(yy*fxp->stride)+xx];

    if(alpha!=0&&in_r_edge==0)
     {
     if(rc4)
      {
      if(rc4->w==0)
       {
       rc4->x=c2.x;
       rc4->y=c2.y;
       rc4->w=rc4->h=8;
       }
      else
       {
       if(c2.x<rc4->x)
        {
        dif=rc4->x-c2.x;
        rc4->x=c2.x;
        rc4->w+=dif;
        }
       //else
       if(c2.x>rc4->x)
        {
        rc4->w=(c2.x-rc4->x)+1;
        }

       if(c2.y<rc4->y)
        {
        dif=rc4->y-c2.y;
        rc4->y=c2.y;
        rc4->h+=dif;
        }
       //else
       if(c2.y>rc4->y)
        {
        rc4->h=(c2.y-rc4->y)+1;
        }

       }
      }
     }



    if(alpha&&in_r_edge==0)
     {
     pna.a=alpha;
     if(alpha==255)
      {
      surp->status.mem[off]=pna;
      }
     else
      {
      pnx=surp->status.mem[off];
      a1=(N)(255-alpha);
      a2=(N)(alpha);
      surp->status.mem[off].b=(B)(((a1*pnx.b)+(a2*pna.b))>>8);
      surp->status.mem[off].g=(B)(((a1*pnx.g)+(a2*pna.g))>>8);
      surp->status.mem[off].r=(B)(((a1*pnx.r)+(a2*pna.r))>>8);
      surp->status.mem[off].a=255;
      }
     }
    if(in_caret)
     {
     flag=0;
     if(cs==1)  {   if((hh-yy)<=3) { if(pnd.a!=0) surp->status.mem[off]=pnd; flag=1; }}
     else
     if(cs==2)  {   if((xx<=2)   ) { if(pnd.a!=0) surp->status.mem[off]=pnd; flag=1; }}
     else
     if(cs==3)  {   if((xx<=ww)  ) { if(pnd.a!=0) surp->status.mem[off]=pnd; flag=1; }}
     else
     if(cs==4)
      {
      if((xx<=ww)  )
       {
       pnx=surp->status.mem[off];
       a1=(N)(255-pne.a);
       a2=(N)(pne.a);
       if(pne.a!=0)
        {
        surp->status.mem[off].b=(B)(((a1*pnx.b)+(a2*pne.b))>>8);
        surp->status.mem[off].g=(B)(((a1*pnx.g)+(a2*pne.g))>>8);
        surp->status.mem[off].r=(B)(((a1*pnx.r)+(a2*pne.r))>>8);
        surp->status.mem[off].a=255;
        }
       flag=1;
       }
      }
     if(rc3)
      {
      if(flag)
       {
       if(rc3->w==0) { rc3->x=c2.x; rc3->y=c2.y; rc3->w=rc3->h=1; }
       if(c2.x>rc3->x) { rc3->w=(c2.x-rc3->x)+1; }
       if(c2.y>rc3->y) { rc3->h=(c2.y-rc3->y)+1; }
       }
      }
     }
    c2.x++;
    }
   c2.y++;
   }
  cord.x+=fx[fxi].rect.w;
  }
 if(visible) { *visible=vis; }
 //aaDebugf("%i,%i",rc3->x,rc3->w);
 return RET_YES;
 }









/*

 V appMain                             (V)
 {
 _gui gui;
 B etc[_3K];
 N slf,slt;
 H i,t,chars,fff;
 B cs;
 _rect r1,r2,r3;
 _textreader tr;

 while(!app.is_exiting)
  {
  if(appYield()!=YES)       { app.is_exiting=YES; }
  if(app.is_exit)           { app.is_exiting=YES; }
  switch(aa_stage)
   {
   case 0:
   guiNew(&gui,0);
   if(aaTextReaderOpen(&tr,"aa.h",0,0xffffffff)!=YES) oof;
   fff=0;
   cs=0;
   aaSurfaceUpdate(gui.surface.handle);
    aaSurfaceStatus(gui.surface.handle,&gui.surface.status);
   aaStageSet(10);
   break;


   case 10:
    i=0;
    t=30;
    while(1)
     {
     slf=slt=-1;
     aaTextReaderLineGet(&tr,fff+i,&chars,etc);
     if((fff+i)>=3  &&(fff+i)<=3)     { slf=3; slt=-1; }
     if((fff+i)>=4  &&(fff+i)<=123)   { slf=0; slt=-1; }
     if((fff+i)>=124&&(fff+i)<=124)   { slf=0; slt=-1; }
     aaSurfaceEditorPaint(gui.surface.handle,i,&col_pastelblue[16],&col_gray[31],&col_red[17],&col_cyan[31],gui.font[0].handle,slf,slt,(i==3&&cs==1)?2:-1,3,&r1,&r2,&r3,"%s",etc);
     //aaSurfaceEditorPaint(gui.surface.handle,i,0,0,0,0,font_16x32,slf,slt,(i==3)?2:-1,-1,&r1,&r2,&r3,"%s",etc);
     //aaSurfaceUpdateAreaAdd(gui.surface.handle,&r1,0);
     if(r3.w!=0)
      {
      //aaDebugf("%i,%i,%i,%i,%i",i,aaRectParts(r3));
      aaSurfaceFill(gui.surface.handle,&r3,&col_green[31]);
      //aaSurfaceUpdateAreaAdd(gui.surface.handle,&r31,0);
      }
      aaSurfaceUpdateAreaAdd(gui.surface.handle,&r1,0);
     i++;
     if(i>=t) break;
     }
    aaSurfaceStatus(gui.surface.handle,&gui.surface.status);
   if(gui.surface.status.update_area.state)
    {
    aaSurfaceUpdate(gui.surface.handle);
    aaSurfaceStatus(gui.surface.handle,&gui.surface.status);
    }
   aaStageSet(20);
   break;

   case 20:
   if(appPulseUsr(2,1,200)!=YES) break;
   if(cs==0) { cs=1; }
   else      { cs=0; }
   //aaSleep(420);
   aaStageSet(10);
   break;
   }
  }

 guiDelete(&gui);
 }



 V appMain                             (V)
 {
 _gui gui;
 B etc[_3K];
 N slf,slt;
 H i,t,chars,fff;
 B cs;
 _textreader tr;

 while(!app.is_exiting)
  {
  if(appYield()!=YES)       { app.is_exiting=YES; }
  if(app.is_exit)           { app.is_exiting=YES; }
  switch(aa_stage)
   {
   case 0:
   guiNew(&gui,0);
   if(aaTextReaderOpen(&tr,"aa.h",0,0xffffffff)!=YES) oof;
   fff=0;
   cs=0;
   aaStageSet(10);
   break;


   case 10:
    i=0;
    t=30;
    while(1)
     {
     slf=slt=-1;
     aaTextReaderLineGet(&tr,fff+i,&chars,etc);
     if((fff+i)>=3  &&(fff+i)<=3)     { slf=3; slt=-1; }
     if((fff+i)>=4  &&(fff+i)<=123)   { slf=0; slt=-1; }
     if((fff+i)>=124&&(fff+i)<=124)   { slf=0; slt=-1; }
     aaSurfaceEditorPaint(gui.surface.handle,i,&col_pastelblue[16],&col_gray[31],&col_red[17],&col_cyan[31],gui.font[0].handle,slf,slt,-1,1,"%s",etc);
     i++;
     if(i>=t) break;
     }
    aaSurfaceStatus(gui.surface.handle,&gui.surface.status);
   if(gui.surface.status.update_area.state)
    {
    aaSurfaceUpdate(gui.surface.handle);
    aaSurfaceStatus(gui.surface.handle,&gui.surface.status);
    }
   aaStageSet(20);
   break;

   case 20:
   if(cs==0) { cs=1; }
   else      { cs=0; }
   aaDebugf("%i",cs);
   aaSleep(100);
   aaStageSet(10);
   break;
   }
  }

 guiDelete(&gui);
 }

*/




 B aaSurfaceRectSave                   (H handle,_rect*rect)
 {
 B ret;
 H pix;
 _cord c1;
 _size s1;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(rect==NULL) { return RET_MISSINGPARM; }
 if((N)rect->w<=0) { return RET_BOUNDS; }
 if((N)rect->h<=0) { return RET_BOUNDS; }
 pix=rect->w*rect->h*4;
 if(pix>_4K) { return RET_BOUNDS; }
 aaCordSet(&c1,0,0);
 aaSizeSet(&s1,rect->w,rect->h);
 if(aaSurfaceImageGrab(handle,rect,&c1,&s1,surp->save_buf)!=YES) oof;
 aaRectCopy(&surp->save_rect,rect);
 return RET_YES;
 }



 B aaSurfaceRectUndo                   (H handle,_rect*rect)
 {
 B ret;
 _size s1;
 _rect r1,r2;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(rect) { aaRectCopy(rect,&surp->save_rect); }
 if(surp->save_rect.w==0) { return RET_NOTREADY; }
 aaSizeSet(&s1,surp->save_rect.w,surp->save_rect.h);
 aaRectSet(&r1,0,0,s1.w,s1.h);
 aaRectCopy(&r2,&surp->save_rect);
 aaSurfaceImageDraw(handle,&s1,&r1,surp->save_buf,&r2,0,0,0);
 surp->save_rect.w=0;
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/

//https://github.com/NickMinYang/rgb2yuv/blob/master/sdk/src/rgb2yuv.c



 B aaImageYuv420ToBgra                 (_size*size,Z ystride,Z uvstride,VP yplane,VP uplane,VP vplane,VP dest)
 {
/// register Q yt;
 register N r,g,b,u,v;
 register N b_u,g_uv,r_v,rgb_y;
 register BP dst,dst2;
 register BP ysrc,ysrc2;
 register BP usrc,vsrc;
 register N x,y;
 Z wid,hit,dst_stride;
 Z y_stride,uv_stride;
 H dst_dif;
 N y_dif;
 //register N x,y;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aa.surface_system.yuva_tables_init!=YES)
  {
  aa_SurfaceSystemYuvTablesInit();
  }
 wid=size->w;
 hit=size->h;
 //aaMemoryFill(dest,wid*hit*4,255);

 dst_stride=wid;
 y_stride=ystride;
 uv_stride=uvstride;
 dst=(BP)dest;
 ysrc=(BP)yplane;
 usrc=(BP)uplane;
 vsrc=(BP)vplane;
 dst_dif=8*dst_stride-4*wid;
 y_dif=2*y_stride-wid;
 dst2=dst+4*dst_stride;
 ysrc2=ysrc+y_stride;
 if(hit<0)
  {
  hit=-hit;
  ysrc+=(hit-1)*y_stride;
  ysrc2=ysrc-y_stride;
  usrc+=(hit/2-1)*uv_stride;
  vsrc+=(hit/2-1)*uv_stride;
  y_dif=-wid-2*y_stride;
  uv_stride=-uv_stride;
  }
 hit/=2;
 wid/=2;
 for(y=hit;y;y--)
  {
  for(x=0;x<wid;x++)
   {
   u=usrc[x];
   v=vsrc[x];
   b_u=aa.surface_system.B_U_tab[u];
   g_uv=aa.surface_system.G_U_tab[u]+aa.surface_system.G_V_tab[v];
   r_v=aa.surface_system.R_V_tab[v];
   ///yt=*(QP)&aa.surface_system.RGB_Y_tab[*ysrc];
   ///rgb_y=(yt>>32);

   rgb_y=aa.surface_system.RGB_Y_tab[*ysrc];
   b=(rgb_y+b_u)>>SCALEBITS_OUT;
   g=(rgb_y-g_uv)>>SCALEBITS_OUT;
   r=(rgb_y+r_v)>>SCALEBITS_OUT;
   dst[0]=aaNumClamp(b,0,255);   dst[1]=aaNumClamp(g,0,255);   dst[2]=aaNumClamp(r,0,255); dst[3]=255;
   //dst[0]=b;   dst[1]=g;   dst[2]=r;   dst[3]=255;
   ysrc++;
   ///rgb_y=(yt&0xffffffff);
   rgb_y=aa.surface_system.RGB_Y_tab[*ysrc];
   b=(rgb_y+b_u)>>SCALEBITS_OUT;
   g=(rgb_y-g_uv)>>SCALEBITS_OUT;
   r=(rgb_y+r_v)>>SCALEBITS_OUT;
   dst[4]=aaNumClamp(b,0,255);   dst[5]=aaNumClamp(g,0,255);   dst[6]=aaNumClamp(r,0,255); dst[7]=255;
   //dst[4]=b;   dst[5]=g;   dst[6]=r;   dst[7]=255;
   ysrc++;
   //ysrc+=2;

   ///yt=*(QP)&aa.surface_system.RGB_Y_tab[*ysrc2];
   //rgb_y=(yt>>32);
   rgb_y=aa.surface_system.RGB_Y_tab[*ysrc2];
   b=(rgb_y+b_u)>>SCALEBITS_OUT;
   g=(rgb_y-g_uv)>>SCALEBITS_OUT;
   r=(rgb_y+r_v)>>SCALEBITS_OUT;
   dst2[0]=aaNumClamp(b,0,255);   dst2[1]=aaNumClamp(g,0,255);   dst2[2]=aaNumClamp(r,0,255); dst2[3]=255;
   //dst2[0]=b;   dst2[1]=g;   dst2[2]=r;   dst2[3]=255;
   ysrc2++;
   rgb_y=aa.surface_system.RGB_Y_tab[*ysrc2];
   //rgb_y=(yt&0xffffffff);
   b=(rgb_y+b_u)>>SCALEBITS_OUT;
   g=(rgb_y-g_uv)>>SCALEBITS_OUT;
   r=(rgb_y+r_v)>>SCALEBITS_OUT;
   dst2[4]=aaNumClamp(b,0,255);   dst2[5]=aaNumClamp(g,0,255);   dst2[6]=aaNumClamp(r,0,255); dst2[7]=255;
   //dst2[4]=b;   dst2[5]=g;   dst2[6]=r;  dst2[7]=255;
   //ysrc2+=2;
   ysrc2++;
   dst+=8;
   dst2+=8;
   }
  dst+=dst_dif;
  dst2+=dst_dif;
  ysrc+=y_dif;
  ysrc2+=y_dif;
  usrc+=uv_stride;
  vsrc+=uv_stride;
  }
 return RET_YES;
 }




 B aaImageBgraToYuv420                 (_size*size,Z ystride,Z uvstride,VP yplane,VP uplane,VP vplane,VP srce)
 {
 register Y y,u,v;
 register Y r,g,b;
 register Z _x,_y;
 BP pY,pU,pV;
 BP rgb_data;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 rgb_data=srce;
 pY=yplane;
 pU=uplane;
 pV=vplane;
 for(_y=0;_y<(Z)size->h;_y++)
  {
  for(_x=0;_x<(Z)size->w;_x+=2)
   {
   b=*rgb_data++;
   g=*rgb_data++;
   r=*rgb_data++;
   rgb_data++;
   y=((YV_RY*r+YV_GY*g+YV_BY*b)>>RGB2YUV_SHIFT)+16;
   pY[_x]=y;
   if(_y&1)
    {
    v=((YV_RV*r+YV_GV*g+YV_BV*b)>>RGB2YUV_SHIFT)+128;
    u=((YV_RU*r+YV_GU*g+YV_BU*b)>>RGB2YUV_SHIFT)+128;
    pU[_x>>1]=u;
    pV[_x>>1]=v;
    }
   b=*rgb_data++;
   g=*rgb_data++;
   r=*rgb_data++;
   rgb_data++;
   y=((YV_RY*r+YV_GY*g+YV_BY*b)>>RGB2YUV_SHIFT)+16;
   pY[_x+1]=y;
   }
  pY+=ystride;
  if(_y&1) continue;
  pU+=uvstride;
  pV+=uvstride;
  }
 return RET_YES;
 }




 B aaImageBgraToYuv422                 (_size*size,Z ystride,Z uvstride,VP yplane,VP uplane,VP vplane,VP srce)
 {
 register Y y,u,v;
 register Y r,g,b;
 register Z _x,_y;
 BP pY,pU,pV;
 BP rgb_data;
 Z ypos,upos,vpos;

 UNUSE(ystride);
 UNUSE(uvstride);

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 rgb_data=srce;
 pY=yplane;
 pU=uplane;
 pV=vplane;
 ypos=upos=vpos=0;

 for(_y=0;_y<(Z)size->h;_y++)
  {
  for(_x=0;_x<(Z)size->w;_x++)
   {
   b=*rgb_data++;
   g=*rgb_data++;
   r=*rgb_data++;
   rgb_data++;
   y=((YV_RY*r+YV_GY*g+YV_BY*b)>>RGB2YUV_SHIFT)+16;
   pY[ypos++]=y;
   if(_x&1)
    {
    v=((YV_RV*r+YV_GV*g+YV_BV*b)>>RGB2YUV_SHIFT)+128;
    u=((YV_RU*r+YV_GU*g+YV_BU*b)>>RGB2YUV_SHIFT)+128;
    pU[upos++]=u;
    pV[vpos++]=v;
    }
   }
  }
 return RET_YES;
 }




 B aaImageYuv422ToBgra                 (_size*size,Z ystride,Z uvstride,VP yplane,VP uplane,VP vplane,VP dest)
 {
 N u,v;
 N b_u,g_uv,r_v,rgb_y;
 register N r,g,b;
 Z wid,hit,dst_stride;
 Z y_stride,uv_stride;
 register N x,y;
 H dst_dif;
 register BP dst;
 register BP ysrc,usrc,vsrc;
 register N y_dif;
 register BP dst2;
 register BP ysrc2;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aa.surface_system.yuva_tables_init!=YES)
  {
  aa_SurfaceSystemYuvTablesInit();
  }
 wid=size->w;
 hit=size->h;

 dst_stride=wid;
   y_stride=ystride;
  uv_stride=uvstride;

 dst=(BP)dest;
 ysrc=(BP)yplane;
 usrc=(BP)uplane;
 vsrc=(BP)vplane;

 dst_dif=8*dst_stride-4*wid;
   y_dif=2*y_stride-wid;
  dst2=dst+4*dst_stride;
 ysrc2=ysrc+y_stride;

 if(hit<0)
  {
  hit=-hit;
  ysrc+=(hit-1)*y_stride;
  ysrc2=ysrc-y_stride;
  usrc+=(hit/2-1)*uv_stride;
  vsrc+=(hit/2-1)*uv_stride;
  y_dif=-wid-2*y_stride;
  uv_stride=-uv_stride;
  }
 for(y=hit/2;y;y--)
  {
  for(x=0;x<wid/2;x++)
   {
   u=usrc[x];
   v=vsrc[x];
   b_u=aa.surface_system.B_U_tab[u];
   g_uv=aa.surface_system.G_U_tab[u]+aa.surface_system.G_V_tab[v];
   r_v=aa.surface_system.R_V_tab[v];
   rgb_y=aa.surface_system.RGB_Y_tab[*ysrc];
   b=(rgb_y+b_u)>>SCALEBITS_OUT;
   g=(rgb_y-g_uv)>>SCALEBITS_OUT;
   r=(rgb_y+r_v)>>SCALEBITS_OUT;
   b=aaNumClamp(b,0,255);   g=aaNumClamp(g,0,255);   r=aaNumClamp(r,0,255);
   dst[0]=b;   dst[1]=g;   dst[2]=r;   dst[3]=255;
   ysrc++;
   rgb_y=aa.surface_system.RGB_Y_tab[*ysrc];
   b=(rgb_y+b_u)>>SCALEBITS_OUT;
   g=(rgb_y-g_uv)>>SCALEBITS_OUT;
   r=(rgb_y+r_v)>>SCALEBITS_OUT;
   b=aaNumClamp(b,0,255);   g=aaNumClamp(g,0,255);   r=aaNumClamp(r,0,255);
   dst[4]=b;   dst[5]=g;   dst[6]=r;   dst[7]=255;
   ysrc++;
   rgb_y=aa.surface_system.RGB_Y_tab[*ysrc2];
   b=(rgb_y+b_u)>>SCALEBITS_OUT;
   g=(rgb_y-g_uv)>>SCALEBITS_OUT;
   r=(rgb_y+r_v)>>SCALEBITS_OUT;
   b=aaNumClamp(b,0,255);   g=aaNumClamp(g,0,255);   r=aaNumClamp(r,0,255);
   dst2[0]=b;   dst2[1]=g;   dst2[2]=r;   dst2[3]=255;
   ysrc2++;
   rgb_y=aa.surface_system.RGB_Y_tab[*ysrc2];
   b=(rgb_y+b_u)>>SCALEBITS_OUT;
   g=(rgb_y-g_uv)>>SCALEBITS_OUT;
   r=(rgb_y+r_v)>>SCALEBITS_OUT;
   b=aaNumClamp(b,0,255);   g=aaNumClamp(g,0,255);   r=aaNumClamp(r,0,255);
   dst2[4]=b;   dst2[5]=g;   dst2[6]=r;  dst2[7]=255;
   ysrc2++;
   dst+=8;
   dst2+=8;
   }
  dst+=dst_dif;
  dst2+=dst_dif;
  ysrc+=y_dif;
  ysrc2+=y_dif;
  usrc+=uv_stride;
  vsrc+=uv_stride;
  }
 return RET_YES;
 }




 B aaImageRgbaRemoveKey                (_size*size,VP srce,_rgba*key,D thresh)
 {
 register H xx,yy;
 H off;
 _rgba*p2;
 D dis;
 N r,g,b,rmean;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(size==NULL) { return RET_BADPARM; }
 if(srce==NULL) { return RET_BADPARM; }
 if(key==NULL) { return RET_BADPARM; }
 //if(thresh<0) { thresh=0.0; }
 if(thresh==0.0)
  {
  for(yy=0;yy<size->h;yy++)
   {
   for(xx=0;xx<size->w;xx++)
    {
    off=(yy*size->w)+xx;
    p2=(_rgba*)srce;
    p2+=off;
    if(p2->a==0) { continue; }
    if(p2->r!=key->r) { continue; }
    if(p2->g!=key->g) { continue; }
    if(p2->b!=key->b) { continue; }
    p2->a=0;
    }
   }
  }
 else
  {
  for(yy=0;yy<size->h;yy++)
   {
   off=(yy*size->w)+0;
   p2=(_rgba*)srce;
   p2+=off;
   for(xx=0;xx<size->w;xx++)
    {
    if(p2->a!=0)
     {
     rmean=(p2->r+key->r)/2;
     r=(N)p2->r-(N)key->r;
     g=(N)p2->g-(N)key->g;
     b=(N)p2->b-(N)key->b;
     dis=sqrt((((512+rmean)*r*r)>>8)+4*g*g+(((767-rmean)*b*b)>>8));
     dis=dis/764.0;
     dis=dis*100.0;
     if(dis>100.0) { dis=100.0; }
     if(thresh>0&&dis<=thresh)  {  p2->a=0; }
     else
     if(thresh<0&&dis>=-thresh) {  p2->a=0; }
     }
    //off++;
    p2++;
    }
   }
  }
 return RET_YES;
 }



 B aaImageBgraToJpeg                   (_size*size,VP img,B quality,HP bytes,VP data)
 {
 B ret;
 _jpegctx jpegctx;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_JpegNew(&jpegctx))!=YES) { oops; }
 if((ret=aa_JpegCompress(&jpegctx,quality,size->w,size->h,img))!=YES) { oops; }
 if(bytes) { *bytes=(H)jpegctx.out_len; }
 if(data!=NULL) { aaMemoryCopy(data,(H)jpegctx.out_len,jpegctx.out.mem); }
 if((ret=aa_JpegDelete(&jpegctx))!=YES) { oops; }
 return RET_YES;
 }





 B aaImageJpegToBgra                   (H bytes,VP data,_size*size,VP img)
 {
 B ret;
 _jpegdecctx jpg;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aa_JpegDecNew(&jpg,img);
 if((ret=aa_JpegDecDecompress(&jpg,data,(H)bytes))!=YES) { oops; }
 size->w=jpg.width;
 size->h=jpg.height;
 if(jpg.user_supplied_rgb==NULL)
  {
  aaMemoryCopy(img,size->w*size->h*4,jpg.rgb);
  }
 aa_JpegDecDelete(&jpg);
 return RET_YES;
 }




 /*
 make sur dimgsize is bigger than imgsize

 when you create dimg

 diag=sqrt((imgsize->w*imgsize->w)+(imgsize->h*imgsize->h));
 dimg->w=imgsize->w+(diag-imgsize->w);
 dimg->h=imgsize->h+(diag-imgsize->h);
 */


 B aaImageRotate                       (_size*imgsize,VP img,_size*dimgsize,VP dimg,D angle)
 {
 _cord c1,c2;
 _rgba p1;
 D qmidX,qmidY;
 D qdeltaX,qdeltaY,qangle;
 N qrotX,qrotY;
 N qi,qj,diag;
 N xdd,ydd;
 _rgba*sm;
 _rgba*dm;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(imgsize==NULL) { return RET_MISSINGPARM; }
 if(imgsize->w==0) { return RET_BADPARM; }
 if(imgsize->h==0) { return RET_BADPARM; }
 if(dimgsize==NULL) { return RET_MISSINGPARM; }
 if(dimgsize->w==0) { return RET_BADPARM; }
 if(dimgsize->h==0) { return RET_BADPARM; }
 if(img==NULL)  { return RET_MISSINGPARM; }
 if(dimg==NULL) { return RET_MISSINGPARM; }
 angle=aaMathDegreesToRadians(angle);
 qangle=angle;
 qmidX=imgsize->w/2.0f;
 qmidY=imgsize->h/2.0f;
 diag=(N)(ceil(sqrt((D)(imgsize->w*imgsize->w+imgsize->h*imgsize->h))))+0;
 xdd=(diag-imgsize->w);
 ydd=(diag-imgsize->h);
 xdd=dimgsize->w-imgsize->w;
 ydd=dimgsize->h-imgsize->h;
 sm=(_rgba*)img;
 dm=(_rgba*)dimg;
 for(qi=0;qi<(N)imgsize->h+ydd;qi++)
  {
  for(qj=0;qj<(N)imgsize->w+xdd;qj++)
   {
   qdeltaX=(qj-qmidX)-(xdd/2);
   qdeltaY=(qi-qmidY)-(ydd/2);
   //qrotX=(N)(qmidX+qdeltaX*sin(qangle)+qdeltaY*cos(qangle));
   //qrotY=(N)(qmidY+qdeltaX*cos(qangle)-qdeltaY*sin(qangle));
   qrotX=(N)(qmidX+qdeltaX*cos(qangle)-qdeltaY*sin(qangle));
   qrotY=(N)(qmidY+qdeltaX*sin(qangle)+qdeltaY*cos(qangle));

   c1.x=qrotX;   c1.y=qrotY;
   c2.x=qj;      c2.y=qi;
   if((c2.y>=0&&c2.y<(N)dimgsize->h)&&(c2.x>=0&&c2.x<(N)dimgsize->w))
    {
    dm[(c2.y*dimgsize->w)+c2.x]=col_null;
    }
   if((c1.x>=0&&c1.x<(N)imgsize->w)&&(c1.y>=0&&c1.y<(N)imgsize->h))
    {
    p1=sm[(c1.y*imgsize->w)+c1.x];
    dm[(c2.y*dimgsize->w)+c2.x]=p1;
    }
   }
  }
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/



 B aa_PathPixelProc                    (VP handle,N x,N y,_rgba*pn)
 {
 B ret;
 _aa_surfaceobject*surp;
 _path*path_ptr;
 H have;

 if(pn) {}
 aaCast(surp,_aa_surfaceobject*,handle);
 if(surp->status.cur_path==NULL) { return RET_NOTINITIALIZED; }
 path_ptr=surp->status.cur_path;
 if(path_ptr->magic!=aaHPP(aaPathNew))   { return RET_NOTINITIALIZED; }
 have=path_ptr->slots-path_ptr->count;
 if(have<10) {  if((ret=aa_PathExtend(path_ptr,20))!=YES) { oops; return ret; } }
 aaCordSet(&path_ptr->cord[path_ptr->count],x,y);
 path_ptr->count++;
 return RET_YES;
 }




 B aa_PathExtend                       (_path*path,H need)
 {
 B ret;
 H have,add;

 if(path==NULL)  { return RET_MISSINGPARM; }
 if(path->magic!=aaHPP(aaPathNew)) { return RET_NOTINITIALIZED; }
 have=path->slots-path->count;
 if((need+100)>=have)
  {
  add=path->slots+need+200+(path->slots/10);
  if(path->slots==0) { ret=aaMemoryAllocate((VP)&path->cord,add*sizeof(_cord));    }
  else               { ret=aaMemoryReAllocate((VP)&path->cord,add*sizeof(_cord));  }
  if(ret!=YES) { oops; }
  path->slots=add;
  }
 return RET_YES;
 }



 B aaPathNew                           (_path*path)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(path==NULL)  { return RET_MISSINGPARM; }
 aaMemoryFill(path,sizeof(_path),0);
 path->magic=aaHPP(aaPathNew);
 return RET_YES;
 }




 B aaPathDelete                        (_path*path)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(path==NULL)  { return RET_MISSINGPARM; }
 if(path->magic!=aaHPP(aaPathNew)) { return RET_NOTINITIALIZED; }
 if(path->slots!=0)   {   aaMemoryRelease(path->cord);  }
 aaMemoryFill(path,sizeof(_path),0);
 return RET_YES;
 }




 B aaPathReset                         (_path*path)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(path==NULL)  { return RET_MISSINGPARM; }
 if(path->magic!=aaHPP(aaPathNew)) { return RET_NOTINITIALIZED; }
 path->count=0;
 return RET_YES;
 }



 B aaPathCopy                          (_path*path,_path*spath)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(path==NULL)  { return RET_MISSINGPARM; }
 if(path->magic!=aaHPP(aaPathNew)) { return RET_NOTINITIALIZED; }
 if(spath==NULL) { return RET_MISSINGPARM; }
 return RET_YES;
 }




 B aaPathBegin                         (_path*path,H surfacehandle)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(path==NULL)  { return RET_MISSINGPARM; }
 if(path->magic!=aaHPP(aaPathNew)) { return RET_NOTINITIALIZED; }
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,surfacehandle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 surp->status.cur_path=path;
 path->surface_handle=surfacehandle;
 aaSurfacePixelPutProcSet(path->surface_handle,aa_PathPixelProc);
 return RET_YES;
 }




 B aaPathFinish                        (_path*path)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(path==NULL)  { return RET_MISSINGPARM; }
 if(path->magic!=aaHPP(aaPathNew)) { return RET_NOTINITIALIZED; }
 if(path->surface_handle==0)       { return RET_FAILED; }
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,path->surface_handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 surp->status.cur_path=NULL;
 aaSurfacePixelPutProcSet(path->surface_handle,NULL);
 path->surface_handle=0;
 return RET_YES;
 }





/*-----------------------------------------------------------------------*/



 B aaCursorSet                         (B id)
 {
 //HWND hWnd;
 //H fid,cid;
 HCURSOR cursor_handle;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(id==aa.cursor_system.cursor_id)  {  return RET_YES;  }
 switch(id)
  {
  case aa_CURSOR_None:       cursor_handle=NULL;                             break;
  case aa_CURSOR_Arrow:      cursor_handle=LoadCursor(NULL,IDC_ARROW);       break;
  case aa_CURSOR_HourGlass:  cursor_handle=LoadCursor(NULL,IDC_WAIT);        break;
  case aa_CURSOR_Resize:     cursor_handle=LoadCursor(NULL,IDC_SIZEALL);     break;
  case aa_CURSOR_ResizeV:    cursor_handle=LoadCursor(NULL,IDC_SIZENS);      break;
  case aa_CURSOR_ResizeH:    cursor_handle=LoadCursor(NULL,IDC_SIZEWE);      break;
  case aa_CURSOR_ResizeB:    cursor_handle=LoadCursor(NULL,IDC_SIZENWSE);    break;
  case aa_CURSOR_ResizeF:    cursor_handle=LoadCursor(NULL,IDC_SIZENESW);    break;
  case aa_CURSOR_Move:       cursor_handle=LoadCursor(NULL,IDC_CROSS);       break;
  case aa_CURSOR_Beam:       cursor_handle=LoadCursor(NULL,IDC_IBEAM);       break;
  case aa_CURSOR_Hand:       cursor_handle=aa.cursor_system.hand_cursor_handle; break;
  case aa_CURSOR_Help:       cursor_handle=LoadCursor(NULL,IDC_HELP);         break;
  case aa_CURSOR_TimeGlass:  cursor_handle=LoadCursor(NULL,IDC_APPSTARTING);  break;
  case aa_CURSOR_SlashRound: cursor_handle=LoadCursor(NULL,IDC_NO);           break;
  case aa_CURSOR_ArrowUp:    cursor_handle=LoadCursor(NULL,IDC_UPARROW);      break;

  default:
  return RET_BADPARM;
  }
 aa.cursor_system.current_cursor_handle=cursor_handle;
 aa.cursor_system.cursor_id=id;
 #if 0
 hWnd=GetForegroundWindow();
 fid=GetWindowThreadProcessId(hWnd,0);
 cid=GetCurrentThreadId();
 AttachThreadInput(fid,cid,TRUE);
 SetCursor(aa.cursor_system.current_cursor_handle);
 AttachThreadInput(fid,cid,FALSE);
#endif
 SetCursor(cursor_handle);
 return RET_YES;
 }




 B aaCursorGet                         (BP id)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(id==NULL) { return RET_BADPARM; }
 *id=aa.cursor_system.cursor_id;
 return RET_YES;
 }





 B aaCursorSimulate                    (B flag,N x,N y,H wid,H hit,N etc,H del)
 {
 H flags;
 S H last_wid=0;
 S H last_hit=0;
 N xx,yy;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(wid!=0) { last_wid=wid; }
 if(hit!=0) { last_hit=hit; }
 if(last_wid==0) { oof; return RET_FAILED; }
 if(last_hit==0) { oof; return RET_FAILED; }
 wid=last_wid;
 hit=last_hit;
 flags=0;
 if(aaBitGet(flag,0)) {  flags|=MOUSEEVENTF_ABSOLUTE; }
 if(aaBitGet(flag,1)) {  flags|=MOUSEEVENTF_MOVE; }
 if(aaBitGet(flag,2)) {  flags|=MOUSEEVENTF_LEFTDOWN; }
 if(aaBitGet(flag,3)) {  flags|=MOUSEEVENTF_LEFTUP; }
 if(aaBitGet(flag,4)) {  flags|=MOUSEEVENTF_RIGHTDOWN; }
 if(aaBitGet(flag,5)) {  flags|=MOUSEEVENTF_RIGHTUP; }
 if(aaBitGet(flag,6)) {  flags|=MOUSEEVENTF_WHEEL; }

 xx=(N)(65536.0/wid*x-1);
 yy=(N)(65536.0/hit*y-1);
 mouse_event(flags,xx,yy,etc,0);
 if(del) { aaSleep(del); }
 return RET_YES;
 }

/*-----------------------------------------------------------------------*/

 //V appLabel                            (N x,N y,N w,N h,H fidx,VP fmt,...);
 //PUB _zap zap;







 B aa_TextboxPaint                     (_textbox*textbox)
 {
 N cdif,tdif;
 N sf,st,tmp;
 H i;
 _rgba pen[4];

 aaMissingParm(textbox);
 if(textbox->magic!=aaHPP(aaTextboxInit)) { return RET_NOTINITIALIZED; }
 if(textbox->needs_paint!=YES) { return RET_YES; }
redo:
 sf=st=-1;
 if(textbox->is_select==YES)
  {
  sf=textbox->select_from;
  st=textbox->select_till;
  if(sf>st) { tmp=st; st=sf; sf=tmp; }
  if(st>=(N)textbox->str.len) { st=(N)textbox->str.len-1; }
  textbox->select_from=sf;
  textbox->select_till=st;
  }

 for(i=0;i<4;i++) { aaRgbaCopy(&pen[i],&textbox->pen[i]); }
 if(textbox->is_focused==NO)
  {
  for(i=0;i<4;i++) { pen[i].r*=0.6; pen[i].g*=0.6; pen[i].b*=0.6; }
  }
 aaSurfaceEditorPaint(textbox->surface.handle,
                       &textbox->rect,
                       -1,
                       &pen[0],
                       &pen[1],
                       &pen[2],
                       (textbox->is_focused)?(textbox->is_caret_on?&pen[3]:&col_null):&col_null,
                       textbox->font.handle,
                       sf,st,
                       textbox->caret_off,
                       textbox->caret_style,
                       &textbox->rr[0],
                       &textbox->rr[1],
                       &textbox->rr[2],
                       &textbox->rr[3],
                       &textbox->vis,
                       "%s",&textbox->str.buf[textbox->edge_off]);

 if(textbox->rr[2].h==0)  {  cdif=-1;  }
 else                     {  cdif=(textbox->rect.x+textbox->rect.w)-(textbox->rr[2].x+textbox->rr[2].w);  }
 if(textbox->rr[3].h==0)  {  tdif=-1;  }
 else                     {  tdif=(textbox->rect.x+textbox->rect.w)-(textbox->rr[3].x+textbox->rr[3].w);  }

 /*
 if(textbox->is_select==NO)  {  appLabel(20,100,zap.surface.status.rect.w-40,30,6,""); }
 else                        {  appLabel(20,100,zap.surface.status.rect.w-40,30,6,"sel_from=%i sel_till=%i sf=%i st=%i",textbox->select_from,textbox->select_till,sf,st); }
 appLabel(20,140,zap.surface.status.rect.w-40,30,6,"edge=%i caret=%i write=%i sl=%i",textbox->edge_off,textbox->caret_off,textbox->write_off,textbox->str.len);
 appLabel(20,180,zap.surface.status.rect.w-40,30,6,"vis=%i",textbox->vis);

 appLabel(20,220,zap.surface.status.rect.w-40,30,6,"main_rec=%i,%i",textbox->rect.x,textbox->rect.w);
 appLabel(20,260,zap.surface.status.rect.w-40,30,6,"caretrec=%i,%i",textbox->rr[2].x,textbox->rr[2].w);
 appLabel(20,300,zap.surface.status.rect.w-40,30,6,"text_rec=%i,%i",textbox->rr[3].x,textbox->rr[3].w);

 appLabel(20,340,zap.surface.status.rect.w-40,30,6,"cdif=%i",cdif);
 appLabel(20,380,zap.surface.status.rect.w-40,30,6,"tdif=%i",tdif);

 appLabel(20,440,zap.surface.status.rect.w-40,30,6,"[%s]",&textbox->str.buf[0]);
 appLabel(20,480,zap.surface.status.rect.w-40,30,6,"[%s]",&textbox->str.buf[textbox->edge_off]);
 //if(textbox->write_off==textbox->str.len&&cdif<(textbox->font.status.size.w*3))
 */

 if(tdif) {}
 if(cdif==-1||cdif<((N)textbox->font.status.size.w*1))
  {
  textbox->edge_off++;
  textbox->caret_off--;
  goto redo;
  }



 textbox->needs_paint=NO;
 aaSurfaceUpdateAreaAdd(textbox->surface.handle,&textbox->rect,NO);
 aaSurfaceStatus(textbox->surface.handle,&textbox->surface.status);

 return RET_YES;
 }




 B aaTextboxInit                       (_textbox*textbox,H surfacehandle,H fonthandle)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMissingParm(textbox);
 aaMemoryFill(textbox,sizeof(_textbox),0);
 textbox->magic=aaHPP(aaTextboxInit);
 if((ret=aaSurfaceStatus(surfacehandle,&textbox->surface.status))!=YES) { return ret; }
 textbox->surface.handle=surfacehandle;
 if((ret=aaFontStatus(fonthandle,&textbox->font.status))!=YES) { return ret; }
 textbox->font.handle=fonthandle;
 aaRectSet(&textbox->rect,50,textbox->surface.status.rect.h/2,textbox->surface.status.rect.w-100,textbox->font.status.size.h+4);
 textbox->rect.y-=(textbox->rect.h/2);
 textbox->needs_paint=YES;
 aaRgbaCopy(&textbox->pen[0],&col_pastelblue[12]);
 aaRgbaCopy(&textbox->pen[1],&col_gray[28]);
 aaRgbaCopy(&textbox->pen[2],&col_red[8]);
 aaRgbaCopy(&textbox->pen[3],&col_yellow[27]);
 textbox->is_insert=YES;
 textbox->is_caret_on=YES;
 textbox->caret_off=0;
 textbox->caret_style=2;
 textbox->write_off=0;
 textbox->is_focused=YES;
 textbox->tik=aaMsRunning();
 return RET_YES;
 }




 B aaTextboxRectSet                    (_textbox*textbox,_rect*rect)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMissingParm(textbox);
 if(textbox->magic!=aaHPP(aaTextboxInit)) { return RET_NOTINITIALIZED; }
 aaMissingParm(rect);
 if(rect->w==0) { return RET_BADPARM; }
 aaRectCopy(&textbox->rect,rect);
 if(textbox->rect.h==0) { textbox->rect.h=textbox->font.status.size.h+4; }
 textbox->needs_paint=YES;
 return RET_YES;
 }




 B aaTextboxReset                      (_textbox*textbox)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMissingParm(textbox);
 if(textbox->magic!=aaHPP(aaTextboxInit)) { return RET_NOTINITIALIZED; }
 textbox->needs_paint=YES;
 textbox->is_caret_on=YES;
 textbox->is_select=NO;
 textbox->is_enter=NO;
 textbox->is_tab=NO;
 textbox->is_shift_tab=NO;
 textbox->caret_off=0;
 textbox->write_off=0;
 textbox->edge_off=0;
 textbox->str.len=0;
 textbox->is_focused=YES;
 textbox->cycle++;
 aaStringNull(textbox->str.buf);
 return RET_YES;
 }




 B aaTextboxWritef                     (_textbox*textbox,VP fmt,...)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMissingParm(textbox);
 if(textbox->magic!=aaHPP(aaTextboxInit)) { return RET_NOTINITIALIZED; }
 aaVargsf4K(fmt);
 aaStringCopyf(textbox->str.buf,"%s",str4k.buf);
 aaStringLen(textbox->str.buf,&textbox->str.len);
 textbox->needs_paint=YES;
 return RET_YES;
 }




 B aaTextboxFocusSet                   (_textbox*textbox,B state)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMissingParm(textbox);
 if(textbox->magic!=aaHPP(aaTextboxInit)) { return RET_NOTINITIALIZED; }
 state&=1;
 if(textbox->is_focused==state) { return RET_YES; }
 textbox->is_focused=state;
 textbox->needs_paint=YES;
 return RET_YES;
 }





 B aaTextboxForcePaint                 (_textbox*textbox)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMissingParm(textbox);
 if(textbox->magic!=aaHPP(aaTextboxInit)) { return RET_NOTINITIALIZED; }
 textbox->needs_paint=YES;
 aa_TextboxPaint(textbox);
 return RET_YES;
 }





 B aaTextboxYield                      (_textbox*textbox,_inputengine*inputengine)
 {
 B flag;
 B ak,vk,is;
 B txt[_4K];
 H tl;
 _inputengine*ie;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 aaMissingParm(textbox);
 if(textbox->magic!=aaHPP(aaTextboxInit)) { return RET_NOTINITIALIZED; }
 aaMissingParm(inputengine);
 ie=(_inputengine*)inputengine;
 textbox->is_enter=NO;
 textbox->is_tab=NO;
 textbox->is_shift_tab=NO;
 //-----------------------------------------------------------------------
 flag=0;


 if(textbox->is_focused&&ie->is_ok&&(ie->event_byt[aa_IE_KeyUp])&&(ie->curr->focus_handle==textbox->surface.handle))
  {
  ak=ie->curr->akey;
  vk=ie->curr->vkey;
  is=ie->curr->is_shift;
  is=0;
  while(1)
   {
   if(!is) { textbox->is_select=NO; }
   if(vk==VK_RETURN)
    {
    textbox->is_enter=YES;
    break;
    }
   break;
   }
  }



 if(textbox->is_focused&&ie->is_ok&&(ie->event_byt[aa_IE_KeyDown]||ie->event_byt[aa_IE_KeyHeld])&&(ie->curr->focus_handle==textbox->surface.handle))
  {
  ak=ie->curr->akey;
  vk=ie->curr->vkey;
  is=ie->curr->is_shift;
  is=0;
  while(1)
   {
   if(!is) { textbox->is_select=NO; }
   if(vk=='V'&&ie->curr->is_ctrl)
    {
    if(aaClipBoardTextRead(YES,&tl,sizeof(txt),txt)==YES)
     {
     aaStringInsertStringf(textbox->str.buf,0,textbox->write_off,0,"%s",txt);
     textbox->caret_off+=tl;
     textbox->write_off+=tl;
     flag=1;
     }
    break;
    }
   if(vk=='X'&&ie->curr->is_ctrl)
    {
    if(textbox->str.len!=0)
     {
     aaStringNCopy(txt,textbox->str.buf,textbox->str.len,YES);
     aaClipBoardTextWritef(YES,"%s",txt);
     aaStringNull(textbox->str.buf);
     textbox->str.len=0;
     textbox->write_off=0;
     textbox->caret_off=0;
     textbox->edge_off=0;
     flag=1;
     }
    break;
    }
   if(vk=='C'&&ie->curr->is_ctrl)
    {
    if(textbox->str.len!=0)
     {
     aaStringNCopy(txt,textbox->str.buf,textbox->str.len,YES);
     aaClipBoardTextWritef(YES,"%s",txt);
     flag=1;
     }
    break;
    }
   if(ak>=SPACE_CHAR)

    {
    if(textbox->is_insert)
     {
     aaStringInsertChar(textbox->str.buf,0,textbox->write_off,ie->curr->akey);
     textbox->write_off++;
     textbox->caret_off++;
     }
    else
     {
     textbox->str.buf[textbox->write_off]=ie->curr->akey;
     textbox->write_off++;
     textbox->caret_off++;
     if(textbox->write_off>=(N)textbox->str.len) { textbox->str.buf[textbox->write_off]=NULL_CHAR; }
     }
    flag=1;
    break;
    }
   if(vk==VK_HOME)
    {
    if(textbox->caret_off!=0||textbox->edge_off!=0||textbox->write_off!=0)
     {
     if(is)
      {
      if(textbox->is_select==NO)
       {
       if(textbox->write_off>0)
        {
        textbox->is_select=YES;
        textbox->select_till=textbox->write_off-1;
        }
       }
      else
       {
       if(textbox->write_off>0)
        {
        textbox->is_select=YES;
        textbox->select_till=textbox->select_from-1;
        }
       }
      }
     textbox->caret_off=0;
     textbox->edge_off=0;
     textbox->write_off=0;
     if(textbox->is_select==YES)
      {
      textbox->select_from=textbox->write_off;
      }
     flag=1;
     }
    break;
    }
   if(vk==VK_END)
    {
    if(textbox->str.len>=1&&textbox->write_off!=(N)textbox->str.len)
     {
     if(is)
      {
      if(textbox->is_select==NO)
       {
       textbox->is_select=YES;
       textbox->select_from=textbox->write_off;
       }
      else
       {
       textbox->is_select=YES;
       textbox->select_from=textbox->select_till+1;

       }
      }
     textbox->write_off=textbox->str.len;
     textbox->caret_off=textbox->write_off-textbox->edge_off;
     if(textbox->is_select==YES)
      {
      textbox->select_till=textbox->write_off;
      }
     flag=1;
     }
    break;
    }
   if(vk==VK_LEFT)
    {
    if(textbox->caret_off!=0)
     {
     textbox->caret_off--;
     textbox->write_off--;
     flag=1;
     }
    else
     {
     if(textbox->edge_off!=0)
      {
      textbox->edge_off--;
      textbox->write_off--;
      flag=1;
      }
     }
    break;
    }
   if(vk==VK_RIGHT)
    {
    if(textbox->caret_off<((N)textbox->vis)&&textbox->write_off<(N)
    textbox->str.len)
     {
     textbox->write_off++;
     textbox->caret_off=textbox->write_off-textbox->edge_off;
     flag=1;
     }
    break;
    }
   if(vk==VK_DELETE)
    {
    if(textbox->str.len!=0)
     {
     aaStringDeleteChars(textbox->str.buf,textbox->str.len,textbox->write_off,1);
     flag=1;
     }
    break;
    }
   if(vk==VK_BACK)
    {
    if(textbox->str.len!=0)
     {
     if(textbox->caret_off!=0)
      {
      textbox->caret_off--;
      textbox->write_off--;
      aaStringDeleteChars(textbox->str.buf,textbox->str.len,textbox->write_off,1);
      }
     else
      {
      if(textbox->edge_off!=0)
       {
       textbox->edge_off--;
       textbox->write_off--;
       }
      }
     flag=1;
     }
    break;
    }
   if(vk==VK_INSERT)
    {
    textbox->is_insert^=1;
    flag=1;
    break;
    }
   ///if(vk==VK_RETURN)    {    textbox->is_enter=YES;    break;    }
   if(vk==VK_TAB)
    {
    if(ie->curr->is_shift) { textbox->is_shift_tab=YES; }
    else                   { textbox->is_tab=YES;       }
    break;
    }

   break;
   }
  }
 //---------------------------------------------------------------------


 if(flag)
  {
  if(textbox->is_insert) { textbox->caret_style=2; }
  else                   { textbox->caret_style=1; }
  aaStringLen(textbox->str.buf,&textbox->str.len);
  textbox->is_caret_on=YES;
  textbox->needs_paint=YES;
  textbox->tik=aa_msrunning;
  }


 aa_TextboxPaint(textbox);


 if((aa_msrunning-textbox->tik)>=200)
  {
  textbox->is_caret_on^=1;
  textbox->tik=aa_msrunning;
  textbox->needs_paint=YES;
  }

 return RET_YES;
 }






/*-----------------------------------------------------------------------*/








 B aaGifCreate                         (HP handle,VP filename)
 {
 B ret;
 _aa_gifobject*gifp;
 H file_handle,rem,td,of;
 B buf[_8K];
 N  BitsPerPixel,i;
 _filestreamstatus fs;
 H done,del;
 B record_type;
 BP extension;
 N extension_code,yy;
 N dif;
 H go;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCreate(aa.gif_system.object_id,handle,(VP)&gifp))!=RET_YES) { oops; return ret; }
 gifp->self_handle=*handle;
 if(filename==NULL) {  return RET_BADPARM; }
 if((ret=aaFileStreamCreate(&file_handle,filename,NO,3,3,0,NO))!=RET_YES)
  {
  aa_ObjectDestroy(aa.gif_system.object_id,*handle);
  return ret;
  }
 aaFileStreamStatus(file_handle,&fs);
 gifp->file_bytes=(Q)fs.bytes;
 if((ret=aa_MemoryAllocate((VP)&gifp->file_mem,gifp->file_bytes,"gifint",NO))!=RET_YES)
  {
  aaFileStreamDestroy(file_handle);
  aa_ObjectDestroy(aa.gif_system.object_id,*handle);
  return ret;
  }
 rem=gifp->file_bytes;
 of=0;
 while(1)
  {
  td=rem;
  if(td>_4K) td=_4K;
  if((ret=aaFileStreamRead(file_handle,td,&gifp->file_mem[of]))!=RET_YES)
   {
   aa_ObjectDestroy(aa.gif_system.object_id,*handle);
   aaFileStreamDestroy(file_handle);
   if((ret=aa_MemoryRelease(gifp->file_mem))!=YES) { oops; }
   return ret;
   }
  of+=td;
  rem-=td;
  if(rem==0) break;
  }


 aaFileStreamDestroy(file_handle);
 if(aa_GifSystemReadBytes((PP)&gifp,6,buf)!=RET_YES)
  {
  aa_ObjectDestroy(aa.gif_system.object_id,*handle);
  if((ret=aa_MemoryRelease(gifp->file_mem))!=YES) { oops; }
  return RET_FAILED;
  }
 ret=aaStringNCompare("GIF",buf,3,&dif);
 if(ret!=RET_YES||dif!=0)
  {
  aa_ObjectDestroy(aa.gif_system.object_id,*handle);
  if((ret=aa_MemoryRelease(gifp->file_mem))!=YES) { oops; }
  return RET_FAILED;
  }
 ret=aaStringNCompare("87a",&buf[3],3,&dif);
 if(ret==RET_YES&&dif==0) { gifp->version=0x87a; }
 else
  {
  ret=aaStringNCompare("89a",&buf[3],3,&dif);
  if(ret==RET_YES&&dif==0) { gifp->version=0x89a; }
  }
 if(gifp->version==0)
  {
  aa_ObjectDestroy(aa.gif_system.object_id,*handle);
  if((ret=aa_MemoryRelease(gifp->file_mem))!=YES) { oops; }
  return RET_FAILED;
  }
 if(aa_GifSystemReadBytes((PP)&gifp,2,&gifp->status.size.w)==RET_FAILED||aa_GifSystemReadBytes((PP)&gifp,2,&gifp->status.size.h)==RET_FAILED)
  {
  aa_ObjectDestroy(aa.gif_system.object_id,*handle);
  if((ret=aa_MemoryRelease(gifp->file_mem))!=YES) { oops; }
  return RET_FAILED;
  }
 if(aa_GifSystemReadBytes((PP)&gifp,3,buf)!=RET_YES)
  {
  aa_ObjectDestroy(aa.gif_system.object_id,*handle);
  if((ret=aa_MemoryRelease(gifp->file_mem))!=YES) { oops; }
  return RET_FAILED;
  }
 gifp->total_colors=(W)((((buf[0]&0x70)+1)>>4)+1);
 BitsPerPixel=(buf[0]&0x07)+1;

 if(buf[0]&0x80)
  {
  gifp->bg_color_used=YES;
  gifp->bg_color_index=(W)buf[1];
  if((1<<BitsPerPixel)!=(1<<aa_GifSystemBitSize(1<<BitsPerPixel)))
   {
   aa_ObjectDestroy(aa.gif_system.object_id,*handle);
   if((ret=aa_MemoryRelease(gifp->file_mem))!=YES) { oops; }
   return RET_FAILED;
   }
  gifp->global_color_count=(W)(1<<BitsPerPixel);
  gifp->global_color_bits=(W)aa_GifSystemBitSize((1<<BitsPerPixel));
  for(i=0;i<gifp->global_color_count; i++)
   {
   if(aa_GifSystemReadBytes((PP)&gifp,3,buf)!=RET_YES)
    {
    aa_ObjectDestroy(aa.gif_system.object_id,*handle);
    if((ret=aa_MemoryRelease(gifp->file_mem))!=YES) { oops; }
    return RET_FAILED;
    }
   aaRgbaSet(&gifp->global_color_pen[i],buf[0],buf[1],buf[2],255);
   }
  }
 gifp->file_offset_root=gifp->file_offset;
 ret=aa_MemoryAllocate((VP)&gifp->img,gifp->status.size.w*gifp->status.size.h*4,"gifimg",NO);
 if(ret!=RET_YES)
  {
  aa_ObjectDestroy(aa.gif_system.object_id,*handle);
  if((ret=aa_MemoryRelease(gifp->file_mem))!=YES) { oops; }
  return ret;
  }
 done=NO;
 go=0;
 while(1)
 {
 if((go%150)==149)  {  aaYield(-1.0);  }
 if((ret=aa_GifSystemReadBytes((PP)&gifp,1,&record_type))!=RET_YES) {  break; }
    switch (record_type)
     {
     case '!':
     if((ret=aa_GifSystemReadExtension((PP)&gifp,&extension_code,&extension))!=RET_YES) {  break; }
     if(extension_code!=0xf9)
      {
      while(extension!=NULL)    {    if((ret=aa_GifSystemReadExtensionNext((PP)&gifp,&extension))!=RET_YES) {  break; }    }
      break;
      }
     while(extension!=NULL)
      {
      if(extension[0]!=4) { ret=RET_FAILED; break; }

      del=(W)((extension[3]<<8)+extension[2])*10;
      gifp->status.total_ms+=del;

      if((ret=aa_GifSystemReadExtensionNext((PP)&gifp,&extension))!=RET_YES) {  break; }
      }
     break;

     case ',':
     if((ret=aa_GifSystemReadFrameInfo((PP)&gifp))!=RET_YES) {  break; }
      for(yy=0; yy<(N)gifp->frame_size.h; yy++)
       {
       if((ret=aa_GifSystemReadLine((PP)&gifp,buf,gifp->frame_size.w))!=RET_YES) {  break; }
       }
      if(ret!=RET_YES) { break; }
     gifp->status.total_frames++;
     break;

     case ';':
     done=YES;
     break;

     default:  ret=RET_FAILED;  break;
     }
  if(ret!=RET_YES||done) break;
  go++;
  }
 if(ret!=RET_YES)
  {
  aa_ObjectDestroy(aa.gif_system.object_id,*handle);
  if((ret=aa_MemoryRelease(gifp->file_mem))!=YES) { oops; }
  return ret;
  }
 aaTimerTikGet(&gifp->tik);
 gifp->status.ms=0;
 aaGifRewind(*handle);

 return RET_YES;
 }




 B aaGifCreateFromMemory               (HP handle,H bytes,VP mem)
 {
 B ret;
 _aa_gifobject*gifp;
 H rem,td,of;
 B buf[_8K];
 N  BitsPerPixel,i;
 H done,del;
 B record_type;
 BP extension;
 BP bp;
 N extension_code,yy;
 N dif;
 H go;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCreate(aa.gif_system.object_id,handle,(VP)&gifp))!=RET_YES) { oops; return ret; }
 gifp->self_handle=*handle;
 if(bytes==0) { return RET_BADPARM; }
 if(mem==NULL) { return RET_BADPARM; }
 gifp->file_bytes=(Q)bytes;
 if((ret=aa_MemoryAllocate((VP)&gifp->file_mem,gifp->file_bytes,"gifint",NO))!=RET_YES)
  {
  aa_ObjectDestroy(aa.gif_system.object_id,*handle);
  return ret;
  }
 rem=gifp->file_bytes;
 of=0;
 bp=(BP)mem;
 while(1)
  {
  td=rem;
  if(td>_4K) td=_4K;
  aaMemoryCopy(&gifp->file_mem[of],td,&bp[of]);
  of+=td;
  rem-=td;
  if(rem==0) break;
  }
 if(aa_GifSystemReadBytes((PP)&gifp,6,buf)!=RET_YES)
  {
  aa_ObjectDestroy(aa.gif_system.object_id,*handle);
  if((ret=aa_MemoryRelease(gifp->file_mem))!=YES) { oops; }
  return RET_FAILED;
  }
 ret=aaStringNCompare("GIF",buf,3,&dif);
 if(ret!=RET_YES||dif!=0)
  {
  aa_ObjectDestroy(aa.gif_system.object_id,*handle);
  if((ret=aa_MemoryRelease(gifp->file_mem))!=YES) { oops; }
  return RET_FAILED;
  }
 ret=aaStringNCompare("87a",&buf[3],3,&dif);
 if(ret==RET_YES&&dif==0) { gifp->version=0x87a; }
 else
  {
  ret=aaStringNCompare("89a",&buf[3],3,&dif);
  if(ret==RET_YES&&dif==0) { gifp->version=0x89a; }
  }
 if(gifp->version==0)
  {
  aa_ObjectDestroy(aa.gif_system.object_id,*handle);
  if((ret=aa_MemoryRelease(gifp->file_mem))!=YES) { oops; }
  return RET_FAILED;
  }
 if(aa_GifSystemReadBytes((PP)&gifp,2,&gifp->status.size.w)==RET_FAILED||aa_GifSystemReadBytes((PP)&gifp,2,&gifp->status.size.h)==RET_FAILED)
  {
  aa_ObjectDestroy(aa.gif_system.object_id,*handle);
  if((ret=aa_MemoryRelease(gifp->file_mem))!=YES) { oops; }
  return RET_FAILED;
  }
 if(aa_GifSystemReadBytes((PP)&gifp,3,buf)!=RET_YES)
  {
  aa_ObjectDestroy(aa.gif_system.object_id,*handle);
  if((ret=aa_MemoryRelease(gifp->file_mem))!=YES) { oops; }
  return RET_FAILED;
  }
 gifp->total_colors=(W)((((buf[0]&0x70)+1)>>4)+1);
 BitsPerPixel=(buf[0]&0x07)+1;
 if(buf[0]&0x80)
  {
  gifp->bg_color_used=YES;
  gifp->bg_color_index=(W)buf[1];
  if((1<<BitsPerPixel)!=(1<<aa_GifSystemBitSize(1<<BitsPerPixel)))
   {
   aa_ObjectDestroy(aa.gif_system.object_id,*handle);
   if((ret=aa_MemoryRelease(gifp->file_mem))!=YES) { oops; }
   return RET_FAILED;
   }
  gifp->global_color_count=(W)(1<<BitsPerPixel);
  gifp->global_color_bits=(W)aa_GifSystemBitSize((1<<BitsPerPixel));
  for(i=0;i<gifp->global_color_count; i++)
   {
   if(aa_GifSystemReadBytes((PP)&gifp,3,buf)!=RET_YES)
    {
    aa_ObjectDestroy(aa.gif_system.object_id,*handle);
    if((ret=aa_MemoryRelease(gifp->file_mem))!=YES) { oops; }
    return RET_FAILED;
    }
   aaRgbaSet(&gifp->global_color_pen[i],buf[0],buf[1],buf[2],255);
   }
  }
 gifp->file_offset_root=gifp->file_offset;
 ret=aa_MemoryAllocate((VP)&gifp->img,gifp->status.size.w*gifp->status.size.h*4,"gifimg",NO);
 if(ret!=RET_YES)
  {
  aa_ObjectDestroy(aa.gif_system.object_id,*handle);
  if((ret=aa_MemoryRelease(gifp->file_mem))!=YES) { oops; }
  return ret;
  }
 done=NO;
 go=0;
 while(1)
 {
 if((go%150)==149)  {  aaYield(-1.0);  }
 if((ret=aa_GifSystemReadBytes((PP)&gifp,1,&record_type))!=RET_YES) {  break; }
    switch (record_type)
     {
     case '!':
     if((ret=aa_GifSystemReadExtension((PP)&gifp,&extension_code,&extension))!=RET_YES) {  break; }
     if(extension_code!=0xf9)
      {
      while(extension!=NULL)    {    if((ret=aa_GifSystemReadExtensionNext((PP)&gifp,&extension))!=RET_YES) {  break; }    }
      break;
      }
     while(extension!=NULL)
      {
      if(extension[0]!=4) { ret=RET_FAILED; break; }

      del=(W)((extension[3]<<8)+extension[2])*10;
      gifp->status.total_ms+=del;

      if((ret=aa_GifSystemReadExtensionNext((PP)&gifp,&extension))!=RET_YES) {  break; }
      }
     break;

     case ',':
     if((ret=aa_GifSystemReadFrameInfo((PP)&gifp))!=RET_YES) {  break; }
      for(yy=0; yy<(N)gifp->frame_size.h; yy++)
       {
       if((ret=aa_GifSystemReadLine((PP)&gifp,buf,gifp->frame_size.w))!=RET_YES) {  break; }
       }
      if(ret!=RET_YES) { break; }
     gifp->status.total_frames++;
     break;

     case ';':
     done=YES;
     break;

     default:  ret=RET_FAILED;  break;
     }
  if(ret!=RET_YES||done) break;
  go++;
  }
 if(ret!=RET_YES)
  {
  aa_ObjectDestroy(aa.gif_system.object_id,*handle);
  if((ret=aa_MemoryRelease(gifp->file_mem))!=YES) { oops; }
  return ret;
  }
 aaTimerTikGet(&gifp->tik);
 gifp->status.ms=0;
 aaGifRewind(*handle);

 return RET_YES;
 }




 B aaGifCreateUsingResource            (HP handle,H resnum)
 {
 B ret;
 B path[MAX_PATH];
 B file[33];
 B filename[MAX_PATH];
 H bytes;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==NULL) { return RET_BADPARM; }
 *handle=0;
 if(GetTempPath(MAX_PATH,(CP)path)==0) { oof; }
 while(1)
  {
  aaStringRandomSet(file,8,YES,NO,YES,YES);
  aaStringCopyf(filename,"%s%s.tmp",path,file);
  if(aaFileExists(filename)!=YES) { break; }
  break;
  }
 if((ret=aaResourceToFile(resnum,&bytes,filename))!=RET_YES) { oops; return ret; }
 if((ret=aaGifCreate(handle,filename))!=RET_YES) { return ret; }
 return RET_YES;
 }




 B aaGifDestroy                        (H handle)
 {
 B ret;
 _aa_gifobject*gifp;
 B isprot;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.gif_system.object_id,handle,(VP)&gifp,&isprot))!=RET_YES) { return ret; }
 if(gifp->img!=NULL)  {  if((ret=aa_MemoryRelease(gifp->img))!=YES) { oops; }  }
 if(gifp->file_mem!=NULL) {  if((ret=aa_MemoryRelease(gifp->file_mem))!=YES) { oops; }  }
 aa_ObjectDestroy(aa.gif_system.object_id,handle);
 return RET_YES;
 }




 B aaGifStatus                         (H handle,_gifstatus*gifstatus)
 {
 B ret;
 _aa_gifobject*gifp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.gif_system.object_id,handle,(VP)&gifp,0))!=RET_YES) { return ret; }
 aaTimerTikElapsed(gifp->tik,&gifp->status.ms);
 if(gifstatus) { aaMemoryCopy(gifstatus,sizeof(_gifstatus),&gifp->status); }
 return RET_YES;
 }





 B aaGifRewind                         (H handle)
 {
 B ret;
 _aa_gifobject*gifp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.gif_system.object_id,handle,(VP)&gifp,NULL))!=RET_YES) { return ret; }
 gifp->file_offset=gifp->file_offset_root;
 gifp->status.frame_number=0;
 gifp->frame_transparent_index_set=NO;
 gifp->status.frame_delay=0;
 gifp->disposal_method=0;
 gifp->allow_next=NO;
 return RET_YES;
 }





 B aaGifFrameNext                      (H handle,PP img)
 {
 B ret;
 _aa_gifobject*gifp;
 B record_type,done;
 N extension_code,i,xx,yy;
 B cc;
 B screenbuf[_8K];
 BP extension;
 _rgba*dp;
 _rgba*sp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.gif_system.object_id,handle,(VP)&gifp,NULL))!=RET_YES) { return ret; }
 aaTimerTikElapsed(gifp->tik,&gifp->status.ms);
 if((gifp->status.ms+10)<gifp->status.frame_delay) { return RET_NOTREADY; }
 done=NO;
 gifp->frame_transparent_index_set=NO;
 gifp->status.frame_delay=0;
 gifp->disposal_method=0;
 while(!done)
 {
 if((ret=aa_GifSystemReadBytes((PP)&gifp,1,&record_type))!=RET_YES) {  return ret; }
 switch (record_type)
  {
  case '!':
  if((ret=aa_GifSystemReadExtension((PP)&gifp,&extension_code,&extension))!=RET_YES) {  return ret; }
  if(extension_code!=0xf9)
   {
   while(extension!=NULL)
    {
    if((ret=aa_GifSystemReadExtensionNext((PP)&gifp,&extension))!=RET_YES) {  return ret; }
    }
   break;
   }
  while(extension!=NULL)
   {
   if(extension[0]!=4) {  return RET_FAILED; }
   else
    {
    gifp->disposal_method=extension[1];
    gifp->disposal_method<<=3;
    gifp->disposal_method>>=5;
    gifp->status.frame_delay=(W)((extension[3]<<8)+extension[2])*10;
    if(aaBitGet(extension[1],0))
     {
     gifp->frame_transparent_index_set=YES;
     gifp->frame_transparent_index=extension[4];
     }
    }
   if((ret=aa_GifSystemReadExtensionNext((PP)&gifp,&extension))!=RET_YES) { return ret; }
   }
  break;

  case ',':
  if((ret=aa_GifSystemReadFrameInfo((PP)&gifp))!=RET_YES) {  return ret; }
  cc=gifp->bg_color_index;


  if(gifp->status.frame_number==0&&gifp->bg_color_used)
   {
    for(yy=0; yy<(N)gifp->status.size.h; yy++)
     {
     aaCast(dp,_rgba*,&gifp->img[yy*gifp->status.size.w*4]);
     if(cc==gifp->frame_transparent_index)     aaCast(sp,_rgba*,&col_null);
     else     aaCast(sp,_rgba*,&gifp->global_color_pen[cc]);
     for(xx=0;xx<(N)gifp->status.size.w;xx++)
      {
      *dp=*sp;
      dp++;
      }
     }
   }

 if(gifp->frame_interlaced)
   {
    yy=0;
    i=0;
    while(1)
     {
     if((ret=aa_GifSystemReadLine((PP)&gifp,screenbuf,gifp->frame_size.w))!=RET_YES) {  return ret; }
     aaCast(dp,_rgba*,&gifp->img[((yy+gifp->frame_cord.y)*(gifp->status.size.w*4))+((gifp->frame_cord.x)*4)]);
     for(xx=0;xx<(N)gifp->frame_size.w;xx++)
      {
      cc=screenbuf[xx];
      if(gifp->frame_transparent_index_set&&cc==gifp->frame_transparent_index)
       {
       }
      else
       {
       if(gifp->frame_use_local_color)
        {
        aaCast(sp,_rgba*,&gifp->local_color_pen[cc]);
        }
       else
        {
        aaCast(sp,_rgba*,&gifp->global_color_pen[cc]);
        }
       *dp=*sp;
       }
      dp++;
      }
     yy+=aa_GifInterlacedJumps[i];
     if(yy>= (N)gifp->frame_size.h)
      {
      i++;
      if(i==4) break;
      yy=aa_GifInterlacedOffset[i];
      }
     }
    }
  else
   {
   for(yy=0; yy<(N)gifp->frame_size.h; yy++)
    {
    if((ret=aa_GifSystemReadLine((PP)&gifp,screenbuf,gifp->frame_size.w))!=RET_YES) {  return ret; }
    aaCast(dp,_rgba*,&gifp->img[((yy+gifp->frame_cord.y)*(gifp->status.size.w*4))+((gifp->frame_cord.x)*4)]);
    for(xx=0;xx<(N)gifp->frame_size.w;xx++)
     {
     cc=screenbuf[xx];
     if(gifp->frame_transparent_index_set&&cc==gifp->frame_transparent_index)
      {
      }
     else
      {
      if(gifp->frame_use_local_color)
       {
       aaCast(sp,_rgba*,&gifp->local_color_pen[cc]);
       }
      else
       {
       aaCast(sp,_rgba*,&gifp->global_color_pen[cc]);
       }
      *dp=*sp;
      }
     dp++;
     }
    }
   }
  done=YES;
  break;

  default: oof;
  return RET_FAILED;
  }
 }
 if(done!=YES) oof;
 *img=gifp->img;
 gifp->status.frame_number++;
 aaTimerTikGet(&gifp->tik);
 gifp->status.ms=0;
 if(gifp->status.frame_number==gifp->status.total_frames)  {  aaGifRewind(handle);  }
 return RET_YES;
 }


///=====================================================


 B aaQrDecoderNew                      (_qrdecoder*qrdecoder,H wid,H hit)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(qrdecoder==NULL)  { return RET_MISSINGPARM; }
 if(wid<32||wid>2000) { return RET_BOUNDS; }
 if(hit<32||hit>2000) { return RET_BOUNDS; }
 aaMemoryFill(qrdecoder,sizeof(_qrdecoder),0);
 qrdecoder->magic=aaHPP(aaQrDecoderNew);
 qrdecoder->size.w=wid;
 qrdecoder->size.h=hit;
 if(aaMemoryAllocate((VP)&qrdecoder->image,wid*hit)!=YES)  { oof; }
 aaMemoryNameSet(qrdecoder->image,"image");
 if(aaMemoryAllocate((VP)&qrdecoder->internal,sizeof(_qrdecoderctx))!=YES) { oof; }
 aaMemoryNameSet(qrdecoder->internal,"qrdecinternal");
 return RET_YES;
 }



 B aaQrDecoderDelete                   (_qrdecoder*qrdecoder)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(qrdecoder==NULL)  { return RET_MISSINGPARM; }
 if(qrdecoder->magic!=aaHPP(aaQrDecoderNew)) { return RET_NOTINITIALIZED; }
 if(qrdecoder->pixels&&qrdecoder->pixels!=qrdecoder->image)  { aaMemoryRelease(qrdecoder->pixels); }
 if(qrdecoder->image)                                        { aaMemoryRelease(qrdecoder->image);  }
 if(qrdecoder->internal)                                     { aaMemoryRelease(qrdecoder->internal);  }
 aaMemoryFill(qrdecoder,sizeof(_qrdecoder),0);
 return RET_YES;
 }



 B aaQrDecoderBegin                    (_qrdecoder*qrdecoder,PP img)
 {
 _qrdecoderctx*ctx;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(qrdecoder==NULL)  { return RET_MISSINGPARM; }
 if(qrdecoder->magic!=aaHPP(aaQrDecoderNew)) { return RET_NOTINITIALIZED; }
 ctx=(_qrdecoderctx*)&qrdecoder->internal[0];
 ctx->num_regions=QRDEC_PIXEL_REGION;
 ctx->num_capstones=0;
 ctx->num_grids=0;
 if(img) { *img=qrdecoder->image; }
 return RET_YES;
 }



 B aaQrDecoderFinish                   (_qrdecoder*qrdecoder)
 {
 Z i,x,y,index;
 H c,count;
 _qrdecoderctx*ctx;
 _qrdecodercode code;
 _qrdecoderdata data;
 _qrdecodergrid*qr;
 B err;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(qrdecoder==NULL)  { return RET_MISSINGPARM; }
 if(qrdecoder->magic!=aaHPP(aaQrDecoderNew)) { return RET_NOTINITIALIZED; }
 ctx=(_qrdecoderctx*)&qrdecoder->internal[0];
 qrdecoder->pixels=(BP)qrdecoder->image;
 aa_QrDecThreshold(qrdecoder);
 for(i=0;i<(Z)qrdecoder->size.h;i++) {  aa_QrDecFinderScan(qrdecoder,i);   }
 qrdecoder->capstone_count=ctx->num_capstones;
 for(i=0;i<ctx->num_capstones;i++)   {  aa_QrDecTestGrouping(qrdecoder,i); }
 qrdecoder->data_count=0;
 count=ctx->num_grids;
 for(c=0;c<count;c++)
  {
  index=(Z)c;
  if(index<0||index>ctx->num_grids) { continue; }
  qr=&ctx->grids[index];
  i=0;
  aaMemoryFill(&code,sizeof(code),0);
  aa_QrDecPerspectiveMap(qr->c,0.0,0.0,&code.corners[0]);
  aa_QrDecPerspectiveMap(qr->c,qr->grid_size,0.0,&code.corners[1]);
  aa_QrDecPerspectiveMap(qr->c,qr->grid_size,qr->grid_size,&code.corners[2]);
  aa_QrDecPerspectiveMap(qr->c,0.0,qr->grid_size,&code.corners[3]);
  code.size=qr->grid_size;
  for(y=0;y<qr->grid_size;y++)
   {
   for(x=0;x<qr->grid_size;x++)
    {
    if(aa_QrDecReadCell(qrdecoder,index,x,y)>0) { code.cell_bitmap[i>>3]|=(1<<(i&7)); }
    i++;
    }
   }
  err=aa_QrDecDecode(&code,&data);
  if(err)  { continue; }
  aaMemoryCopy(qrdecoder->data_buf[qrdecoder->data_count],data.payload_len,data.payload);
  qrdecoder->data_bytes[qrdecoder->data_count]=data.payload_len;
  qrdecoder->data_buf[qrdecoder->data_count][data.payload_len]=NULL_CHAR;
  qrdecoder->data_count++;
  if(qrdecoder->data_count>=aaElementCount(qrdecoder->data_buf)) { break; }
  }
 return RET_YES;
 }


/*-----------------------------------------------------------------------*/

 B aaQrDecoderQuick                    (_size*size,_rgba*image,BP dlum,BP blum,BP flipped,HP attempts,VP txt)
 {
 B ret;
 _qrdecoder qd;
 H wid,hit,x,y,i;
 H go,po,isflip,ok,at;
 BP gs,dp;
 _rgba*rgb;
 N lum,drk,bri;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(size==NULL)  { return RET_MISSINGPARM; }
 if(image==NULL) { return RET_MISSINGPARM; }
 if(txt==NULL)   { return RET_MISSINGPARM; }
 aaStringNull(txt);
 if(size->w==0||size->w>1920) { return RET_BOUNDS; }
 if(size->h==0||size->h>1920) { return RET_BOUNDS; }
 if(dlum)     { *dlum=0; }
 if(blum)     { *blum=0; }
 if(flipped)  { *flipped=0; }
 if(attempts) { *attempts=0; }
 wid=size->w;
 hit=size->h;
 at=0;
 for(po=0;po<4;po++)
  {
  drk=128;
  bri=128;
  isflip=(B)po/2;
  for(go=0;go<4;go++)
   {
   if((ret=aaQrDecoderNew(&qd,wid,hit))!=YES) { return ret; }
   aaQrDecoderBegin(&qd,(VP)&gs);
   ok=0;
   for(y=0;y<hit;y++)
    {
    if(isflip) { rgb=&image[(hit-y-1)*wid]; }
    else       { rgb=&image[y*wid];         }
    dp=(BP)&gs[(y*wid)];
    for(x=0;x<wid;x++)
     {
     lum=(N)rgb->r+(N)rgb->g+(N)rgb->b;
     lum=lum/3;
     if(lum<=drk)  {  *dp=0;   }   else
     if(lum>=bri)  {  *dp=255; }   else { *dp=128; }
     dp++;
     rgb++;
     }
    }
   aaQrDecoderFinish(&qd);
   if(qd.data_count!=0)
    {
    for(i=0;i<qd.data_count;i++)
     {
     aaStringCopyf(txt,"%s",qd.data_buf[i]);
     ok=1;
     break;
     }
    }
   if((ret=aaQrDecoderDelete(&qd))!=YES) { return ret; }
   if(ok==1)
    {
    if(dlum) { *dlum=drk; }
    if(blum) { *blum=bri; }
    if(flipped) { *flipped=(B)isflip; }
    if(attempts) { *attempts=at; }
    return RET_YES;
    }
   if(po==0) {  drk-=8;  bri+=16; } else
   if(po==1) {  drk-=16; bri+=8;  } else
   if(po==2) {  drk-=8;  bri+=16; } else
   if(po==3) {  drk-=16; bri+=8;  }
   if(drk<0)   { drk=0; }
   if(bri>255) { bri=255; }
   at++;
   }
  }
 if(attempts) { *attempts=at; }
 return RET_FAILED;
 }



///=====================================================




 B aaQrEncoderNew                      (_qrencoder*qrencoder,B quality,H maxbytes,H bytes,VP data)
 {
 B size,version;
 Z minPenalty,penalty;
 B mask,i,padByte;
 B dat[4000];
 _qrencoderbucket modulesGrid;
 _qrencoderbucket codewords;
 _qrencoderbucket isFunctionGrid;
 Y padding;
 C mode;
 B eccFormatBits;
 W moduleCount;
 W dataCapacity;
 B codewordBytes[_32K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(qrencoder==NULL)  { return RET_MISSINGPARM; }
 if(quality>4)        { return RET_BOUNDS; }
 if(maxbytes>3705)    { return RET_BOUNDS; }
 if(maxbytes<26)      { return RET_BOUNDS; }
 if(data==NULL)       { return RET_MISSINGPARM; }
 if(bytes==0)         { aaStringLen(data,&bytes);  }
 if(bytes>=maxbytes)  { return RET_BOUNDS; }
 if(maxbytes<=26)    { version=1;   } else
 if(maxbytes<=44)    { version=2;   } else
 if(maxbytes<=70)    { version=3;   } else
 if(maxbytes<=100)   { version=4;   } else
 if(maxbytes<=134)   { version=5;   } else
 if(maxbytes<=172)   { version=6;   } else
 if(maxbytes<=196)   { version=7;   } else
 if(maxbytes<=242)   { version=8;   } else
 if(maxbytes<=292)   { version=9;   } else
 if(maxbytes<=346)   { version=10;  } else
 if(maxbytes<=404)   { version=11;  } else
 if(maxbytes<=466)   { version=12;  } else
 if(maxbytes<=532)   { version=13;  } else
 if(maxbytes<=581)   { version=14;  } else
 if(maxbytes<=655)   { version=15;  } else
 if(maxbytes<=733)   { version=16;  } else
 if(maxbytes<=815)   { version=17;  } else
 if(maxbytes<=901)   { version=18;  } else
 if(maxbytes<=991)   { version=19;  } else
 if(maxbytes<=1085)  { version=20;  } else
 if(maxbytes<=1156)  { version=21;  } else
 if(maxbytes<=1258)  { version=22;  } else
 if(maxbytes<=1364)  { version=23;  } else
 if(maxbytes<=1474)  { version=24;  } else
 if(maxbytes<=1588)  { version=25;  } else
 if(maxbytes<=1706)  { version=26;  } else
 if(maxbytes<=1828)  { version=27;  } else
 if(maxbytes<=1921)  { version=28;  } else
 if(maxbytes<=2051)  { version=29;  } else
 if(maxbytes<=2185)  { version=30;  } else
 if(maxbytes<=2323)  { version=31;  } else
 if(maxbytes<=2465)  { version=32;  } else
 if(maxbytes<=2611)  { version=33;  } else
 if(maxbytes<=2761)  { version=34;  } else
 if(maxbytes<=2876)  { version=35;  } else
 if(maxbytes<=3034)  { version=36;  } else
 if(maxbytes<=3196)  { version=37;  } else
 if(maxbytes<=3362)  { version=38;  } else
 if(maxbytes<=3706)  { version=39;  }
 aaMemoryFill(dat,sizeof(dat),0);
 size=version*4+17;
 aaMemoryFill(qrencoder,sizeof(_qrencoder),0);
 qrencoder->magic=aaHPP(aaQrEncoderNew);
 qrencoder->version=version;
 qrencoder->size=size;
 qrencoder->ecc=quality;
 eccFormatBits=(((0x02<<6)|(0x03<<4)|(0x00<<2)|(0x01<<0))>>(2*qrencoder->ecc))&0x03;
 aaMemoryCopy(dat,bytes,data);
 moduleCount=QRENC_NUM_RAW_DATA_MODULES[version-1];
 dataCapacity=moduleCount/8-QRENC_NUM_ERROR_CORRECTION_CODEWORDS[eccFormatBits][version-1];
 aa_QrEncBucketInitBuffer(&codewords,codewordBytes,(Z)sizeof(codewordBytes));
 mode=aa_QrEncEncodeDataCodewords(&codewords,dat,bytes,version);
 if(mode<0) { oof; return RET_FAILED; }
 qrencoder->mode=mode;
 padding=(dataCapacity*8)-codewords.bitOffsetOrWidth;
 if(padding>4) { padding=4; }
 aa_QrEncBucketAppendBits(&codewords,0,padding);
 aa_QrEncBucketAppendBits(&codewords,0,(8-codewords.bitOffsetOrWidth%8)%8);
 for(padByte=0xEC;codewords.bitOffsetOrWidth<(dataCapacity*8);padByte^=0xEC^0x11) {    aa_QrEncBucketAppendBits(&codewords,padByte,8);    }
 aa_QrEncBucketInitGrid(&modulesGrid,qrencoder->modules,size);
 B isFunctionGridBytes[aa_QrEncBucketGetGridSizeBytes(size)];
 aa_QrEncBucketInitGrid(&isFunctionGrid,isFunctionGridBytes,size);
 aa_QrEncBucketDrawFunctionPatterns(&modulesGrid,&isFunctionGrid,version,eccFormatBits);
 aa_QrEncPerformErrorCorrection(version,eccFormatBits,&codewords);
 aa_QrEncBucketDrawCodewords(&modulesGrid,&isFunctionGrid,&codewords);
 mask=0;
 minPenalty=INT32_MAX;
 for(i=0;i<8;i++)
  {
  aa_QrEncBucketDrawFormatBits(&modulesGrid,&isFunctionGrid,eccFormatBits,i);
  aa_QrEncBucketApplyMask(&modulesGrid,&isFunctionGrid,i);
  penalty=aa_QrEncBucketGetPenaltyScore(&modulesGrid);
  if(penalty<minPenalty) {   mask=i;   minPenalty=penalty;        }
  aa_QrEncBucketApplyMask(&modulesGrid,&isFunctionGrid,i);
  }
 qrencoder->mask=mask;
 aa_QrEncBucketDrawFormatBits(&modulesGrid,&isFunctionGrid,eccFormatBits,mask);
 aa_QrEncBucketApplyMask(&modulesGrid,&isFunctionGrid,mask);
 return RET_YES;
 }





 B aaQrEncoderDelete                   (_qrencoder*qrencoder)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(qrencoder==NULL)  { return RET_MISSINGPARM; }
 if(qrencoder->magic!=aaHPP(aaQrEncoderNew)) { return RET_NOTINITIALIZED; }
 aaMemoryFill(qrencoder,sizeof(_qrencoder),0);
 return RET_YES;
 }




 B aaQrEncoderGet                      (_qrencoder*qrencoder,N x,N y,BP state)
 {
 Y offset;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(qrencoder==NULL)  { return RET_MISSINGPARM; }
 if(qrencoder->magic!=aaHPP(aaQrEncoderNew)) { return RET_NOTINITIALIZED; }
 if(state==NULL) { return RET_MISSINGPARM; }
 if(x<0||x>=qrencoder->size||y<0||y>=qrencoder->size) { *state=0; return RET_YES; }
 offset=y*qrencoder->size+x;
 *state=(qrencoder->modules[offset>>3]&(1<<(7-(offset&0x07))))!=0;
 return RET_YES;
 }





///=====================================================



 B aaInputKeySimulate                  (B virtkey,B isscan,B isdown)
 {
 INPUT ip;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMemoryFill(&ip,sizeof(ip),0);
 ip.type=INPUT_KEYBOARD;
 ip.ki.wVk=virtkey;
 ip.ki.wScan=virtkey;
 if(isdown)  {  ip.ki.dwFlags=0;  }
 else        {  ip.ki.dwFlags=KEYEVENTF_KEYUP;  }
 if(isscan) { ip.ki.dwFlags|=KEYEVENTF_SCANCODE;  }
 if(SendInput(1,&ip,sizeof(INPUT))!=1) { oof; }
 return RET_YES;
 }





 B aaInputKeyPairSimulate              (B virtkey1,B virtkey2,H sleep)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(virtkey1==0&&virtkey2==0) { return RET_BADPARM; }
 if(virtkey1!=0) { aaInputKeySimulate(virtkey1,NO,YES); }
 if(virtkey2!=0) { aaInputKeySimulate(virtkey2,NO,YES); }
 aaSleep(sleep);
 if(virtkey2!=0) { aaInputKeySimulate(virtkey2,NO,NO); }
 if(virtkey1!=0) { aaInputKeySimulate(virtkey1,NO,NO); }
 return RET_YES;
 }




 B aaInputKeyPattern                   (H state)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 switch(state)
  {
  case 0:  return(aaInputKeySimulate(VK_LMENU,NO,YES));
  case 1:  return(aaInputKeySimulate(VK_TAB,NO,YES));
  case 2:  return(aaInputKeySimulate(VK_TAB,NO,NO));
  case 3:  return(aaInputKeySimulate(VK_LMENU,NO,NO));
  case 4:  return(aaInputKeySimulate(VK_F5,NO,YES));
  case 5:  return(aaInputKeySimulate(VK_F5,NO,NO));
  default: break;
  }
 return RET_BADPARM;
 }





 B aaInputKeyStringSimulate            (VP fmt,...)
 {
 va_list argptr;
 B str[_4K];
 H s,sl;
 B v1,v2;
 B ch;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,str);
 aaStringLen(str,&sl);
 for(s=0;s<sl;s++)
  {
  v1=v2=0;
  while(1)
   {
   ch=str[s];
   if(ch>='A'&&ch<='Z')  {  v1=VK_SHIFT;   v2=ch;    break;    }
   if(ch>='a'&&ch<='z')  {  v1=(B)(ch-32); v2=0; break; }
   if(ch>='0'&&ch<='9')  {  v1=ch; v2=0; break; }
   if(ch=='!') { v1=VK_SHIFT; v2='1'; break; }
   if(ch=='@') { v1=VK_SHIFT; v2='2'; break; }
   if(ch=='#') { v1=VK_SHIFT; v2='3'; break; }
   if(ch=='$') { v1=VK_SHIFT; v2='4'; break; }
   if(ch=='\%') { v1=VK_SHIFT; v2='5'; break; }
   if(ch=='^') { v1=VK_SHIFT; v2='6'; break; }
   if(ch=='&') { v1=VK_SHIFT; v2='7'; break; }
   if(ch=='*') { v1=VK_SHIFT; v2='8'; break; }
   if(ch=='(') { v1=VK_SHIFT; v2='9'; break; }
   if(ch==')') { v1=VK_SHIFT; v2='0'; break; }
   if(ch==SPACE_CHAR) { v1=VK_SPACE; break; }
   if(ch=='-') { v1=VK_SUBTRACT; break; }
   if(ch=='+') { v1=VK_ADD; break; }
   if(ch=='.') { v1=VK_DECIMAL; break; }
   if(ch==',') { v1=0xbc; break; }
   if(ch=='=') { v1=187; break; }
   if(ch=='_') { v1=VK_SHIFT; v2=189; break; }
   if(ch=='<') { v1=VK_SHIFT; v2=188; break; }
   if(ch=='>') { v1=VK_SHIFT; v2=190; break; }
   if(ch=='/') { v1=191; break; }
   if(ch=='?') { v1=VK_SHIFT; v2=191; break; }

   if(ch=='[') { v1=219; break; }
   if(ch==']') { v1=221; break; }
   if(ch=='{') { v1=VK_SHIFT; v2=219; break; }
   if(ch=='}') { v1=VK_SHIFT; v2=221; break; }

   if(ch=='\\') { v1=220; break; }
   if(ch=='|')  { v1=VK_SHIFT; v2=220; break; }

   if(ch==';')  { v1=186; break; }
   if(ch=='\'') { v1=220; break; }
   if(ch==':')  { v1=VK_SHIFT; v2=186; break; }
   if(ch=='\"') { v1=VK_SHIFT; v2=220; break; }

   if(ch=='`') { v1=192; break; }
   if(ch=='~') { v1=VK_SHIFT; v2=192; break; }

   if(ch==LF_CHAR) { v1=VK_RETURN; break; }

   break;
   }
  if((v1==0&&v2==0)&&ch!=CR_CHAR) {  continue; }
  aaInputKeyPairSimulate(v1,v2,8);
  }
 return RET_YES;
 }



 B aaInputKeyCharSimulate              (B ch,B count)
 {
 B txt[_1K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaStringFill(txt,(H)count,ch,YES);
 aaNote(0,"t4 %s",txt);
 return(aaInputKeyStringSimulate("%s",txt));
 }





 B aaInputStateGet                     (_inputstate*inputstate)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aa_InputStateGet(inputstate,1,1));
 }









 B aaInputEngine                       (_inputengine*inputengine,H iespeed,H evwth,H rsdel,H mvdel)
 {
 B ret;
 H kr,i,c;
 _inputstate*curr;
 _inputstate*prev;
 _inputstate*ldwn;
 _inputstate*rdwn;
 _inputstate*pcur;
 _inputengine*ieng;
 _inputengine iengine;
 Q difa,difb;
 _cord c1;
 _aa_surfaceobject*surp;
 _cord cd1;
 _rect prev_rc;
 _rect rc1;
 H flag,ew,eh;
 _surfacespot*sspot;
 S Q last_drag_ms;
 Q resize_delay;
 Q move_delay;
 //_rect r1;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif



 if(aa.input_system.ie_ms_tik==0)  {  aa.input_system.ie_ms_tik=aaMsRunning();  }
 aa.input_system.ihke_events_waiting_threshold=evwth;
 aa_ie_events_waiting_threshold=aa.input_system.ihke_events_waiting_threshold;
 if(inputengine!=NULL)  {  inputengine->is_ok=NO;  }


 if((aa.input_system.vkey_held_count!=0))//&&aa.input_system.vkey_down_count==0)||aa.input_system.vkey_up_count!=0)
  {
  if(iespeed!=0&&((aaMsRunning()-aa.input_system.ie_ms_tik)<(Q)iespeed))  {    return RET_NOTREADY;    }
  }

 aa.input_system.ie_ms_tik=aaMsRunning();


 if(rsdel<=iespeed) { rsdel=iespeed; }
 if(mvdel<=iespeed) { mvdel=iespeed; }

 resize_delay=rsdel;
 move_delay=mvdel;

 if(inputengine==NULL) { ieng=(_inputengine*)&iengine;    }
 else                  { ieng=(_inputengine*)inputengine; }

 if(ieng->magic!=aaHPP(aaInputEngine))
  {
  aaMemoryFill(ieng,sizeof(_inputengine),0);
  ieng->magic=aaHPP(aaInputEngine);
  }
 ieng->curr=(_inputstate*)&ieng->ises[0];
 ieng->prev=(_inputstate*)&ieng->ises[1];
 ieng->ldwn=(_inputstate*)&ieng->ises[2];
 ieng->rdwn=(_inputstate*)&ieng->ises[3];
 ieng->pcur=(_inputstate*)&ieng->ises[4];
 ieng->event_bit=0;
 ieng->bits_on=0;
 ieng->is_ok=NO;
 ieng->surface_resizing=0;
 ieng->surface_moving=0;

 if(aaBitGet(ieng->internal_flag,0))
  {
  aaMemoryFill(ieng->ldwn,sizeof(_inputstate),0);
  ieng->internal_flag=aaBitClr(ieng->internal_flag,0);
  }
 if(aaBitGet(ieng->internal_flag,1))
  {
  aaMemoryFill(ieng->rdwn,sizeof(_inputstate),0);
  ieng->internal_flag=aaBitClr(ieng->internal_flag,1);
  }
 if(aaBitGet(ieng->internal_flag,2))
  {
  aaMemoryCopy(ieng->prev,sizeof(_inputstate),ieng->pcur);
  aaMemoryFill(ieng->pcur,sizeof(_inputstate),0);
  ieng->internal_flag=aaBitClr(ieng->internal_flag,2);
  }


 while(1)
  {
  if((ret=aaInputStateGet(ieng->curr))!=YES) {  oops;   return ret;   }
  aaMemoryFill(ieng->event_byt,sizeof(ieng->event_byt),0);
  ieng->is_ok=YES;
  ieng->seq=aa.input_system.engine_sequence;
  curr=(_inputstate*)ieng->curr;
  prev=(_inputstate*)ieng->prev;
  ldwn=(_inputstate*)ieng->ldwn;
  rdwn=(_inputstate*)ieng->rdwn;
  pcur=(_inputstate*)ieng->pcur;
  if(curr->is_left!=prev->is_left)
   {
//   aaDebugf("cl=%i pl=%i",curr->is_left,prev->is_left);
   if(curr->is_left==YES)    {    aaMemoryCopy(ieng->ldwn,sizeof(_inputstate),ieng->curr);    }
   else                      {    ieng->internal_flag=aaBitSet(ieng->internal_flag,0);        }

   if(curr->is_left==YES&&prev->is_left==NO&&ldwn->is_left==YES&&ldwn->over_handle!=0)    {    aaSurfaceCursorCapture(ldwn->over_handle,YES);    }   else
   if(curr->is_left==NO&&prev->is_left==YES)                                              {    aaSurfaceCursorCapture(ldwn->over_handle,NO);    }
   }

  //--------------------------
  if(curr->is_right!=prev->is_right)
   {
   if(curr->is_right==YES)    {    aaMemoryCopy(ieng->rdwn,sizeof(_inputstate),ieng->curr);    }
   else                       {    ieng->internal_flag=aaBitSet(ieng->internal_flag,1);        }

   if(curr->is_right==YES&&prev->is_right==NO&&rdwn->is_right==YES&&rdwn->over_handle!=0)  {   aaSurfaceCursorCapture(rdwn->over_handle,YES);    }   else
   if(curr->is_right==NO&&prev->is_right==YES)                                             {   aaSurfaceCursorCapture(rdwn->over_handle,NO);     }
   }
  break;
  }
 /*================================================================================*/

 if(aa.input_system.ihke_events_waiting!=0)
  {
  logg("%s:%i ievw=%I64u",__func__,__LINE__,aa.input_system.ihke_events_waiting);
  }

 /*================================================================================*/
 while(1)
  {
  //---------------------------------------------- left clicks
  if(curr->is_left==YES&&prev->is_left==NO&&ldwn->is_left==YES)     {   ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_LeftDown);   }
  if(curr->is_left==NO&&prev->is_left==YES&&ldwn->is_left==YES)     {   ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_LeftUp);     }
  if(curr->is_left==YES&&prev->is_left==YES&&ldwn->is_left==YES)    {   ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_LeftHeld);   }
  //---------------------------------------------- right clicks
  if(curr->is_right==YES&&prev->is_right==NO&&rdwn->is_right==YES)  {   ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_RightDown);  }
  if(curr->is_right==NO&&prev->is_right==YES&&rdwn->is_right==YES)  {   ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_RightUp);    }
  if(curr->is_right==YES&&prev->is_right==YES&&rdwn->is_right==YES) {   ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_RightHeld);  }

  //---------------------------------------------- spots
  if(curr->spot_index!=-1&&prev->spot_index==-1)                    {   ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_SpotEnter);  }  else
  if(curr->spot_index!=-1&&prev->is_ok!=YES)                        {   ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_SpotEnter);  }
  if(curr->spot_index!=-1&&prev->spot_index!=-1&&prev->is_ok==YES)
   {
   if(curr->spot_index!=prev->spot_index)
    {
    ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_SpotEnter);
    ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_SpotChange);
    ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_SpotLeave);
    }
   }
  if(curr->spot_index==-1&&prev->spot_index!=-1&&prev->is_ok==YES)
   {
   ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_SpotLeave);
   }

  //---------------------------------------------- surfaces
  if(curr->over_handle!=0&&prev->over_handle==0)   {   ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_SurfaceEnter);  }  else
  if(curr->over_handle!=0&&prev->is_ok!=YES)       {   ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_SurfaceEnter);  }
  if(curr->over_handle!=0&&prev->over_hwnd!=curr->over_hwnd)
   {
   if(prev->over_handle!=0)
    {
    ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_SurfaceEnter);
    ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_SurfaceChange);
    ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_SurfaceLeave);
    }
   else
    {
    ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_SurfaceEnter);
    }
   }
  if(curr->over_handle==0&&prev->over_handle!=0&&prev->is_ok==YES)
   {
   ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_SurfaceLeave);
   }

  //---------------------------------------------- wheel
  if(curr->wheel!=prev->wheel)                                      {  ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_WheelChange);   }


  //---------------------------------------------- keys
  if(curr->key_msg!=0)                                              {  ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_KeyMsg);   }
  if(aaMemoryCompare(&curr->vkey_state,sizeof(curr->vkey_state),&prev->vkey_state,0)!=YES)
   {
   ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_KeyStateChange);
   }


  //---------------------------------------------- keys
  if(curr->key_msg=='d')
   {
   kr=(H)(curr->skey<<8)+curr->vkey;
   if(aa.input_system.vs_key_rep[kr]==0)   {  ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_KeyDown);  }
   else                                    {  ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_KeyHeld);  }
   if(aa.input_system.vs_key_rep[kr]<126)  {  aa.input_system.vs_key_rep[kr]++;    }
   ieng->key_rep[curr->vkey]=aa.input_system.vs_key_rep[kr];
   }
  if(curr->key_msg=='u')
   {
   ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_KeyUp);
   kr=(H)(curr->skey<<8)+curr->vkey;
   if(aa.input_system.vs_key_rep[kr]==0)
    {
    oof;
    aaDebugfHwnds();
    aaWinEventLog(2,0,123,8999,"%s %s %i\nup but rep was zero kr=%02x %02x %02x %02x %02x %c %ci",__FILE__,__func__,__LINE__,kr,curr->skey,curr->vkey,curr->akey,curr->xkey,aaCharIsVisible(curr->akey)?curr->akey:32,aaCharIsVisible(curr->xkey)?curr->xkey:32);
    aa_stats[27]++;
    }
   aa.input_system.vs_key_rep[kr]=0;
   ieng->key_rep[curr->vkey]=aa.input_system.vs_key_rep[kr];
   }

  //---------------------------------------------- mouse
  if(aaCordEqualsCord(&curr->cord,&prev->cord)!=YES)                {   ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_Move);   }

  if(aaBitGet(ieng->event_bit,aa_IE_Move))
   {
   if(curr->is_left&&ldwn->is_left)
    {
    if(aa.input_system.is_dragging!=YES)
     {
     ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_DragStart);
     aa.input_system.is_dragging=YES;
     }
    ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_Drag);
    }
   }

  ieng->is_dragging=aa.input_system.is_dragging;
  if(aaBitGet(ieng->event_bit,aa_IE_LeftUp))
   {
   if(aa.input_system.is_dragging==YES)
    {
    ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_DragEnd);
    aa.input_system.is_dragging=NO;
    }
   }
  //-----------------------------------------------spot clicking
  if(aaBitGet(ieng->event_bit,aa_IE_LeftUp))
   {
   if(ldwn->over_hwnd==curr->over_hwnd)
    {
    ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_SpotClick);
    ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_Click);
    if(ldwn->spot_id==0||curr->spot_id!=ldwn->spot_id)
     {
     ieng->event_bit=aaBitClr(ieng->event_bit,aa_IE_SpotClick);
     }
    }
   }

  if(aaBitGet(ieng->event_bit,aa_IE_RightUp))
   {
   if(rdwn->over_hwnd==curr->over_hwnd)
    {
    ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_RightSpotClick);
    ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_RightClick);
    if(rdwn->spot_id==0||curr->spot_id!=rdwn->spot_id)
     {
     ieng->event_bit=aaBitClr(ieng->event_bit,aa_IE_RightSpotClick);
     }
    }
   }

   #if 0
  if(aaBitGet(ieng->event_bit,aa_IE_RightUp))
   {
   if(ldwn->over_hwnd==curr->over_hwnd)
    {
    ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_RightSpotClick);
    ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_RightClick);
    if(ldwn->spot_id==0||curr->spot_id!=rdwn->spot_id)
     {
     ieng->event_bit=aaBitClr(ieng->event_bit,aa_IE_RightSpotClick);
     }
    }
   }
   #endif

  if(aaBitGet(ieng->event_bit,aa_IE_SpotClick)||aaBitGet(ieng->event_bit,aa_IE_Click))
   {
   difa=ieng->curr->microsecs-ieng->ldwn->microsecs;
   difb=ieng->curr->microsecs-aa.input_system.dbl_click_prev_ms;
   if(difa<140000)
    {
    if(aa.input_system.dbl_click_state==0)
     {
     aa.input_system.dbl_click_prev_ms=ieng->curr->microsecs;
     aa.input_system.dbl_click_handle=ieng->ldwn->over_handle;
     aa.input_system.dbl_click_spot_id=ieng->ldwn->spot_id;
     aa.input_system.dbl_click_cord.x=ieng->ldwn->cord.x;
     aa.input_system.dbl_click_cord.y=ieng->ldwn->cord.y;
     aa.input_system.dbl_click_state=1;
     }
    else
     {
     if((ieng->curr->over_handle==aa.input_system.dbl_click_handle))
      {
      if(difb<450000)
       {
       if(ieng->curr->spot_id!=0&&ieng->curr->spot_id==aa.input_system.dbl_click_spot_id)
        {
        ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_DblSpotClick);
        }
       else
        {
        aaCordSubtract(&ieng->ldwn->cord,&aa.input_system.dbl_click_cord,&c1);
        if((c1.x>-4&&c1.x<+4)&&(c1.y>-4&&c1.y<+4))
         {
         ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_DblClick);
         }
        }
       }
      }
     aa.input_system.dbl_click_state=0;
     }
    }
   else
    {
    aa.input_system.dbl_click_state=0;
    }
   }



  break;
  }
 /*================================================================================*/

 if(aa.input_system.ihke_events_waiting!=0)
  {
  logg("%s:%i ievw=%I64u",__func__,__LINE__,aa.input_system.ihke_events_waiting);
  }

 if(curr->focus_hwnd!=prev->focus_hwnd)
  {
  ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_FocusChange);
  }

 if(ieng->event_bit!=0)
  {
  for(i=0;i<64;i++)
   {
   if(aaBitGet(ieng->event_bit,i))  {   ieng->event_byt[i]=1;  ieng->bits_on++; }
   }
  }
 if(ieng->bits_on!=0)
  {
  aa.input_system.engine_sequence++;
  }

 if(curr->spot_id!=0) { ieng->c_spot=curr->spot_ptr; }
 if(prev->spot_id!=0) { ieng->p_spot=prev->spot_ptr; }
 if(ldwn->spot_id!=0) { ieng->l_spot=ldwn->spot_ptr; }
 if(rdwn->spot_id!=0) { ieng->r_spot=rdwn->spot_ptr; }

 aaMemoryCopy(pcur,sizeof(_inputstate),curr);
 ieng->internal_flag=aaBitSet(ieng->internal_flag,2);


 if(ieng->bits_on)
  {
  c=0;
  for(i=0;i<64;i++)
   {
   if(ieng->event_byt[i]) { ieng->event[c]=i; c++; if(c>=aaElementCount(ieng->event)) { break; } }
   }
  }

 if(ieng->event_byt[aa_IE_SpotLeave])
  {
  if((ret=aa_ObjectCheck(aa.surface_system.object_id,ieng->prev->over_handle,(VP)&surp,NULL))==RET_YES)
   {
   if(surp->status.resize_border_pixels!=0)
    {
    if(surp->status.is_maximized!=YES)
     {
     if(surp->status.is_sizeable==YES)
      {
      aaCursorSet(aa_CURSOR_Arrow);
      //aaCursorSet(aa.cursor_system.cursor_id);
      }
     }
    }
   }
  }

 if(ieng->event_byt[aa_IE_SpotEnter])
  {
  if((ret=aa_ObjectCheck(aa.surface_system.object_id,ieng->curr->over_handle,(VP)&surp,NULL))==RET_YES)
   {
   if(surp->status.resize_border_pixels!=0)
    {
    if(surp->status.is_maximized!=YES)
     {
     if(surp->status.is_sizeable==YES)
      {
      if(ieng->curr->spot_type==SPOT_SizerL||ieng->curr->spot_type==SPOT_SizerR)     {       aaCursorSet(aa_CURSOR_ResizeH);       }
      else
      if(ieng->curr->spot_type==SPOT_SizerBR||ieng->curr->spot_type==SPOT_SizerTL)   {       aaCursorSet(aa_CURSOR_ResizeB);       }
      else
      if(ieng->curr->spot_type==SPOT_SizerBL||ieng->curr->spot_type==SPOT_SizerTR)   {       aaCursorSet(aa_CURSOR_ResizeF);       }
      else
      if(ieng->curr->spot_type==SPOT_SizerB||ieng->curr->spot_type==SPOT_SizerT)     {       aaCursorSet(aa_CURSOR_ResizeV);       }
      }
     }
    }
   }
  }


 if(ieng->event_byt[aa_IE_DragStart]&&ieng->ldwn->over_handle!=0)
  {
  if((ret=aa_ObjectCheck(aa.surface_system.object_id,ieng->ldwn->over_handle,(VP)&surp,NULL))==RET_YES)
   {
   if(surp->status.resize_border_pixels!=0||surp->status.move_pixels!=0)
    {
    if(surp->status.is_maximized!=YES)
     {
    // if(surp->status.is_sizeable==YES)
      {
      aaRectCopy(&surp->rect_save,&surp->status.rect);
      last_drag_ms=aaMsRunning();
      }
     }
    }
   }
  }

 if(ieng->event_byt[aa_IE_Drag]&&ieng->ldwn->over_handle!=0)
  {
  if((ret=aa_ObjectCheck(aa.surface_system.object_id,ieng->ldwn->over_handle,(VP)&surp,NULL))==RET_YES)
   {
//   if(surp->status.resize_border_pixels!=0)
    {
    if(surp->status.is_maximized!=YES)
     {
     //if(surp->status.is_sizeable==YES)
      {
      aaRectCopy(&prev_rc,&surp->status.rect);
      flag=0;
      if(ieng->ldwn->spot_type==SPOT_Caption)
       {
       if((aa_msrunning-last_drag_ms)>=move_delay)
        {
        aaCordSubtract(&ieng->curr->cord,&ieng->ldwn->over_cord,&cd1);
        if(cd1.x!=surp->status.rect.x) { flag=aaBitSet(flag,0); }
        if(cd1.y!=surp->status.rect.y) { flag=aaBitSet(flag,1); }
        if(flag)
         {
         aaSurfaceCordSet(ieng->ldwn->over_handle,&cd1);
         aaSurfaceStatus(ieng->ldwn->over_handle,&surp->status);
         ieng->surface_moving=ieng->ldwn->over_handle;
         last_drag_ms=aa_msrunning;
         }
        }
       }
      else
      if((ieng->ldwn->spot_type>=SPOT_SizerT&&ieng->ldwn->spot_type<=SPOT_SizerTL)&&surp->status.is_sizeable==YES)
       {
       if((aa_msrunning-last_drag_ms)>=resize_delay)
        {
        aaCordSubtract(&ieng->curr->cord,&ieng->ldwn->cord,&cd1);
        aaRectCopy(&rc1,&surp->status.rect);
        if(ieng->ldwn->spot_type==SPOT_SizerBR) { rc1.h=(N)surp->rect_save.h+cd1.y; }  else
        if(ieng->ldwn->spot_type==SPOT_SizerB)  { rc1.h=(N)surp->rect_save.h+cd1.y; }  else
        if(ieng->ldwn->spot_type==SPOT_SizerBL) { rc1.h=(N)surp->rect_save.h+cd1.y; }  else
        if(ieng->ldwn->spot_type==SPOT_SizerT)  { rc1.h=(N)surp->rect_save.h-cd1.y; }  else
        if(ieng->ldwn->spot_type==SPOT_SizerTR) { rc1.h=(N)surp->rect_save.h-cd1.y; }  else
        if(ieng->ldwn->spot_type==SPOT_SizerTL) { rc1.h=(N)surp->rect_save.h-cd1.y; }
        if(ieng->ldwn->spot_type==SPOT_SizerBR) { rc1.w=(N)surp->rect_save.w+cd1.x; }  else
        if(ieng->ldwn->spot_type==SPOT_SizerBL) { rc1.w=(N)surp->rect_save.w-cd1.x; }  else
        if(ieng->ldwn->spot_type==SPOT_SizerTR) { rc1.w=(N)surp->rect_save.w+cd1.x; }  else
        if(ieng->ldwn->spot_type==SPOT_SizerTL) { rc1.w=(N)surp->rect_save.w-cd1.x; }  else
        if(ieng->ldwn->spot_type==SPOT_SizerL)  { rc1.w=(N)surp->rect_save.w-cd1.x; }  else
        if(ieng->ldwn->spot_type==SPOT_SizerR)  { rc1.w=(N)surp->rect_save.w+cd1.x; }
        if((N)rc1.w<=(N)surp->status.min_size.w) { rc1.w=surp->status.min_size.w;  }
        if((N)rc1.w>=(N)surp->status.max_size.w) { rc1.w=surp->status.max_size.w;  }
        if((N)rc1.h<=(N)surp->status.min_size.h) { rc1.h=surp->status.min_size.h;  }
        if((N)rc1.h>=(N)surp->status.max_size.h) { rc1.h=surp->status.max_size.h;  }
        if(rc1.x!=prev_rc.x) { flag=aaBitSet(flag,0); }
        if(rc1.y!=prev_rc.y) { flag=aaBitSet(flag,1); }
        if(rc1.w!=prev_rc.w) { flag=aaBitSet(flag,2); }
        if(rc1.h!=prev_rc.h) { flag=aaBitSet(flag,3); }
        if(ieng->ldwn->spot_type==SPOT_SizerBL)   {   rc1.x+=(prev_rc.w-rc1.w);   }  else
        if(ieng->ldwn->spot_type==SPOT_SizerL)    {   rc1.x+=(prev_rc.w-rc1.w);   }  else
        if(ieng->ldwn->spot_type==SPOT_SizerT)    {   rc1.y+=(prev_rc.h-rc1.h);   }  else
        if(ieng->ldwn->spot_type==SPOT_SizerTR)   {   rc1.y+=(prev_rc.h-rc1.h);   }  else
        if(ieng->ldwn->spot_type==SPOT_SizerTL)   {   rc1.x+=(prev_rc.w-rc1.w); rc1.y+=(prev_rc.h-rc1.h);  }
        if(flag)
         {
         if(aaRectEqualsRect(&rc1,&surp->status.rect)!=YES)
          {
          if(aaSurfaceRectSet(ieng->ldwn->over_handle,&rc1)!=YES) oof;
          aaSurfaceStatus(ieng->ldwn->over_handle,&surp->status);
          aaRectSet(&rc1,0,0,surp->status.size.w,surp->status.size.h);
          ew=eh=surp->status.resize_border_pixels;
          i=4; aaSurfaceSpotSet(ieng->ldwn->over_handle,i,SPOT_SizerTL,3000,0,0,ew,eh,&sspot);
          i=5; aaSurfaceSpotSet(ieng->ldwn->over_handle,i,SPOT_SizerT,3000,ew,0,rc1.w-(ew*2),eh,&sspot);
          i=6; aaSurfaceSpotSet(ieng->ldwn->over_handle,i,SPOT_SizerTR,3000,rc1.w-ew,0,ew,eh,&sspot);
          i=7; aaSurfaceSpotSet(ieng->ldwn->over_handle,i,SPOT_SizerBL,3000,0,rc1.h-eh,ew,eh,&sspot);
          i=8; aaSurfaceSpotSet(ieng->ldwn->over_handle,i,SPOT_SizerB,3000,ew,rc1.h-eh,rc1.w-(ew*2),eh,&sspot);
          i=9; aaSurfaceSpotSet(ieng->ldwn->over_handle,i,SPOT_SizerBR,3000,rc1.w-ew,rc1.h-eh,ew,eh,&sspot);
          i=10; aaSurfaceSpotSet(ieng->ldwn->over_handle,i,SPOT_SizerL,3000,0,eh,ew,rc1.h-(eh*2),&sspot);
          i=11; aaSurfaceSpotSet(ieng->ldwn->over_handle,i,SPOT_SizerR,3000,rc1.w-ew,eh,ew,rc1.h-(eh*2),&sspot);
          aaSurfaceStatus(ieng->ldwn->over_handle,&surp->status);
          ieng->surface_resizing=ieng->ldwn->over_handle;

          if(surp->status.move_pixels!=0)
           {
           i=1;
           aaSurfaceSpotRemove(ieng->ldwn->over_handle,i);
           aaSurfaceSpotSet(ieng->ldwn->over_handle,i,SPOT_Caption,2990,0,0,surp->status.rect.w,surp->status.move_pixels,&sspot);
           }
          last_drag_ms=aa_msrunning;
          }
         // last_drag_ms was here
         }
        }
       }
      }
     }
    }
   }
  }
 return RET_YES;
 }






#if 0
 B aaInputKeyWait                      (B async)
 {
 B ret;
 _inputengine ie;
 S Q last_ie_seq=F64;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

// oof;
 while(1)
  {
   aaDebugf("%I64d %I64d ok=%i",last_ie_seq,aa.input_system.last_ie.seq,aa.input_system.last_ie.is_ok);
  //if(aaYield(1000)!=YES) { ret=RET_NO; break; }
  if(last_ie_seq==aa.input_system.last_ie.seq)
   {
   if(async) { ret=RET_NO; break; }
   ret=aaYield(1000);
   if(ret!=RET_YES) { break; }
   continue;
   }
  if(aa.input_system.last_ie.is_ok!=YES)
   {
   if(async) { ret=RET_NO; break; }
   ret=aaYield(1000);
   if(ret!=RET_YES) { break; }
   continue;
   }
  aaMemoryCopy(&ie,sizeof(_inputengine),&aa.input_system.last_ie);
  //aaDebugf("#%i static.last_ie_seq=%I64u aa.input_system.last_ie.seq=%I64u",__LINE__,last_ie_seq,aa.input_system.last_ie.seq);
  last_ie_seq=aa.input_system.last_ie.seq;
  if(ie.event_byt[aa_IE_KeyUp])   { aaDebugf("keyup"); ret=RET_YES; break; }
  if(ie.event_byt[aa_IE_KeyHeld]) { aaDebugf("keyhl"); ret=RET_YES; break; }
  if(ie.event_byt[aa_IE_KeyDown]) { aaDebugf("keydn"); ret=RET_YES; break; }
  }
 return ret;
 }

#endif
/*-----------------------------------------------------------------------*/






 B aaDisplaySet                        (_size*size,B bits,B revert)
 {
 DEVMODE dm;
 N res;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bits!=0&&bits!=15&&bits!=16&&bits!=24&&bits!=32) { return RET_BADPARM; }
 if(size!=NULL)
  {
  if(aaSizeIsValid(size)!=YES) { return RET_BADPARM; }
  }
 if(size!=NULL||bits!=0)
  {
  aaMemoryFill(&dm,sizeof(dm),0);
  dm.dmSize=sizeof(dm);
  if(size!=NULL) { dm.dmFields=(DM_PELSWIDTH|DM_PELSHEIGHT); }
  if(bits!=0)    { dm.dmFields|=DM_BITSPERPEL; }
  dm.dmBitsPerPel=bits;
  if(size!=NULL) { dm.dmPelsWidth=size->w;  dm.dmPelsHeight=size->h; }
  res=ChangeDisplaySettings(&dm,0);
  switch(res)
   {
   case DISP_CHANGE_SUCCESSFUL:  break;
   case DISP_CHANGE_RESTART:  oof;  break;
   case DISP_CHANGE_BADFLAGS:   return RET_BADPARM;
   case DISP_CHANGE_FAILED: return RET_FAILED;
   case DISP_CHANGE_BADMODE: return RET_FAILED;
   case DISP_CHANGE_NOTUPDATED: return RET_FAILED;
   default: oof; return RET_FAILED;
   }
  }
 if(revert==YES) { aa.display_system.is_revert=YES; }
 return RET_YES;
 }





 B aaDisplayInfoGet                    (_displayinfo*displayinfo,B level)
 {
 HDC dc;
 HWND wnd,twnd;
 RECT rr;
 H i,todo,pos;
 aa_MONITOR_INFO mi;
 N vars[1+(64*6)];
 W WidthMm,HeightMm;
 DISPLAY_DEVICE ddMon;
 DWORD devMon;
 C DeviceID[_1K];
 D area;
 H tot_sz;
 H tot_big;
 H tot_sml;
 H tot_index;
 H tot_sml_index;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 //aaDebugf("%s level=%i",__func__,level);
 if(displayinfo==NULL) { return RET_BADPARM; }

 aaMemoryFill(displayinfo,sizeof(_displayinfo),0);
 displayinfo->level=level;
 displayinfo->magic=aaHPP(aaDisplayInfoGet);
 if(aaBitGet(level,0))//..level>=8)
  {
 aaRectSet(&displayinfo->virtual_rect,GetSystemMetrics(76),GetSystemMetrics(77),GetSystemMetrics(78),GetSystemMetrics(79));
 aaSizeSet(&displayinfo->screen_size,GetSystemMetrics(SM_CXSCREEN),GetSystemMetrics(SM_CYSCREEN));
 if(aaSizeIsValid(&displayinfo->screen_size)!=YES)   { oof;  return RET_FAILED;   }
 displayinfo->aspect_ratio=(F)displayinfo->screen_size.w/(F)displayinfo->screen_size.h;
 if((dc=GetDC(GetDesktopWindow()))==NULL)   {  oof; return RET_FAILED;   }
 displayinfo->screen_bits=(B)GetDeviceCaps(dc,BITSPIXEL);
 displayinfo->screen_dpi.w=GetDeviceCaps(dc,LOGPIXELSX);
 displayinfo->screen_dpi.h=GetDeviceCaps(dc,LOGPIXELSY);
 displayinfo->screen_vrefresh=GetDeviceCaps(dc,VREFRESH);
 ReleaseDC(GetDesktopWindow(),dc);
 if(displayinfo->screen_bits==0)            {  oof; return RET_FAILED;   }
 if((wnd=aa.input_system.tray_hwnd)==NULL)
  {
  if((wnd=FindWindow("Shell_TrayWnd",NULL))==NULL) { /* oof; */ return RET_FAILED; }
  aa.input_system.tray_hwnd=wnd;
  }
 displayinfo->taskbar_hwnd=wnd;
 if(GetWindowRect(wnd,&rr)==0)              { oof;  return RET_FAILED; }
 WinRectToRect(&rr,&displayinfo->taskbar_rect);
 if((rr.bottom-rr.top)>=(rr.right-rr.left))
  {
  if(rr.left>10) { displayinfo->taskbar_orientation=aa_DIRECTION_E; }
  else           { displayinfo->taskbar_orientation=aa_DIRECTION_W; }
  }
 else
  {
  if(rr.top>10) { displayinfo->taskbar_orientation=aa_DIRECTION_S; }
  else          { displayinfo->taskbar_orientation=aa_DIRECTION_N; }
  }
 if((twnd=FindWindowEx(wnd,NULL,"TrayNotifyWnd",NULL))!=NULL)
  {
  GetWindowRect(twnd,&rr);
  WinRectToRect(&rr,&displayinfo->tray_rect);
  displayinfo->tray_hwnd=wnd;
  }
 else
  {
  if((rr.bottom-rr.top)>=(rr.right-rr.left))
   {
   if(rr.left>10) { aaRectSet(&displayinfo->tray_rect,rr.left,rr.bottom-100,(rr.right-rr.left),100);  }
   else           { aaRectSet(&displayinfo->tray_rect,rr.left,rr.bottom-100,(rr.right-rr.left),100); }
   }
  else
   {
   if(rr.top>10) { aaRectSet(&displayinfo->tray_rect,rr.left-100,rr.top,100,(rr.bottom-rr.top)); }
   else          { aaRectSet(&displayinfo->tray_rect,rr.left-100,rr.top,100,(rr.bottom-rr.top)); }
   }
  }
 }

 if(aaBitGet(level,1))//..level>=8)
  {
  displayinfo->monitor_count=(B)GetSystemMetrics(80);
  aaMemoryFill(vars,sizeof(vars),0);
  displayinfo->monitor_primary_index=F8;
  displayinfo->monitor_largest_index=F8;
  displayinfo->monitor_smallest_index=F8;
  if(displayinfo->monitor_count>=1)
   {
   if(aa.core_system.EnumDisplayMonitors(0,NULL,MonitorEproc,(LPARAM)vars)!=TRUE) { oof; }
   todo=vars[0];
   if(todo>displayinfo->monitor_count) { todo=displayinfo->monitor_count; }
   todo=displayinfo->monitor_count;
   todo=aaNumRoof(todo,aaElementCount(displayinfo->monitor_rect));
   tot_big=0;
   tot_sml=0xffffffff;
   tot_index=0;
   tot_sml_index=0;
   for(i=0;i<todo;i++)
    {
    aaRectSet(&displayinfo->monitor_rect[i],vars[1+(i*6)+2],vars[1+(i*6)+3],vars[1+(i*6)+4]-vars[1+(i*6)+2],vars[1+(i*6)+5]-vars[1+(i*6)+3]);
    //aaDebugf(">> %i,%i,%i,%i",displayinfo->monitor_rect[i].x,displayinfo->monitor_rect[i].y,displayinfo->monitor_rect[i].w,displayinfo->monitor_rect[i].h);
    displayinfo->monitor_handle[i]=vars[1+(i*6)+0];
    tot_sz=displayinfo->monitor_rect[i].w*displayinfo->monitor_rect[i].h;
    if(tot_sz>tot_big) { tot_big=tot_sz; tot_index=i; }
    if(tot_sz<tot_sml) { tot_sml=tot_sz; tot_sml_index=i; }
    if(displayinfo->monitor_handle[i]!=0&&displayinfo->monitor_primary_index==F8)
     {
     aaMemoryFill(&mi,sizeof(mi),0);
     mi.cb_size=sizeof(mi);
     if(aa.core_system.GetMonitorInfoEx((HANDLE)displayinfo->monitor_handle[i],&mi)!=0)
      {
      if((mi.flags&0x00000001))  {  displayinfo->monitor_primary_index=(B)i;     }
      aaMemoryFill(&ddMon,sizeof(ddMon),0);
      ddMon.cb=sizeof(ddMon);
      devMon=0;
      if(aaBitGet(level,2))//level>=9)
       {
       while(EnumDisplayDevices(mi.szDevice,devMon,&ddMon,0))
        {
         //aaDebugf("i=%i %s",i,ddMon.DeviceName);
        if(ddMon.StateFlags&DISPLAY_DEVICE_ACTIVE&&!(ddMon.StateFlags&DISPLAY_DEVICE_MIRRORING_DRIVER))
         {
         if(aaStringFindChar(ddMon.DeviceName,0,&pos,BSLASH_CHAR,YES,3,YES)==YES)
          {
          if(aaStringNICompare(ddMon.DeviceName,mi.szDevice,pos,0)==YES)
           {
           if(aa_DisplayGetSizeForDevID(DeviceID,&WidthMm,&HeightMm))
            {
            aaStringNCopy(displayinfo->monitor_name[i],ddMon.DeviceString,sizeof(displayinfo->monitor_name[0])-1,YES);
            aaSizeSet(&displayinfo->monitor_mm[i],WidthMm,HeightMm);
            displayinfo->monitor_ppmm[i][0]=(D)displayinfo->monitor_rect[i].w/(D)displayinfo->monitor_mm[i].w;
            displayinfo->monitor_ppmm[i][1]=(D)displayinfo->monitor_rect[i].h/(D)displayinfo->monitor_mm[i].h;
            area=((D)displayinfo->monitor_mm[i].w*(D)displayinfo->monitor_mm[i].w);
            area+=((D)displayinfo->monitor_mm[i].h*(D)displayinfo->monitor_mm[i].h);
            displayinfo->monitor_diagonal_mm[i]=sqrt(area);
            break;
            }
           }
          }
         }
        devMon++;
        aaMemoryFill(&ddMon,sizeof(ddMon),0);
        ddMon.cb=sizeof(ddMon);
        }
       }
      }
     }
    }
   displayinfo->monitor_largest_index=(B)tot_index;
   displayinfo->monitor_smallest_index=(B)tot_sml_index;
   }
  }
 for(i=0;i<16;i++)
  {
  if(displayinfo->monitor_handle[i]==0) { continue; }
  if(displayinfo->monitor_rect[i].h==0) { continue; }
  if(displayinfo->monitor_rect[i].w==0) { continue; }
  displayinfo->monitor_aspect[i]=(F)displayinfo->monitor_rect[i].w/(F)displayinfo->monitor_rect[i].h;
  }
 if(SystemParametersInfo(SPI_GETWORKAREA,0,&rr,0)==0) { oow; }
 aaRectFromWinRect(&displayinfo->desktop_rect,&rr);
 return RET_YES;
 }








 B aaDisplayMonitorFromCord            (_displayinfo*displayinfo,_cord*cord,BP monitorindex)
 {
 HMONITOR mon;
 POINT pt;
 H i;
 S B is_init;
 S _displayinfo di;
 _displayinfo*dip;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(monitorindex) { *monitorindex=0; }
 if(is_init==NO)
  {
  if(displayinfo==NULL) { aaDisplayInfoGet(&di,F8); }
  else                  { aaMemoryCopy(&di,sizeof(_displayinfo),displayinfo); }
  is_init=1;
  }

 dip=&di;
 if(displayinfo!=NULL) { dip=displayinfo; }
 if(cord==NULL)
  {
  WinPointSet(&pt,0,0);
  mon=MonitorFromPoint(pt,MONITOR_DEFAULTTOPRIMARY);
  }
 else
  {
  WinPointSet(&pt,cord->x,cord->y);
  mon=MonitorFromPoint(pt,MONITOR_DEFAULTTONEAREST);
  }
 if(monitorindex&&mon==0) { *monitorindex=0; return RET_YES; }
 for(i=0;i<16;i++)  { if((HMONITOR)dip->monitor_handle[i]==mon&&mon!=0) {  break; }  }
 if(monitorindex) { *monitorindex=(B)i; }
 return RET_YES;
 }




 B aaDisplayGammaGet                   (WP gbuf)
 {
 B ret;
 HDC dc;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(gbuf==NULL) { return RET_BADPARM; }
 if((ret=aa_DisplaySystemLoadModules())!=YES) { return ret; }
 if((dc=GetDC(0))==NULL) {  return RET_FAILED; }
 if(aa.display_system.GetDeviceGammaRamp (dc,gbuf)==FALSE) {  ret=RET_NOTSUPPORTED; }
 else                                  {  ret=RET_YES; }
 ReleaseDC(0,dc);
 return ret;
 }




 B aaDisplayGammaSet                   (WP gbuf)
 {
 B ret;
 HDC dc;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(gbuf==NULL) { return RET_BADPARM; }
 if((ret=aa_DisplaySystemLoadModules())!=YES) { return ret; }
 if((dc=GetDC(0))==NULL) {  return RET_FAILED; }
 if(aa.display_system.SetDeviceGammaRamp (dc,gbuf)==FALSE) { ret=RET_NOTSUPPORTED;  }
 else                                  {  ret=RET_YES; }
 ReleaseDC(0,dc);
 return ret;
 }





 B aaDisplayGammaBrightnessSet         (WP gbuf,B brightness)
 {
 H i;
 N v;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(gbuf==NULL) { return RET_BADPARM; }
 for(i=0;i<256;i++)
  {
  v=i*(brightness+128);
  v=aaNumRoof(v,65535);
  gbuf[0+i]=gbuf[256+i]=gbuf[512+i]=(WORD)v;
  }
 return RET_YES;
 }


 B aaDisplayBrightnessSet              (B brightness)
 {
 W gb[_2K];
 B ret;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaDisplayGammaGet(gb))!=YES) { return ret; }
 if((ret=aaDisplayGammaBrightnessSet(gb,brightness))!=YES) { return ret; }
 if((ret=aaDisplayGammaSet(gb))!=YES) { return ret; }
 return RET_YES;
 }




 B aaDisplayBrightnessFlash            (B count,H sleep)
 {
 W gam[_2K];
 H i;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaDisplayGammaGet(gam);
 sleep=aaNumClamp(sleep,1,100);
 for(i=0;i<(H)count;i++)
  {
  aaDisplayGammaBrightnessSet(gam,0);
  aaDisplayGammaSet(gam);
  aaSleep(sleep);
  aaDisplayGammaBrightnessSet(gam,128);
  aaDisplayGammaSet(gam);
  aaSleep(sleep);
  }
 return RET_YES;
 }




 B aaDisplayPixelGet                   (_cord*cord,_rgba*pn)
 {
 HDC dc;
 COLORREF rpix;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(cord==NULL) { return RET_BADPARM; }
 if(pn==NULL) { return RET_BADPARM; }
 if((dc=GetDC(0))==NULL) { return RET_FAILED; }
 rpix=GetPixel(dc,cord->x,cord->y);
 ReleaseDC(0,dc);
 if((Y)rpix==CLR_INVALID) { return RET_BOUNDS;  }
 pn->r=GetRValue(rpix);
 pn->g=GetGValue(rpix);
 pn->b=GetBValue(rpix);
 pn->a=255;
 return RET_YES;
 }




 B aaDisplayPixelSet                   (_cord*cord,_rgba*pn)
 {
 HDC dc;
 COLORREF pix,rpix;
 _rgba pb;
 N a1,a2;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(cord==NULL) { return RET_BADPARM; }
 if(pn==NULL) { return RET_BADPARM; }
 if((dc=GetDC(0))==NULL) { return RET_FAILED; }
 if(pn->a==255)
  {
  pix=RGB(pn->r,pn->g,pn->b);
  rpix=SetPixel(dc,cord->x,cord->y,pix);
  ReleaseDC(0,dc);
  if((N)rpix==-1) {  return RET_FAILED; }
  return RET_YES;
  }
 rpix=GetPixel(dc,cord->x,cord->y);
 pb.r=GetRValue(rpix);
 pb.g=GetGValue(rpix);
 pb.b=GetBValue(rpix);
 a1=(N)(255-pn->a);
 a2=(N)(pn->a);
 pb.b=(B)(((a1*pb.b)+(a2*pn->b))>>8);
 pb.g=(B)(((a1*pb.g)+(a2*pn->g))>>8);
 pb.r=(B)(((a1*pb.r)+(a2*pn->r))>>8);
 pb.a=255;
 pix=RGB(pb.r,pb.g,pb.b);
 rpix=SetPixel(dc,cord->x,cord->y,pix);
 ReleaseDC(0,dc);
 if((N)rpix==-1) {  return RET_FAILED; }
 return RET_YES;
 }




 B aaDisplayInfoToString               (_displayinfo*displayinfo,VP str)
 {
 H i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 aaStringNull(str);
 if(displayinfo==NULL) { return RET_BADPARM; }
 aaStringAppendf(str,"screen_size=%ix%i\n",displayinfo->screen_size.w,displayinfo->screen_size.h);
 aaStringAppendf(str,"screen_bits=%i\n",displayinfo->screen_bits);
 aaStringAppendf(str,"screen_dpi=%i,%i\n",displayinfo->screen_dpi.w,displayinfo->screen_dpi.h);
 aaStringAppendf(str,"screen_vreshresh=%i\n",displayinfo->screen_vrefresh);
 aaStringAppendf(str,"taskbar_rect=%i,%i,%i,%i\n",displayinfo->taskbar_rect.x,displayinfo->taskbar_rect.y,displayinfo->taskbar_rect.w,displayinfo->taskbar_rect.h);
 aaStringAppendf(str,"taskbar_orientation=%i ");
 switch(displayinfo->taskbar_orientation)
  {
  case aa_DIRECTION_E: aaStringAppendf(str,"E\n"); break;
  case aa_DIRECTION_W: aaStringAppendf(str,"W\n"); break;
  case aa_DIRECTION_N: aaStringAppendf(str,"N\n"); break;
  case aa_DIRECTION_S: aaStringAppendf(str,"S\n"); break;
  default: aaStringAppendf(str,"?\n"); break;
  }
 aaStringAppendf(str,"taskbar_hwnd=0x%08x\n",displayinfo->taskbar_hwnd);
 aaStringAppendf(str,"tray_rect=%i,%i,%i,%i\n",displayinfo->tray_rect.x,displayinfo->tray_rect.y,displayinfo->tray_rect.w,displayinfo->tray_rect.h);
 aaStringAppendf(str,"tray_hwnd=0x%08x\n",displayinfo->tray_hwnd);
// aaStringAppendf(str,"is_wide_screen=%s\n",aaBoolString(displayinfo->is_wide_screen));
// aaStringAppendf(str,"is_tall_screen=%s\n",aaBoolString(displayinfo->is_tall_screen));
 aaStringAppendf(str,"aspect_ratio=%.2f\n",displayinfo->aspect_ratio);
 aaStringAppendf(str,"monitor_count=%i\n",displayinfo->monitor_count);
 aaStringAppendf(str,"monitor_largest_index=%i\n",displayinfo->monitor_largest_index);
 aaStringAppendf(str,"monitor_primary_index=%i\n",displayinfo->monitor_primary_index);
 for(i=0;i<displayinfo->monitor_count;i++)
  {
  aaStringAppendf(str,"monitor:[%i]\n",i);
  aaStringAppendf(str,"monitor_rect=%i,%i,%i,%i\n",displayinfo->monitor_rect[i].x,displayinfo->monitor_rect[i].y,displayinfo->monitor_rect[i].w,displayinfo->monitor_rect[i].h);
  aaStringAppendf(str,"monitor_handle=0x%08x\n",displayinfo->monitor_handle[i]);
  aaStringAppendf(str,"monitor_aspect=%.2f\n",displayinfo->monitor_aspect[i]);
  aaStringAppendf(str,"monitor_name=%s\n",displayinfo->monitor_name[i]);
  aaStringAppendf(str,"monitor_mm=%i,%i\n",displayinfo->monitor_mm[i].w,displayinfo->monitor_mm[i].h);
  aaStringAppendf(str,"monitor_ppmm=%.2f,%.2f\n",displayinfo->monitor_ppmm[i][0],displayinfo->monitor_ppmm[i][1]);
  aaStringAppendf(str,"monitor_diagonal_mm=%.2f\n",displayinfo->monitor_diagonal_mm[i]);
  }
 aaStringAppendf(str,"virtual_rect=%i,%i,%i,%i\n",displayinfo->virtual_rect.x,displayinfo->virtual_rect.y,displayinfo->virtual_rect.w,displayinfo->virtual_rect.h);
 aaStringAppendf(str,"desktop_rect=%i,%i,%i,%i\n",displayinfo->desktop_rect.x,displayinfo->desktop_rect.y,displayinfo->desktop_rect.w,displayinfo->desktop_rect.h);
 return RET_YES;
 }



 B aaDisplayMonitorPowerSet            (B state)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(state) { SendMessage(HWND_BROADCAST,WM_SYSCOMMAND,SC_MONITORPOWER,(LPARAM)-1); }
 else      { SendMessage(HWND_BROADCAST,WM_SYSCOMMAND,SC_MONITORPOWER,(LPARAM)2);  }
 return RET_YES;
 }



 B aaDisplayPowerBrightnessGet         (BP acordc,BP aclev,BP dclev)
 {
 BOOL br;
 HANDLE hdev;
 H bytes;
 B buf[256];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(acordc) { *acordc=F8; }
 if(aclev)  { *aclev=F8;  }
 if(dclev)  { *dclev=F8;  }
 hdev=CreateFile(TEXT("\\\\.\\LCD"),0,FILE_SHARE_READ|FILE_SHARE_WRITE,NULL,OPEN_EXISTING,0,NULL);
 if(hdev==INVALID_HANDLE_VALUE) { return RET_FAILED; }
 br=DeviceIoControl(hdev,IOVIDQRY_DISPLAY_BRIGHT,NULL,0,buf,sizeof(buf),&bytes,NULL);
 CloseHandle(hdev);
 if(br==0)  { oow; return RET_FAILED; }
 if(bytes>=1)  { if(acordc) *acordc=buf[0]; }
 if(bytes>=2)  { if(aclev)  *aclev=buf[1];  }
 if(bytes>=3)  { if(dclev)  *dclev=buf[2];  }
 return RET_YES;
 }


 B aaDisplayPowerBrightnessSet         (B acordc,B aclev,B dclev)
 {
 BOOL br;
 HANDLE hdev;
 H bytes;
 B buf[3];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(acordc==0||acordc>3) { return RET_BADPARM; }
 if(aclev>=100) { aclev=100; }
 if(dclev>=100) { dclev=100; }
 buf[0]=(B)acordc;
 buf[1]=(B)aclev;
 buf[2]=(B)dclev;
 hdev=CreateFile(TEXT("\\\\.\\LCD"),0,FILE_SHARE_READ|FILE_SHARE_WRITE,NULL,OPEN_EXISTING,0,NULL);
 if(hdev==INVALID_HANDLE_VALUE) { return RET_FAILED; }
 br=DeviceIoControl(hdev,IOVIDSET_DISPLAY_BRIGHT,buf,3,NULL,0,&bytes,NULL);
 CloseHandle(hdev);
 if(br==0) { oow; return RET_FAILED; }
 return RET_YES;
 }



 B aaDisplayToMm                       (_displayinfo*displayinfo,B monitorindex,_cord*pixel,DP xmm,DP ymm)
 {
 B mi;
 D xr,yr;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(displayinfo==NULL) { return RET_BADPARM; }
 if(displayinfo->magic!=aaHPP(aaDisplayInfoGet)) { return RET_NOTINITIALIZED; }
 if(xmm) { *xmm=0; }
 if(ymm) { *ymm=0; }
 if(monitorindex>=aaElementCount(displayinfo->monitor_rect)) { return RET_BOUNDS; }
 mi=monitorindex;
 if(displayinfo->monitor_mm[mi].w==0)    { return RET_FAILED; }
 if(displayinfo->monitor_mm[mi].h==0)    { return RET_FAILED; }
 if(displayinfo->monitor_ppmm[mi][0]==0) { return RET_FAILED; }
 if(displayinfo->monitor_ppmm[mi][1]==0) { return RET_FAILED; }
 if(pixel==NULL) { return RET_BADPARM; }
 xr=displayinfo->monitor_ppmm[mi][0];
 yr=displayinfo->monitor_ppmm[mi][1];
 xr=(D)pixel->x/xr;
 yr=(D)pixel->y/yr;
 if(xmm!=NULL) { *xmm=xr; }
 if(ymm!=NULL) { *ymm=yr; }
 return RET_YES;
 }






 B aaDisplayFromMm                     (_displayinfo*displayinfo,B monitorindex,D xmm,D ymm,_cord*pixel)
 {
 B mi;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(displayinfo==NULL) { return RET_BADPARM; }
 if(displayinfo->magic!=aaHPP(aaDisplayInfoGet)) { return RET_NOTINITIALIZED; }
 if(pixel) { pixel->x=pixel->y=0; }
 if(monitorindex>=aaElementCount(displayinfo->monitor_rect)) { return RET_BOUNDS; }
 mi=monitorindex;
 if(displayinfo->monitor_mm[mi].w==0)    { return RET_FAILED; }
 if(displayinfo->monitor_mm[mi].h==0)    { return RET_FAILED; }
 if(displayinfo->monitor_ppmm[mi][0]==0) { return RET_FAILED; }
 if(displayinfo->monitor_ppmm[mi][1]==0) { return RET_FAILED; }
 if(pixel==NULL) { return RET_BADPARM; }
 xmm=xmm*displayinfo->monitor_ppmm[mi][0];
 ymm=ymm*displayinfo->monitor_ppmm[mi][1];
 pixel->x=(N)xmm;
 pixel->y=(N)ymm;
 return RET_YES;
 }



 B aaDisplayCapture                    (HWND hwnd,_rect*r1,B incmouse,VP img)
 {
 BITMAPINFO bmi;
 BP dib_data;
 _size s1;
 _rect rr1;
 HWND source_hwnd;
 HDC source_dc;
 HDC capture_dc;
 HBITMAP bmp;
 _rgba*pn;
 H xx;
 B vflip=YES;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(hwnd==0) { hwnd=GetDesktopWindow(); }
 source_hwnd=hwnd;
 if(r1==NULL) { aaRectSet(&rr1,0,0,320,240); }
 else         { aaRectCopy(&rr1,r1); }
 aaSizeSet(&s1,rr1.w,rr1.h);
  source_dc=GetDC(source_hwnd);
 capture_dc=CreateCompatibleDC(source_dc);
 WinBmpInfoSet(&bmi,rr1.w,(vflip)?-rr1.h:rr1.h,32,NO);
 bmp=CreateDIBSection(capture_dc,(LPBITMAPINFO)&bmi,DIB_RGB_COLORS,(V**)&dib_data,NULL,0);
 SelectObject(capture_dc,bmp);
 StretchBlt(capture_dc,0,0,rr1.w,rr1.h,source_dc,rr1.x,rr1.y,rr1.w,rr1.h,(incmouse)?(CAPTUREBLT|SRCCOPY):(SRCCOPY));
 aaMemoryCopy(img,s1.w*s1.h*4,dib_data);
 pn=(_rgba*)img;
 for(xx=0;xx<(s1.w*s1.h);xx++)  {  pn[xx].a=255;  }
 ReleaseDC(source_hwnd,source_dc);
 DeleteObject(bmp);
 DeleteDC(capture_dc);
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/




 B aaUpdateAreaReset                   (_updatearea*updatearea)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(updatearea==NULL) { return RET_BADPARM; }
 aaMemoryFill(updatearea,sizeof(_updatearea),0);
 updatearea->magic=aa_UPDATEAREA_MAGIC;
 return RET_YES;
 }





 B aaUpdateAreaAdd                     (_updatearea*updatearea,_rect*rect)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(updatearea==NULL) { return RET_BADPARM; }
 if(updatearea->magic!=aa_UPDATEAREA_MAGIC) { oof; return RET_FAILED; }
 if(rect!=NULL)
  {
  if((ret=aaRectIsValid(rect))!=YES) { oof; return ret; }
  if(updatearea->state==NO)  {  aaRectCopy(&updatearea->rect,rect);   }
  else                       {   aaRectAdd(&updatearea->rect,rect,&updatearea->rect);   }
  updatearea->state=YES;
  }
 return RET_YES;
 }




 B aaUpdateAreaRemove                  (_updatearea*updatearea,_rect*rect)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(updatearea==NULL) { return RET_BADPARM; }
 if(updatearea->magic!=aa_UPDATEAREA_MAGIC) { return RET_FAILED; }
 if(rect!=NULL)
  {
  if((ret=aaRectIsValid(rect))!=YES) { return ret; }
  }
 return RET_YES;
 }


/*-----------------------------------------------------------------------*/


 B aaAudioCountGet                     (BP playcount,BP reccount)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(playcount!=NULL)  {  *playcount=(B)waveOutGetNumDevs();  }
 if(reccount!=NULL)   {  *reccount=(B)waveInGetNumDevs();  }
 return RET_YES;
 }





 B aaAudioNameGet                      (B id,B rec,VP name)
 {
 B count;
 WAVEINCAPS capi;
 WAVEOUTCAPS capo;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(name!=NULL) { aaStringNull(name); }
 if(id>=10) { return RET_NOTFOUND; }
 if(rec)
  {
  aaAudioCountGet(NULL,&count);
  if(id>=count) { return RET_NOTFOUND; }
  if(waveInGetDevCaps(id,&capi,sizeof(capi))!=MMSYSERR_NOERROR)   {   return RET_FAILED;   }
  if(name) {  aaStringNCopy(name,capi.szPname,64,YES); }
  }
 else
  {
  aaAudioCountGet(&count,NULL);
  if(id>=count) { return RET_NOTFOUND; }
  if(waveOutGetDevCaps(id,&capo,sizeof(capo))!=MMSYSERR_NOERROR)   {   return RET_FAILED;   }
  if(name) { aaStringNCopy(name,capo.szPname,64,YES); }
  }
 return RET_YES;
 }






 B aaAudioModeSet                      (_audiomode*audiomode,H frequency,B bits,B channels)
 {
 B ret;
 //_audiomode am;
 //B m;
// H r;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(audiomode==NULL) { return RET_BADPARM; }
 audiomode->frequency=frequency;
 audiomode->bits=bits;
 audiomode->channels=channels;
 ret=aa_AudioSystemModeVerify(audiomode,YES);
 if(ret!=RET_YES) { return RET_FAILED; }
 return RET_YES;
 }




 B aaAudioModeCopy                     (_audiomode*audiomode,_audiomode*saudiomode)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(audiomode==NULL) { return RET_BADPARM; }
 if(saudiomode==NULL) { return RET_BADPARM; }
 audiomode->frequency=saudiomode->frequency;
 audiomode->bits=saudiomode->bits;
 audiomode->channels=saudiomode->channels;
 audiomode->rate=saudiomode->rate;
 audiomode->bps=saudiomode->bps;
 audiomode->mode=saudiomode->mode;
 return RET_YES;
 }





 B aaAudioModeIsValid                  (_audiomode*audiomode)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(audiomode==NULL) { return RET_BADPARM; }
 ret=aa_AudioSystemModeVerify(audiomode,NO);
 if(ret!=RET_YES) { return RET_FAILED; }
 return RET_YES;
 }





 B aaAudioModeEqualsAudioMode          (_audiomode*audiomode,_audiomode*audiomode2)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(audiomode==NULL) { return RET_BADPARM; }
 if(audiomode2==NULL) { return RET_BADPARM; }
 if((ret=aaAudioModeIsValid(audiomode))!=RET_YES)  { return RET_FAILED; }
 if((ret=aaAudioModeIsValid(audiomode2))!=RET_YES) { return RET_FAILED; }
 if(audiomode->frequency!=audiomode2->frequency) { return RET_NO; }
 if(audiomode->bits!=audiomode2->bits)           { return RET_NO; }
 if(audiomode->channels!=audiomode2->channels)   { return RET_NO; }
 //if(audiomode->rate!=audiomode2->rate)           { return RET_NO; }
 if(audiomode->bps!=audiomode2->bps)             { return RET_NO; }
 if(audiomode->mode!=audiomode2->mode)           { return RET_NO; }
 return RET_YES;
 }






 B aaAudioSamplesPerBeat               (_audiomode*audiomode,D bpm,DP samples)
 {
 B ret;
 D tempo,dub;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaAudioModeIsValid(audiomode))!=YES) { return ret; }
 if(bpm<=0.0) { return RET_BADPARM; }
// if(ms<0.0) { return RET_BADPARM; }
 if(samples) { *samples=0; }
 tempo=bpm/60.0;
 //dur=ms/1000.0;
 dub=(D)audiomode->frequency;
 dub=dub/tempo;
 //dub=dub*dur;
 if(samples) { *samples=dub; }
 return RET_YES;
 }



//=====================================================



 B aaAudioToFloats                     (_audiomode*audiomode,H isamples,B mode,VP idata,FP odata)
 {
 //B ret;
 H i;
 register D dub;
 register IP pcm16;
 CP pcm8;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 ///if((ret=aaAudioModeIsValid(audiomode))!=YES) { return ret; }
 if(isamples==0) { return RET_YES; }
 if(idata==NULL) { return RET_BADPARM; }
 if(odata==NULL) { return RET_BADPARM; }
 pcm16=(IP)idata;
 pcm8=(CP)idata;
 if(audiomode->bits==8)
  {
  if(audiomode->channels==1)
    {
    for(i=0;i<isamples;i++)
     {
     dub=(D)pcm8[(i)];
     dub=dub/128.0;
     if(dub>+1.0) dub=+1.0;
     if(dub<-1.0) dub=-1.0;
     if(mode==0) { odata[(i)]=(F)dub; }
     }
    }
   else
   if(audiomode->channels==2)
    {
    for(i=0;i<isamples;i++)
     {
     dub=(D)pcm8[(i*2)+0];
     dub=dub/128.0;
     if(dub>+1.0) dub=+1.0;
     if(dub<-1.0) dub=-1.0;
     odata[(i*2)+0]=(F)dub;
     dub=(D)pcm8[(i*2)+1];
     dub=dub/128.0;
     if(dub>+1.0) dub=+1.0;
     if(dub<-1.0) dub=-1.0;
     odata[(i*2)+1]=(F)dub;
     }
    }
  }
 else
  if(audiomode->bits==16)
   {
   if(audiomode->channels==1)
    {
    for(i=0;i<isamples;i++)
     {
     dub=(D)pcm16[(i)];
     dub=dub/32768.0;
     if(dub>+1.0) dub=+1.0;
     if(dub<-1.0) dub=-1.0;
//     odata[(i)]=(F)dub;
     if(mode==0) { odata[i]=(F)dub; }
     else
     if(mode==3) { odata[i]=(F)dub; }
     }
    }
   else
   if(audiomode->channels==2)
    {
    for(i=0;i<isamples;i++)
     {
     dub=(D)pcm16[(i*2)+0];
     dub=dub/32768.0;
     if(dub>+1.0) dub=+1.0;
     else
     if(dub<-1.0) dub=-1.0;
     if(mode==0) { odata[(i*2)+0]=(F)dub; }
     else
     if(mode==3) { odata[(i)]=(F)dub; }


     dub=(D)pcm16[(i*2)+1];
     dub=dub/32768.0;
     if(dub>+1.0) dub=+1.0;
     else
     if(dub<-1.0) dub=-1.0;
     if(mode==0)  odata[(i*2)+1]=(F)dub;
     else
     if(mode==3)  odata[isamples+i]=(F)dub;

     }
    }
   }
 return RET_YES;
 }



 B aaAudioFromFloats                   (_audiomode*audiomode,H isamples,B mode,FP idata,VP odata)
 {
 //B ret;
 H i;
 register D dub;
 register IP pcm16;
 CP pcm8;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 ///if((ret=aaAudioModeIsValid(audiomode))!=YES) { return ret; }
 if(isamples==0) { return RET_YES; }
 if(idata==NULL) { return RET_BADPARM; }
 if(odata==NULL) { return RET_BADPARM; }
 pcm16=(IP)odata;
 pcm8=(CP)odata;

 if(audiomode->bits==8)
  {
 if(audiomode->channels==1)
  {
  for(i=0;i<isamples;i++)
   {
   dub=idata[(i)];
     dub=dub*128.0;
     if(dub>+127.0) dub=+127.0;
     if(dub<-128.0) dub=-128.0;
   pcm8[(i)]=(I)dub;
   }
  }
 else
 if(audiomode->channels==2)
  {
  for(i=0;i<isamples;i++)
   {
   dub=idata[(i*2)+0];
   dub=dub*128.0;
   if(dub>+127.0) dub=+127.0;
   if(dub<-128.0) dub=-128.0;
   pcm8[(i*2)+0]=(I)dub;
   dub=idata[(i*2)+1];
   dub=dub*128.0;
   if(dub>+127.0) dub=+127.0;
   if(dub<-128.0) dub=-128.0;
   pcm8[(i*2)+1]=(I)dub;
   }
  }

  }
 else
 if(audiomode->bits==16)
  {
 if(audiomode->channels==1)
  {
  for(i=0;i<isamples;i++)
   {
   if(mode==0) dub=idata[i];
   else
   if(mode==3) dub=idata[i];

  // dub=idata[(i)];
     dub=dub*32768.0;
     if(dub>+32767.0) dub=+32767.0;
     if(dub<-32768.0) dub=-32768.0;
   pcm16[(i)]=(I)dub;
   }
  }
 else
 if(audiomode->channels==2)
  {
  for(i=0;i<isamples;i++)
   {
   if(mode==0) dub=idata[(i*2)+0];
   else
   if(mode==3) dub=idata[i];
   dub=dub*32768.0;
   if(dub>+32767.0) dub=+32767.0;
   else
   if(dub<-32768.0) dub=-32768.0;
   pcm16[(i*2)+0]=(I)dub;
   if(mode==0) dub=idata[(i*2)+1];
   else
   if(mode==3) dub=idata[isamples+i];
   dub=dub*32768.0;
   if(dub>+32767.0) dub=+32767.0;
   else
   if(dub<-32768.0) dub=-32768.0;
   pcm16[(i*2)+1]=(I)dub;
   }
  }
  }
 return RET_YES;
 }


///=====================================================




 B aaAudioConverterInit                (_audioconverter*audioconverter,_audiomode*imode,_audiomode*omode)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(audioconverter==NULL) { return RET_BADPARM; }
 if(imode==NULL) { return RET_BADPARM; }
 if(omode==NULL) { return RET_BADPARM; }
 if((ret=aaAudioModeIsValid(imode))!=YES) { return ret; }
 if((ret=aaAudioModeIsValid(omode))!=YES) { return ret; }
 aaMemoryFill(audioconverter,sizeof(_audioconverter),0);
 aaMemoryCopy(&audioconverter->i_mode,sizeof(_audiomode),imode);
 aaMemoryCopy(&audioconverter->o_mode,sizeof(_audiomode),omode);
 audioconverter->magic=aaHPP(aaAudioConverterInit);
 return RET_YES;
 }








 B aaAudioConverterProcess             (_audioconverter*audioconverter,H isamples,VP idata,D tempo,HP osamples,VP odata)
 {
 D oratio;
 D iratio;
 D oaccum;
 D iaccum;
 register H i_pos;
 register H o_pos;
 //H prev_o_pos;
 //H prev_i_pos;
 //N dif_o_pos;
 //N dif_i_pos;
 //N r;
 H todo,sodo;
 IP s_16m;
 BP s_8m;
 D lv,rv;
 I temp_i;
 H k,j;
 IP pcmi;
 CP pcmc;
 H bytes;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(audioconverter==NULL) { return RET_BADPARM; }
 if(audioconverter->magic!=aaHPP(aaAudioConverterInit)) { return RET_NOTINITIALIZED; }
 if(idata==NULL) {  return RET_BADPARM; }
 todo=isamples;


 if(tempo==1.0)
  {
  //if(aaAudioModeEqualsAudioMode(&audioconverter->i_mode,&audioconverter->o_mode)==YES)
  if(audioconverter->i_mode.mode==audioconverter->o_mode.mode)
   {
   if(osamples) { *osamples=isamples;  }
   bytes=isamples*audioconverter->i_mode.bps;
   if(odata) { aaMemoryCopy(odata,bytes,idata); }
   return RET_YES;
   }
  }


 if(tempo==0.0)  {  oof;  }
 else
 if(tempo==1.0)  {  iratio=(D)audioconverter->i_mode.frequency/(audioconverter->o_mode.frequency/tempo);  oratio=1.0;  }
 else
 if(tempo>1.0)   {  oratio=(D)(audioconverter->o_mode.frequency/tempo)/(audioconverter->i_mode.frequency);  iratio=1.0;  }
 else
 if(tempo<1.0)   {  iratio=(D)audioconverter->i_mode.frequency/(audioconverter->o_mode.frequency/tempo); oratio=1.0;  }

 iaccum=0;
 oaccum=0;
 i_pos=0;
 o_pos=0;
 s_16m=(IP)idata;
 s_8m=(BP)idata;
 //prev_o_pos=o_pos;
 //prev_i_pos=i_pos;
  while(1)
   {
   if(i_pos>=todo)    {    break;    }
//   lv=rv=0;

   if(audioconverter->i_mode.channels==2&&audioconverter->i_mode.bits==16) {   lv=(D)(s_16m[(i_pos*2)+0]);    rv=(D)(s_16m[(i_pos*2)+1]);    }
   else
   if(audioconverter->i_mode.channels==1&&audioconverter->i_mode.bits==8)  {   temp_i=((s_8m[(i_pos*1)+0])-128)<<8;   rv=lv=(D)temp_i;    }
   else
   if(audioconverter->i_mode.channels==2&&audioconverter->i_mode.bits==8)  {   temp_i=((s_8m[(i_pos*2)+0])-128)<<8;   lv=(D)temp_i;   temp_i=((s_8m[(i_pos*2)+1])-128)<<8;    rv=(D)temp_i;    }
   else
   if(audioconverter->i_mode.channels==1&&audioconverter->i_mode.bits==16) {   rv=lv=(D)(s_16m[(i_pos*1)+0]);    }

 //  aa.audio_system.ch_block[(o_pos*2)+0]=rv;
  // aa.audio_system.ch_block[(o_pos*2)+1]=lv;
   if(lv<-32760) { lv=-32760; }
   if(lv>+32760) { lv=+32760; }
   if(rv<-32760) { rv=-32760; }
   if(rv>+32760) { rv=+32760; }

   o_pos*=2;
   aa.audio_system.ch_block[o_pos++]=rv;
   aa.audio_system.ch_block[o_pos]=lv;

   oaccum+=oratio;   o_pos=(H)oaccum;
   iaccum+=iratio;   i_pos=(H)iaccum;
   }


 if(odata==NULL)  {  *osamples=o_pos;  return RET_YES;  }
 pcmi=(IP)odata;
 pcmc=(CP)odata;
 sodo=o_pos;
 if(audioconverter->o_mode.bits==8)
  {
  if(audioconverter->o_mode.channels==1)
   {
   for(k=0;k<sodo;k++)
    {
    temp_i=(I)aa.audio_system.ch_block[(k*2)+0];
    temp_i=(temp_i>>8)-128;
    pcmc[(k*1)+0]=(C)temp_i;
    }
   }
  else
  if(audioconverter->o_mode.channels==2)
   {
   for(k=0;k<sodo;k++)
    {
    temp_i=(I)aa.audio_system.ch_block[(k*2)+0];
    temp_i=(temp_i>>8)-128;
    pcmc[(k*2)+0]=(C)temp_i;
    temp_i=(I)aa.audio_system.ch_block[(k*2)+1];
    temp_i=(temp_i>>8)-128;
    pcmc[(k*2)+1]=(C)temp_i;
    }
   }
  }
 else
 if(audioconverter->o_mode.bits==16)
  {
  if(audioconverter->o_mode.channels==1)
   {
   for(k=0;k<sodo;k++)
    {
    temp_i=(I)aa.audio_system.ch_block[(k*2)+0];
    pcmi[(k*1)+0]=(I)temp_i;
    }
   }
  else
  if(audioconverter->o_mode.channels==2)
   {
   j=0;
   for(k=0;k<sodo;k++)
    {
    pcmi[j]=(I)aa.audio_system.ch_block[j]; j++;
    pcmi[j]=(I)aa.audio_system.ch_block[j]; j++;
    //temp_i=(I)aa.audio_system.ch_block[(k*2)+0];
    ///pcmi[(k*2)+0]=(I)temp_i;
    ///temp_i=(I)aa.audio_system.ch_block[(k*2)+1];
    ///pcmi[(k*2)+1]=(I)temp_i;
    }
   }
  }
 *osamples=(sodo);
 return RET_YES;
 }




//=====================================================



 B aaAudioPitchTempoGet                (_aapitchtempo*aapitchtempo,N octave,N note,D fine,B mode)
 {
 D sem;
 D oct;
 F pv;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aapitchtempo==NULL) { return RET_BADPARM; }
 if(octave>7) { return RET_BOUNDS; }
 aapitchtempo->octave=octave;
 if(note>11)  { return RET_BOUNDS; }
 aapitchtempo->fine=fine;
 aapitchtempo->note=note;
 aapitchtempo->pitch=1.0;
 aapitchtempo->tempo=1.0;
 oct=(D)octave-4;
 aapitchtempo->piano=(N)(oct*12)+note;
 sem=(oct*12)+note;
 sem=sem+fine;
 pv=pow(2.,sem/12.);
 if(aaBitGet(mode,0))  {  aapitchtempo->pitch=pv;  }
 if(aaBitGet(mode,1))  {  aapitchtempo->tempo=1.0/pv;  }
 return RET_YES;
 }
/*


 B aaAudioPitchTempoGet                (_aapitchtempo*aapitchtempo,N octave,N note,D fine)
 {
 D sem;
 D oct;
 F pv;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aapitchtempo==NULL) { return RET_BADPARM; }
 if(octave>7) { return RET_BOUNDS; }
 aapitchtempo->octave=octave;
 if(note>11)  { return RET_BOUNDS; }
 aapitchtempo->fine=fine;
 aapitchtempo->note=note;
 aapitchtempo->pitch=1.0;
 aapitchtempo->tempo=1.0;
 oct=(D)octave-4;//-2;
 aapitchtempo->piano=(N)(oct*12)+note;
 sem=(oct*12)+note;
 sem=sem+fine;
 pv=pow(2.,sem/12.);
 aapitchtempo->pitch=pv;
 aapitchtempo->tempo=1.0/pv;
 //aaDebugf("octave=%i note=%i pitch=%.2f",octave,note,pv);
 return RET_YES;
 }
*/






 B aaAudioPitchShiftInit               (_aapitchshift*aapitchshift,N framesize,B oversample)
 {
 N i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aapitchshift==NULL) { return RET_BADPARM; }
 if(framesize<32) { return RET_BOUNDS; }
 if(framesize>AA_PITCHSHIFT_MAX_FRAMESIZE) { return RET_BOUNDS; }
 if(aaMathIsPowerOfTwo((N)framesize)!=YES) { return RET_BADPARM; }
 if(oversample>4) { return RET_BOUNDS; }
 aaMemoryFill(aapitchshift,sizeof(_aapitchshift),0);
 aapitchshift->magic=aaHPP(aaAudioPitchShiftInit);
 aapitchshift->frame_size=framesize;
 if(oversample==0) {  aapitchshift->osamp=1; }  else
 if(oversample==1) {  aapitchshift->osamp=2; }  else
 if(oversample==2) {  aapitchshift->osamp=4; }  else
 if(oversample==3) {  aapitchshift->osamp=6; }  else
 if(oversample==4) {  aapitchshift->osamp=8; }
 for(i=0;i<framesize;i++)
  {
  aapitchshift->window[i]=-.5*cos(2.*aaPi*(D)i/(D)framesize)+.5;
  }
 return RET_YES;
 }



 B aaAudioPitchShift                   (_aapitchshift*aapitchshift,F amount,N isamps,F rate,FP indata,FP outdata)
 {
 D magn,phase,tmp,real,imag,signx;
 D freqPerBin,expct;
 N i,k,qpd,index,inFifoLatency,stepSize,fftframesize2;
 D window;
 //D am;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aapitchshift==NULL) { return RET_BADPARM; }
 if(aapitchshift->magic!=aaHPP(aaAudioPitchShiftInit)) { return RET_NOTINITIALIZED; }
 if(amount==1.0)
  {
  aaMemoryCopy(outdata,sizeof(F)*isamps*1,indata);
  return RET_YES;
  }
  //         am=amount;

 fftframesize2=aapitchshift->frame_size/2;
 stepSize=aapitchshift->frame_size/aapitchshift->osamp;
 freqPerBin=rate/(D)aapitchshift->frame_size;
 //expct=2.*aaPi*(D)stepSize/(D)aapitchshift->frame_size;
 expct=aaPi2*(D)stepSize/(D)aapitchshift->frame_size;
 inFifoLatency=aapitchshift->frame_size-stepSize;
 if(aapitchshift->rover==0) aapitchshift->rover=inFifoLatency;
 for(i=0;i<isamps;i++)
  {
  aapitchshift->fifo_in[aapitchshift->rover]=indata[i];
  outdata[i]=aapitchshift->fifo_out[aapitchshift->rover-inFifoLatency];
  aapitchshift->rover++;
  if(aapitchshift->rover>=aapitchshift->frame_size)
   {
   aapitchshift->rover=inFifoLatency;
   for(k=0;k<aapitchshift->frame_size;k++)
    {
    //window=-.5*cos(2.*aaPi*(D)k/(D)aapitchshift->frame_size)+.5;
    window=aapitchshift->window[k];
    aapitchshift->fft_worksp[2*k]=aapitchshift->fifo_in[k]*window;
    aapitchshift->fft_worksp[2*k+1]=0.;
    }
   aa_AudioSystemFFT(aapitchshift->fft_worksp,aapitchshift->frame_size,-1);
   for(k=0;k<=fftframesize2;k++)
    {
    real=aapitchshift->fft_worksp[2*k];
    imag=aapitchshift->fft_worksp[2*k+1];
    magn=2.*sqrt(real*real+imag*imag);
    phase=0.;
    if(imag!=0.)
     {
     if(imag>0.)   signx=+1.;
     else          signx=-1.;
     if(real==0.)  phase=signx*aaPi/2.0;
     else          phase=atan2(imag,real);
     }
    tmp=phase-aapitchshift->last_phase[k];
    aapitchshift->last_phase[k]=phase;
    tmp-=(D)k*expct;
    qpd=tmp/aaPi;
    if(qpd>=0) qpd+=qpd&1;
    else       qpd-=qpd&1;
    tmp-=aaPi*(D)qpd;
    //tmp=aapitchshift->osamp*tmp/(2.*aaPi);
    tmp=aapitchshift->osamp*tmp/(aaPi2);
    tmp=(D)k*freqPerBin+tmp*freqPerBin;
    aapitchshift->ana_magn[k]=magn;
    aapitchshift->ana_freq[k]=tmp;
    }
   aaMemoryFill(aapitchshift->syn_magn,aapitchshift->frame_size*sizeof(F),0);
   aaMemoryFill(aapitchshift->syn_freq,aapitchshift->frame_size*sizeof(F),0);
   for(k=0;k<=fftframesize2;k++)
    {
    index=k*(amount);
    if(index<=fftframesize2)
     {
     aapitchshift->syn_magn[index]+=aapitchshift->ana_magn[k];
     aapitchshift->syn_freq[index]=aapitchshift->ana_freq[k]*amount;
     }

    }
   for(k=0;k<=fftframesize2;k++)
    {
    magn=aapitchshift->syn_magn[k];
    tmp=aapitchshift->syn_freq[k];
    tmp-=(D)k*freqPerBin;
    tmp/=freqPerBin;
    //tmp=2.*aaPi*tmp/aapitchshift->osamp;
    tmp=aaPi2*tmp/aapitchshift->osamp;
    tmp+=(D)k*expct;
    aapitchshift->sum_phase[k]+=tmp;
    phase=aapitchshift->sum_phase[k];
    aapitchshift->fft_worksp[2*k]=magn*cos(phase);
    aapitchshift->fft_worksp[2*k+1]=magn*sin(phase);
    }
   for(k=aapitchshift->frame_size+2;k<2*aapitchshift->frame_size;k++)
    {
    aapitchshift->fft_worksp[k]=0.;
    }
   aa_AudioSystemFFT(aapitchshift->fft_worksp,aapitchshift->frame_size,1);
   for(k=0;k<aapitchshift->frame_size;k++)
    {
    window=aapitchshift->window[k];
    //window=-.5*cos(2.*aaPi*(D)k/(D)aapitchshift->frame_size)+.5;
    aapitchshift->output_accum[k]+=2.*window*aapitchshift->fft_worksp[2*k]/(fftframesize2*aapitchshift->osamp);
    }
   for(k=0;k<stepSize;k++)
    {
    aapitchshift->fifo_out[k]=aapitchshift->output_accum[k];
    }
   aaMemoryMove(aapitchshift->output_accum,aapitchshift->frame_size*sizeof(F),aapitchshift->output_accum+stepSize);
   for(k=0;k<inFifoLatency;k++)
    {
    aapitchshift->fifo_in[k]=aapitchshift->fifo_in[k+stepSize];
    }
   }
  }
 return RET_YES;
 }






 B aaAudioNoteToFrequency              (N oct,N note,DP freq)
 {
 D res;
 //D base_a4;
 D base_c4;
 N n;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(oct>8)   { return RET_BOUNDS; }
 if(note>11) { return RET_BOUNDS; }
 //base_a4=440.0;
 base_c4=261.626;
 res=-1;
 n=(oct*12)+note;
 if(n<0||n>120) { oof; }
 //res=base_a4*pow(2.0,(n-57)/12.0);
 res=base_c4*pow(2.0,(n-(4*12))/12.0);
 if(freq) { *freq=res; }
 return RET_YES;
 }




 B aaAudioFrequencyToNote              (D freq,NP oct,NP note)
 {
 D res;
 //D base_a4;
 D base_c4;
 N n;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 //base_a4=440.0;
 base_c4=261.626;
 ///res=round(12*log2(freq/base_a4))+57;
 res=round(12*log2(freq/base_c4))+(4*12);//+57;
 n=(N)res;
 if(oct)  { *oct=n/12;  }
 if(note) { *note=n%12; }
 return RET_YES;
 }


//=====================================================





 B aaAudioCreate                       (HP handle,B id,B rec,_audiomode*audiomode,H blocksize,H maxblocks,H maxchannels,B(*proc)(H,_audiostatus*,H,H,VP))
 {
 B ret;
 _aa_audioobject*audp;
 _audiochannel*chan;
 MMRESULT mr;
 H i,ms,elapsed;
 C txt[65];
 BP mem;
 H len;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaAudioModeIsValid(audiomode))!=RET_YES) { return RET_FAILED; }
 ///if((ret=aa_AudioSystemModeVerify(audiomode))!=RET_YES) { return ret; }
 rec&=1;
 if(blocksize<120)  { return RET_BOUNDS; }
 if(maxblocks==0)   { return RET_BOUNDS; }
 if(rec&&maxchannels!=0) { return RET_BOUNDS; }
 if(maxchannels>32) { return RET_BOUNDS; }

 if((ret=aaAudioNameGet(id,rec,txt))!=RET_YES) { return ret; }
 if((ret=aa_ObjectCreate(aa.audio_system.object_id,handle,(VP)&audp))!=RET_YES) { oops;  return ret; }
 audp->self_handle=*handle;
 rec&=1;
 if(rec==NO)
  {
  audp->status.is_record=NO;
  audp->status.id=id;
  audp->status.block_size=blocksize;
  audp->status.max_blocks=maxblocks;
  aaStringCopy(audp->status.name,txt);
  ret=aaMemoryCopy(&audp->status.mode,sizeof(_audiomode),audiomode);
  WinWaveFormatExFromAudioMode(&audp->wfx,audiomode);
  if((ret=aaQueCreate(&audp->que_handle))!=RET_YES) { oops; Boop; }
  if((ret=aaQueStatus(audp->que_handle,&audp->que_status))!=RET_YES) { oops; Boop; }
  len=blocksize*audiomode->bps;
  if((ret=aa_MemoryAllocate((VP)&mem,len*maxblocks,"WaveAlloc",NO))!=RET_YES) { oops; }
  aaCast(audp->wave_buf,BP,mem);
  for(i=0;i<maxblocks;i++)  {   WinWaveHdrSet(&audp->wave_hdr[i],(LPSTR)&audp->wave_buf[(i*len)],len,0,i,0);   }
  if((mr=waveOutOpen((LPHWAVEOUT)&audp->handle,(UINT)id,&audp->wfx,(DWORD)aa_AudioSystemOutProc,(DWORD)*handle,CALLBACK_FUNCTION))!=MMSYSERR_NOERROR)
   {
   if((ret=aa_MemoryRelease(audp->wave_buf))!=YES) { oops; }
   aaQueDestroy(audp->que_handle);
   audp->que_handle=0;
   audp->wave_buf=NULL;
   aa_ObjectDestroy(aa.audio_system.object_id,*handle);
   *handle=0;
   if(mr==MMSYSERR_NODRIVER) { return RET_NOTFOUND; }
   return RET_FAILED;
   }
  for(i=0;i<audp->status.max_blocks;i++)
   {
   if(waveOutPrepareHeader((HWAVEOUT)audp->handle,&audp->wave_hdr[i],sizeof(WAVEHDR))!=MMSYSERR_NOERROR) { oof; break; }
   }
  if((mr=mixerOpen(&audp->status.mixer_device,(UINT)audp->handle,0,0,MIXER_OBJECTF_HWAVEOUT))!=MMSYSERR_NOERROR) { oof; }
  if(aa_AudioSystemGetLineControls((VP)&audp,&audp->ctrl_master_line,(H)-1,0,&audp->ctrl_master_volume,&audp->ctrl_master_mute)!=YES) oof;
  }
 else //////////////////////////////////////////////++++++++++++++++++++++++++++++++++++++++++++++++
  {
  audp->status.is_record=YES;
  audp->status.id=id;
  audp->status.block_size=blocksize;
  audp->status.max_blocks=maxblocks;
  aaStringCopy(audp->status.name,txt);
  aaMemoryCopy(&audp->status.mode,sizeof(_audiomode),audiomode);
  WinWaveFormatExFromAudioMode(&audp->wfx,audiomode);
  if((ret=aaQueCreate(&audp->que_handle))!=RET_YES) { oops;  Boop; }
  if((ret=aaQueStatus(audp->que_handle,&audp->que_status))!=RET_YES) { oops; Boop; }
  len=blocksize*audiomode->bps;
  if((ret=aa_MemoryAllocate((VP)&mem,len*maxblocks,"WaveAlloc",NO))!=RET_YES) { oops; }
  aaCast(audp->wave_buf,BP,mem);
  for(i=0;i<maxblocks;i++) {  WinWaveHdrSet(&audp->wave_hdr[i],(LPSTR)&audp->wave_buf[i*len],len,0,i,0);   }
  if((mr=waveInOpen(&audp->handle,id,&audp->wfx,(H)aa_AudioSystemInProc,*handle,CALLBACK_FUNCTION))!=MMSYSERR_NOERROR)
   {
   if((ret=aa_MemoryRelease(audp->wave_buf))!=YES) { oops; }
   aaQueDestroy(audp->que_handle);
   audp->que_handle=0;
   audp->wave_buf=NULL;
   aa_ObjectDestroy(aa.audio_system.object_id,*handle);
   *handle=0;
   if(mr==MMSYSERR_NODRIVER) { return RET_NOTFOUND; }
   return RET_FAILED;
   }
  for(i=0;i<audp->status.max_blocks; i++)
   {
   if(waveInPrepareHeader(audp->handle,&audp->wave_hdr[i],sizeof(WAVEHDR))!=MMSYSERR_NOERROR) { oof; break; }
   if(waveInAddBuffer(audp->handle,&audp->wave_hdr[i],sizeof(WAVEHDR))!=MMSYSERR_NOERROR) { oof; break; }
   }
  if((mr=mixerOpen(&audp->status.mixer_device,(UINT)audp->handle,0,0,MIXER_OBJECTF_HWAVEIN))!=MMSYSERR_NOERROR) { oof; }
  if(aa_AudioSystemGetLineControls((VP)&audp,&audp->ctrl_master_line,(H)-1,0,&audp->ctrl_master_volume,&audp->ctrl_master_mute)!=YES) oof;
  }
 aaTimerTikGet(&ms);
 logg("wainting for open_receive message");
 while(1)
  {
  if(audp->is_openreceived==YES) break;
  aaTimerTikElapsed(ms,&elapsed);
  if(elapsed>5000) { aaNote(0,"audio opn tout waitn 4 WIM_OPEN msg");  break;   }
  aaSleep(2);
  }
 audp->status.div=(D)(audiomode->frequency)/1000000.0;
 aaAudioReset(*handle);
 audp->status.wave_device=audp->handle;
 audp->self_handle=*handle;
 audp->status.proc=proc;
 if(audp->status.is_record==NO&&maxchannels!=0)
  {
  audp->status.channel_count=maxchannels;
  if((ret=aaMemoryAllocate((VP)&audp->status.channel,sizeof(_audiochannel)*maxchannels))!=YES) { oops; }
  for(i=0;i<audp->status.channel_count;i++)
   {
   chan=(_audiochannel*)&audp->status.channel[i];
   chan->magic=1212;
   //chan->is_active=YES;
   //audp->status.channel_active_count++;
   aaQueCreate(&chan->que.handle);
   aaQueStatus(chan->que.handle,&chan->que.status);
   }
  }
 return RET_YES;
 }




 B aaAudioDestroy                      (H handle)
 {
 B ret;
 _aa_audioobject*audp;
 _audiochannel*chan;
 B isprot;
 H i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.audio_system.object_id,handle,(VP)&audp,&isprot))!=RET_YES) { return ret; }
 if(isprot==YES) { return RET_FORBIDDEN; }
 if(audp->status.is_record==NO)
  {
  waveOutReset((HWAVEOUT)audp->handle);
  for(i=0;i<audp->status.max_blocks;i++)
   {
   waveOutUnprepareHeader((HWAVEOUT)audp->handle,&audp->wave_hdr[i],sizeof(WAVEHDR));
   }
  waveOutReset((HWAVEOUT)audp->handle);
  waveOutClose((HWAVEOUT)audp->handle);
  if(audp->wave_buf!=NULL) {  if((ret=aa_MemoryRelease(audp->wave_buf))!=YES) { oops; }  audp->wave_buf=NULL; }
  if(audp->que_handle!=0)
   {
   if(aaQueDestroy(audp->que_handle)!=RET_YES)
    {
    logg("que destroy failed");
    }
   audp->que_handle=0;
   }

  if(audp->status.channel_count)
   {
   for(i=0;i<audp->status.channel_count;i++)
    {
    chan=(_audiochannel*)&audp->status.channel[i];
    if(chan->magic==0) { continue; }
    if(chan->que.handle!=0) { aaQueDestroy(chan->que.handle); chan->que.handle=0; }
    aaMemoryFill(chan,sizeof(_audiochannel),0);
    }
   aaMemoryRelease(audp->status.channel);
   audp->status.channel=NULL;
   audp->status.channel_count=0;
   }
  }
 else // record
  {
  waveInReset((HWAVEIN)audp->handle);
  for(i=0;i<audp->status.max_blocks;i++)
   {
   waveInUnprepareHeader((HWAVEIN)audp->handle,&audp->wave_hdr[i],sizeof(WAVEHDR));
   }
  waveInReset((HWAVEIN)audp->handle);
  waveInClose((HWAVEIN)audp->handle);
  if(audp->wave_buf!=NULL) {  if((ret=aa_MemoryRelease(audp->wave_buf))!=YES) { oops; }  audp->wave_buf=NULL; }
  if(audp->que_handle!=0)
   {
   if(aaQueDestroy(audp->que_handle)!=RET_YES)
    {
    logg("que destroy failed");
    }
   audp->que_handle=0;
   }
  }
 if(audp->status.mixer_device!=0)
  {
  mixerClose(audp->status.mixer_device);
  }
 aa_ObjectDestroy(aa.audio_system.object_id,handle);
 return RET_YES;
 }










 B aaAudioStatus                       (H handle,_audiostatus*audiostatus)
 {
 B ret;
 _aa_audioobject*audp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.audio_system.object_id,handle,(VP)&audp,NULL))!=RET_YES) { return ret; }
 aa_AudioStatus((VP)&audp,YES);
 if(audiostatus) {   aaMemoryCopy(audiostatus,sizeof(_audiostatus),&audp->status);   }
 return RET_YES;
 }





 B aaAudioReset                        (H handle)
 {
 B ret;
 _aa_audioobject*audp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.audio_system.object_id,handle,(VP)&audp,NULL))!=RET_YES) { return ret; }
 if(audp->status.is_record==YES)
  {
  if(waveInReset(audp->handle)!=MMSYSERR_NOERROR) { oof; Boop; return RET_FAILED; }
  audp->status.is_paused=YES;
  }
 else
  {
  if(waveOutReset((HWAVEOUT)audp->handle)!=MMSYSERR_NOERROR) { oof; Boop; return RET_FAILED; }
  if(waveOutPause((HWAVEOUT)audp->handle)!=MMSYSERR_NOERROR) { oof;  return RET_FAILED; }
  audp->status.is_paused=YES;
  }
 aaQueDiscard(audp->que_handle,0xffffffff);
 aaQueStatus(audp->que_handle,&audp->que_status);
 audp->status.mcs=0;
 audp->status.samples_qued=0;
 audp->status.sample_position=0;
 audp->status.samples_written=0;
 ///audp->status.samples_surplus=0;
 //if((ret=aa_AudioSystemUpdateSamplePosition((VP)&audp))!=RET_YES) oops;
///ashot
 aa_AudioStatus((VP)&audp,0);
 return RET_YES;
 }








 B aaAudioPause                        (H handle,B state)
 {
 B ret;
 _aa_audioobject*audp;
 MMRESULT mr;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.audio_system.object_id,handle,(VP)&audp,NULL))!=RET_YES) { return ret; }
 if(audp->status.is_record==YES)
  {
  if(state==YES)
   {
   if(audp->status.is_paused==NO)
    {
    if(waveInStop(audp->handle)!=MMSYSERR_NOERROR) oof;
    audp->status.is_paused=YES;
    }
   }
  else
   {
   if(audp->status.is_paused==YES)
    {
    if(waveInStart(audp->handle)!=MMSYSERR_NOERROR) oof;
    audp->status.is_paused=NO;
    }
   }
  return RET_YES;
  }
 if(state==YES)
  {
  if(audp->status.is_paused==YES) { return RET_YES; }
  if((mr=waveOutPause((HWAVEOUT)audp->handle))!=MMSYSERR_NOERROR)
   {
   logg("mr=%i",mr);
   return RET_FAILED;
   }
  audp->status.is_paused=YES;
  }
 else
  {
  if(audp->status.is_paused==NO) { return RET_YES; }
  if((mr=waveOutRestart((HWAVEOUT)audp->handle))!=MMSYSERR_NOERROR)
   {
   oof;
   prevent_warning(mr);
   aaLog(-1,"mr=%i",mr);
   return RET_FAILED;
   }
  audp->status.is_paused=NO;
  }
 return RET_YES;
 }





 B aaAudioWrite                        (H handle,H samples,VP data)
 {
 B ret;
 _aa_audioobject*audp;
 H bytes;
 H todo;
 B block[_16K];
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.audio_system.object_id,handle,(VP)&audp,NULL))!=RET_YES) { return ret; }
 if(samples==0)  {  return RET_YES;  }
 //bytes=samples*audp->status.mode.bps;
 ///if((N)bytes<0||bytes>_128MEG) aaNote(0,"Tried 2 wrt smples=%i byts=%i",samples,bytes);
 if(data==NULL)
  {
  aaMemoryFill(block,_8K,0);
  while(1)
   {
   if(samples==0) break;
   todo=samples;
   todo=aaNumRoof(todo,_2K);
   if(todo==0) break;
   if((ret=aaQueWrite(audp->que_handle,todo,block))!=RET_YES) { oops; return ret; }
   audp->status.samples_written+=(todo);///audp->status.mode.bps);
   samples-=todo;
   }
  }
 else
  {
  bp=(BP)data;
  while(1)
   {
   if(samples==0) break;
   todo=samples;
   todo=aaNumRoof(todo,_2K);
   if(todo==0) break;
   bytes=todo*audp->status.mode.bps;
   if((ret=aaQueWrite(audp->que_handle,bytes,bp))!=RET_YES) { oops; return ret; }
   audp->status.samples_written+=(todo);
   samples-=todo;
   bp+=bytes;
   }
  }
 aaQueStatus(audp->que_handle,&audp->que_status);
///ashot
 aa_AudioStatus((VP)&audp,0);
 return RET_YES;
 }







 B aaAudioRead                         (H handle,H samples,VP data)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaAudioPeek(handle,0,samples,data))!=RET_YES) {  return ret; }
 if((ret=aaAudioDiscard(handle,samples))!=RET_YES) {  return ret; }
 return RET_YES;
 }






 B aaAudioPeek                         (H handle,H sample,H samples,VP data)
 {
 B ret;
 _aa_audioobject*audp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.audio_system.object_id,handle,(VP)&audp,NULL))!=RET_YES) { return ret; }
 if(samples==0) { return RET_YES; }
 if(data==NULL) { return RET_BADPARM; }
 if((ret=aaQuePeek(audp->que_handle,sample*audp->status.mode.bps,samples*audp->status.mode.bps,data))!=RET_YES) { return ret; }
 return RET_YES;
 }




 B aaAudioDiscard                      (H handle,H samples)
 {
 B ret;
 _aa_audioobject*audp;
 H bytes;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.audio_system.object_id,handle,(VP)&audp,NULL))!=RET_YES) { return ret; }
 if(samples==0xffffffff) { bytes=audp->que_status.bytes/audp->status.mode.bps; bytes=bytes*audp->status.mode.bps; }
 else             { bytes=samples*audp->status.mode.bps; }
 if(bytes==0) { return RET_YES; }
 if((ret=aaQueDiscard(audp->que_handle,bytes))!=RET_YES) { return ret; }
 aaQueStatus(audp->que_handle,&audp->que_status);
 audp->status.samples_written+=(bytes/audp->status.mode.bps);
 //aa_AudioSystemProcessQues((VP)&audp);
 //if((ret=aa_AudioSystemUpdateSamplePosition((VP)&audp))!=RET_YES) oops;
///ashot
 aa_AudioStatus((VP)&audp,0);
 return RET_YES;
 }








 B aaAudioMix                          (H handle,H channel,H samples,VP data,F amp)
 {
 B ret;
 _aa_audioobject*audp;
 _audiochannel*chan;
 B block[_16K];
 F flo[_64K];
 H todo,bytes,i;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.audio_system.object_id,handle,(VP)&audp,NULL))!=RET_YES) { return ret; }
 if(audp->status.is_record) { return RET_FAILED; }
 if(channel>=audp->status.channel_count) { return RET_BOUNDS; }
 if(samples==0) {  return RET_YES; }
 chan=(_audiochannel*)&audp->status.channel[channel];
 if(chan->magic==0) { oof; return RET_FAILED; }
 if(chan->que.handle==0) { oof; }
 bytes=samples*audp->status.mode.bps;
 if(data==NULL||amp<=0.0)
  {
  aaMemoryFill(block,_8K,0);
  while(1)
   {
   todo=samples;
   if(todo==0) { break; }
   todo=aaNumRoof(todo,_2K);
   bytes=todo*audp->status.mode.bps;
   if((ret=aaQueWrite(chan->que.handle,bytes,block))!=RET_YES) { oops; return ret; }
   samples-=todo;
   }
  }
 else
  {
  bp=(BP)data;
  while(1)
   {
   todo=samples;
   if(todo==0) { break; }
   todo=aaNumRoof(todo,_1K);
   bytes=todo*audp->status.mode.bps;
   aaMemoryCopy(block,bytes,bp);
   if(amp!=1.0)
    {
    if((ret=aaAudioToFloats(&audp->status.mode,todo,3,block,flo))!=YES) { oops; }
    for(i=0;i<todo;i+=1)   {   flo[i]*=amp;    flo[todo+i]*=amp;     }
    if((ret=aaAudioFromFloats(&audp->status.mode,todo,3,flo,block))!=YES) { oops; }
    }
   if((ret=aaQueWrite(chan->que.handle,bytes,block))!=RET_YES) { oops; return ret; }
   samples-=todo;
   bp+=bytes;
   }
  }
 aaQueStatus(chan->que.handle,&chan->que.status);
   chan->samples_qued=chan->que.status.bytes/audp->status.mode.bps;
   chan->total_samples_written=chan->que.status.total_bytes_written/audp->status.mode.bps;
   chan->total_samples_read=chan->que.status.total_bytes_read/audp->status.mode.bps;
   chan->total_blocks_read=chan->total_samples_read/audp->status.block_size;
   chan->total_blocks_written=chan->total_samples_written/audp->status.block_size;
   chan->blocks_qued=chan->samples_qued/audp->status.block_size;
 aa_AudioStatus((VP)&audp,0);
 return RET_YES;
 }




 B aaAudioLock                         (H handle,B state)
 {
 B ret;
 _aa_audioobject*audp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.audio_system.object_id,handle,(VP)&audp,NULL))!=RET_YES) { return ret; }
 if(audp->status.is_record) { return RET_FAILED; }
 state&=1;
 audp->status.is_mix_locked=state;
///ashot
 aa_AudioStatus((VP)&audp,0);
 return RET_YES;
 }











 B aaAudioMuteSet                      (H handle,B state)
 {
 B ret;
 _aa_audioobject*audp;
 N val;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.audio_system.object_id,handle,(VP)&audp,NULL))!=RET_YES) { return ret; }
 if(state)  {  val=1;  }
 else       {  val=0;  }
 if(aa_AudioSystemSetMute((VP)&audp,audp->ctrl_master_mute,&val)!=YES) { return RET_FAILED; }
 audp->status.is_mute=(B)val;
 return RET_YES;
 }





 B aaAudioVolumeSet                    (H handle,W volume)
 {
 B ret;
 _aa_audioobject*audp;
 N val;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.audio_system.object_id,handle,(VP)&audp,NULL))!=RET_YES) { return ret; }
 val=(N)volume;
 if(aa_AudioSystemSetVolume((VP)&audp,audp->ctrl_master_volume,&val)!=YES) { return RET_FAILED; }
 audp->status.volume=volume;
 return RET_YES;
 }





/*-----------------------------------------------------------------------*/



 B aaWavLoad                           (_wav*wav,_audiomode*audiomode,VP filename)
 {
 B ret;
 H fh;
 _filestreamstatus fs;
 BP mem;
 C ch[5];
 N itmp,bps,skip;
 I stmp,align;
 _audiomode am;
 D ratio;
 //B odata[_64K];
 H dbytes,samples,todo,soff,doff;
 H osamples;
 _audioconverter acon;
 _wav dwav;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(wav==NULL)  { return RET_BADPARM; }
 aaMemoryFill(wav,sizeof(_wav),0);
 wav->magic=aaHPP(aaWavLoad);
 aaStringCopyf(wav->file_name,"%s",filename);
 if(filename==NULL) { oof; return RET_BADPARM; }
 if((ret=aaFileStreamCreate(&fh,filename,NO,3,3,0,NO))!=RET_YES) { aaNote(0,"%s %s",arets,filename); return ret; }
 if((ret=aaFileStreamOffsetSet(fh,12))!=RET_YES) { aaFileStreamDestroy(fh);  return ret;  }
 if((ret=aaFileStreamRead(fh,4,ch))!=RET_YES)    { aaFileStreamDestroy(fh);  return ret;  }
 ch[4]=NULL_CHAR;
 while(1)
  {
  if(aaStringCompare(ch,"fmt ",NULL)==RET_YES)            { break; }
  if((ret=aaFileStreamRead(fh,4,&itmp))!=RET_YES)         { aaFileStreamDestroy(fh);  return ret;  }
  if((ret=aaFileStreamOffsetAdjust(fh,(Q)itmp))!=RET_YES) { aaFileStreamDestroy(fh);  return ret;  }
  if((ret=aaFileStreamRead(fh,4,ch))!=RET_YES)            { aaFileStreamDestroy(fh);  return ret;  }
  }
 if((ret=aaFileStreamRead(fh,4,&skip))!=RET_YES) { aaFileStreamDestroy(fh); return ret;  }
 skip-=16;
 if((ret=aaFileStreamRead(fh,2,&stmp))!=RET_YES) { aaFileStreamDestroy(fh); return ret;  }
 if(stmp!=1)                                     { aaFileStreamDestroy(fh); return RET_FAILED; }
 if((ret=aaFileStreamRead(fh,2,&stmp))!=RET_YES) { aaFileStreamDestroy(fh); return ret;  }
 if(stmp>2)                                      { aaFileStreamDestroy(fh); return RET_FAILED; }
 am.channels=stmp;
 if((ret=aaFileStreamRead(fh,4,&itmp))!=RET_YES) { aaFileStreamDestroy(fh); return ret;  }
 if(itmp!=8000&&itmp!=16000&&itmp!=11025&&itmp!=22050&&itmp!=32000&&itmp!=44100&&itmp!=48000) { aaFileStreamDestroy(fh); return RET_FAILED;  }
 am.frequency=itmp;
 if((ret=aaFileStreamRead(fh,4,&bps))!=RET_YES)   { aaFileStreamDestroy(fh); return ret;  }
 am.bps=(B)bps;
 if((ret=aaFileStreamRead(fh,2,&align))!=RET_YES) { aaFileStreamDestroy(fh); return ret;  }
 if(align!=1&&align!=2&&align!=4&&align!=6)       { aaFileStreamDestroy(fh); return RET_FAILED; }
 if((ret=aaFileStreamRead(fh,2,&stmp))!=RET_YES)  { aaFileStreamDestroy(fh); return ret;  }
 if(stmp!=32&&stmp!=16&&stmp!=8)                  { aaFileStreamDestroy(fh); return RET_FAILED; }
 am.bits=stmp;
 if(skip>0)
  {
  if((ret=aaFileStreamOffsetAdjust(fh,(G)skip))!=RET_YES) { aaFileStreamDestroy(fh); return ret;  }
  }
 aaAudioModeSet(&am,am.frequency,am.bits,am.channels);
 if((ret=aaAudioModeIsValid(&am))!=YES)           { aaFileStreamDestroy(fh); return RET_FAILED;  }
 if((ret=aaFileStreamRead(fh,4,ch))!=RET_YES)     { aaFileStreamDestroy(fh); return ret;  }
 while(1)
  {
  if(aaStringCompare(ch,"data",NULL)==RET_YES) { break; }
  if((ret=aaFileStreamRead(fh,4,&itmp))!=RET_YES)         { aaFileStreamDestroy(fh); return ret;  }
  if((ret=aaFileStreamOffsetAdjust(fh,(G)itmp))!=RET_YES) { aaFileStreamDestroy(fh); return ret;  }
  if((ret=aaFileStreamRead(fh,4,ch))!=RET_YES)            { aaFileStreamDestroy(fh); return ret;  }
  }
 if((ret=aaFileStreamRead(fh,4,&itmp))!=RET_YES)    { aaFileStreamDestroy(fh); return ret;  }
 aaFileStreamStatus(fh,&fs);
 if((ret=aaMemoryAllocate((VP)&mem,itmp))!=RET_YES) { aaFileStreamDestroy(fh); return ret;  }
 aaMemoryNameSet(mem,"wavitm");
 if((ret=aaFileStreamRead(fh,itmp,mem))!=RET_YES)   { aaFileStreamDestroy(fh); aaMemoryRelease(mem); return ret;  }
 wav->samples=itmp/align;
 aaFileStreamDestroy(fh);
 wav->ptr=mem;

 aaMemoryCopy(&wav->o_mode,sizeof(_audiomode),&am);
 wav->duration=(D)wav->samples/(D)wav->o_mode.frequency;

 if(audiomode==NULL)  {  aaAudioModeCopy(&wav->a_mode,&wav->o_mode);  }
 else                 {  aaAudioModeCopy(&wav->a_mode,audiomode);  }

 if(aaAudioModeEqualsAudioMode(&wav->a_mode,&wav->o_mode)==NO)
  {
  wav->is_converted=YES;
  if(wav->o_mode.rate>wav->a_mode.rate)   {   ratio=(D)wav->o_mode.rate/(D)wav->a_mode.rate; }
  else                                    {   ratio=(D)wav->a_mode.rate/(D)wav->o_mode.rate; }
  dbytes=wav->samples;
  ratio=dbytes*ratio;
  dbytes=(H)ratio;
  dbytes=dbytes*wav->a_mode.bps;
  dbytes+=_32K;
  if((ret=aaAudioConverterInit(&acon,&wav->o_mode,&wav->a_mode))!=YES) { oops; }
  aaMemoryCopy(&dwav,sizeof(dwav),wav);
//  aaMemoryCopy(&dwav.a_mode,sizeof(_audiomode),audiomode);
  if((ret=aaMemoryAllocate((VP)&dwav.ptr,dbytes))!=YES) { oops; }
  samples=wav->samples;
  soff=doff=0;
  while(1)
   {
   if(samples==0) break;
   todo=aaNumRoof(samples,_2K);
   ///if((ret=aaAudioConverterProcess(&acon,todo,&wav->ptr[soff],1.0,&osamples,odata))!=YES) { oops; }
   ///aaMemoryCopy(&dwav.ptr[doff],osamples*wav->a_mode.bps,odata);
   if((ret=aaAudioConverterProcess(&acon,todo,&wav->ptr[soff],1.0,&osamples,&dwav.ptr[doff]))!=YES) { oops; }
   ///aaMemoryCopy(&dwav.ptr[doff],osamples*wav->a_mode.bps,odata);
   doff+=(osamples*wav->a_mode.bps);
   soff+=(todo*wav->o_mode.bps);
   samples-=todo;
   }
  if(aaWavRelease(wav)!=YES) { oof; }
  aaMemoryCopy(wav,sizeof(_wav),&dwav);
  }

 return RET_YES;
 }






 B aaWavRelease                        (_wav*wav)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(wav==NULL)  { return RET_BADPARM; }
 if(wav->magic!=aaHPP(aaWavLoad)) { return RET_NOTINITIALIZED; }
 if(wav->ptr) { aaMemoryRelease(wav->ptr); }
 aaMemoryFill(wav,sizeof(_wav),0);
 return RET_YES;
 }



 B aaWavAlias                          (_wav*wav,_wavalias*wavalias,B resetoffset,N oct,N note)
 {
 H off;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(wav==NULL)  { return RET_BADPARM; }
 if(wav->magic!=aaHPP(aaWavLoad)) { return RET_NOTINITIALIZED; }
 if(wavalias==NULL) { return RET_BADPARM; }
 off=wav->offset;
 aaMemoryFill(wavalias,sizeof(_wavalias),0);
 wavalias->magic=aaHPP(aaWavAlias);
 if(!resetoffset) { wavalias->offset=off; }
 if(aaAudioConverterInit(&wavalias->acon,&wav->a_mode,&wav->a_mode)!=YES) oof;
 if(aaAudioPitchTempoGet(&wavalias->ptem,oct,note,0,1)!=YES) { oof; }
 aaMemoryCopy(&wavalias->wav,sizeof(_wav),wav);
 return RET_YES;
 }





 B aaWavRead                           (_wav*wav,H samples,VP data)
 {
 H cando,todo,bytes,offs;
 BP od;
 G parm0,parm1;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(wav==NULL)  { return RET_BADPARM; }
 if(wav->magic!=aaHPP(aaWavLoad)) { return RET_NOTINITIALIZED; }
 od=(BP)data;
 parm0=*(GP)&wav->user_data[1];
 parm1=*(GP)&wav->user_data[9];
 UNUSE(parm0);
 UNUSE(parm1);
 while(1)
  {
  if(samples==0) { break; }
  cando=wav->samples-wav->offset;
  if(cando)
   {
   todo=aaNumRoof(samples,cando);
   todo=aaNumRoof(todo,_1K);
   bytes=todo*wav->a_mode.bps;
   offs=wav->offset*wav->a_mode.bps;
   aaMemoryCopy(od,bytes,&wav->ptr[offs]);
   wav->offset+=todo;
   samples-=todo;
   od=od+(todo*wav->a_mode.bps);
   }
  else
   {
   todo=samples;
   todo=aaNumRoof(todo,_1K);
   bytes=todo*wav->a_mode.bps;
   aaMemoryFill(od,bytes,0);
   samples-=todo;
   od=od+(todo*wav->a_mode.bps);
   }

  /*
  if(wav->user_data[0]==aa_WAVMODE_CrossLoop)
   {
   todo=aaNumRoof(samples,cando);
   todo=aaNumRoof(todo,_1K);
   bytes=todo*wav->mode.bps;
   offs=wav->offset*wav->mode.bps;
   aaMemoryCopy(od,bytes,&wav->ptr[offs]);
   wav->offset+=todo;
   if(wav->offset>=wav->samples||(parm1>0&&wav->offset>=(H)parm1))
    {
    wav->offset=(H)parm0;
    }
   //wav->offset%=(wav->samples);
   samples-=todo;
   od=od+(todo*wav->mode.bps);
   }
  else
  if(wav->user_data[0]==aa_WAVMODE_Loop)
   {
   todo=aaNumRoof(samples,cando);
   todo=aaNumRoof(todo,_1K);
   bytes=todo*wav->mode.bps;
   offs=wav->offset*wav->mode.bps;
   aaMemoryCopy(od,bytes,&wav->ptr[offs]);
   wav->offset+=todo;
   wav->offset%=(wav->samples);
   samples-=todo;
   od=od+(todo*wav->mode.bps);
   }
  else
  if(wav->user_data[0]==aa_WAVMODE_OneShot)
   {
   if(cando)
    {
    todo=aaNumRoof(samples,cando);
    todo=aaNumRoof(todo,_1K);
    bytes=todo*wav->mode.bps;
    offs=wav->offset*wav->mode.bps;
    aaMemoryCopy(od,bytes,&wav->ptr[offs]);
    wav->offset+=todo;
    samples-=todo;
    od=od+(todo*wav->mode.bps);
    }
   else
    {
    todo=samples;
    todo=aaNumRoof(todo,_1K);
    bytes=todo*wav->mode.bps;
    aaMemoryFill(od,bytes,0);
    samples-=todo;
    od=od+(todo*wav->mode.bps);
    }
   }
  else
   {
   oof;
   }
  */
  }
 return RET_YES;
 }


/*-----------------------------------------------------------------------*/




 B aaBiquadInit                        (_biquad*bq,B type,H srate,D freq,D gain,D width)
 {
 D za,omega,sn,cs,alpha,beta,sr;
 D a0,a1,a2,b0,b1,b2;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bq==NULL) { return RET_BADPARM; }
 aaMemoryFill(bq,sizeof(_biquad),0);
 if(srate==0||srate>96000) { return RET_BADPARM; }
 if(freq==0||freq>20000) { return RET_BADPARM; }
 sr=(D)srate;
 za=pow(10,gain/40);
 omega=2*aaPi*freq/sr;
 sn=sin(omega);
 cs=cos(omega);
 alpha=sn*sinh(0.69314718055994530942/2*width*omega/sn);
 beta=sqrt(za+za);
 switch (type)
  {
  case aa_BIQUAD_LPass:
  b0=(1-cs)/2;
  b1=1-cs;
  b2=(1-cs)/2;
  a0=1+alpha;
  a1=-2*cs;
  a2=1-alpha;
  break;

  case aa_BIQUAD_HPass:
  b0=(1+cs)/2;
  b1=-(1+cs);
  b2=(1+cs)/2;
  a0=1+alpha;
  a1=-2*cs;
  a2=1-alpha;
  break;

  case aa_BIQUAD_BPass:
  b0=alpha;
  b1=0;
  b2=-alpha;
  a0=1+alpha;
  a1=-2*cs;
  a2=1-alpha;
  break;

  case aa_BIQUAD_Notch:
  b0=1;
  b1=-2*cs;
  b2=1;
  a0=1+alpha;
  a1=-2*cs;
  a2=1-alpha;
  break;

  case aa_BIQUAD_PeakR:
  b0=1+(alpha*za);
  b1=-2*cs;
  b2=1-(alpha*za);
  a0=1+(alpha/za);
  a1=-2*cs;
  a2=1-(alpha/za);
  break;

  case aa_BIQUAD_LShlf:
  b0=za*((za+1)-(za-1)*cs+beta*sn);
  b1=2*za*((za-1)-(za+1)*cs);
  b2=za*((za+1)-(za-1)*cs-beta*sn);
  a0=(za+1)+(za-1)*cs+beta*sn;
  a1=-2*((za-1)+(za+1)*cs);
  a2=(za+1)+(za-1)*cs-beta*sn;
  break;

  case aa_BIQUAD_HShlf:
  b0=za*((za+1)+(za-1)*cs+beta*sn);
  b1=-2*za*((za-1)+(za+1)*cs);
  b2=za*((za+1)+(za-1)*cs-beta*sn);
  a0=(za+1)-(za-1)*cs+beta*sn;
  a1=2*((za-1)-(za+1)*cs);
  a2=(za+1)-(za-1)*cs-beta*sn;
  break;

  default:
  return RET_BADPARM;
  }
 bq->magic=aa_BIQUAD_MAGIC;
 bq->type=type;
 bq->rate=srate;
 bq->freq=freq;
 bq->gain=gain;
 bq->width=width;
 bq->a0=b0/a0;
 bq->a1=b1/a0;
 bq->a2=b2/a0;
 bq->a3=a1/a0;
 bq->a4=a2/a0;
 bq->x1=bq->x2=0;
 bq->y1=bq->y2=0;
 return RET_YES;
 }






 B aaBiquadProcess                     (_biquad*bq,D sin,DP sout)
 {
 D r;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bq==NULL) { return RET_BADPARM; }
 if(sout==NULL) { return RET_BADPARM; }
 if(bq->magic!=aa_BIQUAD_MAGIC) { return RET_NOTSTARTED; }
 if(bq->type==0) {  *sout=sin;  return RET_YES;  }
 r=bq->a0*sin+bq->a1*bq->x1+bq->a2*bq->x2-bq->a3*bq->y1-bq->a4*bq->y2;
 bq->x2=bq->x1;
 bq->x1=sin;
 bq->y2=bq->y1;
 bq->y1=r;
 *sout=r;
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/


 B aaTonerInit                         (_toner*toner,_audiomode*audiomode,D tonefreq,D amplitude)
 {
 D dub;
 B have_prev;
 D pos,wos;
 _toner prev_toner;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 aaMissingParm(toner);
 aaMissingParm(audiomode);
 if(tonefreq<0||tonefreq>20000)   { return RET_BOUNDS; }
 if(amplitude<0||amplitude>32767) { return RET_BOUNDS; }
 have_prev=NO;
 if(toner->magic==aaHPP(aaTonerInit))
  {
  have_prev=YES;
  aaMemoryCopy(&prev_toner,sizeof(_toner),toner);
  }
 aaMemoryFill(toner,sizeof(_toner),0);
 toner->magic=aaHPP(aaTonerInit);
 aaAudioModeCopy(&toner->amode,audiomode);
 toner->tone_freq=tonefreq;
 toner->samples_per_cycle=toner->amode.frequency/toner->tone_freq;
 dub=toner->samples_per_cycle*2.0;
 toner->cur_sample=0;
 toner->tot_samples=(N)dub;
 toner->amplitude=amplitude;
 if(have_prev)
  {
  pos=(D)prev_toner.tot_samples;
  dub=(D)prev_toner.cur_sample;
  wos=pos/dub;
  ///aaDebugf("prev cur=%i tot=%i = %.2f",prev_toner.cur_sample,prev_toner.tot_samples,wos);
  dub=(D)toner->tot_samples;
  pos=dub/wos;
  toner->cur_sample=(N)pos;
  ///aaDebugf(" now cur=%i tot=%i = %.2f",toner->cur_sample,toner->tot_samples,pos);
  }
 return RET_YES;
 }




 B aaTonerGenerate                     (_toner*toner,H samples,VP data)
 {
 D sample_val;
 H out_offset;
 IP out_data;
 I is;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 aaMissingParm(toner);
 if(toner->magic!=aaHPP(aaTonerInit)) { return RET_NOTINITIALIZED; }
 aaMissingParm(data);
 out_data=(IP)data;
 out_offset=0;
 while(1)
  {
  if(toner->cur_sample>=toner->tot_samples) { toner->cur_sample=0; }
  if(samples==0) { break; }
  sample_val=sin(toner->cur_sample/toner->samples_per_cycle*2.0*aaPi)*toner->amplitude;
  if(sample_val<-32760.0) { sample_val=-32760.0; }
  if(sample_val>+32760.0) { sample_val=+32760.0; }
  toner->cur_sample+=1;
  samples-=1;
  is=(I)sample_val;
  out_data[out_offset++]=is;//(I)sample_val;
  //out_data[out_offset++]=(I)sample_val;
  if(toner->amode.channels==2) { out_data[out_offset++]=is;   }
  }
 return RET_YES;
 }


/*-----------------------------------------------------------------------*/





 B aaVidCapCountGet                    (BP count)
 {
 H c,cnt;
 BOOL bl;

 if(count==NULL) { return RET_BADPARM; }
 cnt=0;
 for(c=0;c<10;c++)
  {
  bl=capGetDriverDescription(c,0,0,0,0);
  if(bl==TRUE) { cnt++; }
  }
 *count=(B)cnt;
 return RET_YES;
 }




 B aaVidCapNameGet                     (B id,VP name)
 {
 if(name==NULL) { return RET_BADPARM; }
 aaStringNull(name);
 if(id>=10) { return RET_NOTFOUND; }
 if(capGetDriverDescription(id,name,50,0,0)==FALSE) { return RET_NOTFOUND; }
 return RET_YES;
 }





 B aaVidCapCreate                      (HP handle,B id)
 {
 B ret;
 _aa_vidcapobject*vdcp;
 _aa_threadobject*thrp;
 H win_handle,bytes;
 HWND currently_active_window;
 BP mem;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==NULL)  {  return RET_BADPARM;  }
 if(id>=10) { return RET_NOTFOUND; }

 if((ret=aa_ObjectCreate(aa.vidcap_system.object_id,handle,(VP)&vdcp))!=RET_YES)  { oops; return ret;  }
 vdcp->self_handle=*handle;
 currently_active_window=GetActiveWindow();
 if(currently_active_window!=NULL)
  {
  if(aa_SurfaceSystemFindSurfaceByHwnd(&win_handle,NULL,currently_active_window)==YES)
   {
   vdcp->window_to_active_after_connect=win_handle;
   }
  }
 vdcp->status.is_previewmode=NO;
 if(aa_EventDefine(&vdcp->connect_event,YES,NO,"VidCap.Event.%i.%lx",id,GetTickCount())!=YES)
  {
  logg("dmdm");
  }
 vdcp->device_id=id;
 vdcp->status.id=id;
 capGetDriverDescription((WORD)vdcp->device_id,(CP)vdcp->status.name,32,(CP)vdcp->status.ver,32);
 if((ret=aaThreadCreate(&vdcp->thread_handle,aa_VidCapThread,*handle,0,NULL,YES))!=RET_YES)
  {
  logg("vidcapthreadcreate failed=%s",ret_string[ret]);
  aa_EventUndefine(&vdcp->connect_event);
  aa_ObjectDestroy(aa.vidcap_system.object_id,*handle);
  return RET_FAILED;
  }
 logg("radioing vidcap thread");
 aa_ObjectCheck(aa.thread_system.object_id,vdcp->thread_handle,(VP)&thrp,NULL);
 vdcp->thread_id=thrp->id;
 vdcp->is_frame_waiting=NO;
 vdcp->status.is_frameready=NO;
 logg("allocating memory for vidcap frame");
 bytes=320*242*4; //???
 if((ret=aa_MemoryAllocate((VP)&mem,bytes,"vidcapframe",YES))!=RET_YES)
  {
  oops;
  if(aaThreadDestroy(vdcp->thread_handle)!=RET_YES) { oof; Boop; }
  aa_EventUndefine(&vdcp->connect_event);
  aa_ObjectDestroy(aa.vidcap_system.object_id,*handle);
  oops;
  return RET_FAILED;
  }
 vdcp->frame_buf=mem;
 vdcp->frame_buf_bytes=bytes;
 logg("memory for vidcap frame OK, unpausing vidcap thread ");
 aaThreadPause(vdcp->thread_handle,NO);
 logg("vidcap created");
 return RET_YES;
 }




 B aaVidCapCreateAutoDetect            (HP handle,B id,_size*size)
 {
 B ret;
 _aa_vidcapobject*vdcp;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aaSizeIsValid(size)!=YES) { return RET_BADPARM; }
 if((ret=aaVidCapCreate(handle,id))!=RET_YES) { return ret; }
 if((ret=aa_ObjectCheck(aa.vidcap_system.object_id,*handle,(VP)&vdcp,NULL))!=RET_YES) { oops; }
 if(vdcp->status.is_detecting==YES) { return RET_YES; }
 if(vdcp->status.is_detected==YES) { return RET_YES; }
 vdcp->status.is_detecting=YES;
 aaSizeCopy(&vdcp->auto_detect_size,size);
 return RET_YES;
 }





 B aaVidCapDestroy                     (H handle)
 {
 B ret;
 _aa_vidcapobject*vdcp;
 _threadstatus ts;
 B isprot;
 H go;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.vidcap_system.object_id,handle,(VP)&vdcp,&isprot))!=RET_YES) { return ret; }
 if(isprot==YES) { return RET_FORBIDDEN; }
 logg("VidCapDestroy()");
 if(vdcp->status.is_ready)
  {
  if(vdcp->hwnd!=NULL)
   {
   if(vdcp->status.is_previewmode==YES)
    {
    if(capPreview(vdcp->hwnd,FALSE)==FALSE) { aaLog(__LINE__,"fail2 stop preview"); }
    }
   else
    {
    logg("Calling aa_VidCapAbort in vidcapdestroy");
    aa_VidCapAbort((VP)&vdcp);
    logg("aa_VidCapAbort returns in  vidcapdestroy");
    }
   vdcp->status.is_ready=NO;
   }
  else { oof; }
  }
 logg("calling threadExit in VidCapDestroy()");
 aaThreadExit(vdcp->thread_handle);
 if(PostThreadMessage(vdcp->thread_id,WM_QUIT,0,0)==0)
  {
  logg("postthreadmessage failed");
  }

 go=0;
 while(1)
  {
  ret=aaThreadStatus(vdcp->thread_handle,&ts);
  if(ret!=YES) { oof; Boop; }
  if(ts.is_exited) break;
  aaSleep(1);
  go++;
  if(go>300) { break; }
  }

 if(vdcp->status.is_connected==YES)
  {
  capDriverDisconnect(vdcp->hwnd);
  vdcp->status.is_connected=NO;
  }

 if(vdcp->hwnd)
  {
  DestroyWindow(vdcp->hwnd);
  vdcp->hwnd=NULL;
  }
 if(vdcp->status.surface_handle!=0)
  {
  logg("Destroy vidcap frame surface");
  if(aaSurfaceDestroy(vdcp->status.surface_handle)!=RET_YES) oof;
  vdcp->status.surface_handle=0;
  aaMemoryFill(&vdcp->status.surface_status,sizeof(_surfacestatus),0);
  }
 if(vdcp->frame_buf!=NULL)
  {
  logg("Release vidcap frame buf");
  if((ret=aa_MemoryRelease(vdcp->frame_buf))!=YES) { oops; }
  vdcp->frame_buf=NULL;
  vdcp->frame_buf_bytes=0;
  }
 if(vdcp->thread_handle!=0)
  {
  if(aaThreadDestroy(vdcp->thread_handle)!=RET_YES) { oof; Boop; }
  vdcp->thread_handle=0;
  }

 if(vdcp->connect_event.handle!=NULL)
  {
  if(aa_EventUndefine(&vdcp->connect_event)!=YES)
   {
   logg("dewD");
   }
  }
 aa_ObjectDestroy(aa.vidcap_system.object_id,handle);
 return RET_YES;
 }






 B aaVidCapStatus                      (H handle,_vidcapstatus*vidcapstatus)
 {
 B ret;
 _aa_vidcapobject*vdcp;
 _size s1;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.vidcap_system.object_id,handle,(VP)&vdcp,NULL))!=RET_YES) { return ret; }

 if(vdcp->status.is_connected==NO&&vdcp->status.is_failed==NO)
  {
  ret=aa_EventIsSignaled(&vdcp->connect_event);
  if(ret==RET_FAILED) { oof; Boop; }
  if(ret==RET_YES)   {   }
  else               {   }
  if(ret==RET_YES)
   {
   if(vdcp->is_connect_failed==NO)
    {
    if(vdcp->window_to_active_after_connect!=0)
     {
     aaSurfaceFocus(vdcp->window_to_active_after_connect);
     logg("VidCap About to activate after connect");
     vdcp->window_to_active_after_connect=0;
     }
    vdcp->status.is_connected=YES;
    logg("----- Vidcap %i conneced ---",vdcp->device_id);
    }
   else
    {
    vdcp->status.is_failed=YES;
    logg("Vidcap Failed");
    }
   }
  }
 if(vdcp->is_sourcebox_message_received==YES&&vdcp->status.is_sourcebox_open==YES&&vdcp->is_sourcebox_closed==YES)
  {
  if(vdcp->window_to_active_after_sourcebox_close!=0)
   {
   aaSurfaceFocus(vdcp->window_to_active_after_sourcebox_close);
   logg("Reactivated window %i after sourcebox close",vdcp->window_to_active_after_sourcebox_close);
   vdcp->window_to_active_after_sourcebox_close=0;
   }
  vdcp->status.is_sourcebox_open=NO;
  vdcp->is_sourcebox_closed=NO;
  }
 if(vidcapstatus)  {  aaMemoryCopy(vidcapstatus,sizeof(_vidcapstatus),&vdcp->status);  }
 if(vdcp->status.is_detecting==NO)
  {
  if(vdcp->status.is_ready==YES&&vdcp->is_frame_waiting==YES) { vdcp->status.is_detected=YES; }
  return RET_YES;
  }
 switch(vdcp->auto_detect_stage)
  {
  case 0:
  vdcp->auto_detect_stage=10;
  break;

  case 10:
  if(vdcp->status.is_failed==YES)
   {
   vdcp->auto_detect_stage=200;
   vdcp->status.is_detecting=NO;
   break;
   }
  if(vdcp->status.is_connected==NO) { break; }
  vdcp->auto_detect_stage=20;
  break;

  case 20:
  aaSizeCopy(&s1,&vdcp->auto_detect_size);
  switch(vdcp->auto_detect_bit_mode)
   {
   case 0:   ret=aaVidCapFormatSet(handle,&s1,24); //aaDebugf("bm=%i ret=%s",vdcp->auto_detect_bit_mode,ret_string[ret]);
              if(ret==YES) { vdcp->auto_detect_stage=40;  break; }
              break;
   case 1:    ret=aaVidCapFormatSet(handle,&s1,12); //aaDebugf("bm=%i ret=%s",vdcp->auto_detect_bit_mode,ret_string[ret]);
              if(ret==YES) { vdcp->auto_detect_stage=40;  break; }
              break;
   case 2:    ret=aaVidCapFormatSet(handle,&s1,11); //aaDebugf("bm=%i ret=%s",vdcp->auto_detect_bit_mode,ret_string[ret]);
              if(ret==YES) { vdcp->auto_detect_stage=40;  break; }
              break;
   case 3:    ret=aaVidCapFormatSet(handle,&s1,16); //aaDebugf("bm=%i ret=%s",vdcp->auto_detect_bit_mode,ret_string[ret]);
              if(ret==YES) { vdcp->auto_detect_stage=40;  break; }
              break;
   case 4:    ret=aaVidCapFormatSet(handle,&s1,32); //aaDebugf("bm=%i ret=%s",vdcp->auto_detect_bit_mode,ret_string[ret]);
              if(ret==YES) { vdcp->auto_detect_stage=40;  break; }
              break;
   case 5:    ret=aaVidCapFormatSet(handle,&s1,15); //aaDebugf("bm=%i ret=%s",vdcp->auto_detect_bit_mode,ret_string[ret]);
              if(ret==YES) { vdcp->auto_detect_stage=40;  break; }
              break;
   default:
   vdcp->auto_detect_stage=200;
   vdcp->status.is_detecting=NO;
   vdcp->status.is_failed=YES;
   break;
   }
  if(vdcp->auto_detect_stage==20)
   {
   vdcp->auto_detect_bit_mode++;
   break;
   }
  break;

  case 40:
  if(vdcp->status.is_frameready!=YES) { break; }
  vdcp->auto_detect_stage=50;
  vdcp->status.is_detecting=NO;
  break;

  default:
  break;
  }
 if(vidcapstatus)
  {
  aaMemoryCopy(vidcapstatus,sizeof(_vidcapstatus),&vdcp->status);
  }
 return RET_YES;
 }








 B aaVidCapFormatSet                   (H handle,_size*size,B bits)
 {
 B ret;
 _aa_vidcapobject*vdcp;
 BITMAPINFO cool;
 BOOL rv;
 aa_CAPTUREPARMS caparm;
 _size sz;
 HWND aw;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.vidcap_system.object_id,handle,(VP)&vdcp,NULL))!=RET_YES) { return ret; }
 #if aa_VIDCAP_ALLOW_YUY2==YES
 if(bits!=11&&bits!=12&&bits!=13&&bits!=16&&bits!=24&&bits!=32) { return RET_BADPARM; }
 #else
 if(bits!=11&&bits!=12&&bits!=16&&bits!=24&&bits!=32) { return RET_BADPARM; }
 #endif

 if((ret=aaSizeIsValid(size))!=RET_YES) { return ret; }
 if(vdcp->status.is_connected==NO)  {  return RET_NOTREADY;  }

 logg("Seeing if vidcap format is different");
 while(1)
  {
  aaSizeCopy(&sz,size);
  if(aaSizeEqualsSize(&sz,&vdcp->requested_capture_size)==NO) break;
  if(bits!=vdcp->requested_capture_bits) break;
  logg("nothing changed");
  return RET_YES;
  }

 if(vdcp->status.is_ready==YES)
  {
  if(vdcp->status.is_previewmode==NO) {   aa_VidCapAbort((VP)&vdcp);   }
  else { oof; }
  }
 vdcp->status.is_ready=NO;
 aaSizeCopy(&sz,size);
 WinBmpInfoSet(&cool,sz.w,sz.h,bits,NO+0);
 logg("Setting vidcap format");
 if((rv=capSetVideoFormat(vdcp->hwnd,&cool,sizeof(cool)))==FALSE)  { return RET_FAILED;  }
 aaSizeCopy(&vdcp->requested_capture_size,&sz);
 vdcp->requested_capture_bits=bits;
 vdcp->is_frame_waiting=NO;
 vdcp->status.is_frameready=NO;
 vdcp->status.frames_dropped=0;
 vdcp->status.frame_number=0;
 vdcp->status.bits=(B)cool.bmiHeader.biBitCount;
 aaSizeSet(&vdcp->status.size,cool.bmiHeader.biWidth,cool.bmiHeader.biHeight);
 vdcp->using_bmp_compression=cool.bmiHeader.biCompression;
 logg(" in %s mode",aaBoolStrings(vdcp->status.is_previewmode,"preview","non-preview"));
 if(vdcp->status.is_previewmode)
  {
  if(capPreview(vdcp->hwnd,TRUE)==FALSE) { oof; }
  logg("and no scaling");
  if(capPreviewScale(vdcp->hwnd,FALSE)==FALSE) { oof; }
  aw=GetActiveWindow();
  SetWindowLong(vdcp->hwnd,GWL_EXSTYLE,WS_EX_TOOLWINDOW);
  if(capPreviewRate(vdcp->hwnd,30000)==FALSE) oof;
  oof;
  if(aw!=NULL) SetActiveWindow(aw);
  }
 else
  {
  WinCapParmsInit(&caparm);
  if(capCaptureSetSetup(vdcp->hwnd,&caparm,sizeof(caparm))==FALSE) { oof; Boop; }
  if(capCaptureSequenceNoFile(vdcp->hwnd)==FALSE) { oof; Boop; }
  }
 vdcp->status.is_ready=YES;
 logg("aa_vidcapformatSet success status.is_ready=YES");
 return RET_YES;
 }









 B aaVidCapPreviewSet                  (H handle,B state)
 {
 B ret;
 _aa_vidcapobject*vdcp;
 _size old_size;
 B old_bits;
 BITMAPINFO cool;
 HWND active_window_hwnd;
 aa_CAPTUREPARMS caparm;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.vidcap_system.object_id,handle,(VP)&vdcp,NULL))!=RET_YES) { return ret; }

 if(state==YES)
  {
  if(vdcp->status.is_previewmode==YES) {  return RET_YES;   }
  if(vdcp->status.is_ready==NO)   {   vdcp->status.is_previewmode=YES;   return RET_YES;   }
  if(vdcp->status.is_sourcebox_open==YES)  {   return RET_FAILED;   }
  aaSizeCopy(&old_size,&vdcp->status.size);
  old_bits=vdcp->status.bits;
  aa_VidCapAbort((VP)&vdcp);
  vdcp->status.is_ready=NO;
  WinBmpInfoSet(&cool,old_size.w,old_size.h,old_bits,NO);
  vdcp->is_frame_waiting=NO;
  vdcp->status.is_frameready=NO;
  vdcp->status.bits=(B)cool.bmiHeader.biBitCount;
  aaSizeSet(&vdcp->status.size,cool.bmiHeader.biWidth,cool.bmiHeader.biHeight);
  vdcp->using_bmp_compression=cool.bmiHeader.biCompression;
  vdcp->status.is_previewmode=YES;
  logg("aaVidcapPreviewSet(YES) ... calling capPreview=TRUE");
  if(capPreview(vdcp->hwnd,TRUE)==FALSE)   {   }
  if(capPreviewScale(vdcp->hwnd,FALSE)==FALSE)   {   }
  active_window_hwnd=GetActiveWindow();
  SetWindowLong(vdcp->hwnd,GWL_EXSTYLE,WS_EX_TOOLWINDOW);
  SetWindowPos(vdcp->hwnd,HWND_TOPMOST,0,0,0,0,SWP_NOSIZE|SWP_NOMOVE|SWP_NOACTIVATE);
  ShowWindow(vdcp->hwnd,SW_SHOW);
  //aaDebugf("one one one %i",__LINE__);
  if(capPreviewRate(vdcp->hwnd,30000)==FALSE)   {   }
  if(active_window_hwnd!=NULL) SetActiveWindow(active_window_hwnd);
  vdcp->status.is_ready=YES;
  }
 else
  {
  if(vdcp->status.is_previewmode==NO)   {   return RET_YES;   }
  if(vdcp->status.is_ready==NO)  {  vdcp->status.is_previewmode=NO;   return RET_YES;   }
  aaSizeCopy(&old_size,&vdcp->status.size);
  old_bits=vdcp->status.bits;
  if(capPreview(vdcp->hwnd,FALSE)==FALSE)   {   }
  vdcp->status.is_ready=NO;
  WinBmpInfoSet(&cool,old_size.w,old_size.h,old_bits,NO);
  vdcp->status.is_frameready=NO;
  vdcp->is_frame_waiting=NO;
  vdcp->status.bits=(B)cool.bmiHeader.biBitCount;
  aaSizeSet(&vdcp->status.size,cool.bmiHeader.biWidth,cool.bmiHeader.biHeight);
  vdcp->using_bmp_compression=cool.bmiHeader.biCompression;
  vdcp->status.is_previewmode=NO;
  WinCapParmsInit(&caparm);
 //  logg("aaVidcapPreviewSet(NO) ... calling cpaturesetsetup");
  if(capCaptureSetSetup(vdcp->hwnd,&caparm,sizeof(caparm))==FALSE)  {  }
  if(capCaptureSequenceNoFile(vdcp->hwnd)==FALSE)  {  }
  vdcp->status.is_ready=YES;
  }
 return RET_YES;
 }





 B aaVidCapFrameIsReady                (H handle)
 {
 B ret;
 _aa_vidcapobject*vdcp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.vidcap_system.object_id,handle,(VP)&vdcp,NULL))!=RET_YES) { return ret; }
 if(vdcp->status.is_ready==NO)  {  return RET_NOTREADY;  }
 if(vdcp->is_frame_waiting==NO)   {  return RET_NOTREADY;  }
 return RET_YES;
 }





 B aaVidCapFrameNext                   (H handle)
 {
 B ret;
 _aa_vidcapobject*vdcp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.vidcap_system.object_id,handle,(VP)&vdcp,NULL))!=RET_YES) { return ret; }
 if(vdcp->status.is_ready==NO)  {  return RET_NOTREADY;  }
 if(vdcp->is_frame_waiting==NO)   {  return RET_NOTREADY;  }
 vdcp->is_frame_waiting=NO;
 vdcp->status.is_frameready=NO;
 return RET_YES;
 }





 B aaVidCapSourceBoxShow               (H handle)
 {
 B ret;
 _aa_vidcapobject*vdcp;
 H win_handle;
 HWND currently_active_window;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.vidcap_system.object_id,handle,(VP)&vdcp,NULL))!=RET_YES) { return ret; }
 if(vdcp->status.has_sourcebox==NO)  { return RET_NOTFOUND;  }
 if((ret=aaVidCapPreviewSet(handle,YES))!=YES) { oops; }
 if(vdcp->status.is_previewmode==NO)  {  return RET_FAILED;  }
 if(vdcp->status.is_ready==NO)  {  return RET_NOTREADY;  }
 if(vdcp->status.is_sourcebox_open==YES)  {  return RET_YES;  }
 currently_active_window=GetActiveWindow();
 if(currently_active_window!=NULL)
  {
  if(aa_SurfaceSystemFindSurfaceByHwnd(&win_handle,NULL,currently_active_window)==YES)
   {
   vdcp->window_to_active_after_sourcebox_close=win_handle;
   }
  }
 vdcp->is_sourcebox_message_received=NO;
 vdcp->is_sourcebox_closed=NO;
 vdcp->status.is_sourcebox_open=YES;
 if(PostThreadMessage(vdcp->thread_id,WM_USER_VIDCAP_SOURCE,0,0)==FALSE)  {  oow;  }
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/





 B aaFilePartsGet                      (VP filename,_fileparts*fileparts)
 {
 H sl,tmp;
 B txt[_1K];
 B str[_1K];
 H off,count;
 _parser pa;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(fileparts==NULL) { return RET_BADPARM; }
 aaMemoryFill(fileparts,sizeof(_fileparts),0);
 if(filename==NULL) { return RET_BADPARM; }
 aaStringLen(filename,&sl);
 if(sl==0) { return RET_YES; }
 aaStringLower(filename,0,txt);
 if(txt[1]==':'&&(txt[0]>='a'&&txt[0]<='z'))
  {
  fileparts->drive=txt[0];
  aaMemoryCopy(txt,sl,&txt[2]);
  sl-=2;
  txt[sl]=NULL_CHAR;
  }
 aaStringCountChars(txt,sl,&count,BSLASH_CHAR,NO,YES); tmp=count;
 aaStringCountChars(txt,sl,&count,FSLASH_CHAR,NO,YES); count+=tmp;
   str[0]=BSLASH_CHAR;
   str[1]=FSLASH_CHAR;
   str[2]=str[3]=0;
 if(count>=1)
  {
  aaParserInit(&pa,txt,sl);
  while(1)
   {
   if(pa.is_end) { break; }
   aaParserSeekToCharList(&pa,str,NO,YES);
   aaStringFindCharList(pa.bp,pa.to_end,&off,str,YES,0,YES);
   if(off==0xffffffff) { break; }
   if(off==0) aaNote(0,"%i %s %s",pa.to_end,pa.bp,filename);
   aaStringNCopy(fileparts->path[fileparts->path_count],pa.bp,off,YES);
   aaParserSeek(&pa,off);
   fileparts->path_count++;
   }
  aaStringCopy(txt,pa.bp);
  sl=pa.to_end;
  }
 if(sl==0) { return RET_YES; }
 aaParserInit(&pa,txt,sl);
 aaStringFindChar(pa.bp,pa.to_end,&off,'.',YES,0,YES);
 if(off==0xffffffff)
  {
  aaStringCopy(fileparts->file,pa.bp);
  aaStringCopy(fileparts->filename,fileparts->file);
  return RET_YES;
  }
 aaStringNCopy(fileparts->file,pa.bp,off,YES);
 aaStringCopy(fileparts->filename,fileparts->file);
 aaParserSeek(&pa,off);
 aaStringAppend(fileparts->filename,pa.bp);
 while(1)
  {
  if(pa.is_end) { break; }
  aaParserSeekToChar(&pa,'.',NO,YES);
  aaStringFindChar(pa.bp,pa.to_end,&off,'.',YES,0,YES);

  aaStringNCopy(fileparts->extension[fileparts->extension_count],pa.bp,off,YES);
  fileparts->extension_count++;
  if(off==0xffffffff) { break; }
  aaParserSeek(&pa,off);
  }
 return RET_YES;
 }




 B aaFileEqualsFile                    (VP filename,VP filename2)
 {
 _fileid fid,fidb;
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaFileInfoGet(filename,0,0,0,0,&fid))!=RET_YES) {  return ret;  }
 if((ret=aaFileInfoGet(filename2,0,0,0,0,&fidb))!=RET_YES) {  return ret;  }
 if(fidb.volume!=fid.volume||fidb.object[0]!=fid.object[0]||fidb.object[1]!=fid.object[1])  { return RET_NO;  }
 return RET_YES;
 }



 B aaFileIsOpen                        (VP filename,...)
 {
 B str[_4K];
 va_list argptr;
 HANDLE fh;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(filename,argptr,str);
 fh=CreateFile((LPCTSTR)str,GENERIC_READ,0,NULL,OPEN_EXISTING,0,NULL);
 CloseHandle(fh);
 if((fh!=NULL)&&(fh!=INVALID_HANDLE_VALUE))  {    return RET_NO;  }
 return RET_YES;
 }



/*
__int64 size=( ((__int64)ffd.nFileSizeHigh)<<32 )+ffd.nFileSizeLow;
printf("Big size=%I64d bytes.\n", size);
*/

typedef struct _FILE_STANDARD_INFO {
  LARGE_INTEGER AllocationSize;
  LARGE_INTEGER EndOfFile;
  DWORD         NumberOfLinks;
  BOOLEAN        DeletePending;
  BOOLEAN       Directory;
} FILE_STANDARD_INFO,*PFILE_STANDARD_INFO;





 B aaFileInfoGet                       (VP filename,QP bytes,BP isfolder,_systime*ctime,_systime*mtime,_fileid*id)
 {
 DWORD a,er;
 HANDLE file_handle;
 SYSTEMTIME st;
 FILETIME fct,fmt,tmt;
 BY_HANDLE_FILE_INFORMATION info;
 LARGE_INTEGER di;
 B isfold;
 Q fs;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(id)       { id->volume=0; id->object[0]=id->object[1]=0; }
 if(bytes)    { *bytes=0; }
 if(isfolder) { *isfolder=NO; }
 if(ctime) { aaTimeNull(ctime); }
 if(mtime) { aaTimeNull(mtime); }
 if(aaStringIsNull(filename)==YES) { return RET_BADPARM; }

 isfold=NO;
 a=GetFileAttributes(filename);
 if(a==INVALID_FILE_ATTRIBUTES) { return RET_NOTFOUND; }
 if(a&FILE_ATTRIBUTE_DIRECTORY)
  {
  isfold=YES;
  if(isfolder) { *isfolder=YES; }
  }
 if(ctime==NULL&&mtime==NULL&&id==NULL)
  {
  if(isfold) { return RET_YES; }
  }
 file_handle=0;
 aaMemoryFill(&info,sizeof(info),0);
 SetLastError(0);
 if(isfold==NO) { file_handle=CreateFile(filename,GENERIC_READ,FILE_SHARE_READ|FILE_SHARE_WRITE,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);  }
 else           { file_handle=CreateFile(filename,GENERIC_READ,FILE_SHARE_READ|FILE_SHARE_WRITE,NULL,OPEN_EXISTING,FILE_FLAG_BACKUP_SEMANTICS,NULL); }
 if(file_handle==INVALID_HANDLE_VALUE)
  {
  er=GetLastError();
  if(er==ERROR_SHARING_VIOLATION||er==ERROR_ACCESS_DENIED) { return RET_DENIED; }
  oow;
  return RET_FAILED;
  }

 if(isfolder==NULL&&ctime==NULL&&mtime==NULL&&id==NULL&&bytes!=NULL)
  {
  di.QuadPart=0;
  if(GetFileSizeEx(file_handle,&di)==0) { oof; oow; }
  *bytes=di.QuadPart;
  CloseHandle(file_handle);
  return RET_YES;
  }



 if(GetFileInformationByHandle(file_handle,&info)==0)
  {
  di.QuadPart=0;
  if(GetFileSizeEx(file_handle,&di)==0) { oof; oow; }
  aaNote(0,"line=%i %I64u",__LINE__,di.QuadPart);
  CloseHandle(file_handle);
  return RET_FAILED;
  }
 if((ctime||mtime))
  {
  if(GetFileTime(file_handle,(ctime)?&fct:NULL,NULL,(mtime)?&fmt:NULL)!=0)
   {
   if(ctime)
    {
    if(FileTimeToLocalFileTime(&fct,&tmt)==0) { oof; oow; oof;   CloseHandle(file_handle);    return RET_FAILED;    }
    if(FileTimeToSystemTime(&tmt,&st)==0) {   oof; oow; oof; CloseHandle(file_handle);    return RET_FAILED;    }
    WinSystemTimeToSysTime(&st,ctime);
    }
   if(mtime)
    {
    if(FileTimeToLocalFileTime(&fmt,&tmt)==0) {  oof;  oow; oof; CloseHandle(file_handle);    return RET_FAILED;    }
    if(FileTimeToSystemTime(&tmt,&st)==0) {    oof; oow; oof; CloseHandle(file_handle);    return RET_FAILED;    }
    WinSystemTimeToSysTime(&st,mtime);
    }
   }
  }
 if(id)
  {
  id->volume=info.dwVolumeSerialNumber;
  id->object[0]=info.nFileIndexLow;
  id->object[1]=info.nFileIndexHigh;
  }
 if(bytes)
  {
  fs=info.nFileSizeHigh;
  fs<<=32;
  fs|=info.nFileSizeLow;
  *bytes=fs;
  }
 if(file_handle!=0)
  {
  CloseHandle(file_handle);
  }
 return RET_YES;
 }




 B aaFileInformationGet                (VP filename,_fileinformation*fileinformation)
 {
 B ret;
 _fileinformation*fi;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(fileinformation==NULL) { return RET_BADPARM; }
 aaMemoryFill(fileinformation,sizeof(_fileinformation),0);
 if(filename==NULL) { return RET_BADPARM; }
 if(aaStringIsEmpty(filename,YES)!=NO) { return RET_BADPARM; }
 aaStringCopyf(fileinformation->file_name,"%s",filename);
 fi=(_fileinformation*)fileinformation;
 if((ret=aaFileInfoGet(fi->file_name,&fi->bytes,&fi->is_folder,&fi->created,&fi->modified,&fi->id))!=YES)
  {
  if(ret==RET_NOTFOUND) { fi->is_exists=NO; return RET_NOTFOUND; }
  return ret;
  }
 fi->is_exists=YES;
 if((ret=aaFileAttributesGet(fi->file_name,&fi->attributes))!=YES) { return ret; }
 return RET_YES;
 }






 B aaFileSizeGet                       (VP filename,QP bytes)
 {
 DWORD er;
 HANDLE file_handle;
 LARGE_INTEGER di;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bytes)    { *bytes=0; }
 if(aaStringIsNull(filename)==YES) { return RET_BADPARM; }
 SetLastError(0);
 file_handle=CreateFile(filename,GENERIC_READ,FILE_SHARE_READ|FILE_SHARE_WRITE,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
 if(file_handle==INVALID_HANDLE_VALUE)
  {
  er=GetLastError();
  if(er==ERROR_SHARING_VIOLATION||er==ERROR_ACCESS_DENIED) { return RET_DENIED; }
  if(er==ERROR_FILE_NOT_FOUND) { return RET_NOTFOUND; }
  oow;
  return RET_FAILED;
  }
 di.QuadPart=0;
 if(GetFileSizeEx(file_handle,&di)==0) { oof; oow; }
 *bytes=di.QuadPart;
 CloseHandle(file_handle);
 return RET_YES;
 }







 B aaFileExists                        (VP filename,...)
 {
 B isfold;
 va_list argptr;
 B str[_4K];
 DWORD a,er;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(filename,argptr,str);
 a=GetFileAttributes((CP)str);
 if(a==INVALID_FILE_ATTRIBUTES)
  {
  er=GetLastError();
  if(er==ERROR_ACCESS_DENIED) { oof; return RET_DENIED; }
  if(er==ERROR_SHARING_VIOLATION) { oof; return RET_DENIED; }
  if(er==ERROR_FILE_NOT_FOUND) { return RET_NO; }
  return RET_NO;
  }
 isfold=NO;
 if(a&FILE_ATTRIBUTE_DIRECTORY) { isfold=YES;  }
 if(isfold==YES) { return RET_NO; }
 return RET_YES;
 }




 B aaFileDelete                        (VP filename,...)
 {
 B ret;
 BOOL bo;
 DWORD er;
 va_list argptr;
 B str[_4K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(filename,argptr,str);
 ret=aaFileExists(str);
 if(ret==RET_NO) { return RET_NOTFOUND; }
 if(ret!=RET_YES) { return ret; }
 bo=DeleteFile((CP)str);
 if(bo==0)
  {
  er=GetLastError();
  if(er==ERROR_ACCESS_DENIED) { return RET_DENIED; }
  if(er==ERROR_SHARING_VIOLATION) { return RET_DENIED; }
  if(er==ERROR_FILE_NOT_FOUND) { return RET_NOTFOUND; }
  return RET_FAILED;
  }
 return RET_YES;
 }






 B aaFileCopy                          (VP filename,VP destfilename,B allowoverwrite)
 {
 B ret;
 B isfolder;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaFileInfoGet(filename,NULL,&isfolder,0,0,0))!=RET_YES) { return ret; }
 if(isfolder==YES) { return RET_FAILED; }
 ret=aaFileInfoGet(destfilename,NULL,&isfolder,0,0,0);
 if(ret==YES&&isfolder==YES) { return RET_FAILED; }
 if(ret==YES&&isfolder==NO&&allowoverwrite!=YES) { return RET_EXISTS; }
 if(CopyFile(filename,destfilename,(allowoverwrite==YES)?FALSE:TRUE)==0) { return RET_FAILED; }
 return RET_YES;
 }




 B aaFileRename                        (VP filename,VP destfilename)
 {
 B ret;
 B isfolder;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaFileInfoGet(filename,NULL,&isfolder,0,0,0))!=RET_YES) {  return ret; }
 if(isfolder==YES) { return RET_FAILED; }
 if(MoveFileEx(filename,destfilename,MOVEFILE_REPLACE_EXISTING)==0) { return RET_FAILED; }
 return RET_YES;
 }









 B aaFileSaveFromMemory                (VP filename,H bytes,VP mem)
 {
 HANDLE han;
 H todo,off,done;
 BP bp;
 B block[_16K];
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(filename==NULL) { return RET_BADPARM; }
 han=CreateFile(filename,GENERIC_READ|GENERIC_WRITE,3,NULL,CREATE_ALWAYS,0x08000000,NULL);
 if(han==INVALID_HANDLE_VALUE) { oow; aaNote(0,"eee %s",filename); return RET_FAILED; }
 if(bytes==0xffffffff) { aaStringLen(mem,&bytes); }
 if(bytes==0) { CloseHandle(han); return YES; }
 off=0;
 if(mem!=NULL) { aaCast(bp,BP,mem); }
 else          { aaCast(bp,BP,block); todo=aaNumRoof(bytes,sizeof(block)); aaMemoryFill(block,todo,0); }
 while(1)
  {
  todo=bytes;
//  aaDebugf("todo=%i bytes=%i off=%i",todo,bytes,off);
  if(todo==0) { ret=YES; break; }
  todo=aaNumRoof(todo,sizeof(block));
  done=0;
  //aaDebugf("todo=%i bytes=%i off=%i",todo,bytes,off);
  if(WriteFile(han,&bp[off],todo,&done,NULL)==0) { ret=RET_FAILED; oow; aaNote(0,"off=%i todo=%i done=%i",off,todo,done);  break; }
  if(done!=todo) {  ret=RET_FAILED; oof; break; }
  bytes-=done;
  if(mem!=NULL) { off+=todo; }
  }
 CloseHandle(han);
 if(ret!=YES) { DeleteFile(filename); }
 return ret;
 }







 B aaFileAppendFromMemory              (VP filename,H bytes,VP mem)
 {
 HANDLE han;
 H todo,off,done,er;
 BP bp;
 B block[_16K];
 B ret;
 LARGE_INTEGER zi;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(filename==NULL) { return RET_BADPARM; }
 ret=aaFileExists(filename);
 if(ret==YES)
  {
  han=CreateFile(filename,GENERIC_READ|GENERIC_WRITE,FILE_SHARE_READ|FILE_SHARE_WRITE,NULL,OPEN_EXISTING,0x08000000,NULL);
  if(han==INVALID_HANDLE_VALUE)
   {
   er=GetLastError();
   if(er==ERROR_ACCESS_DENIED) { return RET_DENIED; }
   if(er==ERROR_SHARING_VIOLATION) { return RET_DENIED; }
   if(er==ERROR_FILE_NOT_FOUND) { return RET_NOTFOUND; }
   return RET_FAILED;
   }
  zi.QuadPart=0;
  if(SetFilePointerEx(han,zi,0,FILE_END)==0)
   {
   oow;
   CloseHandle(han);
   return RET_FAILED;
   }
  if(GetFileSizeEx(han,&zi)==0)  {   CloseHandle(han);    return RET_FAILED;   }
  }
 else
 if(ret==RET_NO)
  {
  han=CreateFile(filename,GENERIC_READ|GENERIC_WRITE,FILE_SHARE_READ|FILE_SHARE_WRITE,NULL,CREATE_ALWAYS,0x08000000,NULL);
  if(han==INVALID_HANDLE_VALUE) { return RET_FAILED; }
  }
 else
  {
  oops;
  return ret;
  }
 if(bytes==0xffffffff) { aaStringLen(mem,&bytes); }
 if(bytes==0) { CloseHandle(han); return YES; }
 off=0;
 if(mem!=NULL) { aaCast(bp,BP,mem); }
 else          { aaCast(bp,BP,block); todo=aaNumRoof(bytes,sizeof(block)); aaMemoryFill(block,todo,0); }
 while(1)
  {
  todo=bytes;
  if(todo==0) { ret=YES; break; }
  todo=aaNumRoof(todo,sizeof(block));
  done=0;
  if(WriteFile(han,&bp[off],todo,&done,NULL)==0) { ret=RET_FAILED; break; }
  if(done!=todo) {  ret=RET_FAILED; break; }
  bytes-=done;
  if(mem!=NULL) { off+=todo; }
  }
 CloseHandle(han);
 if(ret!=YES) { DeleteFile(filename); }
 return ret;
 }






 B aaFileAppendf                       (VP filename,VP fmt,...)
 {
 va_list argptr;
 B temp[_16K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,temp);
 return(aaFileAppendFromMemory(filename,0xffffffff,temp));
 }










 B aaFileLoadToMemory                  (VP filename,Q fromoffset,H bytes,PP mem,HP bytesloaded)
 {
 B ret;
 H file_handle;
 _filestreamstatus file_status;
 Q todo,off,to_end;
 BP new_mem;
 Q fo;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bytesloaded) { *bytesloaded=0; }
 if(mem==NULL) { return RET_BADPARM; }
 *mem=NULL;
 if(bytes==0)  { return RET_BADPARM; }

 if(aaFileExists("%s",filename)==RET_NO) { return RET_NOTFOUND; } // added oct 2017. because aafileunitload seems to load non-existent files


 if((ret=aaFileStreamCreate(&file_handle,filename,aa_FILECREATE_OPEN,aa_FILEMODE_R,aa_FILESHARE_RW,1,NO))!=RET_YES)
  {
  return ret;
  }
 aaFileStreamStatus(file_handle,&file_status);

 if((G)fromoffset>=(G)file_status.bytes)
  {
  aaFileStreamDestroy(file_handle);
  return RET_BOUNDS;
  }
 to_end=(file_status.bytes-fromoffset);
 if(bytes==0xffffffff) { bytes=to_end; }
 if(bytes>to_end) { bytes=to_end; }
 if(fromoffset!=0)
  {
  fo=(Q)fromoffset;
  if((ret=aaFileStreamOffsetSet(file_handle,fo))!=RET_YES) {  aaFileStreamDestroy(file_handle);   return ret;   }
  }
 if((ret=aaMemoryAllocate((VP)&new_mem,bytes))!=RET_YES)  {  aaFileStreamDestroy(file_handle);  return ret;  }
 aaMemoryNameSet(new_mem,"fileload");
 off=0;
 while(1)
  {
  todo=bytes;
  if(todo>_16K) { todo=_16K; }
  if((ret=aaFileStreamRead(file_handle,todo,&new_mem[off]))!=RET_YES)
   {
   if((ret=aa_MemoryRelease(new_mem))!=YES) { oops; }
   aaFileStreamDestroy(file_handle);
   return ret;
   }
  bytes-=todo;
  off+=todo;
  if(bytes==0) { break; }
  }
 if(bytesloaded) { *bytesloaded=off; }
 aaFileStreamDestroy(file_handle);
 *mem=new_mem;
 return RET_YES;
 }





 B aaFileLoadToBuffer                  (VP filename,Q fromoffset,H bytes,VP mem,HP bytesloaded)
 {
 B ret;
 H file_handle;
 _filestreamstatus file_status;
 Q todo,off,to_end;
 BP new_mem;
 Q fo;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bytesloaded) { *bytesloaded=0; }
 if(mem==NULL) { return RET_BADPARM; }
 if(bytes==0)  { return RET_BADPARM; }
 if((ret=aaFileStreamCreate(&file_handle,filename,aa_FILECREATE_OPEN,aa_FILEMODE_R,aa_FILESHARE_RW,1,NO))!=RET_YES) {  return ret;  }
 aaFileStreamStatus(file_handle,&file_status);
 if(fromoffset>=file_status.bytes) { aaFileStreamDestroy(file_handle); return RET_BOUNDS; }
 to_end=(file_status.bytes-fromoffset);
 if(bytes==0xffffffff) { bytes=to_end; }
 if(bytes>to_end)  {  bytes=to_end; }
 if(fromoffset!=0)
  {
  fo=fromoffset;
  if((ret=aaFileStreamOffsetSet(file_handle,fo))!=RET_YES)  {  aaFileStreamDestroy(file_handle);   return ret;   }
  }
 aaCast(new_mem,BP,mem);
 off=0;
 while(1)
  {
  todo=bytes;
  if(todo>_4K) { todo=_4K; }
  if((ret=aaFileStreamRead(file_handle,(H)todo,&new_mem[off]))!=RET_YES)  {   aaFileStreamDestroy(file_handle);   return ret;   }
  bytes-=todo;
  off+=todo;
  if(bytes==0) { break; }
  }
 if(bytesloaded) { *bytesloaded=(H)off; }
 aaFileStreamDestroy(file_handle);

 return RET_YES;
 }







 B aaFileUniqueCreate                  (VP filename,VP path,H chars,B alpha,B num,VP ext,B docreate)
 {
 B ret;
 B txt[_1K];
 B dir[_1K];
 B ful[_1K];
 B fex[_1K];
 H fh;
 B ch;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(chars==0||chars>64) { return RET_BOUNDS; }
 if(alpha!=YES&&num!=YES) { return RET_BADPARM; }
 if(filename) { aaStringNull(filename); }
 if(path==NULL)  {  if((ret=aaFileFolderWorkingGet(dir))!=YES) { return ret; }  }
 else            {  aaStringCopy(dir,path);  }
 if((ret=aaFileFolderExists(dir))!=YES) { return RET_FAILED; }
 if(aaStringIsNull(ext)==NO) { aaStringCopyf(fex,ext); }
 else                        { aaStringCopyf(fex,""); }
 while(1)
  {
  aaStringRandomSet(txt,chars,alpha,0,num,YES);
  aaStringCopyf(ful,"%s",dir);
  aaStringLastCharGet(ful,0,&ch);
  if(ch==BSLASH_CHAR) { aaStringAppendf(ful,"%s.%s",txt,fex); }
  else                { aaStringAppendf(ful,"\\%s.%s",txt,fex); }
  if(aaFileExists(ful)==YES) { continue; }
  if(docreate==YES)
   {
   if((ret=aaFileStreamCreate(&fh,ful,YES,aa_FILEMODE_RW,aa_FILESHARE_RW,1,NO))!=RET_YES) {  oops; }
   aaFileStreamDestroy(fh);
   }
  if(filename) { aaStringCopyf(filename,"%s.%s",txt,fex); }
  break;
  }
 return RET_YES;
 }





 B aaFileTimeSet                       (VP filename,_systime*ctime,_systime*mtime)
 {
 HANDLE hfile;
 SYSTEMTIME sti;
 FILETIME ct,mt,tt;
 BOOL b;
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(ctime==NULL&&mtime==NULL) { return RET_BADPARM; }
 if(filename==NULL) { return RET_BADPARM; }
 ret=aaFileExists(filename);
 if(ret==NO) { return RET_NOTFOUND; }
 if(ret!=YES) { return ret; }
 hfile=CreateFile(filename,GENERIC_WRITE,0,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
 if(hfile==INVALID_HANDLE_VALUE) { return RET_FAILED;  }
 if(ctime)
  {
  sti.wYear=ctime->year;
  sti.wMonth=ctime->month;
  sti.wDay=ctime->date;
  sti.wDayOfWeek=ctime->dow;
  sti.wHour=ctime->hour;
  sti.wMinute=ctime->minute;
  sti.wSecond=ctime->second;
  sti.wMilliseconds=0;
  SystemTimeToFileTime(&sti,&tt);
  LocalFileTimeToFileTime(&tt,&ct);
  }
 if(mtime)
  {
  sti.wYear=mtime->year;
  sti.wMonth=mtime->month;
  sti.wDay=mtime->date;
  sti.wDayOfWeek=mtime->dow;
  sti.wHour=mtime->hour;
  sti.wMinute=mtime->minute;
  sti.wSecond=mtime->second;
  sti.wMilliseconds=0;
  SystemTimeToFileTime(&sti,&tt);
  LocalFileTimeToFileTime(&tt,&mt);
  }
 b=1;
 if(ctime&&mtime)    {   b=SetFileTime(hfile,&ct,0,&mt);  } else
 if(ctime&&!mtime)   {   b=SetFileTime(hfile,&ct,0,0);  } else
 if(!ctime&&mtime)   {   b=SetFileTime(hfile,0,0,&mt);  }
 CloseHandle(hfile);
 if(b==0) { return RET_FAILED; }
 return RET_YES;
 }




 B aaFileSizeSet                       (VP filename,Q bytes)
 {
 Q by;
 B ret;
 _filestreamunit fsu;
 LARGE_INTEGER np;
 BOOL b;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(filename==NULL) { return RET_BADPARM; }
 if((ret=aaFileExists(filename))==NO) { return RET_NOTFOUND; }
 if(ret!=YES) { return ret; }
 if((ret=aaFileStreamCreate(&fsu.handle,filename,aa_FILECREATE_OPEN,3,3,1,0))!=RET_YES) { return ret;  }
 if((ret=aaFileStreamStatus(fsu.handle,&fsu.status))!=RET_YES)
  {
  aaFileStreamDestroy(fsu.handle);
  return ret;
  }
 np.QuadPart=bytes;
 b=SetFilePointerEx(fsu.status._handle,np,0,FILE_BEGIN);
 if(b==0) { oow; aaFileStreamDestroy(fsu.handle); return RET_FAILED; }
 b=SetEndOfFile(fsu.status._handle);
 if(b==0) { oow; aaFileStreamDestroy(fsu.handle); return RET_FAILED; }

 aaFileStreamDestroy(fsu.handle);
 if((ret=aaFileInfoGet(filename,&by,0,0,0,0))!=RET_YES) { return ret; }
 if(by!=bytes) { return RET_FAILED; }
 return RET_YES;
 }




 B aaFileIsUpxCompressed               (VP filename)
 {
 _filestreamunit fsu;
 H p,n,x,y;
 B file[_4K];
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(filename==NULL)  {  aaStringCopyf(file,"%s",aa.core_system.module_filename);  }
 else                {  aaStringCopyf(file,"%s",filename);  }
 if(aaFileExists(file)!=YES) { return RET_NOTFOUND; }
 if((ret=aaFileStreamCreate(&fsu.handle,file,aa_FILECREATE_OPEN,aa_FILEMODE_R,3,1,0))!=YES) { return RET_FAILED; }
 aaFileStreamStatus(fsu.handle,&fsu.status);
 aaFileStreamOffsetSet(fsu.handle,0x3c);
 aaFileStreamRead(fsu.handle,sizeof(H),&p);
 aaFileStreamOffsetSet(fsu.handle,p+0x74);
 aaFileStreamRead(fsu.handle,sizeof(H),&n);
 x=p+0x78+n*8;
 aaFileStreamOffsetSet(fsu.handle,x+0*0x28+0);
 aaFileStreamRead(fsu.handle,sizeof(H),&y);
 aaFileStreamDestroy(fsu.handle);
 if((y&0xFFFFFF)!=('U'+('P'<<8)+('X'<<16))) { return RET_NO; }
 return RET_YES;
 }




 B aaFileAttributesGet                 (VP filename,_fileattributes*fileattribs)
 {
 B ret;
 H dwa;
 B isfolder;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(fileattribs==NULL) { return RET_BADPARM; }
 aaMemoryFill(fileattribs,sizeof(_fileattributes),0);
 if((ret=aaFileInfoGet(filename,0,&isfolder,NULL,NULL,NULL))!=YES) { return ret; }
 dwa=GetFileAttributes(filename);
 if(dwa==INVALID_FILE_ATTRIBUTES) { oow; return RET_FAILED; }
 if((dwa&FILE_ATTRIBUTE_ARCHIVE))   { fileattribs->is_archive=YES;   }
 if((dwa&FILE_ATTRIBUTE_HIDDEN))    { fileattribs->is_hidden=YES;    }
 if((dwa&FILE_ATTRIBUTE_NORMAL))    { fileattribs->is_normal=YES;    }
 if((dwa&FILE_ATTRIBUTE_OFFLINE))   { fileattribs->is_offline=YES;   }
 if((dwa&FILE_ATTRIBUTE_READONLY))  { fileattribs->is_read_only=YES; }
 if((dwa&FILE_ATTRIBUTE_SYSTEM))    { fileattribs->is_system=YES;    }
 if((dwa&FILE_ATTRIBUTE_TEMPORARY)) { fileattribs->is_temp=YES;      }
 return RET_YES;
 }




 B aaFileAttributesSet                 (VP filename,_fileattributes*fileattribs)
 {
 B ret;
 H dwa;
 B isfolder;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(fileattribs==NULL) { return RET_BADPARM; }
 aaMemoryFill(fileattribs,sizeof(_fileattributes),0);
 if((ret=aaFileInfoGet(filename,0,&isfolder,NULL,NULL,NULL))!=YES) { return ret; }
 dwa=0;
 if(fileattribs->is_archive)   { dwa|=FILE_ATTRIBUTE_ARCHIVE;   }
 if(fileattribs->is_hidden)    { dwa|=FILE_ATTRIBUTE_HIDDEN;    }
 if(fileattribs->is_normal)    { dwa|=FILE_ATTRIBUTE_NORMAL;    }
 if(fileattribs->is_offline)   { dwa|=FILE_ATTRIBUTE_OFFLINE;   }
 if(fileattribs->is_read_only) { dwa|=FILE_ATTRIBUTE_READONLY;  }
 if(fileattribs->is_system)    { dwa|=FILE_ATTRIBUTE_SYSTEM;    }
 if(fileattribs->is_temp)      { dwa|=FILE_ATTRIBUTE_TEMPORARY; }
 if(SetFileAttributes(filename,dwa)==0) { oow; return RET_FAILED; }
 return RET_YES;
 }






 structure
 {
 W wLanguage;
 W wCodePage;
 }
 _LANGANDCODEPAGE;





 B aaFileDetailsGet                    (VP filename,_filedetails*filedetails,VP string)
 {
 B ret;
 B buf[_8K];
 B txt[_8K];
 B tok[_1K];
 BOOL bl;
 UINT size;
 TCHAR szQuery[256];
 TCHAR szsz[256];
 LPBYTE lpBuffer=0;
 VS_FIXEDFILEINFO*pFileInfo;
 _LANGANDCODEPAGE*lpTranslate;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(filename==NULL) { return RET_BADPARM; }
 if(string) { aaStringNull(string); }
 if((ret=aaFileExists(filename))!=RET_YES) { oops; return ret; }
 if(filedetails==NULL) { return RET_BADPARM; }
 aaMemoryFill(filedetails,sizeof(_filedetails),0);
 if((bl=GetFileVersionInfo(filename,0,sizeof(buf),buf))==0) { oow; }
 if((bl=VerQueryValue(buf,"\\",(VP*)&lpBuffer,&size))==0) {oow; }
 pFileInfo=(VS_FIXEDFILEINFO*)lpBuffer;
 filedetails->major_version=HIWORD(pFileInfo->dwFileVersionMS);
 filedetails->minor_version=LOWORD(pFileInfo->dwFileVersionMS);
 filedetails->build_number=HIWORD(pFileInfo->dwFileVersionLS);
 filedetails->revision_number=LOWORD(pFileInfo->dwFileVersionLS);

 if((pFileInfo->dwFileFlags&VS_FF_DEBUG)) { filedetails->is_debug_info=YES; }
 if((pFileInfo->dwFileFlags&VS_FF_PRERELEASE)) { filedetails->is_pre_release=YES; }
 if((pFileInfo->dwFileFlags&VS_FF_PRIVATEBUILD)) { filedetails->is_private_build=YES; }
 if((pFileInfo->dwFileFlags&VS_FF_SPECIALBUILD)) { filedetails->is_special_build=YES; }
 if((pFileInfo->dwFileOS&VOS_DOS)) { filedetails->for_dos=YES; }
 if((pFileInfo->dwFileOS&VOS_NT)) { filedetails->for_nt=YES; }
 if((pFileInfo->dwFileOS&VOS__WINDOWS16)) { filedetails->for_win16=YES; }
 if((pFileInfo->dwFileOS&VOS__WINDOWS32)) { filedetails->for_win32=YES; }
 if((pFileInfo->dwFileOS&VOS_OS216)) { filedetails->for_os216=YES; }
 if((pFileInfo->dwFileOS&VOS_OS232)) { filedetails->for_os232=YES; }
 if((pFileInfo->dwFileOS&VOS__PM16)) { filedetails->for_pm16=YES; }
 if((pFileInfo->dwFileOS&VOS__PM32)) { filedetails->for_pm32=YES; }
 if((pFileInfo->dwFileOS&VOS_DOS_WINDOWS16)) { filedetails->for_dos16=YES; }
 if((pFileInfo->dwFileOS&VOS_DOS_WINDOWS32)) { filedetails->for_dos32=YES; }
 if((pFileInfo->dwFileOS&VOS_NT_WINDOWS32)) { filedetails->for_nt32=YES; }
 if((pFileInfo->dwFileType&VFT_APP)) { filedetails->is_application=YES; }
 if((pFileInfo->dwFileType&VFT_DLL)) { filedetails->is_dll=YES; }
 if((pFileInfo->dwFileType&VFT_DRV)) { filedetails->is_drv=YES; }
 if((pFileInfo->dwFileType&VFT_FONT)) { filedetails->is_font=YES; }
 if((pFileInfo->dwFileType&VFT_STATIC_LIB)) { filedetails->is_static_lib=YES; }
 if((pFileInfo->dwFileType&VFT_VXD)) { filedetails->is_vxd=YES; }
 if(filedetails->is_drv)
  {
  if((pFileInfo->dwFileSubtype&VFT2_DRV_COMM)) { filedetails->is_drv_comm=YES; }
  if((pFileInfo->dwFileSubtype&VFT2_DRV_DISPLAY)) { filedetails->is_drv_display=YES; }
  if((pFileInfo->dwFileSubtype&VFT2_DRV_INSTALLABLE)) { filedetails->is_drv_installable=YES; }
  if((pFileInfo->dwFileSubtype&VFT2_DRV_KEYBOARD)) { filedetails->is_drv_keyboard=YES; }
  if((pFileInfo->dwFileSubtype&VFT2_DRV_LANGUAGE)) { filedetails->is_drv_language=YES; }
  if((pFileInfo->dwFileSubtype&VFT2_DRV_MOUSE)) { filedetails->is_drv_mouse=YES; }
  if((pFileInfo->dwFileSubtype&VFT2_DRV_NETWORK)) { filedetails->is_drv_network=YES; }
  if((pFileInfo->dwFileSubtype&VFT2_DRV_PRINTER)) { filedetails->is_drv_printer=YES; }
  if((pFileInfo->dwFileSubtype&VFT2_DRV_SOUND)) { filedetails->is_drv_sound=YES; }
  if((pFileInfo->dwFileSubtype&VFT2_DRV_SYSTEM)) { filedetails->is_drv_system=YES; }
  }
 if(filedetails->is_font)
  {
  if((pFileInfo->dwFileSubtype&VFT2_FONT_RASTER)) { filedetails->is_font_raster=YES; }
  if((pFileInfo->dwFileSubtype&VFT2_FONT_TRUETYPE)) { filedetails->is_font_truetype=YES; }
  if((pFileInfo->dwFileSubtype&VFT2_FONT_VECTOR)) { filedetails->is_font_vector=YES; }
  }
 if((bl=VerQueryValue(buf,"\\VarFileInfo\\Translation",(VOID FAR* FAR*)&lpBuffer,&size))==0) { oow; }
 lpTranslate=(_LANGANDCODEPAGE*)lpBuffer;
 filedetails->language=lpTranslate->wLanguage;
 filedetails->codepage=lpTranslate->wCodePage;
 wsprintf(szQuery,"\\StringFileInfo\\%04x%04x",lpTranslate->wLanguage,lpTranslate->wCodePage);
 wsprintf(szsz,"%s\\CompanyName",szQuery);
 if((bl=VerQueryValue(buf,szsz,(VOID FAR* FAR*)&lpBuffer,&size))!=0) {  aaStringCopyf(filedetails->company_name,"%s",lpBuffer); }
 wsprintf(szsz,"%s\\FileDescription",szQuery);
 if((bl=VerQueryValue(buf,szsz,(VOID FAR* FAR*)&lpBuffer,&size))!=0) {  aaStringCopyf(filedetails->file_description,"%s",lpBuffer); }
 wsprintf(szsz,"%s\\FileVersion",szQuery);
 if((bl=VerQueryValue(buf,szsz,(VOID FAR* FAR*)&lpBuffer,&size))!=0) {  aaStringCopyf(filedetails->file_version,"%s",lpBuffer); }
 wsprintf(szsz,"%s\\InternalName",szQuery);
 if((bl=VerQueryValue(buf,szsz,(VOID FAR* FAR*)&lpBuffer,&size))!=0) {  aaStringCopyf(filedetails->internal_name,"%s",lpBuffer); }
 wsprintf(szsz,"%s\\LegalCopyright",szQuery);
 if((bl=VerQueryValue(buf,szsz,(VOID FAR* FAR*)&lpBuffer,&size))!=0) {  aaStringCopyf(filedetails->legal_copyright,"%s",lpBuffer); }
 wsprintf(szsz,"%s\\LegalTrademarks",szQuery);
 if((bl=VerQueryValue(buf,szsz,(VOID FAR* FAR*)&lpBuffer,&size))!=0) {  aaStringCopyf(filedetails->legal_trademarks,"%s",lpBuffer); }
 wsprintf(szsz,"%s\\OriginalFileName",szQuery);
 if((bl=VerQueryValue(buf,szsz,(VOID FAR* FAR*)&lpBuffer,&size))!=0) {  aaStringCopyf(filedetails->original_filename,"%s",lpBuffer); }
 wsprintf(szsz,"%s\\ProductName",szQuery);
 if((bl=VerQueryValue(buf,szsz,(VOID FAR* FAR*)&lpBuffer,&size))!=0) {  aaStringCopyf(filedetails->product_name,"%s",lpBuffer); }
 wsprintf(szsz,"%s\\ProductVersion",szQuery);
 if((bl=VerQueryValue(buf,szsz,(VOID FAR* FAR*)&lpBuffer,&size))!=0) {  aaStringCopyf(filedetails->product_version,"%s",lpBuffer); }
 wsprintf(szsz,"%s\\Comments",szQuery);
 if((bl=VerQueryValue(buf,szsz,(VOID FAR* FAR*)&lpBuffer,&size))!=0) {  aaStringCopyf(filedetails->comments,"%s",lpBuffer); }
 wsprintf(szsz,"%s\\PrivateBuild",szQuery);
 if((bl=VerQueryValue(buf,szsz,(VOID FAR* FAR*)&lpBuffer,&size))!=0) {  aaStringCopyf(filedetails->private_build,"%s",lpBuffer); }
 wsprintf(szsz,"%s\\SpecialBuild",szQuery);
 if((bl=VerQueryValue(buf,szsz,(VOID FAR* FAR*)&lpBuffer,&size))!=0) {  aaStringCopyf(filedetails->special_build,"%s",lpBuffer); }
 if(string)
  {
  aaStringNull(txt);
  aaStringCopyf(tok,"major_version=%i",filedetails->major_version); aaStringAppendf(txt,"%-25s\n",tok);
  aaStringCopyf(tok,"minor_version=%i",filedetails->minor_version); aaStringAppendf(txt,"%-25s\n",tok);
  aaStringCopyf(tok,"build_number=%i",filedetails->build_number); aaStringAppendf(txt,"%-25s\n",tok);
  aaStringCopyf(tok,"revision_number=%i",filedetails->revision_number); aaStringAppendf(txt,"%-25s\n",tok);
  aaStringCopyf(tok,"language=%x",filedetails->language); aaStringAppendf(txt,"%-25s\n",tok);
  aaStringCopyf(tok,"codepage=%x",filedetails->codepage); aaStringAppendf(txt,"%-25s\n",tok);
  if(filedetails->is_debug_info)    {  aaStringCopyf(tok,"is_debug_info=%i",filedetails->is_debug_info); aaStringAppendf(txt,"%-25s\n",tok);  }
  if(filedetails->is_pre_release)   {  aaStringCopyf(tok,"is_pre_release=%i",filedetails->is_pre_release); aaStringAppendf(txt,"%-25s\n",tok);  }
  if(filedetails->is_private_build) {  aaStringCopyf(tok,"is_private_build=%i",filedetails->is_private_build); aaStringAppendf(txt,"%-25s\n",tok);  }
  if(filedetails->is_special_build) {  aaStringCopyf(tok,"is_special_build=%i",filedetails->is_special_build); aaStringAppendf(txt,"%-25s\n",tok);  }
  if(filedetails->for_dos)   { aaStringCopyf(tok,"for_dos=%i",filedetails->for_dos); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->for_dos16) { aaStringCopyf(tok,"for_dos16=%i",filedetails->for_dos16); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->for_dos32) { aaStringCopyf(tok,"for_dos32=%i",filedetails->for_dos32); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->for_nt)    { aaStringCopyf(tok,"for_nt=%i",filedetails->for_nt); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->for_nt32)  { aaStringCopyf(tok,"for_nt32=%i",filedetails->for_nt32); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->for_win16) { aaStringCopyf(tok,"for_win16=%i",filedetails->for_win16); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->for_win32) { aaStringCopyf(tok,"for_win32=%i",filedetails->for_win32); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->for_os216) { aaStringCopyf(tok,"for_os216=%i",filedetails->for_os216); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->for_os232) { aaStringCopyf(tok,"for_os232=%i",filedetails->for_os232); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->for_pm16)  { aaStringCopyf(tok,"for_pm16=%i",filedetails->for_pm16); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->for_pm32)  { aaStringCopyf(tok,"for_pm32=%i",filedetails->for_pm32); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->is_application)        { aaStringCopyf(tok,"is_application=%i",filedetails->is_application); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->is_dll)                { aaStringCopyf(tok,"is_dll=%i",filedetails->is_dll); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->is_drv)             { aaStringCopyf(tok,"is_drv=%i",filedetails->is_drv); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->is_drv_comm)        { aaStringCopyf(tok,"is_drv_comm=%i",filedetails->is_drv_comm); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->is_drv_display)     { aaStringCopyf(tok,"is_drv_display=%i",filedetails->is_drv_display); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->is_drv_installable) { aaStringCopyf(tok,"is_drv_installable=%i",filedetails->is_drv_installable); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->is_drv_keyboard)    { aaStringCopyf(tok,"is_drv_keyboard=%i",filedetails->is_drv_keyboard); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->is_drv_language)    { aaStringCopyf(tok,"is_drv_language=%i",filedetails->is_drv_language); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->is_drv_mouse)       { aaStringCopyf(tok,"is_drv_mouse=%i",filedetails->is_drv_mouse); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->is_drv_network)     { aaStringCopyf(tok,"is_drv_network=%i",filedetails->is_drv_network); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->is_drv_printer)     { aaStringCopyf(tok,"is_drv_printer=%i",filedetails->is_drv_printer); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->is_drv_sound)       { aaStringCopyf(tok,"is_drv_sound=%i",filedetails->is_drv_sound); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->is_drv_system)      { aaStringCopyf(tok,"is_drv_system=%i",filedetails->is_drv_system); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->is_font)          { aaStringCopyf(tok,"is_font=%i",filedetails->is_font); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->is_font_raster)   { aaStringCopyf(tok,"is_font_raster=%i",filedetails->is_font_raster); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->is_font_truetype) { aaStringCopyf(tok,"is_font_truetype=%i",filedetails->is_font_truetype); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->is_font_vector)   { aaStringCopyf(tok,"is_font_vector=%i",filedetails->is_font_vector); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->is_static_lib) { aaStringCopyf(tok,"is_static_lib=%i",filedetails->is_static_lib); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->is_vxd)        { aaStringCopyf(tok,"is_vxd=%i",filedetails->is_vxd); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->company_name[0])      { aaStringCopyf(tok,"company_name=%s",filedetails->company_name); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->file_description[0])  { aaStringCopyf(tok,"file_description=%s",filedetails->file_description); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->file_version[0])      { aaStringCopyf(tok,"file_version=%s",filedetails->file_version); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->internal_name[0])     { aaStringCopyf(tok,"internal_name=%s",filedetails->internal_name); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->legal_copyright[0])   { aaStringCopyf(tok,"legal_copyright=%s",filedetails->legal_copyright); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->legal_trademarks[0])  { aaStringCopyf(tok,"legal_trademarks=%s",filedetails->legal_trademarks); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->original_filename[0]) { aaStringCopyf(tok,"original_filename=%s",filedetails->original_filename); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->product_name[0])      { aaStringCopyf(tok,"product_name=%s",filedetails->product_name); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->product_version[0])   { aaStringCopyf(tok,"product_version=%s",filedetails->product_version); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->comments[0])          { aaStringCopyf(tok,"comments=%s",filedetails->comments); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->private_build[0])     { aaStringCopyf(tok,"private_build=%s",filedetails->private_build); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->special_build[0])     { aaStringCopyf(tok,"special_build=%s",filedetails->special_build); aaStringAppendf(txt,"%-25s\n",tok); }
  aaStringCopyf(string,"%s",txt);
  }
 return RET_YES;
 }






 B aaFileFolderCreate                  (VP fmt,...)
 {
 B foldername[_2K];
 B ret;
 B fold[_1K];
 B path[_1K];
 H off,pos;
 B ch;
 aaVargsf(fmt)

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaStringCopyf(foldername,"%s",str64k.buf);
 if(foldername[0]==NULL_CHAR) { return RET_BADPARM; }
 ret=aaFileFolderExists(foldername);
 if(ret==RET_YES) { return ret; }
 if(ret!=RET_NO)  { oops; }
 aaStringCopy(fold,foldername);
 aaStringReplaceChar(fold,0,FSLASH_CHAR,BSLASH_CHAR);
 aaStringLastCharGet(fold,0,&ch);
 if(ch!=BSLASH_CHAR) { aaStringAppend(fold,"\\"); }
 off=0;
 while(1)
  {
  aaStringFindChar(&fold[off],0,&pos,BSLASH_CHAR,YES,0,YES);
  if(pos==0xffffffff) { break; }
  aaStringNCopy(path,foldername,off+pos,YES);
  aaStringAppend(path,"\\");
  if(aaFileFolderExists(path)!=YES)
   {
   if(CreateDirectory((CP)path,NULL)==0) { return RET_FAILED; }
   }
  off+=(pos+1);
  }
 return RET_YES;
 }





 B aaFileFolderDelete                  (VP fmt,...)
 {
 BOOL bo;
 DWORD er;
 B foldername[_2K];
 B ret,isfold;

 aaVargsf(fmt)
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMemoryFill(foldername,sizeof(foldername),0);
 aaStringCopyf(foldername,"%s",str64k.buf);
 if(foldername[0]==NULL_CHAR) { return RET_BADPARM; }
 if((ret=aaFileInfoGet(foldername,NULL,&isfold,0,0,0))!=RET_YES) { return ret; }
 if(isfold==NO) { return RET_FAILED; }
 SetLastError(0);
 bo=RemoveDirectory((CP)foldername);
 if(bo==0)
  {
  er=GetLastError();
  if(er==ERROR_ACCESS_DENIED) { return RET_DENIED; }
  if(er==ERROR_SHARING_VIOLATION) { return RET_DENIED; }
  if(er==ERROR_FILE_NOT_FOUND) { return RET_NOTFOUND; }
  if(er==ERROR_DIR_NOT_EMPTY) {   return RET_EXISTS; }
  oow;
  aaNote(0,"%s %i",foldername,er);
  return RET_FAILED;
  }
 return RET_YES;
 }



 B aaFileFolderExists                  (VP fmt,...)
 {
 B isfold;
 DWORD a;
 B foldername[_2K];
 aaVargsf(fmt)

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaStringCopyf(foldername,"%s",str64k.buf);
 a=GetFileAttributes((CP)foldername);
 if(a==INVALID_FILE_ATTRIBUTES) { return RET_NO; }
 isfold=NO;
 if(a&FILE_ATTRIBUTE_DIRECTORY) { isfold=YES;  }
 if(isfold==NO) { return RET_NO; }
 return RET_YES;
 }




 B aaFileFolderWorkingSet              (VP fmt,...)
 {
 B foldername[_2K];
 B ret,isfold;
 B fold[_2K];
 aaVargsf(fmt)

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaStringCopyf(foldername,"%s",str64k.buf);
 if(foldername[0]==NULL_CHAR)
  {
  aaStringCopy(fold,aa.core_system.module_path);
  }
 else
  {
  aaStringCopy(fold,foldername);
  }
 if((ret=aaFileInfoGet(fold,NULL,&isfold,0,0,0))!=RET_YES) { return ret; }
 if(isfold==NO) { return RET_FAILED; }
 if(SetCurrentDirectory((CP)fold)==0) { return RET_FAILED; }
 return RET_YES;
 }




 B aaFileFolderWorkingGet              (VP foldername)
 {
 B fold[_2K];
 B ascii;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(foldername==NULL) { return RET_BADPARM; }
 aaStringNull(foldername);
 if(GetCurrentDirectory(_2K,(VP)fold)==0) { return RET_FAILED; }
 aaStringCharGet(fold,0,-1,&ascii);
 if(ascii!=BSLASH_CHAR) {  aaStringAppendChar(fold,BSLASH_CHAR); }
 aaStringCopy(foldername,fold);
 return RET_YES;
 }





 B aaFileFolderDllSet                  (VP fmt,...)
 {
 B foldername[_2K];
 B ret,isfold;
 B fold[_2K];
 aaVargsf(fmt)

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaStringCopyf(foldername,"%s",str64k.buf);
 if(foldername[0]==NULL_CHAR)
  {
  aaStringCopy(fold,aa.core_system.module_path);
  }
 else
  {
  aaStringCopy(fold,foldername);
  }
 if((ret=aaFileInfoGet(fold,NULL,&isfold,0,0,0))!=RET_YES) { return ret; }
 if(isfold==NO) { return RET_FAILED; }

 if(aa.core_system.SetDllDirectory((CP)fold)==0) {  return RET_FAILED; }
 return RET_YES;
 }





 B aaFileFolderRename                  (VP foldername,VP newfoldername)
 {
 B ret;
 B isfolder;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaFileInfoGet(foldername,NULL,&isfolder,0,0,0))!=RET_YES) { return ret; }
 if(isfolder!=YES) { return RET_FAILED; }
 if(MoveFileEx(foldername,newfoldername,MOVEFILE_WRITE_THROUGH|MOVEFILE_COPY_ALLOWED)==0) { return RET_FAILED; }
 return RET_YES;
 }




 B aaFileFolderTreeCreate              (VP foldername,B levels,B hex)
 {
 B etc[_1K];
 B buf[_1K];
 B fmt[_1K];
 B txt[_1K];
 H i,l,c,s,p,off,z,mul;
 B rot[_1K];
 _syspath sp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(hex) mul=16;
 else    mul=10;
 if(levels>=6) { return RET_BOUNDS; }
 aaSysPathGet(&sp);
 if(aaStringIsNull(foldername)==NO)
  {
  aaStringCopyf(rot,"%s",foldername);
  if(rot[0]=='/') {  aaStringCopyf(rot,"%s%s",sp.current_dir,rot);   }
  }
 else  {  aaStringCopyf(rot,"%s",sp.current_dir);  }
 aaFileFolderCreate(rot);
 c=1;
 for(l=0;l<levels;l++) { c=c*mul;  }
 if(mul==10) { aaStringCopyf(fmt,"%%0%ii",levels);  }
 else        { aaStringCopyf(fmt,"%%0%ix",levels); }
 l=0;
 etc[0]=0;
 for(i=0;i<c;i++)
  {
  aaStringCopyf(buf,fmt,i);
  p=0;
  for(s=0;s<100;s++)
   {
   etc[p++]=buf[s];
   etc[p++]='/';
   }
  etc[p]=0;
  for(z=0;z<levels;z++)
   {
   aaStringCopyf(txt,"%s/%s",rot,etc);
   aaStringFindChar(txt,0,&off,'/',YES,(levels-z-1),NO);
   txt[off]=0;
   aaFileFolderCreate("%s",txt);
   txt[off]='/';
   }
  }
 return RET_YES;
 }




 B aaFileFolderTreeDelete              (VP foldername,B levels,B hex,B delfiles)
 {
 B etc[_1K];
 B buf[_1K];
 B fmt[_1K];
 B txt[_1K];
 H i,l,c,s,p,off,z,mul;
 B rot[_1K];
 _syspath sp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(hex) mul=16;
 else    mul=10;
 if(levels>=6) { return RET_BOUNDS; }
 aaSysPathGet(&sp);
 if(aaStringIsNull(foldername)==NO)
  {
  aaStringCopyf(rot,"%s",foldername);
  if(rot[0]=='/') {  aaStringCopyf(rot,"%s%s",sp.current_dir,rot);   }
  }
 else  {  aaStringCopyf(rot,"%s",sp.current_dir);  }
 c=1;
 for(l=0;l<levels;l++) { c=c*mul;  }
 if(mul==10) { aaStringCopyf(fmt,"%%0%ii",levels); }
 else        { aaStringCopyf(fmt,"%%0%ix",levels); }
 l=0;
 etc[0]=0;
 for(i=0;i<c;i++)
  {
  aaStringCopyf(buf,fmt,i);
  p=0;
  for(s=0;s<100;s++)
   {
   etc[p++]=buf[s];
   etc[p++]='/';
   }
  etc[p]=0;
  for(z=0;z<levels;z++)
   {
   aaStringCopyf(txt,"%s/%s",rot,etc);
   //if(delfiles)     {     aaDebugf("zdel %s",txt); oof;     }
   if(delfiles) { aaDebugf("del %s",txt);  }
   aaStringFindChar(txt,0,&off,'/',YES,(levels-z-1),NO);
   txt[off]=0;
   if(delfiles) { aaDebugf("del %s",txt);  }
   aaFileFolderDelete(txt);
   txt[off]='/';
   }
  }
 aaFileFolderCreate(rot);
 return RET_YES;
 }




 B aaFileFolderTreeVerify              (VP foldername,B levels,B hex)
 {
 B ret;
 B etc[_1K];
 B buf[_1K];
 B fmt[_1K];
 B txt[_1K];
 H i,l,c,s,p,off,z,mul;
 B rot[_1K];
 _syspath sp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(hex) mul=16;
 else    mul=10;
 if(levels>=6) { return RET_BOUNDS; }
 aaSysPathGet(&sp);
 if(aaStringIsNull(foldername)==NO)
  {
  aaStringCopyf(rot,"%s",foldername);
  if(rot[0]=='/') {  aaStringCopyf(rot,"%s%s",sp.current_dir,rot);   }
  }
 else  {  aaStringCopyf(rot,"%s",sp.current_dir);  }
 c=1;
 for(l=0;l<levels;l++) { c=c*mul;  }
 if(mul==10) { aaStringCopyf(fmt,"%%0%ii",levels); }
 else        { aaStringCopyf(fmt,"%%0%ix",levels); }
 l=0;
 etc[0]=0;
 for(i=0;i<c;i++)
  {
  aaStringCopyf(buf,fmt,i);
  p=0;
  for(s=0;s<100;s++)
   {
   etc[p++]=buf[s];
   etc[p++]='/';
   }
  etc[p]=0;
  for(z=0;z<levels;z++)
   {
   aaStringCopyf(txt,"%s/%s",rot,etc);
   aaStringFindChar(txt,0,&off,'/',YES,(levels-z-1),NO);
   txt[off]=0;
   ret=aaFileFolderExists("%s",txt);
   if(ret!=RET_YES) {  return RET_FAILED;    }
   //aaFileFolderDelete(txt);
   txt[off]='/';
   }
  }
 //aaFileFolderCreate(rot);
 return RET_YES;
 }






 B aaFileUnitLoad                      (_fileunit*unit,VP fmt,...)
 {
 B ret;
 H by;
 va_list argptr;
 B txt[_4K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,txt);
 if(unit==NULL) { return RET_BADPARM; }
 aaMemoryFill(unit,sizeof(_fileunit),0);
 if((ret=aaFileLoadToMemory(txt,0,0xffffffff,(VP)&unit->mem,&by))!=YES) { return ret; }
 unit->magic=aa_FILEUNIT_MAGIC;
 unit->bytes=(Q)by;
 return RET_YES;
 }




 B aaFileUnitRelease                   (_fileunit*unit)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(unit==NULL) { return RET_BADPARM; }
 if(unit->magic!=aa_FILEUNIT_MAGIC) { return RET_FAILED; }
 if(unit->mem!=NULL) { aaMemoryRelease(unit->mem); }
 aaMemoryFill(unit,sizeof(_fileunit),0);
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/


 B aaFileBoxOpen                       (H surfacehandle,VP initdir,VP initfile,VP fltr,B maxfiles,VP caption)
 {
 H sl,id;
 B ret;
 _aa_surfaceobject*surp;
 H mx;
 B etc[_2K];
 _fileboxstatus fs;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aa.filebox_system.is_open==YES) { return RET_ALREADYOPEN; }
 if(maxfiles==0) { return RET_BADPARM; }
 if(surfacehandle!=0)
  {
  if((ret=aa_ObjectCheck(aa.surface_system.object_id,surfacehandle,(VP)&surp,NULL))!=RET_YES) { return ret; }
  }
 aaMemoryFill(&aa.filebox_system,sizeof(_aa_fileboxsystem),0);
 if(caption==NULL) { aaStringCopy(aa.filebox_system.caption,"FileBox");  }
 else                { aaStringCopy(aa.filebox_system.caption,caption);  }
 if(fltr!=NULL)
  {
  aaStringLen(fltr,&sl);
  if(sl>255) { return RET_BADPARM; }
  aaStringCopy(aa.filebox_system.filter,fltr);
  }
 if(initdir!=NULL)
  {
  aaStringLen(initdir,&sl);
  if(sl>255) { return RET_BADPARM; }
  aaStringCopy(aa.filebox_system.initial_dir,initdir);
  aaStringReplaceChar(aa.filebox_system.initial_dir,0,FSLASH_CHAR,BSLASH_CHAR);
  }
 else
  {
  if(aaFileFolderWorkingGet(etc)==YES)
   {
   aaStringCopy(aa.filebox_system.initial_dir,etc);
   aaStringReplaceChar(aa.filebox_system.initial_dir,0,FSLASH_CHAR,BSLASH_CHAR);
   }
  }

 if(initfile!=NULL)
  {
  aaStringLen(initfile,&sl);
  if(sl>255) { return RET_BADPARM; }
  aaStringCopy(aa.filebox_system.initial_file,initfile);
  }
 aa.filebox_system.max_files=maxfiles;
 if(surfacehandle!=0) { aa.filebox_system.parent_hwnd=surp->status.hwnd; }
 mx=(sizeof(fs.filename)/sizeof(fs.filename[0]));
 if(fs.count==mx) {  }
 if((ret=aaMemoryAllocate((VP)&aa.filebox_system.selection,sizeof(fs.filename)+_1K))!=RET_YES)
  {
  aaMemoryFill(&aa.filebox_system,sizeof(_aa_fileboxsystem),0);
  return ret;
  }
 aa.filebox_system.is_open=YES;
 aa.filebox_system.handle=CreateThread(NULL,0,aa_FileBoxProc,&aa.filebox_system,0,&id);
 if(aa.filebox_system.handle==NULL)
  {
  aaMemoryRelease(aa.filebox_system.selection);
  aaMemoryFill(&aa.filebox_system,sizeof(_aa_fileboxsystem),0);
  return RET_FAILED;
  }
 return RET_YES;
 }




 B aaFileBoxClose                      (V)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aa.filebox_system.is_open!=YES) { return RET_NOTOPEN; }
 if(aa.filebox_system.is_close==YES) { return RET_YES; }
 if(TerminateThread((HANDLE)aa.filebox_system.handle,(UINT)0)==FALSE) { oof; oow; oof; }
 CloseHandle((HANDLE)aa.filebox_system.handle);
 if(aa.filebox_system.selection!=NULL) { aaMemoryRelease(aa.filebox_system.selection); }
 aaMemoryFill(&aa.filebox_system,sizeof(_aa_fileboxsystem),0);
 aa.filebox_system.is_close=YES;
 return RET_YES;
 }




 B aaFileBoxStatus                     (_fileboxstatus*fileboxstatus)
 {
 BOOL q;
 B tok[_4K];
 H c,toklen,offset,ec;
 B mode;
 B ascii;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(fileboxstatus==NULL) { return RET_BADPARM; }
 aaMemoryFill(fileboxstatus,sizeof(_fileboxstatus),0);
 if(aa.filebox_system.is_open!=YES) { return RET_NOTOPEN; }
 if(aa.filebox_system.is_failure)   { fileboxstatus->is_failure=YES;  }
 if(aa.filebox_system.is_cancelled)   { fileboxstatus->is_cancelled=YES;  }


 q=GetExitCodeThread(aa.filebox_system.handle,&ec);
 if(ec==STILL_ACTIVE) {  return RET_INUSE; }
 if(q==0||ec==0)
  {
  aa.filebox_system.is_cancelled=YES;
  fileboxstatus->is_cancelled=YES;
//  return RET_CANCELLED;
  }
 if(aa.filebox_system.is_cancelled) { return RET_CANCELLED; }
 if(aa.filebox_system.is_failure) { return RET_FAILED; }
 aaMemoryFill(tok,sizeof(tok),0);
 aaStringCopyf(&tok[_0K],"%s",&aa.filebox_system.selection[0]);
 aaStringCopyf(&tok[_1K],"%s",&aa.filebox_system.selection[aa.filebox_system.of.nFileOffset]);
 aaStringCopyf(&tok[_2K],"%s",&aa.filebox_system.selection[aa.filebox_system.of.nFileExtension]);
 mode=0;
 if(aa.filebox_system.max_files<2)
  {
  if(aa.filebox_system.of.nFileOffset!=0&&aa.filebox_system.of.nFileExtension!=0) { mode=1; }
  else
  if(aa.filebox_system.of.nFileOffset!=0&&aa.filebox_system.of.nFileExtension==0) { mode=2; }
  }
 else
 if(aa.filebox_system.max_files>=2)
  {
  if(aa.filebox_system.of.nFileOffset!=0&&aa.filebox_system.of.nFileExtension!=0) { mode=3; }
  else
  if(aa.filebox_system.of.nFileOffset!=0&&aa.filebox_system.of.nFileExtension==0) { mode=4; }
  }
 offset=aa.filebox_system.of.nFileOffset;
 if(mode==0||offset==0)
  {
  aa.filebox_system.is_failure=YES;
  fileboxstatus->is_failure=YES;
  }
 c=0;
 toklen=0;
 tok[toklen]=NULL_CHAR;
 while(1)
  {
  ascii=aa.filebox_system.selection[offset++];
  if(ascii!=NULL_CHAR)   {   tok[toklen++]=ascii;   tok[toklen]=NULL_CHAR;   continue;   }
  tok[toklen]=ascii;
  if(toklen==0||(toklen>=sizeof(fileboxstatus->filename[0])))
   {
   oof;
   aa.filebox_system.is_failure=YES;
   fileboxstatus->is_failure=YES;
   break;
   }
  aaStringNCopy(fileboxstatus->filename[c],tok,toklen,YES);
  c++;
  ascii=aa.filebox_system.selection[offset];
  if(ascii==NULL_CHAR) { break; }
  toklen=0;
  tok[toklen]=NULL_CHAR;
  }
 fileboxstatus->count=c;
 aaStringNCopy(fileboxstatus->path,aa.filebox_system.selection,aa.filebox_system.of.nFileOffset,YES);
 if(aa.filebox_system.is_failure)
  {
  return RET_FAILED;
  }
 if(fileboxstatus->count!=0)
  {
  if(aaStringIsEmpty(fileboxstatus->path,YES)==NO)
   {
   fileboxstatus->is_success=YES;
   }
  }
 return RET_YES;
 }










/*-----------------------------------------------------------------------*/



 B aaFolderBoxOpen                     (H surfacehandle,VP initdir,VP caption)
 {
 H sl,id;
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aa.folderbox_system.is_open==YES) { return RET_ALREADYOPEN; }
 if(surfacehandle!=0)
  {
  if((ret=aa_ObjectCheck(aa.surface_system.object_id,surfacehandle,(VP)&surp,NULL))!=RET_YES) { return ret; }
  }
 aaMemoryFill(&aa.folderbox_system,sizeof(_aa_folderboxsystem),0);
 if(caption==NULL) { aaStringCopy(aa.folderbox_system.caption,"FolderBox");  }
 else                { aaStringCopy(aa.folderbox_system.caption,caption);  }
 if(initdir!=NULL)
  {
  aaStringLen(initdir,&sl);
  if(sl>512) { return RET_BADPARM; }
  aaStringCopy(aa.folderbox_system.initial_dir,initdir);
  }
 if(surfacehandle!=0) { aa.folderbox_system.surface_handle=surfacehandle;  }
 if(surfacehandle!=0) { aa.folderbox_system.parent_hwnd=surp->status.hwnd; }
   aa.folderbox_system.bi.hwndOwner=aa.folderbox_system.parent_hwnd;
   aa.folderbox_system.bi.pszDisplayName=aa.folderbox_system.szDir;
   aa.folderbox_system.bi.lpszTitle=(CP)aa.folderbox_system.caption;
   aa.folderbox_system.bi.ulFlags=BIF_USENEWUI;
   aa.folderbox_system.bi.lpfn=aa_FolderBoxCallback;
   aa.folderbox_system.bi.lParam=(LPARAM)aa.folderbox_system.initial_dir;
   aa.folderbox_system.bi.iImage=-1;
 aa.folderbox_system.is_close=NO;
 aa.folderbox_system.is_cancelled=NO;
 aa.folderbox_system.is_open=YES;
 aa.folderbox_system.handle=CreateThread(NULL,0,aa_FolderBoxProc,&aa.folderbox_system,0,&id);
 if(aa.folderbox_system.handle==NULL)
  {
  aaMemoryFill(&aa.folderbox_system,sizeof(_aa_folderboxsystem),0);
  return RET_FAILED;
  }
 return RET_YES;
 }





 B aaFolderBoxClose                    (V)
 {
 T V (*def_cotaskmemfree) (LPVOID);
 def_cotaskmemfree my_cotaskmemfree;
 HMODULE lib;
 _folderboxstatus fs;
 DWORD ec;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(aa.folderbox_system.is_open!=YES) { return RET_NOTOPEN; }
 aaFolderBoxStatus(&fs);
 if(fs.is_cancelled!=YES&&fs.is_success!=YES)
  {
  aaFocusToHwnd(aa.folderbox_system.dialog_hwnd);
  if(EndDialog(aa.folderbox_system.dialog_hwnd,0)==0) { oof; oow; }
  while(1)
   {
   aaFolderBoxStatus(&fs);
   if(fs.is_cancelled==YES||fs.is_success==YES) break;
   aaYield(-1.0);
   }
  while(1)
   {
   if(GetExitCodeThread(aa.folderbox_system.handle,&ec)==0) { oof; oow; break; }
   if(ec!=STILL_ACTIVE) {  break; }
   aaYield(-1.0);
   }
  }
 CloseHandle((HANDLE)aa.folderbox_system.handle);
 if(aa.folderbox_system.pidl!=NULL)
  {
  if((lib=LoadLibrary("ole32.dll"))==NULL) { oof; }
  my_cotaskmemfree=(def_cotaskmemfree)     GetProcAddress(lib,"CoTaskMemFree");
  if(my_cotaskmemfree==NULL) oof;
  my_cotaskmemfree(aa.folderbox_system.pidl);
  FreeLibrary(lib);
  }
 aaMemoryFill(&aa.folderbox_system,sizeof(_aa_folderboxsystem),0);
 return RET_YES;
 }







 B aaFolderBoxStatus                   (_folderboxstatus*folderboxstatus)
 {
 BOOL q;
 DWORD ec=0;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(folderboxstatus==NULL) { return RET_BADPARM; }
 aaMemoryFill(folderboxstatus,sizeof(_folderboxstatus),0);
 if(aa.folderbox_system.is_open!=YES) { return RET_NOTOPEN; }
 if(aa.folderbox_system.is_failure)   { folderboxstatus->is_failure=YES;  }
 if(aa.folderbox_system.is_cancelled)   { folderboxstatus->is_cancelled=YES;  }
 if(aa.folderbox_system.is_cancelled) { return RET_CANCELLED; }
 if(aa.folderbox_system.is_failure) { return RET_FAILED; }
 q=GetExitCodeThread(aa.folderbox_system.handle,&ec);
 if(ec==STILL_ACTIVE) {  return RET_YES; }
 if(q==0||ec==0)
  {
  aa.folderbox_system.is_cancelled=YES;
  folderboxstatus->is_cancelled=YES;
  return RET_CANCELLED;
  }
 if(aa.folderbox_system.pidl==NULL)
  {
  folderboxstatus->is_cancelled=YES;
  }
 else
  {
  if(folderboxstatus->is_success!=YES)
   {
   if(SHGetPathFromIDList(aa.folderbox_system.pidl,(LPSTR)aa.folderbox_system.r_path)==FALSE) oof;
   }
  folderboxstatus->is_success=YES;
  }
 if(folderboxstatus->is_success==YES) { aaStringCopyf(folderboxstatus->path,"%s",aa.folderbox_system.r_path); }
 return RET_YES;
 }


/*-----------------------------------------------------------------------*/

 B aaDirOpen                           (HP handle,B gettimes,VP filespec)
 {
 B ret;
 _aa_dirobject*dirp;
 HANDLE h;
 H c;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCreate(aa.dir_system.object_id,handle,(VP)&dirp))!=RET_YES) { oops; return ret; }
 dirp->self_handle=*handle;
 dirp->status.in_progress=YES;
 gettimes&=1;
 dirp->status.is_gettimes=gettimes;
 h=FindFirstFile(filespec,&dirp->wfd);
 if(h==INVALID_HANDLE_VALUE) { dirp->status.is_completed=YES; }
 else
  {
  dirp->handle=h;
  c=128;
  aaMemoryAllocate((VP)&dirp->mem,c*sizeof(_direntry));
  aaCast(dirp->status.entry,_direntry*,dirp->mem);
  dirp->slots=c;
  }
 aaStringCopy(dirp->status.file_spec,filespec);
 return RET_YES;
 }




 B aaDirClose                          (H handle)
 {
 B ret;
 _aa_dirobject*dirp;
 B isprot;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.dir_system.object_id,handle,(VP)&dirp,&isprot))!=RET_YES) { return ret; }
 if(isprot) { return RET_FORBIDDEN; }
 if(dirp->handle!=NULL)  {  FindClose(dirp->handle);  }
 if(dirp->slots!=0)  {  aaMemoryRelease(dirp->mem);  }
 aa_ObjectDestroy(aa.dir_system.object_id,handle);
 return RET_YES;
 }




 B aaDirStatus                         (H handle,_dirstatus*dirstatus,H iterations)
 {
 B ret;
 _aa_dirobject*dirp;
 H left,toadd,go;
 _direntry*ep;
 H i;
 BP old_mem;
 BOOL bl;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.dir_system.object_id,handle,(VP)&dirp,NULL))!=RET_YES) { return ret; }
 if(dirp->status.in_progress!=YES) { return RET_FAILED; }
 if(iterations==0) { iterations=1; }
 for(go=0;go<iterations;go++)
  {
  if(dirp->status.is_completed==YES) { break; }
  left=dirp->slots-dirp->status.total_entries;
  if(left<4)
   {
   old_mem=dirp->mem;
   toadd=(dirp->slots)+(dirp->slots/4)+128;
   aaMemoryReAllocate((VP)&old_mem,(dirp->slots+toadd)*sizeof(_direntry));
   dirp->mem=old_mem;
   dirp->slots+=toadd;
   }
  aaCast(ep,_direntry*,dirp->mem);
  i=dirp->status.total_entries;
  ep[i].attributes=dirp->wfd.dwFileAttributes;
  if(dirp->wfd.dwFileAttributes&FILE_ATTRIBUTE_DIRECTORY) { ep[i].is_folder=YES; }
  else                                                    { ep[i].is_folder=NO; }
  aaStringCopy(ep[i].file_name,dirp->wfd.cFileName);
  aaStringCopy(ep[i].alt_file,dirp->wfd.cAlternateFileName);
  ep[i].file_bytes=(Q)(dirp->wfd.nFileSizeHigh*0xffffffff)+dirp->wfd.nFileSizeLow;
  ep[i].is_dotty=0;
  if(ep[i].is_folder)
   {
   dirp->status.dir_entries++;
   if(ep[i].file_name[0]=='.'&&ep[i].file_name[1]==NULL_CHAR)                          { ep[i].is_dotty=1; } else
   if(ep[i].file_name[0]=='.'&&ep[i].file_name[1]=='.'&&ep[i].file_name[2]==NULL_CHAR) { ep[i].is_dotty=2; }
   //if(ep[i].is_dotty==0) {   dirp->status.folder_entries++; }
   dirp->status.folder_entries++;
   }
  else     { dirp->status.file_entries++; }
  if(dirp->status.is_gettimes)
   {
   WinFileTimeToSysTime(&dirp->wfd.ftCreationTime,&ep[i].created);
   WinFileTimeToSysTime(&dirp->wfd.ftLastWriteTime,&ep[i].modified);
   }
///     aaDebugf(">  %s",dirp->wfd.cFileName);
  dirp->status.total_entries++;
  bl=FindNextFile(dirp->handle,&dirp->wfd);
  if(bl==0)
   {
   if(GetLastError()==ERROR_NO_MORE_FILES)
    {
    FindClose(dirp->handle);
    dirp->handle=0;
    dirp->status.is_completed=YES;
    }
   else oof;
   }

  }
 aaCast(dirp->status.entry,_direntry*,dirp->mem);
 if(dirstatus) { aaMemoryCopy(dirstatus,sizeof(_dirstatus),&dirp->status); }
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/



 B aaDirWalkerCreate                   (HP handle,VP root,VP spec,B incfiles,H maxdepth,B(*proc)(H,VP,_dirwalkerstatus*,_direntry*))
 {
 B ret;
 _aa_dirwalkerobject*dwlkp;
 B txt[_2K];
 H pos;
 B ascii;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 if((ret=aa_ObjectCreate(aa.dirwalker_system.object_id,handle,(VP)&dwlkp))!=RET_YES) { oops; return ret; }
 #endif
 dwlkp->self_handle=*handle;
 dwlkp->status.in_progress=YES;
 if(incfiles) { dwlkp->status.is_incfiles=YES; }
 dwlkp->status.max_depth=maxdepth;
 if(aaStringIsEmpty(root,YES)==NO)
  {
  aaStringCopyf(dwlkp->status.root,"%s",root);
  }
 else
  {
  aaStringCopyf(dwlkp->status.root,"%s",root);
  if((ret=aaFileFolderWorkingGet(dwlkp->status.root))!=YES) { oops; }
  }
 aaStringReplaceChar(dwlkp->status.root,0,BSLASH_CHAR,FSLASH_CHAR);
 aaStringLastCharGet(dwlkp->status.root,0,&ascii);
 if(ascii==FSLASH_CHAR) { aaStringLastCharSet(dwlkp->status.root,0,NULL_CHAR,YES); }
 aaStringCopyf(dwlkp->status.spec,"%s",spec);
 aaMiniStackNew(&dwlkp->dms);
 dwlkp->stage=20;
 dwlkp->status.proc=proc;
 aaStringLen(dwlkp->status.root,&dwlkp->root_sl);
 aaStringCopyf(txt,"%s/%s",dwlkp->status.root,dwlkp->status.spec);
  dwlkp->ti=0;
   if((ret=aaDirOpen(&dwlkp->status.dir.handle,(dwlkp->status.is_incfiles),txt))!=YES) { oops;  }
   if((ret=aaDirStatus(dwlkp->status.dir.handle,&dwlkp->status.dir.status,100))!=YES) { oops; }
   aaStringCopyf(dwlkp->status.cur_dir,"%s",dwlkp->status.dir.status.file_spec);
   aaStringFindChar(dwlkp->status.cur_dir,0,&pos,'/',YES,0,NO);
   if(pos!=0xffffffff) {  dwlkp->status.cur_dir[pos+1]=NULL_CHAR; }
  if((ret=aaListNew(&dwlkp->status.list,YES,0,0,1))!=YES) { oops; }
 dwlkp->stage=20;
 return RET_YES;
 }




 B aaDirWalkerDestroy                  (H handle)
 {
 B ret;
 _aa_dirwalkerobject*dwlkp;
 B isprot;
 H han;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 if((ret=aa_ObjectCheck(aa.dirwalker_system.object_id,handle,(VP)&dwlkp,&isprot))!=RET_YES) { return ret; }
 #endif
 if(isprot) { return RET_FORBIDDEN; }
 if(dwlkp->status.dir.handle!=0)
  {
  aaDirClose(dwlkp->status.dir.handle);
  dwlkp->status.dir.handle=0;
  }
 while(1)
  {
  if(dwlkp->dms.bytes<8) { break; }
  if(aaMiniStackPopDword(&dwlkp->dms,&han)!=YES) { break; }
  if(aaMiniStackPopDword(&dwlkp->dms,&han)!=YES) { break; }
  aaDirClose(han);
  }
 aaListDelete(&dwlkp->status.list);
 #ifdef aa_VERSION
 aa_ObjectDestroy(aa.dirwalker_system.object_id,handle);
 #endif
 return RET_YES;
 }






 B aaDirWalkerStatus                   (H handle,_dirwalkerstatus*dirwalkerstatus,H iterationsa,H iterationsb)
 {
 B ret;
 _aa_dirwalkerobject*dwlkp;
 H pos,ti,han,go,index,fulls,flag;
 H depth;
 B needs_status=YES;
 B is_cancelled=NO;
 B txt[_2K];
 B str[_2K];
 B(*proc)(H,VP,_dirwalkerstatus*,_direntry*);

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 if((ret=aa_ObjectCheck(aa.dirwalker_system.object_id,handle,(VP)&dwlkp,NULL))!=RET_YES) { return ret; }
 #endif
 if(dwlkp->status.in_progress!=YES) { return RET_FAILED; }
 if(iterationsa==0) { iterationsa=1; }
 if(iterationsb==0) { iterationsb=1; }
if(dwlkp->in_proc)
  {
  if(dirwalkerstatus) { aaMemoryCopy(dirwalkerstatus,sizeof(_dirwalkerstatus),&dwlkp->status); }
  return RET_YES;
  }
 fulls=0;
 for(go=0;go<iterationsa;go++)
  {
  if(dwlkp->status.is_completed==YES) { break; }
  if(is_cancelled==YES)  { dwlkp->stage=60; break; }

  switch(dwlkp->stage)
   {
   case 10:
   break;


   case 20:
   fulls++;
   if((ret=aaDirStatus(dwlkp->status.dir.handle,&dwlkp->status.dir.status,iterationsb))!=YES) { oops; dwlkp->stage=666; break; }
   if(dwlkp->status.dir.status.is_completed!=YES) { break; }
   needs_status=YES;
   dwlkp->stage=30;
   break;


   case 30:
   if(needs_status)
    {
    if(aaDirStatus(dwlkp->status.dir.handle,&dwlkp->status.dir.status,1)!=YES) oof;
    needs_status=NO;
    }
   ti=dwlkp->ti;
   if(ti>=dwlkp->status.dir.status.total_entries)  { dwlkp->stage=40;    break;    }
   aaStringCopyf(dwlkp->status.cur_dir,"%s",dwlkp->status.dir.status.file_spec);
   aaStringFindChar(dwlkp->status.cur_dir,0,&pos,'/',YES,0,NO);
   if(pos!=0xffffffff) {  dwlkp->status.cur_dir[pos+1]=NULL_CHAR; }
   aaStringCopyf(str,"%s%s",dwlkp->status.cur_dir,dwlkp->status.dir.status.entry[ti].file_name);
   aaStringCopyf(str,"%s",&str[dwlkp->root_sl]);
   if(dwlkp->status.dir.status.entry[ti].is_dotty==NO)
    {
    while(1)
     {
     depth=dwlkp->dms.height/2;
     if(depth>dwlkp->status.max_depth) { break; }
     if(dwlkp->status.is_incfiles==NO&&dwlkp->status.dir.status.entry[ti].is_folder==NO) { break; }

     flag=YES;
     if(dwlkp->status.proc)
      {
      dwlkp->in_proc=YES;
      proc=dwlkp->status.proc;
      ret=proc(handle,str,&dwlkp->status,&dwlkp->status.dir.status.entry[ti]);
      if(ret!=RET_YES) { flag=NO; }
      if(ret==RET_CANCELLED) { is_cancelled=YES; }
      dwlkp->in_proc=NO;
      }
     if(flag==YES)
      {
      if((ret=aaListAppend(&dwlkp->status.list,&index,str,sizeof(_direntry),&dwlkp->status.dir.status.entry[ti]))!=YES)
       {
       aaNote(0,"%s %s",ret_string[ret],str);
       aaNote(0,"index=%i ti=%i",index,ti);
       aaNote(0,"zqas %s",dwlkp->status.dir.status.entry[ti].file_name);
       aaNote(0,"32rr %s",&dwlkp->status.list.mun.mem[dwlkp->status.list.entry[index].key_off]);
       }
      if(dwlkp->status.dir.status.entry[ti].is_folder==NO) { dwlkp->status.total_files_added++; }
      else                                                 { dwlkp->status.total_folders_added++; }
      dwlkp->status.total_added=dwlkp->status.total_files_added+dwlkp->status.total_folders_added;
      }
     break;
     }
    }
   if(dwlkp->status.dir.status.entry[ti].is_dotty==NO&&dwlkp->status.dir.status.entry[ti].is_folder==YES)
    {
    depth=dwlkp->dms.height/2;
    if(depth<=dwlkp->status.max_depth)
     {
     aaDirStatus(dwlkp->status.dir.handle,&dwlkp->status.dir.status,1);
     aaStringCopyf(txt,"%s",dwlkp->status.dir.status.file_spec);
     aaStringCharSet(txt,0,-3,0);
     aaStringAppendf(txt,"%s",dwlkp->status.dir.status.entry[dwlkp->ti].file_name);
     aaStringAppendf(txt,"/%s",dwlkp->status.spec);
     dwlkp->ti++;
     aaMiniStackPushDword(&dwlkp->dms,dwlkp->status.dir.handle);
     aaMiniStackPushDword(&dwlkp->dms,dwlkp->ti);
     dwlkp->ti=0;
     if((ret=aaDirOpen(&dwlkp->status.dir.handle,(dwlkp->status.is_incfiles),txt))!=YES) { oops;  }
     if((ret=aaDirStatus(dwlkp->status.dir.handle,&dwlkp->status.dir.status,1))!=YES) { oops; }
     aaStringCopyf(dwlkp->status.cur_dir,"%s",dwlkp->status.dir.status.file_spec);
     aaStringFindChar(dwlkp->status.cur_dir,0,&pos,'/',YES,0,NO);
     if(pos!=0xffffffff) {  dwlkp->status.cur_dir[pos+1]=NULL_CHAR; }
     dwlkp->stage=20;
     dwlkp->status.total_folders_found++;
     dwlkp->status.total_found=dwlkp->status.total_files_found+dwlkp->status.total_folders_found;
     break;
     }
    dwlkp->ti++;
    dwlkp->status.total_folders_found++;
    dwlkp->status.total_found=dwlkp->status.total_files_found+dwlkp->status.total_folders_found;
    break;
    }
   if(dwlkp->status.dir.status.entry[ti].is_dotty==NO&&dwlkp->status.dir.status.entry[ti].is_folder==NO)
    {
    dwlkp->status.total_files_found++;
    dwlkp->status.total_found=dwlkp->status.total_files_found+dwlkp->status.total_folders_found;
    }
   dwlkp->ti++;
   break;

   case 40:
   aaDirClose(dwlkp->status.dir.handle);
   dwlkp->status.dir.handle=0;
   if(dwlkp->dms.bytes<8) { dwlkp->stage=50; break; }
   if((ret=aaMiniStackPopDword(&dwlkp->dms,&ti))!=YES)  { oops; dwlkp->stage=666; break; }
   if((ret=aaMiniStackPopDword(&dwlkp->dms,&han))!=YES) { oops; dwlkp->stage=666; break; }
   dwlkp->status.dir.handle=han;
   if((ret=aaDirStatus(dwlkp->status.dir.handle,&dwlkp->status.dir.status,1))!=YES) { oops; dwlkp->stage=666; break; }
   dwlkp->ti=ti;
   if(dwlkp->dms.bytes==0)
    {
    aaStringCopyf(txt,"%s",dwlkp->status.dir.status.file_spec);
    aaStringCharSet(txt,0,-3,0);
    aaStringAppendf(txt,"%s",dwlkp->status.dir.status.entry[dwlkp->ti].file_name);
    aaStringAppendf(txt,"/");
    }
   dwlkp->stage=20;
   break;

   case 80:
   oof;
   break;

   case 50:
   dwlkp->status.is_completed=YES;
   break;

   case 60:
   dwlkp->status.is_cancelled=YES;
   break;

   case 666:
   return RET_FAILED;
   }
  }
 if(dirwalkerstatus) { aaMemoryCopy(dirwalkerstatus,sizeof(_dirwalkerstatus),&dwlkp->status); }
 return RET_YES;
 }







/*-----------------------------------------------------------------------*/



 B aaDriveEject                        (B drive,B state)
 {
 MCI_OPEN_PARMS op;
 H flags;
 C name[4];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(drive>='A'&&drive<='Z') drive+=(C)32;
 if(drive<'a'||drive>'z') { return RET_BADPARM; }
 aaStringCopyf(name,"%c:\\",drive);
 aaMemoryFill(&op,sizeof(op),0);
 op.lpstrDeviceType=(LPCSTR)MCI_DEVTYPE_CD_AUDIO;
 op.lpstrElementName=name;
 flags=MCI_OPEN_TYPE|MCI_OPEN_TYPE_ID|MCI_OPEN_ELEMENT|MCI_OPEN_SHAREABLE;
 if(!mciSendCommand(0,MCI_OPEN,flags,(H)&op))
  {
  if(state) mciSendCommand(op.wDeviceID,MCI_SET,MCI_SET_DOOR_OPEN,0);
  else      mciSendCommand(op.wDeviceID,MCI_SET,MCI_SET_DOOR_CLOSED,0);
  mciSendCommand(op.wDeviceID,MCI_CLOSE,MCI_WAIT,0);
  }
 return RET_YES;
 }




 B aaDriveInfoGet                      (B drive,_driveinfo*driveinfo)
 {
 UINT u;
 B bin[100];
 H val;
 C rootpath[129];
 B ty;
 LPCTSTR szHD;
 UCHAR szFileSys[255],szVolNameBuff[255];
 DWORD dwSerial,dwMFL,dwSysFlags;
 BOOL bSuccess;
 B etc[_1K];
 H va,vb,vc,vd;
 D d0,d1,d2;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(driveinfo==NULL) { return RET_BADPARM; }
 aaMemoryFill(driveinfo,sizeof(_driveinfo),0);
 aaStringCopy(driveinfo->type_txt,"???");
 driveinfo->type=aa_DRIVETYPE_UNKNOWN;
 if(drive>='A'&&drive<='Z') drive+=(C)32;
 if(drive<'a'||drive>'z') { return RET_BADPARM; }
 rootpath[0]=drive;
 rootpath[1]=':';
 rootpath[2]=0;
 u=GetDriveType(rootpath);
 ty=(B)u;
 driveinfo->type=ty;
 driveinfo->drive=drive;
  switch(ty)
   {
   case aa_DRIVETYPE_UNKNOWN: aaStringCopy(driveinfo->type_txt,"???"); break;
   case aa_DRIVETYPE_ERROR: aaStringCopy(driveinfo->type_txt,"ERR"); break;
   case aa_DRIVETYPE_REMOVABLE: aaStringCopy(driveinfo->type_txt,"RMV"); break;
   case aa_DRIVETYPE_FIXED: aaStringCopy(driveinfo->type_txt,"FXD"); break;
   case aa_DRIVETYPE_REMOTE: aaStringCopy(driveinfo->type_txt,"REM"); break;
   case aa_DRIVETYPE_CDROM: aaStringCopy(driveinfo->type_txt,"C.D"); break;
   case aa_DRIVETYPE_RAMDISK: aaStringCopy(driveinfo->type_txt,"RAM"); break;
   default: aaStringCopy(driveinfo->type_txt,"BAD"); break;
   }
 if(ty==aa_DRIVETYPE_UNKNOWN) { return RET_NOTFOUND;  }
 if(ty==aa_DRIVETYPE_ERROR) { return RET_NOTFOUND; }
 szHD=(VP)etc;
 aaStringCopyf((VP)szHD,"%c:\\",drive);
 bSuccess=GetVolumeInformation(szHD,(LPTSTR)szVolNameBuff,255,&dwSerial,&dwMFL,&dwSysFlags,(LPTSTR)szFileSys,255);
 if(!bSuccess){ return RET_FAILED;}

 driveinfo->volume_id=dwSerial;
 driveinfo->max_filename_len=dwMFL;
 if(szVolNameBuff[0]==NULL_CHAR) { aaStringCopy(driveinfo->volume_name,"NOTPRESENT"); }
 else                            { aaStringCopy(driveinfo->volume_name,szVolNameBuff); }
  if(ty>=aa_DRIVETYPE_REMOVABLE)
   {
   if(GetDiskFreeSpace(rootpath,&va,&vb,&vc,&vd)==0) { oow; }
   d0=(D)vd*va*vb;
   d1=(D)vc*va*vb;
   d2=d0-d1;
   va=va*vb;
   driveinfo->size=(Q)d0;
   driveinfo->left=(Q)d1;
   driveinfo->used=(Q)d2;
   ///driveinfo->left=driveinfo->size-driveinfo->used;
   driveinfo->page_size=va;
   #if 1
   aaDigestQuickf(aa_DIGESTTYPE_Sha256,NULL,driveinfo->digest,"%u:%I64u:%u:%s",driveinfo->type,driveinfo->size,driveinfo->volume_id,driveinfo->volume_name);
   for(u=0;u<40;u+=2)
    {
    val=driveinfo->digest[u+0];
    if(aaCharIsNum(val)) { val-='0';          }
    else                 { val-='a'; val+=10; }
    bin[(u/2)]=(val<<4);
    val=driveinfo->digest[u+1];
    if(aaCharIsNum(val)) { val-='0';          }
    else                 { val-='a'; val+=10; }
    bin[(u/2)]+=(val);
    }
   for(u=0;u<5;u++)
    {
    val=*(HP)&bin[u*4];
    if(u==0) {    driveinfo->crc=val; }
    else     {    driveinfo->crc^=val; }
    }
   #endif
   return RET_YES;
   }
 return RET_NOTFOUND;
 }






 B aaDriveListGet                      (_drivelist*drivelist)
 {
 B d;
 UINT em;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(drivelist==NULL) { return RET_BADPARM; }
 aaMemoryFill(drivelist,sizeof(_drivelist),0);
 em=SetErrorMode(SEM_FAILCRITICALERRORS);
 for(d=0;d<26;d++)
  {
  drivelist->ret[d]=aaDriveInfoGet('a'+d,&drivelist->info[d]);
  if(drivelist->ret[d]!=YES) { continue; }
  drivelist->num_found++;
  }
 SetErrorMode(em);
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/

 B aaFileStreamCreate                  (HP handle,VP filename,B create,B rwmode,B shmode,B cmode,B deleteon)
 {
 B ret;
 _aa_filestreamobject*fsp;
 DWORD access_mode=0;
 DWORD share_mode=0;
 DWORD er;
 B isfolder;
 H opt;
 _fileid id;
 BP bp;
 N which;
 LARGE_INTEGER li;
 BY_HANDLE_FILE_INFORMATION info;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(handle) { *handle=0; }
 if(rwmode>3||shmode>3)              { return RET_BADPARM; }
 if(filename==NULL/*&&create!=YES*/) { return RET_BADPARM; }
 which=-1;
 aaCast(bp,BP,filename);
 if(bp[0]=='$') {  aaStringIsIString(bp,&which,"$stdin","$stdout",NULL);  }
 if((ret=aa_ObjectCreate(aa.filestream_system.object_id,handle,(VP)&fsp))!=RET_YES) {oops; return ret; }
 fsp->self_handle=*handle;
 if(rwmode==aa_FILEMODE_NONE)  { access_mode=0; }               else
 if(rwmode==aa_FILEMODE_R)     { access_mode=GENERIC_READ; }    else
 if(rwmode==aa_FILEMODE_W)     { access_mode=GENERIC_WRITE; }   else
 if(rwmode==aa_FILEMODE_RW)    { access_mode=GENERIC_READ|GENERIC_WRITE; }
 if(shmode==aa_FILESHARE_NONE) { share_mode=0; }                 else
 if(shmode==aa_FILESHARE_R)    { share_mode=FILE_SHARE_READ; }   else
 if(shmode==aa_FILESHARE_W)    { share_mode=FILE_SHARE_WRITE; }  else
 if(shmode==aa_FILESHARE_RW)   { share_mode=FILE_SHARE_READ|FILE_SHARE_WRITE; }
 opt=0;
 if(aaBitGet(cmode,0)) { opt|=FILE_FLAG_SEQUENTIAL_SCAN; }
 if(aaBitGet(cmode,1)) { opt|=FILE_FLAG_RANDOM_ACCESS;  }
 if(aaBitGet(cmode,2)) { opt|=FILE_FLAG_WRITE_THROUGH; }
 if(which!=-1)
  {
  if(deleteon) { aa_ObjectDestroy(aa.filestream_system.object_id,*handle);   *handle=0;   return RET_FAILED;   }
  fsp->status.is_created=NO;
  aaStringCopy(fsp->status.filename,filename);
  if(which==0)   {   fsp->status.is_std_input=YES;   fsp->handle=GetStdHandle(STD_INPUT_HANDLE);    }
  else
  if(which==1)   {   fsp->status.is_std_output=YES;  fsp->handle=GetStdHandle(STD_OUTPUT_HANDLE);   }
  if(fsp->handle==INVALID_HANDLE_VALUE) {  aa_ObjectDestroy(aa.filestream_system.object_id,*handle);   *handle=0;   return RET_FAILED;   }
  fsp->status.id.volume=0;
  fsp->status.id.object[0]=0;
  fsp->status.id.object[1]=0;
  fsp->status.bytes=0;
  fsp->status.offset=0;
  fsp->status.left=fsp->status.bytes-fsp->status.offset;
  if(SetNamedPipeHandleState(fsp->handle,PIPE_READMODE_BYTE|PIPE_WAIT,0,0)==0) oof;
  fsp->is_stdio=YES;
  fsp->status._handle=fsp->handle;
  fsp->last_size=fsp->status.bytes;  fsp->last_offset=fsp->status.offset;
  return RET_YES;
  }
 if(deleteon) { fsp->status.is_delete=YES; }
 else         { fsp->status.is_delete=NO; }
 if(fsp->status.is_delete) { opt|=FILE_FLAG_DELETE_ON_CLOSE; }
 if(create==aa_FILECREATE_CREATENEW)
  {
  if(filename==NULL)   { oof;    }
  else                 { aaStringCopy(fsp->status.filename,filename);   }
  if((fsp->handle=CreateFile(filename,access_mode,share_mode,NULL,CREATE_ALWAYS,opt,NULL))==INVALID_HANDLE_VALUE)
   {
   aa_ObjectDestroy(aa.filestream_system.object_id,*handle);
   *handle=0;
   return RET_FAILED;
   }
  fsp->status.is_created=YES;
  }
 else
  {
  ret=aaFileInfoGet(filename,NULL,&isfolder,0,0,&id);
  if(isfolder==YES) { oof; ret=RET_FAILED; }
  if(ret!=RET_YES)
   {
   if(ret==RET_NOTFOUND&&create==aa_FILECREATE_CREATE) {}
   else
    {
    aa_ObjectDestroy(aa.filestream_system.object_id,*handle);
    *handle=0;
    return ret;
    }
   }
  if((fsp->handle=CreateFile(filename,access_mode,share_mode,NULL,(create==aa_FILECREATE_CREATE)?OPEN_ALWAYS:OPEN_EXISTING,opt,NULL))==INVALID_HANDLE_VALUE)
   {
   er=GetLastError();
   aa_ObjectDestroy(aa.filestream_system.object_id,*handle);
   *handle=0;
   if(er==ERROR_ACCESS_DENIED) { return RET_DENIED; }
   if(er==ERROR_SHARING_VIOLATION) { return RET_DENIED; }
   if(er==ERROR_FILE_NOT_FOUND) { return RET_NOTFOUND; }
   if(er==ERROR_PATH_NOT_FOUND) { return RET_NOTFOUND; }
   oow;
   return RET_FAILED;
   }
  fsp->status.is_created=NO;
  }
 fsp->status.id.volume=id.volume;
 fsp->status.id.object[0]=id.object[0];
 fsp->status.id.object[1]=id.object[1];
 if(GetFileInformationByHandle(fsp->handle,&info)==0) { oof; oow; }
 else
  {
  li.LowPart=info.nFileSizeLow;
  li.HighPart=info.nFileSizeHigh;
  fsp->status.bytes=li.QuadPart;
  }
 fsp->status.left=fsp->status.bytes-fsp->status.offset;
 aaStringCopy(fsp->status.filename,filename);
 if(create==aa_FILECREATE_CREATENEW)
  {
  aaFileStreamFlush(*handle);
  }
 fsp->gfs_required=YES;
 fsp->status._handle=fsp->handle;
 fsp->last_size=fsp->status.bytes;
 fsp->last_offset=fsp->status.offset;
 return RET_YES;
 }








 B aaFileStreamDestroy                 (H handle)
 {
 B ret;
 _aa_filestreamobject*fsp;
 B isprot;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.filestream_system.object_id,handle,(VP)&fsp,&isprot))!=RET_YES) { return ret; }
 if(isprot==YES) { oof; Boop; return RET_FORBIDDEN; }

 if(fsp->status.is_mapped)
  {
  if(fsp->status.mapped_ptr!=NULL)
   {
   if(UnmapViewOfFile(fsp->status.mapped_ptr)==0) { oow; }
   fsp->status.mapped_ptr=NULL;
   }
  if(fsp->map_handle)
   {
   CloseHandle(fsp->map_handle);
   fsp->map_handle=NULL;
   }
  fsp->status.is_mapped=NO;
  }
 CloseHandle(fsp->handle);
 aa_ObjectDestroy(aa.filestream_system.object_id,handle);
 return RET_YES;
 }






 B aaFileStreamStatus                  (H handle,_filestreamstatus*filestreamstatus)
 {
 B ret;
 _aa_filestreamobject*fsp;
 LARGE_INTEGER li;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.filestream_system.object_id,handle,(VP)&fsp,NULL))!=RET_YES) { return ret; }
 if(fsp->status.is_std_input!=YES&&fsp->status.is_std_output!=YES)
  {
  aa_stats[28]++;
  if(GetFileSizeEx(fsp->handle,&li)==0)
   {
   if(GetLastError()!=NO_ERROR) {  oow; return RET_FAILED; }
   }
  fsp->status.bytes=li.QuadPart;
  fsp->gfs_required=NO;
  fsp->status.left=fsp->status.bytes-fsp->status.offset;
  fsp->last_size=fsp->status.bytes;
  fsp->last_offset=fsp->status.offset;
  }
 if(filestreamstatus) {   aaMemoryCopy(filestreamstatus,sizeof(_filestreamstatus),&fsp->status); }
 return RET_YES;
 }




 B aaFileStreamInfoGet                 (H handle,QP bytes,_systime*ctime,_systime*mtime,_fileid*id)
 {
 B ret;
 _aa_filestreamobject*fsp;
 SYSTEMTIME st;
 FILETIME fct,fmt,tmt;
 BY_HANDLE_FILE_INFORMATION info;
 LARGE_INTEGER li;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.filestream_system.object_id,handle,(VP)&fsp,NULL))!=RET_YES) { return ret; }
 if(id)  { id->volume=0; id->object[0]=id->object[1]=0; }
 if(bytes) { *bytes=0; }
 if(ctime) { aaTimeNull(ctime); }
 if(mtime) { aaTimeNull(mtime); }
 if(bytes)
  {
  if(GetFileSizeEx(fsp->handle,&li)==0)
   {
   if(GetLastError()!=NO_ERROR) { oof; }
   }
  if(bytes) { *bytes=li.QuadPart; }
  }
 if(ctime||mtime)
  {
  if(GetFileTime(fsp->handle,(ctime)?&fct:NULL,NULL,(mtime)?&fmt:NULL)!=0)
   {
   if(ctime)
    {
    if(FileTimeToLocalFileTime(&fct,&tmt)==0) {        return RET_FAILED;    }
    if(FileTimeToSystemTime(&tmt,&st)==0) {        return RET_FAILED;    }
    WinSystemTimeToSysTime(&st,ctime);
    }
   if(mtime)
    {
    if(FileTimeToLocalFileTime(&fmt,&tmt)==0) {        return RET_FAILED;    }
    if(FileTimeToSystemTime(&tmt,&st)==0) {        return RET_FAILED;    }
    WinSystemTimeToSysTime(&st,mtime);
    }
   }
  }
 if(id)
  {
  if(GetFileInformationByHandle(fsp->handle,&info)==0)  {   return RET_FAILED;   }
  id->volume=info.dwVolumeSerialNumber;
  id->object[0]=info.nFileIndexLow;
  id->object[1]=info.nFileIndexHigh;
  }
 return RET_YES;
 }




 /* see readfile win32 api help: for pipes ...

lpNumberOfBytesRead
Points to the number of bytes read. ReadFile sets this value to zero before doing any work or error radioing. If this parameter is zero when ReadFile returns TRUE on a named pipe, the other end of the message-mode pipe called the WriteFile function with nNumberOfBytesToWrite set to zero.
If lpOverlapped is NULL, lpNumberOfBytesRead cannot be NULL.
If lpOverlapped is not NULL, lpNumberOfBytesRead can be NULL. If this is an overlapped read operation, you can get the number of bytes read by calling GetOverlappedResult. If hFile is associated with an I/O completion port, you can get the n
 */


 B aaFileStreamRead                    (H handle,H bytes,VP data)
 {
 B ret;
 _aa_filestreamobject*fsp;
 H oked;
 BOOL result;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.filestream_system.object_id,handle,(VP)&fsp,NULL))!=RET_YES) { return ret; }
 if(bytes==0)  {  return RET_YES; }
 if(data==NULL) { return RET_BADPARM; }
 if((fsp->status.offset+bytes)>fsp->status.bytes) { return RET_BOUNDS; }
 SetLastError(0);
 result=ReadFile(fsp->handle,data,bytes,&oked,NULL);
 if(result==0) { oow; }
 if(result&&oked==0) { oow;aaNote(0,"bytes=%I64d",bytes);  return RET_FAILED; }
 if(result&&oked==bytes)
  {
  aa_stats[29]++;
  fsp->crlf_state=0;
  fsp->status.offset+=(Q)oked;
  fsp->status.left=fsp->status.bytes-fsp->status.offset;
   fsp->last_offset=fsp->status.offset;
  return RET_YES;
  }
 if(result)
  {
  oow;
  }
 aaNote(0,"fromoff=%I64u left=%I64u byt=%I64u bytes=%u oked=%u result=%u",fsp->status.offset,fsp->status.left,fsp->status.bytes,bytes,oked,result);
 return RET_FAILED;
 }





 B aaFileStreamPeek                    (H handle,H bytes,VP data)
 {
 B ret;
 _aa_filestreamobject*fsp;
 Q pos;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.filestream_system.object_id,handle,(VP)&fsp,NULL))!=RET_YES) { return ret; }
 aaFileStreamStatus(handle,0);
 pos=fsp->status.offset;
 if((ret=aaFileStreamRead(handle,bytes,data))!=YES) { oops; }
 if((ret=aaFileStreamOffsetSet(handle,pos))!=RET_YES) oops;
 aaFileStreamStatus(handle,0);
 return ret;
 }





 B aaFileStreamWriteEof                (H handle)
 {
 B ret;
 _aa_filestreamobject*fsp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.filestream_system.object_id,handle,(VP)&fsp,NULL))!=RET_YES)  {  return ret; }
 if(fsp->status.is_mapped) { return RET_INUSE; }
 if(fsp->status.mapped_ptr!=NULL) { return RET_INUSE; }
 if(fsp->map_handle) { return RET_INUSE; }
 if(SetEndOfFile(fsp->handle)==0)  {  return RET_FAILED;  }
 fsp->cycle=0;
 fsp->gfs_required=YES;
 aaFileStreamStatus(handle,0);
 return RET_YES;
 }





 B aaFileStreamWrite                   (H handle,H bytes,VP data)
 {
 B ret;
 _aa_filestreamobject*fsp;
 DWORD er;
 H oked;
 Q ilef;
 B resetcycle;
 Q remaining,todo,tot;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.filestream_system.object_id,handle,(VP)&fsp,NULL))!=RET_YES)  {  return ret; }
 if(bytes==0)  { return RET_YES; }
 if(data==NULL) {  return RET_BADPARM; }
 bp=(BP)data;
 remaining=(Q)bytes;
 tot=0;
 while(1)
  {
  if(remaining==0) { break; }
  todo=aaNumRoof(remaining,_4K);
  ilef=fsp->status.left;
  if((Q)bytes>=ilef) { resetcycle=YES; }
  else               { resetcycle=NO; }
  SetLastError(0);
  fsp->gfs_required=YES;
  if(WriteFile(fsp->handle,bp,(H)todo,&oked,NULL)==0)
   {
   er=GetLastError();
   if(er==ERROR_ACCESS_DENIED)
    {
    aaNote(0,"denied, but did %i of %i tot=%I64d",oked,todo,tot);
    return RET_DENIED;
    }
   oow;
   }

  if(oked!=(H)todo) { oof; }
  tot+=(Q)oked;
  if(resetcycle==YES) fsp->cycle=0;
  fsp->status.offset+=(Q)oked;
  if(fsp->status.offset>=fsp->status.bytes)
   {
   aaFileStreamStatus(handle,0);
   fsp->status.left=fsp->status.bytes-fsp->status.offset;
   }
  remaining-=todo;
  bp+=todo;
  }
 aaFileStreamStatus(handle,0);
 return RET_YES;
 }




 B aaFileStreamWritef                  (H handle,VP fmt,...)
 {
 B ret;
 _aa_filestreamobject*fsp;
 va_list argptr;
 B temp[_16K];
 BP tmp=NULL_POINTR;
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaCast(tmp,BP,temp);
 if(aa.is_ready==YES)
  {
  if((ret=aa_MemoryTemp((VP)&tmp,_64K,aa_MEMORYTEMP_FileWritef))!=RET_YES) { return ret; }
  }
 aaFmt(fmt,argptr,tmp);
 if((ret=aa_ObjectCheck(aa.filestream_system.object_id,handle,(VP)&fsp,NULL))!=RET_YES)  {  return ret; }
 aaStringLen(tmp,&sl);
 ret=aaFileStreamWrite(handle,sl,tmp);
 return(ret);
 }




 B aaFileStreamWriteByte               (H handle,B beo,B val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(beo) {}
 return(aaFileStreamWrite(handle,1,&val));
 }



 B aaFileStreamWriteWord               (H handle,B beo,W val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(beo) { val=aaNumSwapWord(val);   }
 return(aaFileStreamWrite(handle,2,&val));
 }


 B aaFileStreamWriteDword              (H handle,B beo,H val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(beo) { val=aaNumSwapDword(val);   }
 return(aaFileStreamWrite(handle,4,&val));
 }



 B aaFileStreamWriteQuad               (H handle,B beo,Q val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(beo) { val=aaNumSwapQuad(val); }
 return(aaFileStreamWrite(handle,8,&val));
 }



 B aaFileStreamWriteFloat              (H handle,B beo,F val)
 {
 B tmp[4];
 B buf[4];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(sizeof(F)!=4) { oof; }
 *(FP)&buf[0]=val;
 if(beo)
  {
  tmp[0]=buf[3];  tmp[1]=buf[2];
  tmp[2]=buf[1];  tmp[3]=buf[0];
  return(aaFileStreamWrite(handle,4,tmp));
  }
 return(aaFileStreamWrite(handle,4,buf));
 }




 B aaFileStreamWriteDouble             (H handle,B beo,D val)
 {
 B tmp[8];
 B buf[8];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(sizeof(D)!=8) { oof; }
 *(DP)&buf[0]=val;
 if(beo)
  {
  tmp[0]=buf[7];  tmp[1]=buf[6];
  tmp[2]=buf[5];  tmp[3]=buf[4];
  tmp[4]=buf[3];  tmp[5]=buf[2];
  tmp[6]=buf[1];  tmp[7]=buf[0];
  return(aaFileStreamWrite(handle,8,tmp));
  }
 return(aaFileStreamWrite(handle,8,buf));
 }





 B aaFileStreamReadByte                (H handle,B beo,BP val)
 {
 B ret;
 B v;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(val==NULL) { return RET_BADPARM; }
 if((ret=aaFileStreamRead(handle,1,&v))!=RET_YES) { return ret; }
 if(beo) {}
 *val=v;
 return RET_YES;
 }


 B aaFileStreamReadWord                (H handle,B beo,WP val)
 {
 B ret;
 W v;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(val==NULL) { return RET_BADPARM; }
 if((ret=aaFileStreamRead(handle,2,&v))!=RET_YES) { return ret; }
 if(beo) { v=aaNumSwapWord(v); }
 *val=v;
 return RET_YES;
 }


 B aaFileStreamReadDword               (H handle,B beo,HP val)
 {
 B ret;
 H v;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(val==NULL) { return RET_BADPARM; }
 if((ret=aaFileStreamRead(handle,4,&v))!=RET_YES) { return ret; }
 if(beo) { v=aaNumSwapDword(v); }
 *val=v;
 return RET_YES;
 }


 B aaFileStreamReadQuad                (H handle,B beo,QP val)
 {
 B ret;
 Q v;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(val==NULL) { return RET_BADPARM; }
 if((ret=aaFileStreamRead(handle,8,&v))!=RET_YES) { return ret; }
 if(beo) { v=aaNumSwapQuad(v); }
 *val=v;
 return RET_YES;
 }



 B aaFileStreamReadFloat               (H handle,B beo,FP val)
 {
 B ret;
 B buf[4];
 B tmp[4];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(val==NULL) { return RET_BADPARM; }
 if((ret=aaFileStreamRead(handle,4,buf))!=RET_YES) { return ret; }
 if(beo)
  {
  tmp[0]=buf[3];  tmp[1]=buf[2];
  tmp[2]=buf[1];  tmp[3]=buf[0];
  *val=*(FP)&tmp[0];
  return RET_YES;
  }
 *val=*(FP)&buf[0];
 return RET_YES;
 }




 B aaFileStreamReadDouble              (H handle,B beo,DP val)
 {
 B ret;
 B buf[8];
 B tmp[8];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(val==NULL) { return RET_BADPARM; }
 if((ret=aaFileStreamRead(handle,8,buf))!=RET_YES) { return ret; }
 if(beo)
  {
  tmp[0]=buf[7];  tmp[1]=buf[6];
  tmp[2]=buf[5];  tmp[3]=buf[4];
  tmp[4]=buf[3];  tmp[5]=buf[2];
  tmp[6]=buf[1];  tmp[7]=buf[0];
  *val=*(DP)&tmp[0];
  return RET_YES;
  }
 *val=*(DP)&buf[0];
 return RET_YES;
 }




 B aaFileStreamPeekByte                (H handle,B beo,BP val)
 {
 B ret;
 B v;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(val==NULL) { return RET_BADPARM; }
 if((ret=aaFileStreamPeek(handle,1,&v))!=RET_YES) { return ret; }
 if(beo) {}
 *val=v;
 return RET_YES;
 }


 B aaFileStreamPeekWord                (H handle,B beo,WP val)
 {
 B ret;
 W v;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(val==NULL) { return RET_BADPARM; }
 if((ret=aaFileStreamPeek(handle,2,&v))!=RET_YES) { return ret; }
 if(beo) { v=aaNumSwapWord(v); }
 *val=v;
 return RET_YES;
 }




 B aaFileStreamPeekDword               (H handle,B beo,HP val)
 {
 B ret;
 H v;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(val==NULL) { return RET_BADPARM; }
 if((ret=aaFileStreamPeek(handle,4,&v))!=RET_YES) { return ret; }
 if(beo) { v=aaNumSwapDword(v); }
 *val=v;
 return RET_YES;
 }



 B aaFileStreamPeekQuad                (H handle,B beo,QP val)
 {
 B ret;
 Q v;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(val==NULL) { return RET_BADPARM; }
 if((ret=aaFileStreamPeek(handle,8,&v))!=RET_YES) { return ret; }
 if(beo) { v=aaNumSwapQuad(v); }
 *val=v;
 return RET_YES;
 }



 B aaFileStreamPeekFloat               (H handle,B beo,FP val)
 {
 B ret;
 B buf[4];
 B tmp[4];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(val==NULL) { return RET_BADPARM; }
 if((ret=aaFileStreamPeek(handle,4,buf))!=RET_YES) { return ret; }
 if(beo)
  {
  tmp[0]=buf[3];  tmp[1]=buf[2];
  tmp[2]=buf[1];  tmp[3]=buf[0];
  *val=*(FP)&tmp[0];
  return RET_YES;
  }
 *val=*(FP)&buf[0];
 return RET_YES;
 }




 B aaFileStreamPeekDouble              (H handle,B beo,DP val)
 {
 B ret;
 B buf[8];
 B tmp[8];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(val==NULL) { return RET_BADPARM; }
 if((ret=aaFileStreamPeek(handle,8,buf))!=RET_YES) { return ret; }
 if(beo)
  {
  tmp[0]=buf[7];  tmp[1]=buf[6];
  tmp[2]=buf[5];  tmp[3]=buf[4];
  tmp[4]=buf[3];  tmp[5]=buf[2];
  tmp[6]=buf[1];  tmp[7]=buf[0];
  *val=*(DP)&tmp[0];
  return RET_YES;
  }
 *val=*(DP)&buf[0];
 return RET_YES;
 }




 B aaFileStreamOffsetSet               (H handle,Q offset)
 {
 B ret;
 _aa_filestreamobject*fsp;
 Q of,dd;
 LARGE_INTEGER li;
 LARGE_INTEGER np;
 LARGE_INTEGER zi;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.filestream_system.object_id,handle,(VP)&fsp,NULL))!=RET_YES) { return ret; }
 SetLastError(0);
 aaMemoryFill(&np,sizeof(np),0);
 if(offset!=F64)
  {
  dd=fsp->status.bytes;
  if(offset==dd) { offset=F64; }
  }
 if(offset!=F64)
  {
  dd=fsp->status.bytes;
  if(offset==dd) { offset=F64; }
  else
   {
   of=offset; // oct 2017
   if(((G)of<0)||((Q)of>dd))
    {
    aaNote(0,"waqa offset=%I64d of=%I64d dd=%I64d",offset,of,dd);
    return RET_BOUNDS;
    }
   if(of>dd) { oof; return RET_BOUNDS; }
   }
  }

 //if(offset==fsp->status.offset)  {  oof;  }

 if(offset==F64)
  {
  zi.QuadPart=0;
  if(SetFilePointerEx(fsp->handle,zi,&np,FILE_END)==0)  {  oof; return RET_FAILED;   }
  fsp->status.offset=np.QuadPart;
  fsp->last_offset=fsp->status.offset;
  fsp->status.left=fsp->status.bytes-fsp->status.offset;
  return RET_YES;
  }

 if(fsp->status.offset==offset&&fsp->status.bytes==fsp->last_size)
  {
  return RET_YES;
  }

 li.QuadPart=offset;
 if(SetFilePointerEx(fsp->handle,li,&np,FILE_BEGIN)==0)
  {
  if(GetLastError()!=NO_ERROR)
   {
   oof;
   return RET_FAILED;
   }
  }
 fsp->status.offset=np.QuadPart;
 fsp->status.left=fsp->status.bytes-fsp->status.offset;
 return RET_YES;
 }








 B aaFileStreamOffsetAdjust            (H handle,G offsetamount)
 {
 B ret;
 _aa_filestreamobject*fsp;
 LARGE_INTEGER li;
 LARGE_INTEGER np;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.filestream_system.object_id,handle,(VP)&fsp,NULL))!=RET_YES) { return ret; }
 if(offsetamount==0) { return RET_YES; }
 SetLastError(0);
 aaMemoryFill(&np,sizeof(np),0);
 li.QuadPart=offsetamount;
 if(SetFilePointerEx(fsp->handle,li,&np,FILE_CURRENT)==0)
  {
  if(GetLastError()!=NO_ERROR)
   {
   return RET_FAILED;
   }
  }
 fsp->status.offset=np.QuadPart;
 fsp->status.left=fsp->status.bytes-fsp->status.offset;
 return RET_YES;
 }




 B aaFileStreamSizeSet                 (H handle,Q bytes)
 {
 B ret;
 _aa_filestreamobject*fsp;
 LARGE_INTEGER li;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.filestream_system.object_id,handle,(VP)&fsp,NULL))!=RET_YES) { return ret; }
 aaFileStreamStatus(handle,0);
 if(fsp->status.is_mapped) { return RET_INUSE; }
 if(fsp->status.mapped_ptr!=NULL) { return RET_INUSE; }
 if(fsp->map_handle) { return RET_INUSE; }

 ///if(bytes<=fsp->status.bytes) { return RET_YES; }
 //off=fsp->status.offset;
 li.QuadPart=bytes;
 if(SetFilePointerEx(fsp->status._handle,li,0,FILE_BEGIN)==0) { oof; }
 if(aaFileStreamWriteEof(handle)!=YES) { oof; }
 if((ret=aaFileStreamStatus(handle,0))!=YES) { oops; }
 if((ret=aaFileStreamOffsetSet(handle,F64))!=YES) { oops; }
 if((ret=aaFileStreamStatus(handle,0))!=YES) { oops; }
 if((G)fsp->status.bytes!=li.QuadPart) { oof; }
 return RET_YES;
 }



 B aaFileStreamSizeAdjust              (H handle,G bytes)
 {
 B ret;
 _aa_filestreamobject*fsp;
 LARGE_INTEGER li;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.filestream_system.object_id,handle,(VP)&fsp,NULL))!=RET_YES) { return ret; }
 aaFileStreamStatus(handle,0);
 if(fsp->status.is_mapped) { return RET_INUSE; }
 if(fsp->status.mapped_ptr!=NULL) { return RET_INUSE; }
 if(fsp->map_handle) { return RET_INUSE; }

 if(bytes==0) { return RET_YES; }
 if(bytes<0)
  {
  bytes=aaNumAbs(bytes);
  //off=fsp->status.offset;
  li.QuadPart=fsp->status.bytes-bytes;
  if(SetFilePointerEx(fsp->status._handle,li,0,FILE_BEGIN)==0) { oof; }
  if(aaFileStreamWriteEof(handle)!=YES) { oof; }
  if((ret=aaFileStreamStatus(handle,0))!=YES) { oops; }
  if((ret=aaFileStreamOffsetSet(handle,F64))!=YES) { oops; }
  if((ret=aaFileStreamStatus(handle,0))!=YES) { oops; }
  if((G)fsp->status.bytes!=li.QuadPart) { oof; }
  return RET_YES;
  }
 //off=fsp->status.offset;
 li.QuadPart=fsp->status.bytes+bytes;
 if(SetFilePointerEx(fsp->status._handle,li,0,FILE_BEGIN)==0) { oof; }
 if(aaFileStreamWriteEof(handle)!=YES) { oof; }
 if((ret=aaFileStreamStatus(handle,0))!=YES) { oops; }
 if((ret=aaFileStreamOffsetSet(handle,F64))!=YES) { oops; }
 if((ret=aaFileStreamStatus(handle,0))!=YES) { oops; }
 if((G)fsp->status.bytes!=li.QuadPart) { oof; }
 return RET_YES;
 }




 B aaFileStreamFlush                   (H handle)
 {
 B ret;
 _aa_filestreamobject*fsp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.filestream_system.object_id,handle,(VP)&fsp,NULL))!=RET_YES) { return ret; }
 FlushFileBuffers(fsp->handle);
 fsp->cycle=0;
 fsp->gfs_required=YES;
 return RET_YES;
 }



 B aaFileStreamOffsetPush              (H handle)
 {
 B ret;
 H mx,i;
 _aa_filestreamobject*fsp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.filestream_system.object_id,handle,(VP)&fsp,NULL))!=RET_YES) { return ret; }
 mx=aaElementCount(fsp->status.offset_stack);
 if(fsp->status.offset_stack_count>=mx) { return RET_BOUNDS; }
 i=mx-1-(fsp->status.offset_stack_count);
 fsp->status.offset_stack[i]=fsp->status.offset;
 fsp->status.offset_stack_count++;
 return RET_YES;
 }




 B aaFileStreamOffsetPop               (H handle)
 {
 B ret;
 H mx,i;
 _aa_filestreamobject*fsp;
 Q off;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.filestream_system.object_id,handle,(VP)&fsp,NULL))!=RET_YES) { return ret; }
 mx=aaElementCount(fsp->status.offset_stack);
 if(fsp->status.offset_stack_count==0) { return RET_FAILED; }
 i=mx-1-(fsp->status.offset_stack_count-1);
 off=fsp->status.offset_stack[i];
 if((ret=aaFileStreamOffsetSet(handle,off))!=RET_YES) { oops; }
 fsp->status.offset_stack[i]=0;
 fsp->status.offset_stack_count--;
 return RET_YES;
 }





 B aaFileStreamStringLen               (H handle,HP chars,BP stringmode)
 {
 B ret;
 _aa_filestreamobject*fsp;
 Q off,from,at,dif;
 B block[_8K];
 H atatime;
 H i,j,flag;
 Q cando;
 B first;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if((ret=aa_ObjectCheck(aa.filestream_system.object_id,handle,(VP)&fsp,NULL))!=RET_YES) { return ret; }
 if(chars==NULL)  {  return RET_BADPARM;  }
 *chars=0;
 if(stringmode) { *stringmode=0; }
 atatime=_2K;
 if((ret=aaFileStreamStatus(handle,0))!=RET_YES) { return ret; }
 from=off=fsp->status.offset;
 first=YES;
 while(1)
  {
  if(first==NO)
   {
   if((ret=aaFileStreamStatus(handle,0))!=RET_YES) { oops; return ret; }
   }
  first=NO;
  if(fsp->status.left==0) { break; }
  cando=aaNumRoof(fsp->status.left,atatime);
  if((ret=aaFileStreamRead(handle,(H)cando,block))!=RET_YES) { oops; }
  for(i=0;i<cando;i++)
   {
   j=cando-i;
   if(j<2) { break; }
   flag=0;
   while(1)
    {
    if(block[i+0]==CR_CHAR&&block[i+1]==LF_CHAR) { flag=1; break; }
    if(block[i+0]==LF_CHAR&&block[i+1]==CR_CHAR) { flag=2; break; }
    if(block[i+0]==CR_CHAR)                      { flag=3; break; }
    if(block[i+0]==LF_CHAR)                      { flag=4; break; }
    break;
    }
   if(flag)
    {
    at=off+i;
    dif=at-from;
    if(flag==1||flag==2) { dif+=2; }
    else                 { dif+=1; }
    *chars=(H)dif;
    if(flag==1) { *stringmode=aa_STRINGMODE_CRLF; } else
    if(flag==2) { *stringmode=aa_STRINGMODE_LFCR; } else
    if(flag==3) { *stringmode=aa_STRINGMODE_CR;   } else
    if(flag==4) { *stringmode=aa_STRINGMODE_LF;   }
    if((ret=aaFileStreamOffsetSet(handle,from))!=RET_YES) { oops; }
    if((ret=aaFileStreamStatus(handle,0))!=RET_YES) { oops; }
    return RET_YES;
    }
   }
  off+=(atatime/2)+1;
  if((ret=aaFileStreamOffsetSet(handle,off))!=RET_YES) { oops; }
  }
 if((ret=aaFileStreamOffsetSet(handle,from))!=RET_YES) { oops; }
 if((ret=aaFileStreamStatus(handle,0))!=RET_YES) { oops; }
 return RET_NOTREADY;
 }






 B aaFileStreamStringRead              (H handle,HP chars,BP stringmode,H maxchars,VP buf)
 {
 B ret;
 H ch,len;
 B mo;
 BP bp;
 _aa_filestreamobject*fsp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(buf) { aaStringNull(buf); }
 if((ret=aa_ObjectCheck(aa.filestream_system.object_id,handle,(VP)&fsp,NULL))!=RET_YES) { return ret; }
 if(stringmode) { *stringmode=0; }
 if(chars==NULL) { return RET_BADPARM; }
 *chars=0;
 if(maxchars==0) { return RET_BADPARM; }
 if(buf==NULL) { return RET_BADPARM; }
 ret=aaFileStreamStringLen(handle,&len,&mo);
 if(stringmode) { *stringmode=mo; }
 if(ret!=RET_NOTREADY&&ret!=RET_YES) {  return ret; }
 if(ret==RET_YES)
  {
  ch=len;
  if(mo==aa_STRINGMODE_LF||mo==aa_STRINGMODE_CR) { ch=len-1; }  else
  if(mo==aa_STRINGMODE_CRLF)                     { ch=len-2; }  else
  if(mo==aa_STRINGMODE_LFCR)
   {
   ch=len;
   aaNote(0,"!mo=%i len=%i off=%I64u toend=%I64u bytes=%I64u file=%s",mo,len,fsp->status.offset,fsp->status.left,fsp->status.bytes,fsp->status.filename);
   }
  *chars=ch;
  if(ch>maxchars) {   return RET_BOUNDS; }
  if((ret=aaFileStreamRead(handle,len,buf))!=RET_YES) { oops; }
  fsp->crlf_state=0;
  aaCast(bp,BP,buf);
  bp[ch]=NULL_CHAR;
  return RET_YES;
  }
 return RET_NOTREADY;
 }





 B aaFileStreamStringLook              (H handle,H fromoff,H index,HP count,HP offset,HP chars,BP stringmode,H maxchars,VP buf)
 {
 B ret;
 H off,cnt,frm;
 H todo,k,sl,to;
 H atatime,prevatatime,have,go;
 B tmp[_16K];
 B was_found;
 Q poff,soff;
  _aa_filestreamobject*fsp;
 BP bp;
 B mo;
 H ma;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.filestream_system.object_id,handle,(VP)&fsp,NULL))!=RET_YES) { return ret; }
 if(count) *count=0;
 if(offset) *offset=0;
 if(chars) *chars=0;
 if(stringmode) *stringmode=0;
 if(buf) { aaStringNull(buf); }
 aaFileStreamStatus(handle,0);
 prevatatime=atatime=_4K;
 have=(H)fsp->status.left;
 soff=fsp->status.offset;
 if(fromoff>=have) { return RET_NOTREADY; }
 have-=fromoff;
 off=cnt=frm=0;
 was_found=NO;
 mo=0;
 ma=0;
 go=0;
 while(1)
  {
  todo=have-off;
  if(todo<2) break;
  todo=aaNumRoof(todo,atatime);
  poff=soff;
  aaFileStreamOffsetSet(handle,poff+fromoff+off);
  aaFileStreamPeek(handle,todo,tmp);
  aaFileStreamOffsetSet(handle,poff);
  mo=0;
  for(k=0;k<todo-1;k++)
   {
   mo=0;
   if(tmp[k+0]==LF_CHAR&&tmp[k+1]!=CR_CHAR) { mo=aa_STRINGMODE_LF; ma=1; }   else
   if(tmp[k+0]==CR_CHAR&&tmp[k+1]!=LF_CHAR) { mo=aa_STRINGMODE_CR; ma=1; }   else
   if(tmp[k+0]==CR_CHAR&&tmp[k+1]==LF_CHAR) { mo=aa_STRINGMODE_CRLF; ma=2; } else { continue; }
   to=off+k;
   sl=to-frm;
   if(was_found!=YES)
    {
    if(offset) *offset=frm;
    if(chars) *chars=sl;
    if(stringmode) *stringmode=mo;
    }
   if(cnt==index)
    {
    was_found=YES;
    if(buf)
     {
     if(sl>=maxchars) { return RET_BOUNDS; }
     poff=soff;
     aaFileStreamOffsetSet(handle,poff+fromoff+frm);
     aaFileStreamPeek(handle,sl,buf);
     aaFileStreamOffsetSet(handle,poff);
     bp=(BP)buf;
     bp[sl]=NULL_CHAR;
     if(count==NULL) { return RET_YES; }
     }
    }
   frm=to+ma;
   cnt++;
   off+=(sl+ma);
   break;
   }
  go++;
  if(mo==0)
   {
   atatime=(go+1)*256;
   if(atatime>=_8K) { break; }
   if(go>32) {  break; }
   atatime=aaNumRoof(atatime,_8K);
   aaFileStreamStatus(handle,0);
   have=(H)fsp->status.left;
   have-=fromoff;
   atatime=aaNumRoof(atatime,have);
   if(atatime==prevatatime)  { break; }
   prevatatime=atatime;
   off=cnt=frm=0;
   mo=0;
   ma=0;
   continue;
   }
  }
 if(count) { *count=cnt; }
 if(was_found) { return RET_YES; }
 return RET_NOTREADY;
 }






 B aaFileStreamSearch                  (H handle,H entrybytes,QP offset,VP data)
 {
 B ret;
 _aa_filestreamobject*fsp;
 Q fb,eb,ic;
 Q mid,lo,hi,oo;
 N res;
 B blka[_4K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(offset) { *offset=0; }
 if(entrybytes==0) { return RET_BADPARM; }
 if(data==NULL)   { return RET_BADPARM; }
 if((ret=aa_ObjectCheck(aa.filestream_system.object_id,handle,(VP)&fsp,NULL))!=RET_YES) { return ret; }
 oo=fsp->status.offset;
 fb=fsp->status.bytes;
 eb=(Q)entrybytes;
 if(eb>=4000) { return RET_BOUNDS; }
 aaMemoryFill(blka,sizeof(blka),0);
 if((fb%eb)!=0) { return RET_CORRUPTED; }
 ic=fb/eb;
 lo=0;
 hi=ic-1;
 while((G)lo<=(G)hi)
  {
  mid=(lo+hi)/2;
  if(offset) { *offset=mid*eb;  }
  if((ret=aaFileStreamOffsetSet(handle,mid*eb))!=YES) { oops; return ret; }
  if((ret=aaFileStreamRead(handle,(H)eb,blka))!=YES) { oops; return ret; }
  aaMemoryCompare(data,(H)eb,blka,&res);
  if(res==0)
   {
   if(offset) { *offset=mid*eb;  }
   aaFileStreamOffsetSet(handle,mid*eb);
   return RET_YES;
   }
  else
  if(res>0)  {  lo=mid+1;   }
  else       {  hi=mid-1;   }
  }
 aaFileStreamOffsetSet(handle,oo);
 return RET_NOTFOUND;
 }




 B aaFileStreamSearchf                 (H handle,H entrybytes,QP offset,VP fmt,...)
 {
 va_list argptr;
 B txt[_4K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMemoryFill(txt,sizeof(txt),0);
 aaFmt(fmt,argptr,txt);
 return(aaFileStreamSearch(handle,entrybytes,offset,txt));
 }




 B aaFileStreamLock                    (H handle,B state)
 {
 B ret;
 _aa_filestreamobject*fsp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.filestream_system.object_id,handle,(VP)&fsp,NULL))!=RET_YES) { return ret; }
 state&=1;
 if(state)
  {
  if(fsp->status.is_locked) { return RET_YES; }
  if(LockFile(fsp->status._handle,0,0,0xffffffff,0xffffffff)==0) { oow; return RET_FAILED; }
  fsp->status.is_locked=YES;
  }
 else
  {
  if(fsp->status.is_locked!=YES) { return RET_YES; }
  if(UnlockFile(fsp->status._handle,0,0,0xffffffff,0xffffffff)==0) { oow; return RET_FAILED; }
  fsp->status.is_locked=NO;
  }
 return RET_YES;
 }







 B aaFileStreamMap                     (H handle,Q offset,PP ptr)
 {
 B ret;
 //HP hp;
 BP adjptr;
 G adjby;
 Q baseoff;
 Q mappedlength;
 //Q foff;
 _aa_filestreamobject*fsp;
 LARGE_INTEGER lgi;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.filestream_system.object_id,handle,(VP)&fsp,NULL))!=RET_YES) { return ret; }

 if(fsp->status.is_mapped==NO)
  {
  if(fsp->map_handle==NULL)
   {
   aaFileStreamStatus(handle,0);
   fsp->status.bytes_when_mapped=fsp->status.bytes;
   fsp->map_handle=CreateFileMapping(fsp->status._handle,NULL,PAGE_READONLY,0,0,NULL);
   if(fsp->map_handle==NULL) { oow; }
   }
  fsp->status.is_mapped=YES;
  }


  if(offset>=fsp->status.bytes_when_mapped)
   {
   if(offset>=fsp->status.bytes)
    {
    return RET_BOUNDS;
    }

   if(fsp->status.mapped_ptr!=NULL)
    {
    if(UnmapViewOfFile(fsp->status.mapped_ptr)==0) { oow; }
    fsp->status.mapped_ptr=NULL;
    }

   if(fsp->map_handle)
    {
    CloseHandle(fsp->map_handle);
    fsp->map_handle=NULL;
    }

   aaFileStreamStatus(handle,0);
   fsp->status.bytes_when_mapped=fsp->status.bytes;
   if((fsp->map_handle=CreateFileMapping(fsp->status._handle,NULL,PAGE_READONLY,0,0,NULL))==NULL) { oow; }

   }


 if(offset>=fsp->status.bytes_when_mapped)
  {
  return RET_BOUNDS;
  }

 if(offset<aa_FILESTREAM_MAPBLOCK_SIZE/2)
  {
  baseoff=0;
  }
 else
  {
  baseoff=((offset+aa_FILESTREAM_MAPBLOCK_SIZE/4)&(~(aa_FILESTREAM_MAPBLOCK_SIZE/2-1)))-aa_FILESTREAM_MAPBLOCK_SIZE/2;
  }

 if(fsp->status.mapped_ptr==NULL)
  {
  lgi.QuadPart=baseoff;
  mappedlength=aaNumMin(fsp->status.bytes_when_mapped-baseoff,aa_FILESTREAM_MAPBLOCK_SIZE);
  if((fsp->status.mapped_ptr=(BP)MapViewOfFile(fsp->map_handle,FILE_MAP_READ,lgi.HighPart,lgi.LowPart,mappedlength))==NULL) { oow; }
  fsp->status.mapped_baseoff=baseoff;
  }

 if(fsp->status.mapped_baseoff!=baseoff)
  {
  if(fsp->status.mapped_ptr!=NULL)
   {
   if(UnmapViewOfFile(fsp->status.mapped_ptr)==0) { oow; }
   fsp->status.mapped_ptr=NULL;
   }
  lgi.QuadPart=baseoff;
  mappedlength=aaNumMin(fsp->status.bytes_when_mapped-baseoff,aa_FILESTREAM_MAPBLOCK_SIZE);
  if((fsp->status.mapped_ptr=(BP)MapViewOfFile(fsp->map_handle,FILE_MAP_READ,lgi.HighPart,lgi.LowPart,mappedlength))==NULL) { oow; }
  fsp->status.mapped_baseoff=baseoff;
  }
 fsp->status.mapped_offset=offset;
 adjptr=fsp->status.mapped_ptr;
 adjby=fsp->status.mapped_offset-fsp->status.mapped_baseoff;
 adjptr+=adjby;
 if(ptr) { *ptr=adjptr; }
 return RET_YES;
 }










 B aaFileStreamUnmap                   (H handle)
 {
 B ret;
 _aa_filestreamobject*fsp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.filestream_system.object_id,handle,(VP)&fsp,NULL))!=RET_YES) { return ret; }

 if(fsp->status.is_mapped)
  {
  if(fsp->status.mapped_ptr!=NULL)
   {
   if(UnmapViewOfFile(fsp->status.mapped_ptr)==0) { oow; }
   fsp->status.mapped_ptr=NULL;
   }
  if(fsp->map_handle)
   {
   CloseHandle(fsp->map_handle);
   fsp->map_handle=NULL;
   }
  fsp->status.mapped_offset=0;
  fsp->status.mapped_baseoff=0;
  fsp->status.mapped_bytes=0;
  fsp->status.bytes_when_mapped=0;
  }

 if((ret=aaFileStreamStatus(handle,0))!=YES) { oops; }
 return ret;
 }






/*-----------------------------------------------------------------------*/




 B aaTextReaderNew                     (_textreader*textreader,H bytes,VP mem)
 {
 B ret;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(textreader==NULL) { return RET_BADPARM; }
 aaMemoryFill(textreader,sizeof(_textreader),0);
 if(mem==NULL) { return RET_BADPARM; }
 if(bytes==0) { aaStringLen(mem,&bytes); }
 if(bytes==0) { oof; }
 textreader->magic=(H)(PP)aaTextReaderNew;
 textreader->is_initialized=YES;

 if((ret=aaMemoryUnitAllocate(&textreader->mun,bytes))!=YES) { oops; }
 aaMemoryCopy(textreader->mun.mem,bytes,mem);
 if((ret=aaStringLineCountGetToMemory(textreader->mun.mem,(H)textreader->mun.bytes,&textreader->line_count,0xffffffff,(VP)&textreader->line_offset,(VP)&textreader->line_chars))!=YES) { oops; return ret; }
 return RET_YES;
 }








 B aaTextReaderOpen                    (_textreader*textreader,VP filename,H startline,H maxlines)
 {
 B ret;
 Q filebytes;
 Q fromoff;
 Q startoff;
 Q forbytes;
 Q todo;
 H pos,lc;
 B block[_8K];
 H add;
 _filestreamunit fsu;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(textreader==NULL) { return RET_BADPARM; }
 aaMemoryFill(textreader,sizeof(_textreader),0);
 if(aaStringIsEmpty(filename,YES)!=NO) { return RET_BADPARM; }
 textreader->magic=(H)(PP)aaTextReaderNew;
 textreader->is_initialized=YES;
 aaStringCopyf(textreader->file_name,"%s",filename);
 fsu.handle=0;
 lc=0;
 startoff=0;
 if(maxlines!=0)
  {
  //if((ret=aaFileInfoGet(textreader->file_name,&filebytes,0,0,0,0))!=YES) { return ret; }
  if((ret=aaFileStreamOpenQuick(&fsu.handle,textreader->file_name))!=YES) { return ret; }
  aaFileStreamStatus(fsu.handle,&fsu.status);
  filebytes=(Q)fsu.status.bytes;

  fromoff=0;
  while(1)
   {
   todo=filebytes-fromoff;
   todo=aaNumRoof(todo,sizeof(block));
   if(todo==0) { break; }
   forbytes=todo;
   if((ret=aaFileStreamOffsetSet(fsu.handle,fromoff))!=YES)      { oops; break; }
   if((ret=aaFileStreamRead(fsu.handle,(H)forbytes,block))!=YES) { oops; break; }
   add=2;
   if((ret=aaStringFindFirstIString(block,(H)forbytes,"\r\n",2,&pos))!=YES)
    {
    if((ret=aaStringFindFirstIString(block,(H)forbytes,"\n",1,&pos))!=YES)   {    pos=forbytes-1;     break;     }
    add=1;
    }
   if(pos==0xffffffff) { oof;  }

   if(textreader->line_count==0) { startoff=fromoff; }
   fromoff+=(Q)pos+add;
   if(startline>lc)    {    lc++;    continue;    }
   lc++;
   textreader->line_count++;
   if(textreader->line_count>=maxlines) { break; }
   }
  filebytes=fromoff;
  filebytes-=startoff;
  if(fsu.handle!=0) {  aaFileStreamDestroy(fsu.handle);  fsu.handle=0; }
  if((ret=aaMemoryUnitAllocate(&textreader->mun,(H)filebytes))!=YES) { return ret; } //oops; }
  if((ret=aaFileLoadToBuffer(textreader->file_name,startoff,(H)filebytes,textreader->mun.mem,0))!=YES) { return ret; } //oops; }
  if((ret=aaStringLineCountGetToMemory(textreader->mun.mem,(H)textreader->mun.bytes,&textreader->line_count,0xffffffff,(VP)&textreader->line_offset,(VP)&textreader->line_chars))!=YES) { return ret; }
  return RET_YES;
  }
 if(fsu.handle!=0) {  aaFileStreamDestroy(fsu.handle);  fsu.handle=0; }

 if((ret=aaFileInfoGet(textreader->file_name,&filebytes,0,0,0,0))!=YES) { return ret; }
 if((ret=aaMemoryUnitAllocate(&textreader->mun,(H)filebytes))!=YES) { return ret; } //oops; }
 if((ret=aaFileLoadToBuffer(textreader->file_name,0,(H)filebytes,textreader->mun.mem,0))!=YES) { return ret;  }// oops; }
 if((ret=aaStringLineCountGetToMemory(textreader->mun.mem,(H)filebytes,&textreader->line_count,0xffffffff,(VP)&textreader->line_offset,(VP)&textreader->line_chars))!=YES) { return ret; } //oops; return ret; }
 return RET_YES;
 }


 B aaTextReaderDelete                  (_textreader*textreader)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(textreader==NULL) { return RET_BADPARM; }
 if(textreader->magic!=(H)(PP)aaTextReaderNew) { return RET_NOTINITIALIZED; }
 if(textreader->is_initialized!=YES) {  return RET_NOTINITIALIZED; }
 if(textreader->line_offset) { aaMemoryRelease(textreader->line_offset); }
 if(textreader->line_chars) { aaMemoryRelease(textreader->line_chars); }
 if(textreader->mun.bytes) { aaMemoryUnitRelease(&textreader->mun); }
 aaMemoryFill(textreader,sizeof(_textreader),0);
 return RET_YES;
 }




 B aaTextReaderLineGet                 (_textreader*textreader,H line,HP chars,VP txt)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(textreader==NULL) { return RET_BADPARM; }
 if(textreader->magic!=(H)(PP)aaTextReaderNew) { return RET_NOTINITIALIZED; }
 if(textreader->is_initialized!=YES) {  return RET_NOTINITIALIZED; }
 if(chars) { *chars=0; }
 if(txt) { aaStringNull(txt); }
 if(line>=textreader->line_count) { return RET_BOUNDS; }
 if(txt==NULL) { return RET_YES; }
 if(textreader->line_chars[line]==0) { return RET_YES; }
 aaStringNCopy(txt,&textreader->mun.mem[textreader->line_offset[line]],textreader->line_chars[line],YES);
 if(chars) { aaStringLen(txt,chars); }
 return RET_YES;
 }


/*-----------------------------------------------------------------------*/






 B aaTextLoaderNew                     (_textloader*textloader,Q offset,VP file,B(*proc)(_textloader*,Q,H,VP))
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(textloader==NULL) { return RET_BADPARM; }
 aaMemoryFill(textloader,sizeof(_textloader),0);
 if((ret=aaFileStreamCreate(&textloader->fsu.handle,file,0,3,3,0,0))!=YES) { return ret; }
 textloader->magic=aaHPP(aaTextLoaderNew);
 textloader->stage=100;
 aaFileStreamStatus(textloader->fsu.handle,&textloader->fsu.status);
 if(offset>=textloader->fsu.status.bytes) { return RET_BOUNDS; }
 if((ret=aaFileStreamOffsetSet(textloader->fsu.handle,offset))!=YES) { oops; }
 aaFileStreamStatus(textloader->fsu.handle,&textloader->fsu.status);
 aaMemoryUnitAllocate(&textloader->bulk_mem,_128K);
 aaListNew(&textloader->list,YES,0,0,1);
 textloader->proc=proc;
 return RET_YES;
 }







 B aaTextLoaderDelete                  (_textloader*textloader)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(textloader==NULL) { return RET_BADPARM; }
 if(textloader->magic!=aaHPP(aaTextLoaderNew)) { return RET_NOTINITIALIZED; }
 if(textloader->fsu.handle) { aaFileStreamDestroy(textloader->fsu.handle); }
 if(textloader->bulk_mem.bytes) { aaMemoryUnitRelease(&textloader->bulk_mem); }
 if(textloader->list.magic) { aaListDelete(&textloader->list); }
 aaMemoryFill(textloader,sizeof(_textloader),0);
 return RET_YES;
 }






 B aaTextLoaderYield                   (_textloader*textloader,H ita)
 {
 B ret;
 H go,pos;
 Q todo;
 B txt[_4K];
 H flag;
 B(*proc)(_textloader*,Q,H,VP);

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(textloader==NULL) { return RET_BADPARM; }
 if(textloader->magic!=aaHPP(aaTextLoaderNew)) { return RET_NOTINITIALIZED; }
 if(ita==0) { ita=1; }
 proc=textloader->proc;
 switch(textloader->stage)
  {
  case 100:
  aaFileStreamStatus(textloader->fsu.handle,&textloader->fsu.status);
  textloader->prev_file_off=textloader->fsu.status.offset;
  todo=aaNumRoof(textloader->fsu.status.left,textloader->bulk_mem.bytes);
  if(todo==0) { textloader->stage=500;  break;   }
  textloader->bulk_len=todo;
  textloader->bulk_off=0;
  if((ret=aaFileStreamRead(textloader->fsu.handle,(H)todo,&textloader->bulk_mem.mem[textloader->bulk_off]))!=YES)
   {
   aaNote(0," todo=%I64d foff=%I64d fleft=%I64d",todo,textloader->fsu.status.offset,textloader->fsu.status.left);
   }
  aaFileStreamStatus(textloader->fsu.handle,&textloader->fsu.status);
  textloader->stage=200;
  break;



  case 200:
  for(go=0;go<ita;go++)
   {
   todo=textloader->bulk_len-textloader->bulk_off;
   if(todo==0) {  textloader->stage=100;    break;    }
   if(aaStringFindChar(&textloader->bulk_mem.mem[(H)textloader->bulk_off],(H)todo,&pos,'\n',YES,0,YES)!=YES)
    {
    aaFileStreamOffsetSet(textloader->fsu.handle,textloader->prev_file_off+textloader->bulk_off);
    textloader->stage=100;
    break;
    }
   flag=0;
   if(pos>0)
    {
    if(textloader->bulk_mem.mem[((H)textloader->bulk_off+pos)-1]==CR_CHAR) { pos--; flag=1; }
    }
   aaStringNCopy(txt,&textloader->bulk_mem.mem[textloader->bulk_off],pos,YES);
   if(proc!=NULL)
    {
    ret=proc(textloader,textloader->line_number,pos,txt);
    if(ret==RET_CANCELLED) { textloader->stage=300; break;   }
    if(ret==RET_YES)
     {
     ret=aaListAppend(&textloader->list,NULL,NULL,pos,&textloader->bulk_mem.mem[textloader->bulk_off]);
     if(ret!=RET_YES) { oops; }
     }
    }
   else
    {
    ret=aaListAppend(&textloader->list,NULL,NULL,pos,&textloader->bulk_mem.mem[textloader->bulk_off]);
    if(ret!=RET_YES) { oops; }
    }
   textloader->bulk_off+=(pos+1);
   if(flag) { textloader->bulk_off++; }
   textloader->line_number++;
   }
  break;



  case 300:
  return RET_CANCELLED;




  case 500:
  return RET_YES;
  }
 return RET_NOTREADY;
 }




//http://www.drdobbs.com/architecture-and-design/text-editors-algorithms-and-architecture/184408975?pgno=2




 B aa_SysIsWinServer                   (V)
 {
 H flag;
 OSVERSIONINFOEX osvi;
 DWORDLONG mask;
 Z op;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMemoryFill(&osvi,sizeof(OSVERSIONINFOEX),0);
 osvi.dwOSVersionInfoSize=sizeof(OSVERSIONINFOEX);
 osvi.dwMajorVersion=5;
 osvi.dwMinorVersion=0;
 osvi.wServicePackMajor=0;
 osvi.wServicePackMinor=0;
 osvi.wProductType=VER_NT_SERVER;
 mask=0;
 op=VER_GREATER_EQUAL;
 VER_SET_CONDITION(mask,VER_MAJORVERSION,op);
 VER_SET_CONDITION(mask,VER_MINORVERSION,op);
 VER_SET_CONDITION(mask,VER_SERVICEPACKMAJOR,op);
 VER_SET_CONDITION(mask,VER_SERVICEPACKMINOR,op);
 VER_SET_CONDITION(mask,VER_PRODUCT_TYPE,VER_EQUAL);
 flag=VER_MAJORVERSION|VER_MINORVERSION;
 flag|=VER_SERVICEPACKMAJOR|VER_SERVICEPACKMINOR;
 flag|=VER_PRODUCT_TYPE;
 if(VerifyVersionInfo(&osvi,flag,mask))  {  return RET_YES;  }
 return RET_NO;
 }




 B aa_SysIsWinXpSp2OrGreater           (V)
 {
 H flag;
 OSVERSIONINFOEX osvi;
 DWORDLONG mask;
 Z op;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMemoryFill(&osvi,sizeof(OSVERSIONINFOEX),0);
 osvi.dwOSVersionInfoSize=sizeof(OSVERSIONINFOEX);
 osvi.dwMajorVersion=5;
 osvi.dwMinorVersion=1;
 osvi.wServicePackMajor=2;
 osvi.wServicePackMinor=0;
 mask=0;
 op=VER_GREATER_EQUAL;
 VER_SET_CONDITION(mask,VER_MAJORVERSION,op);
 VER_SET_CONDITION(mask,VER_MINORVERSION,op);
 VER_SET_CONDITION(mask,VER_SERVICEPACKMAJOR,op);
 VER_SET_CONDITION(mask,VER_SERVICEPACKMINOR,op);
 flag=VER_MAJORVERSION|VER_MINORVERSION;
 flag|=VER_SERVICEPACKMAJOR|VER_SERVICEPACKMINOR;
 if(VerifyVersionInfo(&osvi,flag,mask)) { return RET_YES;  }
 return RET_NO;
 }


/*-----------------------------------------------------------------------*/


 B aaSysRgbaGet                        (_sysrgba*sysrgba)
 {
 H i,mx;
 _rgba*pn;
 B tmp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(sysrgba==NULL) { return RET_BADPARM; }
 *(HP)&sysrgba->col_scrollbar=GetSysColor(COLOR_SCROLLBAR);
 *(HP)&sysrgba->col_activecaption=GetSysColor(COLOR_ACTIVECAPTION);
 *(HP)&sysrgba->col_inactivecaption=GetSysColor(COLOR_INACTIVECAPTION);
 *(HP)&sysrgba->col_activecaption_right=GetSysColor(27);
 *(HP)&sysrgba->col_inactivecaption_right=GetSysColor(28);
 *(HP)&sysrgba->col_menu=GetSysColor(COLOR_MENU);
 *(HP)&sysrgba->col_window=GetSysColor(COLOR_WINDOW);
 *(HP)&sysrgba->col_windowframe=GetSysColor(COLOR_WINDOWFRAME);
 *(HP)&sysrgba->col_menutext=GetSysColor(COLOR_MENUTEXT);
 *(HP)&sysrgba->col_windowtext=GetSysColor(COLOR_WINDOWTEXT);
 *(HP)&sysrgba->col_captiontext=GetSysColor(COLOR_CAPTIONTEXT);
 *(HP)&sysrgba->col_activeborder=GetSysColor(COLOR_ACTIVEBORDER);
 *(HP)&sysrgba->col_inactiveborder=GetSysColor(COLOR_INACTIVEBORDER);
 *(HP)&sysrgba->col_appworkspace=GetSysColor(COLOR_APPWORKSPACE);
 *(HP)&sysrgba->col_highlight=GetSysColor(COLOR_HIGHLIGHT);
 *(HP)&sysrgba->col_highlighttext=GetSysColor(COLOR_HIGHLIGHTTEXT);
 *(HP)&sysrgba->col_graytext=GetSysColor(COLOR_GRAYTEXT);
 *(HP)&sysrgba->col_btntext=GetSysColor(COLOR_BTNTEXT);
 *(HP)&sysrgba->col_inactivecaptiontext=GetSysColor(COLOR_INACTIVECAPTIONTEXT);
 *(HP)&sysrgba->col_3ddkshadow=GetSysColor(COLOR_3DDKSHADOW);
 *(HP)&sysrgba->col_3dlight=GetSysColor(COLOR_3DLIGHT);
 *(HP)&sysrgba->col_infotext=GetSysColor(COLOR_INFOTEXT);
 *(HP)&sysrgba->col_infobk=GetSysColor(COLOR_INFOBK);
 *(HP)&sysrgba->col_desktop=GetSysColor(COLOR_DESKTOP);
 *(HP)&sysrgba->col_3dface=GetSysColor(COLOR_3DFACE);
 *(HP)&sysrgba->col_3dshadow=GetSysColor(COLOR_3DSHADOW);
 *(HP)&sysrgba->col_3dhighlight=GetSysColor(COLOR_3DHIGHLIGHT);
 *(HP)&sysrgba->col_3dhilight=GetSysColor(COLOR_3DHILIGHT);
 *(HP)&sysrgba->col_btnface=GetSysColor(COLOR_BTNFACE);
 *(HP)&sysrgba->col_btnhilight=GetSysColor(COLOR_BTNHILIGHT);
 mx=sizeof(_sysrgba)/sizeof(_rgba);
 aaCast(pn,_rgba*,sysrgba);
 for(i=0;i<mx;i++) {  pn[i].a=255;  tmp=pn[i].b;  pn[i].b=pn[i].r;  pn[i].r=tmp;  }
 return RET_YES;
 }




 B aaSysMetricsGet                     (_sysmetrics*sysmetrics)
 {
 NONCLIENTMETRICS ncm;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(sysmetrics==NULL) { return RET_BADPARM; }
 aaMemoryFill(sysmetrics,sizeof(_sysmetrics),0);
 aaMemoryFill(&ncm,sizeof(ncm),0);
 ncm.cbSize=sizeof(ncm);
 if(SystemParametersInfo(SPI_GETNONCLIENTMETRICS,sizeof(ncm),&ncm,0)==0)  {  oow;  }
 sysmetrics->caption_size.h=GetSystemMetrics(SM_CYCAPTION);
 sysmetrics->caption_button_size.w=GetSystemMetrics(SM_CXSIZE);
 sysmetrics->caption_button_size.h=GetSystemMetrics(SM_CYSIZE);
 sysmetrics->caption_button_size_small.w=GetSystemMetrics(SM_CXSMSIZE);
 sysmetrics->caption_button_size_small.h=GetSystemMetrics(SM_CYSMSIZE);
 aaStringCopyf(sysmetrics->caption_font,"%s",ncm.lfSmCaptionFont.lfFaceName);
 sysmetrics->caption_icon_size.w=GetSystemMetrics(SM_CXSMICON);
 sysmetrics->caption_icon_size.h=GetSystemMetrics(SM_CYSMICON);
 sysmetrics->vert_scroll_width=GetSystemMetrics(SM_CXVSCROLL);
 sysmetrics->horz_scroll_height=GetSystemMetrics(SM_CYHSCROLL);
 sysmetrics->vert_scroll_thumb_height=GetSystemMetrics(SM_CYVTHUMB);
 sysmetrics->horz_scroll_thumb_width=GetSystemMetrics(SM_CXHTHUMB);
 sysmetrics->vert_scroll_arrow_height=GetSystemMetrics(SM_CYVSCROLL);
 sysmetrics->horz_scroll_arrow_width=GetSystemMetrics(SM_CXHSCROLL);
 return RET_YES;
 }





 B aaSysPathGet                        (_syspath*syspath)
 {
 LPITEMIDLIST pidl;
 CP cp;
 C buf[_1K+1];
 B ch;
 H i,len,type;
 HKEY sub;
 LONG r;
 B sz_ls[64],sz_tif[64];
 HWND hwnd;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(syspath==NULL)  {  return RET_BADPARM;  }
 aaMemoryFill(syspath,sizeof(_syspath),0);
 GetWindowsDirectory((CP)syspath->windows,MAX_PATH);
 GetSystemDirectory((CP)syspath->system,MAX_PATH);
 GetTempPath(MAX_PATH,(CP)syspath->temp);
 aaFileFolderWorkingGet(syspath->current_dir);

 if(syspath->windows[0]==NULL_CHAR)      { return RET_FAILED; }
 if(syspath->system[0]==NULL_CHAR)       { return RET_FAILED; }
 if(syspath->temp[0]==NULL_CHAR)         { return RET_FAILED; }
 if(syspath->current_dir[0]==NULL_CHAR)  { return RET_FAILED; }
 hwnd=0;
 if(SHGetSpecialFolderLocation(hwnd,CSIDL_DESKTOPDIRECTORY,&pidl)==NOERROR) { SHGetPathFromIDList(pidl,(CP)syspath->desktop);   }
 if(SHGetSpecialFolderLocation(hwnd,CSIDL_STARTMENU,&pidl)==NOERROR)        { SHGetPathFromIDList(pidl,(CP)syspath->start_menu); }
 if(SHGetSpecialFolderLocation(hwnd,CSIDL_SENDTO,&pidl)==NOERROR)           { SHGetPathFromIDList(pidl,(CP)syspath->send_to);    }
 if(SHGetSpecialFolderLocation(hwnd,CSIDL_PROGRAMS,&pidl)==NOERROR)         { SHGetPathFromIDList(pidl,(CP)syspath->programs);  }

 if(SHGetSpecialFolderLocation(hwnd,CSIDL_PROGRAM_FILES,&pidl)==NOERROR)    { SHGetPathFromIDList(pidl,(CP)syspath->program_files);  }
 if(SHGetSpecialFolderLocation(hwnd,CSIDL_PROGRAM_FILESX86,&pidl)==NOERROR) { SHGetPathFromIDList(pidl,(CP)syspath->program_filesx86);  }
 if(SHGetSpecialFolderLocation(hwnd,CSIDL_COMMON_FAVORITES,&pidl)==NOERROR) { SHGetPathFromIDList(pidl,(CP)syspath->favorites);  }
 if(SHGetSpecialFolderLocation(hwnd,0x1a,&pidl)==NOERROR)                   { SHGetPathFromIDList(pidl,(CP)syspath->roaming);  }
 if(SHGetSpecialFolderLocation(hwnd,0x23,&pidl)==NOERROR)                   { SHGetPathFromIDList(pidl,(CP)syspath->program_data);  }

 if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,"Software\\Microsoft\\Windows\\CurrentVersion",0L,KEY_READ|0x100,&sub)==ERROR_SUCCESS)
  {
  len=_1K; type=REG_SZ;
  r=RegQueryValueEx(sub,"ProgramFilesDir",NULL,&type,(BP)buf,&len);
  RegCloseKey(sub);
  if(r==ERROR_SUCCESS) {  aaStringCopy(syspath->program_files,buf);  }
  }

 aaCast(cp,CP,syspath->windows);          aaStringLastCharGet(cp,0,&ch); if(ch!=BSLASH_CHAR) { aaStringInsertChar(cp,0,0xffffffff,BSLASH_CHAR);  }
 aaCast(cp,CP,syspath->system);           aaStringLastCharGet(cp,0,&ch); if(ch!=BSLASH_CHAR) { aaStringInsertChar(cp,0,0xffffffff,BSLASH_CHAR);  }
 aaCast(cp,CP,syspath->desktop);          aaStringLastCharGet(cp,0,&ch); if(ch!=BSLASH_CHAR) { aaStringInsertChar(cp,0,0xffffffff,BSLASH_CHAR);  }
 aaCast(cp,CP,syspath->start_menu);       aaStringLastCharGet(cp,0,&ch); if(ch!=BSLASH_CHAR) { aaStringInsertChar(cp,0,0xffffffff,BSLASH_CHAR);  }
 aaCast(cp,CP,syspath->send_to);          aaStringLastCharGet(cp,0,&ch); if(ch!=BSLASH_CHAR) { aaStringInsertChar(cp,0,0xffffffff,BSLASH_CHAR);  }
 aaCast(cp,CP,syspath->programs);         aaStringLastCharGet(cp,0,&ch); if(ch!=BSLASH_CHAR) { aaStringInsertChar(cp,0,0xffffffff,BSLASH_CHAR);  }
 aaCast(cp,CP,syspath->program_files);    aaStringLastCharGet(cp,0,&ch); if(ch!=BSLASH_CHAR) { aaStringInsertChar(cp,0,0xffffffff,BSLASH_CHAR);  }
 aaCast(cp,CP,syspath->program_filesx86); aaStringLastCharGet(cp,0,&ch); if(ch!=BSLASH_CHAR) { aaStringInsertChar(cp,0,0xffffffff,BSLASH_CHAR);  }
 aaCast(cp,CP,syspath->favorites);        aaStringLastCharGet(cp,0,&ch); if(ch!=BSLASH_CHAR) { aaStringInsertChar(cp,0,0xffffffff,BSLASH_CHAR);  }
 aaCast(cp,CP,syspath->temp);             aaStringLastCharGet(cp,0,&ch); if(ch!=BSLASH_CHAR) { aaStringInsertChar(cp,0,0xffffffff,BSLASH_CHAR);  }
 aaCast(cp,CP,syspath->current_dir);      aaStringLastCharGet(cp,0,&ch); if(ch!=BSLASH_CHAR) { aaStringInsertChar(cp,0,0xffffffff,BSLASH_CHAR);  }
 aaStringCopy(syspath->module,aa.core_system.module_path);

 aaStringCopy(sz_tif,"Temporary Internet Files");
 aaStringCopy(sz_ls,"Local Settings");
 for(i=0;i<2; i++)
  {
  aaMemoryFill(buf,sizeof(buf),0);
  if(i==0) { aaStringCopy(buf,syspath->windows); }
  else     { GetEnvironmentVariable("USERPROFILE",buf,sizeof(buf)); }
  if(buf[0]==NULL_CHAR) { continue; }
  aaStringLastCharGet(buf,0,&ch);
  if(ch!=BSLASH_CHAR) { aaStringInsertChar(buf,0,0xffffffff,BSLASH_CHAR); }
  if(i==1) {aaStringAppend(buf,sz_ls); }
  aaStringLastCharGet(buf,0,&ch);
  if(ch!=BSLASH_CHAR) { aaStringInsertChar(buf,0,0xffffffff,BSLASH_CHAR); }
  aaStringAppend(buf,sz_tif);
  aaStringLastCharGet(buf,0,&ch);
  if(ch!=BSLASH_CHAR) { aaStringInsertChar(buf,0,0xffffffff,BSLASH_CHAR); }
  if(i==0) { aaStringCopy(syspath->temp_ie_a,buf); }
  else     { aaStringCopy(syspath->temp_ie_b,buf); }
  }

 if(RegOpenKeyEx(HKEY_CURRENT_USER,"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders",0L,KEY_READ|0x100,&sub)==ERROR_SUCCESS)
  {
  len=sizeof(syspath->start_up)-1;
  type=REG_SZ;
  r=RegQueryValueEx(sub,"Startup",NULL,&type,(BP)buf,&len);
  RegCloseKey(sub);
  if(r==ERROR_SUCCESS) {  aaStringCopy(syspath->start_up,buf);  }
  }
 if(RegOpenKeyEx(HKEY_CURRENT_USER,"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders",0L,KEY_READ|0x100,&sub)==ERROR_SUCCESS)
  {
  len=sizeof(syspath->local_app_data)-1;
  type=REG_SZ;
  r=RegQueryValueEx(sub,"Local AppData",NULL,&type,(BP)buf,&len);
  RegCloseKey(sub);
  if(r==ERROR_SUCCESS) {  aaStringCopy(syspath->local_app_data,buf);  }
  }

 if(RegOpenKeyEx(HKEY_CURRENT_USER,"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders",0L,KEY_READ|0x100,&sub)==ERROR_SUCCESS)
  {
  len=sizeof(syspath->documents)-1;
  type=REG_SZ;
  r=RegQueryValueEx(sub,"Personal",NULL,&type,(BP)buf,&len);
  RegCloseKey(sub);
  if(r==ERROR_SUCCESS) {  aaStringCopy(syspath->documents,buf);  }
  }
 return RET_YES;
 }






 B aaSysPathToString                   (_syspath*syspath,VP str)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 aaStringNull(str);
 if(syspath==NULL) { return RET_BADPARM; }
  aaStringAppendf(str,"window=%s\n",syspath->windows);
  aaStringAppendf(str,"system=%s\n",syspath->system);
  aaStringAppendf(str,"desktop=%s\n",syspath->desktop);
  aaStringAppendf(str,"start_menu=%s\n",syspath->start_menu);
  aaStringAppendf(str,"start_up=%s\n",syspath->start_up);
  aaStringAppendf(str,"send_to=%s\n",syspath->send_to);
  aaStringAppendf(str,"programs=%s\n",syspath->programs);
  aaStringAppendf(str,"program_files=%s\n",syspath->program_files);
  aaStringAppendf(str,"program_filesx86=%s\n",syspath->program_filesx86);
  aaStringAppendf(str,"temp=%s\n",syspath->temp);
  aaStringAppendf(str,"roaming=%s\n",syspath->roaming);
  aaStringAppendf(str,"program_data=%s\n",syspath->program_data);
  aaStringAppendf(str,"app_data=%s\n",syspath->local_app_data);
  aaStringAppendf(str,"favorites=%s\n",syspath->favorites);
  aaStringAppendf(str,"documents=%s\n",syspath->documents);
  aaStringAppendf(str,"module=%s\n",syspath->module);
  aaStringAppendf(str,"current_dir=%s\n",syspath->current_dir);
  aaStringAppendf(str,"temp_ie_a=%s\n",syspath->temp_ie_a);
  aaStringAppendf(str,"temp_ie_b=%s",syspath->temp_ie_b);
 return RET_YES;
 }



 B aaSysVarsGet                        (_sysvars*sysvars)
 {
 LPVOID lpvEnv;
 B ascii,bscii;
 BP bp,sp;
 H soff,len;
 H state,i;
 H pos,mx;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(sysvars==NULL) { return RET_BADPARM; }
 aaMemoryFill(sysvars,sizeof(_sysvars),0);
 if((lpvEnv=GetEnvironmentStringsA())==NULL) { return RET_FAILED; }
 sp=(BP)(LPTSTR)lpvEnv;
 soff=0;
 state=0;
 len=0;
 mx=aaElementCount(sysvars->key_ptr);
 while(1)
  {
  if(state==0)
   {
   sysvars->key_off[sysvars->count]=soff;
   sysvars->val_off[sysvars->count]=soff;
   sysvars->key_len[sysvars->count]=0;
   sysvars->val_len[sysvars->count]=0;
   state=1;
   }
  ascii=sp[soff+0];
  bscii=sp[soff+1];
  if(ascii==NULL_CHAR&&bscii==NULL_CHAR) { break; }
  if(ascii!=NULL_CHAR) { soff++; len++; continue; }
  soff++;
  len++;
  sysvars->key_len[sysvars->count]=soff-sysvars->key_off[sysvars->count];
  sysvars->val_len[sysvars->count]=soff-sysvars->val_off[sysvars->count];
  sysvars->count++;
  if(sysvars->count==mx)   {   oof;   }
  state=0;
  }
 aaMemoryCopy(sysvars->buf,len,(BP)lpvEnv);
 for(i=0;i<sysvars->count;i++)
  {
  aaCast(bp,BP,&sysvars->buf[sysvars->key_off[i]]);
  if(aaStringFindChar(bp,sysvars->key_len[i],&pos,'=',YES,0,YES)!=YES) { oof; }
  sysvars->buf[sysvars->key_off[i]+pos]=NULL_CHAR;
  sysvars->val_off[i]+=pos+1;
  sysvars->val_len[i]=sysvars->key_len[i]-pos;
  sysvars->key_len[i]=pos;
  sysvars->key_ptr[i]=&sysvars->buf[sysvars->key_off[i]];
  sysvars->val_ptr[i]=&sysvars->buf[sysvars->val_off[i]];
  aaStringHashGet(sysvars->key_ptr[i],sysvars->key_len[i],&sysvars->key_hash[i],NO);
  }
 FreeEnvironmentStringsA((LPTSTR)lpvEnv);
 return RET_YES;
 }



 B aaSysvarsExplode                    (_sysvars*sysvars,H index,_stringexplode*stringexplode)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(sysvars==NULL) { return RET_BADPARM; }
 if(index>=sysvars->count) { return RET_BOUNDS; }
 if(stringexplode==NULL) { return RET_BADPARM; }
 return(aaStringExplode(sysvars->val_ptr[index],sysvars->val_len[index],stringexplode,';'));
 }




 B aaSysVarsSet                        (VP name,VP fmt,...)
 {
 BOOL bo;

 aaVargsf(fmt);
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aaStringIsEmpty(name,YES)!=NO) { return RET_BADPARM; }
 if(str64k.len==0)  {  bo=SetEnvironmentVariable(name,NULL);  }
 else               {  bo=SetEnvironmentVariable(name,(CP)str64k.buf);  }
 if(bo==0) { return RET_FAILED; }
 return RET_YES;
 }




 B aaSysVarsToString                   (_sysvars*sysvars,VP str)
 {
 H i;
 B txt[_1K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 aaStringNull(str);
 if(sysvars==NULL) { return RET_BADPARM; }
 for(i=0;i<sysvars->count;i++)
  {
  aaStringCopyf(txt,"var[%-3i]",i);
  aaStringAppendf(str,"%s.key=%s\n",txt,sysvars->key_ptr[i]);
  aaStringAppendf(str,"%s.val=%s\n",txt,sysvars->val_ptr[i]);
  }
 return RET_YES;
 }



   //KEY_WOW64_64KEY	0x0100	Access a 64-bit key from either a 32-bit or 64-bit application.
   //KEY_WOW64_32KEY	0x0200	Access a 32-bit key from either a 32-bit or 64-bit application.

 B aaSysInfoGet                        (_sysinfo*sysinfo)
 {
 H bytes;
 B txt[_1K];
 B buf[_8K];
 _mswinver ver;
 DWORD rr;
 SYSTEM_INFO si;
 H len,type;
 HKEY sub;
 LONG r;
 SID_IDENTIFIER_AUTHORITY NtAuthority={SECURITY_NT_AUTHORITY};
 PSID AdministratorsGroup;
 BOOL IsInAdminGroup;
 N parm;
 BOOL vr1,vr2;
 _fileparts fp;
 N res;
 TCHAR szsz[256];
 LPBYTE lpBuffer=NULL;
 Y size;
 Z CPUInfo[4]={-1};
 Z i,nExIds;
 S B proc_brand[129]={NULL_CHAR};

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(sysinfo==NULL) { return RET_BADPARM; }
 if(aa.timer_system.is_timezone_ready!=YES)
  {
  aa_TimerSystemTimezoneGet();
  if(aa.timer_system.is_timezone_ready!=YES) { oof; return RET_FAILED; }
  }
 if(aa.timer_system.cpu_mhz==0.0)
  {
  aa_TimerSystemCpuSpeedGet();
  if(aa.timer_system.cpu_mhz==0.0) { oof; return RET_FAILED; }
  }

 aaMemoryFill(sysinfo,sizeof(_sysinfo),0);
 res=GetSystemMetrics(SM_CLEANBOOT);
 if(res==1||res==2) { sysinfo->is_safemode=YES; }
 sysinfo->version=aa.core_system.version;
 aaStringCopy(sysinfo->author,"Created Ashot Apakian");
 aaStringCopy(sysinfo->copyright,"(c) Copyright Apakian Pty.Ltd.");
 sysinfo->cpu_mhz=aa.timer_system.cpu_mhz;
 sysinfo->profiler_hz=aa.core_system.perf_frequency;
 bytes=200;
 sysinfo->via_shortcut=aa.core_system.via_shortcut;
 aaStringCopy(sysinfo->command_line,aa.core_system.command_line);
 sysinfo->show_state=aa.core_system.command_show;
 sysinfo->instance=aa.core_system.this_instance;
 sysinfo->process_id=aa.core_system.process_id;
 sysinfo->thread_id=aa.core_system.thread_id;
 sysinfo->process_handle=(H)aa.core_system.process_handle;
 sysinfo->thread_handle=(H)aa.core_system.thread_handle;
 aaStringCopyf(sysinfo->class_name,"%s",aa.core_system.class_name);
 sysinfo->std_input_handle=GetStdHandle(STD_INPUT_HANDLE);
 sysinfo->std_output_handle=GetStdHandle(STD_OUTPUT_HANDLE);
 sysinfo->std_error_handle=GetStdHandle(STD_ERROR_HANDLE);

 aaMemoryFill(&ver,sizeof(ver),0);
 ver.cb=sizeof(ver);
 if(GetVersionEx((OSVERSIONINFO*)&ver)!=0)
  {
  sysinfo->os_version[0]=ver.majmin[0];
  sysinfo->os_version[1]=ver.majmin[1];
  sysinfo->os_version[2]=ver.build;
  sysinfo->os_platform=ver.platform;
  sysinfo->os_service_pack[0]=ver.spack[0];
  sysinfo->os_service_pack[1]=ver.spack[1];
  sysinfo->os_flags=ver.smask<<16;
  sysinfo->os_flags+=ver.type;
  /*
 switch (ver.platform)
 {
 case VER_PLATFORM_WIN32_WINDOWS:   aaStringCopy(sysinfo->os_string,"WIN32"); break;
 case VER_PLATFORM_WIN32_NT:
                         if(ver.majmin[0] == 6) { aaStringCopy(sysinfo->os_string,"Vista"); break; }
                         if(ver.majmin[0] == 4) { aaStringCopy(sysinfo->os_string,"WinNT"); break; }
                         if(ver.majmin[0] == 5) { aaStringCopy(sysinfo->os_string,"WinXp"); break; }
                                       aaStringCopy(sysinfo->os_string,"Win??");
                                       break;
    default: aaStringCopy(sysinfo->os_string,"?????"); break;
 }
 */
  vr1=VerifyVersionInfo((OSVERSIONINFOEX*)&ver,VER_MAJORVERSION,VerSetConditionMask(0,VER_MAJORVERSION,VER_EQUAL));
  vr2=VerifyVersionInfo((OSVERSIONINFOEX*)&ver,VER_MINORVERSION,VerSetConditionMask(0,VER_MINORVERSION,VER_EQUAL));
  if(vr1==0||vr2==0)  {}
  if(sysinfo->os_version[0]==6&&sysinfo->os_version[1]==2&&ver.type==VER_NT_WORKSTATION) { aaStringCopyf(sysinfo->os_string,"win8"); } else
  if(sysinfo->os_version[0]==6&&sysinfo->os_version[1]==2&&ver.type!=VER_NT_WORKSTATION) { aaStringCopyf(sysinfo->os_string,"winServer2012"); } else
  if(sysinfo->os_version[0]==6&&sysinfo->os_version[1]==1&&ver.type==VER_NT_WORKSTATION) { aaStringCopyf(sysinfo->os_string,"win7"); } else
  if(sysinfo->os_version[0]==6&&sysinfo->os_version[1]==1&&ver.type!=VER_NT_WORKSTATION) { aaStringCopyf(sysinfo->os_string,"winServer2008"); } else
  if(sysinfo->os_version[0]==6&&sysinfo->os_version[1]==0&&ver.type!=VER_NT_WORKSTATION) { aaStringCopyf(sysinfo->os_string,"winServer2008"); } else
  if(sysinfo->os_version[0]==6&&sysinfo->os_version[1]==0&&ver.type==VER_NT_WORKSTATION) { aaStringCopyf(sysinfo->os_string,"winVista"); } else
  if(sysinfo->os_version[0]==5&&sysinfo->os_version[1]==2&&GetSystemMetrics(SM_SERVERR2)!=0) { aaStringCopyf(sysinfo->os_string,"winServer2003"); } else
  if(sysinfo->os_version[0]==5&&sysinfo->os_version[1]==2&&GetSystemMetrics(SM_SERVERR2)==0) { aaStringCopyf(sysinfo->os_string,"winServer2003"); } else
  if(sysinfo->os_version[0]==5&&sysinfo->os_version[1]==1) { aaStringCopyf(sysinfo->os_string,"winXP"); } else
  if(sysinfo->os_version[0]==5&&sysinfo->os_version[1]==0) { aaStringCopyf(sysinfo->os_string,"win2000"); }
  }
 GetSystemInfo(&si);
 if(aa.memory_system.status.os_hardware_page_size==0)
  {
  aa.memory_system.status.os_hardware_page_size=si.dwPageSize;
  }

 sysinfo->os_hardware_page_size=aa.memory_system.status.os_hardware_page_size;
 sysinfo->processor_count=si.dwNumberOfProcessors;
 if(proc_brand[0]==NULL_CHAR)
  {
  aaCpuIdGet(CPUInfo,0x80000000);
  nExIds=CPUInfo[0];
  if((H)nExIds>=0x80000000)
   {
    for(i=0x80000000;i<=nExIds;++i)
    {
    aaCpuIdGet(CPUInfo,i);
    if((H)i==0x80000002) aaMemoryCopy(&proc_brand[0],sizeof(CPUInfo),CPUInfo);
    else
    if((H)i==0x80000003) aaMemoryCopy(&proc_brand[16],sizeof(CPUInfo),CPUInfo);
    else
    if((H)i==0x80000004) aaMemoryCopy(&proc_brand[32],sizeof(CPUInfo),CPUInfo);
    }
   aaStringCleanup(proc_brand,0,1,0);
   }
  }
 aaStringCopy(sysinfo->processor_brand,proc_brand);
 GetCurrentDirectory(MAX_PATH,(CP)txt);
 sysinfo->allocation_granularity=si.dwAllocationGranularity;
 aaStringCopy(sysinfo->process_filename,aa.core_system.module_filename);
 aaFilePartsGet(sysinfo->process_filename,&fp);
 aaStringCopyf(sysinfo->process_file,"%s",fp.filename);

 GetWindowsDirectory((CP)txt,MAX_PATH);
 sysinfo->os_drive=txt[0];
 if(aaCharIsAlphaHi(sysinfo->os_drive)) { sysinfo->os_drive+=32; }

 if(GetFileVersionInfo((LPCSTR)sysinfo->process_file,0,sizeof(buf),buf)!=0)
  {
  if(VerQueryValue(buf,"\\VarFileInfo\\Translation",(V FAR* FAR*)&lpBuffer,&size)!=0)
   {
   wsprintf(szsz,"\\StringFileInfo\\%04x%04x\\ProductName",((_LANGANDCODEPAGE*)lpBuffer)->wLanguage,((_LANGANDCODEPAGE*)lpBuffer)->wCodePage);
   if(VerQueryValue(buf,szsz,(VOID FAR* FAR*)&lpBuffer,&size)!=0)  {  aaStringCopyf(sysinfo->product_name,"%s",lpBuffer); }
   }
  if(VerQueryValue(buf,"\\VarFileInfo\\Translation",(V FAR* FAR*)&lpBuffer,&size)!=0)
   {
   wsprintf(szsz,"\\StringFileInfo\\%04x%04x\\ProductVersion",((_LANGANDCODEPAGE*)lpBuffer)->wLanguage,((_LANGANDCODEPAGE*)lpBuffer)->wCodePage);
   if(VerQueryValue(buf,szsz,(VOID FAR* FAR*)&lpBuffer,&size)!=0)  {  aaStringCopyf(sysinfo->product_version,"%s",lpBuffer); }
   }
  }


 /* level 0: if basic info, excluding time zone info
    level 1: includes timezone
    level 2: includes username, pc name, language
 */
 sysinfo->timezone_bias=aa.timer_system.timezone_bias;
 sysinfo->is_dls=aa.timer_system.is_dls;
 sysinfo->is_std=aa.timer_system.is_std;
 aaStringCopy(sysinfo->timezone_string,aa.timer_system.timezone_string);
 sysinfo->timezone_bias_total=aa.timer_system.timezone_bias_total;
 if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion",0L,KEY_READ|0x100,&sub)==ERROR_SUCCESS)
  {
  len=sizeof(sysinfo->product_key)-1;
  type=REG_SZ;
  r=RegQueryValueEx(sub,"ProductId",NULL,&type,(BP)buf,&len);
  RegCloseKey(sub);
  if(r==ERROR_SUCCESS)
   {
   aaMemoryCopy(sysinfo->product_key,len,buf);
   aaStringHashGet(sysinfo->product_key,0,&sysinfo->product_key_hash,NO);
   }
  }
 if(RegOpenKeyEx(HKEY_CLASSES_ROOT,"http\\shell\\open\\command",0L,KEY_READ|0x100,&sub)==ERROR_SUCCESS)
  {
  len=sizeof(sysinfo->default_browser_cmd)-1;
  type=REG_SZ;
  r=RegQueryValueEx(sub,NULL,NULL,&type,(BP)buf,&len);
  RegCloseKey(sub);
  if(r==ERROR_SUCCESS) {  aaStringCopy(sysinfo->default_browser_cmd,buf);  }
  }
 if(RegOpenKeyEx(HKEY_CURRENT_USER,"Software\\Clients\\StartMenuInternet",0L,KEY_READ|0x100,&sub)==ERROR_SUCCESS)
  {
  len=sizeof(sysinfo->default_browser)-1;
  type=REG_SZ;
  r=RegQueryValueEx(sub,NULL,NULL,&type,(BP)buf,&len);
  RegCloseKey(sub);
  if(r==ERROR_SUCCESS) {  aaStringCopy(sysinfo->default_browser,buf);  }
  }
 if(aaStringIsNull(sysinfo->default_browser)==NO)
  {
  }
 aaFileInfoGet(sysinfo->process_filename,&sysinfo->process_filebytes,0,0,&sysinfo->process_filedate,0);
 bytes=sizeof(txt);
 if(AllocateAndInitializeSid(&NtAuthority,2,SECURITY_BUILTIN_DOMAIN_RID,DOMAIN_ALIAS_RID_ADMINS,0,0,0,0,0,0,&AdministratorsGroup))
  {
  IsInAdminGroup=FALSE;
  if(CheckTokenMembership(NULL,AdministratorsGroup,&IsInAdminGroup)) { }
  FreeSid(AdministratorsGroup);
  if(IsInAdminGroup) sysinfo->is_admin=YES;
  }
 if(GetUserName((CP)txt,&bytes)!=0)
  {
  if(bytes<sizeof(sysinfo->user_name)) { aaStringCopy(sysinfo->user_name,txt);  }
  }
 bytes=sizeof(txt);
 if(GetComputerName((CP)txt,&bytes)!=0)
  {
  if(bytes<sizeof(sysinfo->computer_name)) { aaStringCopy(sysinfo->computer_name,txt);  }
  }
 sysinfo->language_id=GetSystemDefaultLangID();
 rr=VerLanguageName(sysinfo->language_id,(LPTSTR)sysinfo->language_string,sizeof(sysinfo->language_string));
 sysinfo->language_string[rr]=NULL_CHAR;
 sysinfo->is_restart_on_crash=aa.core_system.is_restart_on_crash;
 if(sysinfo->is_restart_on_crash) { sysinfo->crash_msrunning_required=aa.core_system.crash_msrunning_required; }
 aaStringCopyf(sysinfo->fqdn_name,"%s@%s",sysinfo->user_name,sysinfo->computer_name);
 bytes=GetEnvironmentVariable("comspec",(CP)sysinfo->comspec,sizeof(sysinfo->comspec));
 if(bytes==0||bytes>=sizeof(sysinfo->comspec)) { aaStringNull(sysinfo->comspec); }
 if(SystemParametersInfo(104,0,&parm,0)!=0) { sysinfo->wheel_lines=parm; }
 if(aa.core_system.is_console_ever_attached==YES)   {  sysinfo->is_console=YES; }  else
 if(aa.core_system.is_console_ever_attached==OTHER) {  sysinfo->is_console=NO;  }  else
 if(aa.core_system.is_console_ever_attached==NO)
  {
  if(aaConsoleAttach()==RET_YES)   {   sysinfo->is_console=YES;   aaConsoleDetach();   }
  }
 sysinfo->is_remote_session=aaIsRemoteSession();
 aaProcessIsRunning(sysinfo->process_file,&sysinfo->process_run_count);
 return RET_YES;
 }




 B aaSysInfoToString                   (_sysinfo*sysinfo,VP str)
 {
 B txt[_1K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 aaStringNull(str);
 if(sysinfo==NULL) { return RET_BADPARM; }
  aaStringAppendf(str,"version=%u\n",sysinfo->version);
  aaStringAppendf(str,"author=%s\n",sysinfo->author);
  aaStringAppendf(str,"copyright=%s\n",sysinfo->copyright);
  aaStringAppendf(str,"is_safemode=%u\n",sysinfo->is_safemode);
  aaStringAppendf(str,"cpu_mhz=%.2f\n",sysinfo->cpu_mhz);
  aaStringAppendf(str,"processor_count=%u\n",sysinfo->processor_count);
  aaStringAppendf(str,"processor_brand=%s\n",sysinfo->processor_brand);
  aaStringAppendf(str,"os_hardware_page_size=%u\n",sysinfo->os_hardware_page_size);
  aaStringAppendf(str,"profiler_hz=%.2f\n",sysinfo->profiler_hz);
  aaStringAppendf(str,"allocation_granularity=%u\n",sysinfo->allocation_granularity);
  aaStringAppendf(str,"show_state=%u\n",sysinfo->show_state);
  aaStringAppendf(str,"command_line=%s\n",sysinfo->command_line);
  aaStringAppendf(str,"via_shortcut=%i\n",sysinfo->via_shortcut);
  aaStringAppendf(str,"process_filename=%s\n",sysinfo->process_filename);
  aaStringAppendf(str,"process_file=%s\n",sysinfo->process_file);
  aaStringAppendf(str,"process_id=%u\n",sysinfo->process_id);
  aaStringAppendf(str,"thread_id=%u\n",sysinfo->thread_id);
  aaStringAppendf(str,"process_handle=0x%08x\n",sysinfo->process_handle);
  aaStringAppendf(str,"thread_handle=0x%08x\n",sysinfo->thread_handle);
  aaStringAppendf(str,"class_name=%s\n",sysinfo->class_name);
  aaStringAppendf(str,"instance=%u\n",sysinfo->instance);
  aaStringAppendf(str,"std_input_handle=0x%08x\n",sysinfo->std_input_handle);
  aaStringAppendf(str,"std_output_handle=0x%08x\n",sysinfo->std_output_handle);
  aaStringAppendf(str,"std_error_handle=0x%08x\n",sysinfo->std_error_handle);
  aaStringAppendf(str,"default_browser=%s\n",sysinfo->default_browser);
  aaStringAppendf(str,"default_browser_cmd=%s\n",sysinfo->default_browser_cmd);
  aaStringAppendf(str,"os_version=%u,%u,%u",sysinfo->os_version[0],sysinfo->os_version[1],sysinfo->os_version[2]);
  aaStringAppendf(str,"os_platform=%u\n",sysinfo->os_platform);
  aaStringAppendf(str,"os_service_path=%u,%u",sysinfo->os_service_pack[0],sysinfo->os_service_pack[1]);
  aaStringAppendf(str,"os_flags=%u\n",sysinfo->os_flags);
  aaStringAppendf(str,"os_string=%s\n",sysinfo->os_string);
  aaStringAppendf(str,"timezone_bias=%i\n",sysinfo->timezone_bias);
  aaStringAppendf(str,"timezone_string=%s\n",sysinfo->timezone_string);
  aaStringAppendf(str,"is_dls=%u\n",sysinfo->is_dls);
  aaStringAppendf(str,"is_std=%u\n",sysinfo->is_std);
  aaStringAppendf(str,"timezone_bias_total=%i\n",sysinfo->timezone_bias_total);
  aaStringAppendf(str,"is_admin=%u\n",sysinfo->is_admin);
  aaStringAppendf(str,"user_name=%s\n",sysinfo->user_name);
  aaStringAppendf(str,"computer_name=%s\n",sysinfo->computer_name);
  aaStringAppendf(str,"fqdn_name=%s\n",sysinfo->fqdn_name);
  aaStringAppendf(str,"process_filebytes=%I64u\n",sysinfo->process_filebytes);
  aaTimeToString(&sysinfo->process_filedate,txt,0,0);
  aaStringAppendf(str,"process_filedate=%s\n",txt);
  aaStringAppendf(str,"language_id=%u\n",sysinfo->language_id);
  aaStringAppendf(str,"language_string=%s\n",sysinfo->language_string);
  aaStringAppendf(str,"is_restart_on_crash=%u\n",sysinfo->is_restart_on_crash);
  aaStringAppendf(str,"crash_msrunning_required=%u\n",sysinfo->crash_msrunning_required);
  aaStringAppendf(str,"comspec=%s\n",sysinfo->comspec);
  aaStringAppendf(str,"product_key=%s\n",sysinfo->product_key);
  aaStringAppendf(str,"product_key_hash=0x%08x\n",sysinfo->product_key_hash);
  aaStringAppendf(str,"wheel_lines=%i\n",sysinfo->wheel_lines);
  aaStringAppendf(str,"is_console=%u",sysinfo->is_console);
  aaStringAppendf(str,"is_remote_session=%u",sysinfo->is_remote_session);
 return RET_YES;
 }



 B aaSysPowerGet                       (_syspower*syspower)
 {
 SYSTEM_POWER_STATUS sps;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(syspower==NULL) { return RET_BADPARM; }
 aaMemoryFill(syspower,sizeof(_syspower),0);
 aaMemoryFill(&sps,sizeof(sps),0);
 if(GetSystemPowerStatus(&sps)==0) {  return RET_FAILED; }
 if(sps.ACLineStatus==1) syspower->is_plugged_in=YES;
 if(aaBitGet(sps.BatteryFlag,3)) syspower->is_charging=YES;
 if(aaBitGet(sps.BatteryFlag,7)) syspower->is_battery=NO;
 else                            syspower->is_battery=YES;
 syspower->level=(F)sps.BatteryLifePercent;
 if(syspower->is_battery==NO) { syspower->level=100.0; }
 else                         { syspower->level=(F)sps.BatteryLifePercent; }
 return RET_YES;
 }




 B aaSysBenchmark                      (B testnum,DP time)
 {
 B ret;
 Q c1,c2,c3;
 D tt;
 B bufa[_8K];
 B bufb[_8K];
 H val;
 Q c;
 D da,db;
 Q qa,qb;
 _memoryunit mum[1000];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(time==NULL) { return RET_BADPARM; }
 *time=0;
 val=0;
 da=db=0;
 qa=qb=0;
 aaMemoryFill(bufa,sizeof(bufa),0);
 aaMemoryFill(bufb,sizeof(bufb),0);
 aaMemoryFill(mum,sizeof(mum),0);
 switch(testnum)
  {
  case 0:
  aaTimerProfilerGet(&c1);
  for(c=0;c<10000;c++)   {   aaMemoryFill(bufa,sizeof(bufa),0);   }
  break;

  case 1:
  aaTimerProfilerGet(&c1);
  for(c=0;c<100;c++)   { aaStringRandomSet(bufa,128,1,1,1,1); }
  break;

  case 2:
  aaTimerProfilerGet(&c1);
  da=1.000;
  for(c=0;c<25000;c++)  {   qa=(Q)da;   if((qa%10)==0) { da+=0.5; }   else   { da+=0.1; }   }
  break;

  case 3:
  aaTimerProfilerGet(&c1);
  aaStringRandomSet(bufa,128,1,1,1,1);
  for(c=0;c<5000;c++)   {   aaStringReverse(bufa,128,bufb,YES);   }
  break;

  case 4:
  aaTimerProfilerGet(&c1);
  val=8;
  for(c=0;c<500;c++)
   {
   val=aaNumRoof(val,_8K);
   if((ret=aaMemoryUnitAllocate(&mum[c],val))!=YES) { oops; break; }
   val+=val;
   }
  for(c=0;c<500;c++)   {   if(aaMemoryUnitRelease(&mum[c])!=YES) { oof; break; }   }
  break;

  case 5:
  aaTimerProfilerGet(&c1);
  if((ret=aaFileUniqueCreate(bufa,0,10,1,1,"delme",1))!=YES) { oops; break; }
  aaStringRandomSet(bufb,_4K,1,1,1,1);
  for(c=0;c<4;c++) {   if((ret=aaFileAppendFromMemory(bufa,_4K,bufb))!=YES) { oops; break; }   }
  aaFileDelete(bufa);
  break;


  default:
  aaTimerProfilerGet(&c1);
  break;
  }
 aaTimerProfilerGet(&c2);
 c3=c2-c1;
 tt=(c3*1000000)/aa.core_system.perf_frequency;
 if(da) { *time=0; }
 *time=tt;
 return RET_YES;
 }




 B aaSysRemoteSessionGet               (BP type)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(type) *type=0;
 return RET_YES;
 }



 B aaSysFileIconGet                    (VP filename)
 {
 B ret;
 B isfold;
 Q bytes;
 SHFILEINFO  sfi;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(filename==NULL) { return RET_BADPARM; }
 if((ret=aaFileInfoGet(filename,&bytes,&isfold,0,0,0))==RET_NOTFOUND) { return ret; }
 if(ret!=YES) { oops; return ret; }
 if(isfold) { return RET_FAILED; }
 if(SHGetFileInfo(filename,0,&sfi,sizeof(sfi),SHGFI_SYSICONINDEX|SHGFI_SMALLICON)==0) { return RET_FAILED; }
 return RET_YES;
 }



 B aaSysTrayGet                        (B mid,HWND*wnd,_rect*rect,BP orientation)
 {
 RECT rc;
 //_rect rr;
 B o;
 HWND hw;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(wnd) { *wnd=0; }
 if(rect) { rect->x=rect->y=rect->w=rect->h=0; }
 if(wnd==NULL&&rect==NULL) { return RET_BADPARM; }
 if(aa.input_system.tray_hwnd==NULL)
  {
  if((aa.input_system.tray_hwnd=FindWindow("Shell_TrayWnd",NULL))==NULL) { oof; }
  if(aa.input_system.tray_hwnd==NULL) { return RET_BADPARM; }
  }
 hw=aa.input_system.tray_hwnd;
 if(mid==0)
  {
  hw=aa.input_system.tray_hwnd;
  }
 else
 if(mid==1)
  {
  if((hw=FindWindow("Shell_SecondaryTrayWnd",NULL))==NULL) { return RET_FAILED; }
  }


 GetWindowRect(hw,&rc);
 //WinRectToRect(&rc,&rr);
 if((rc.bottom-rc.top)>=(rc.right-rc.left))
  {
  if(rc.left>10) { o=aa_DIRECTION_E; }
  else           { o=aa_DIRECTION_W; }
  }
 else
  {
  if(rc.top>10) { o=aa_DIRECTION_S; }
  else          { o=aa_DIRECTION_N; }
  }

 if(rect)
  {
  rect->x=rc.left;
  rect->y=rc.top;
  rect->w=rc.right-rc.left;
  rect->h=rc.bottom-rc.top;
  }
 if(orientation) { *orientation=o; }

 if(wnd)
  {
  *wnd=hw;
  }
 return RET_YES;
 }




 B aaSysRestartOnCrashSet              (B state,H msrunreq)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(state==YES)
  {
  if(aa.core_system.is_restart_on_crash==YES) { return RET_YES; }
  aa.core_system.is_restart_on_crash=YES;
  aa.core_system.crash_msrunning_required=msrunreq;
  }
 else
  {
  if(aa.core_system.is_restart_on_crash==NO) { return RET_YES; }
  aa.core_system.is_restart_on_crash=NO;
  aa.core_system.crash_msrunning_required=0;
  }
 return RET_YES;
 }




 B aaSysCpuLoadRefresh                 (V)
 {
 B ret;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 ret=aa_CoreSystemCpuLoadGet();
 aa_CoreSystemTime();
 aa.core_system.prev_msrunning[aa_COREPREVMS_CpuLoadGet]=aa_msrunning;
 return ret;
 }





 B aaSysShortCutCreate                 (VP filename,VP shortcutname,VP workingpath,VP iconfile,H iconindex)
 {
 B ret;
 H sl;
 HRESULT rc;
 Q filebytes;
 B isfold;
 T HRESULT (*def_cocreateinstance)(REFCLSID,LPUNKNOWN,DWORD,REFIID,LPVOID);
 T HRESULT (*def_coinitialize)(LPVOID reserved);
 T V (*def_couninitialize)(V);
 IShellLink*shell;
 IPersistFile*file;
 WORD name[MAX_PATH];
 def_cocreateinstance my_cocreateinstance;
 def_coinitialize my_coinitialize;
 def_couninitialize my_couninitialize;
 HMODULE lib;
 GUID HI_IID_IPersistFile={0x10B,0,0,{0xC0,0,0,0,0,0,0,0x46}};
 GUID HI_IID_IShellLink={0x000214EE,0,0,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaStringLen(filename,&sl))!=RET_YES) {  return ret; }
 if(sl==0||sl>255) { return RET_BADPARM; }
 if((ret=aaFileInfoGet(filename,&filebytes,&isfold,NULL,NULL,NULL))!=RET_YES) {  return ret; }
 if(isfold==YES&&filebytes!=0) {  return RET_FAILED; }
 if((ret=aaStringLen(shortcutname,&sl))!=RET_YES) {  return ret; }
 if(sl==0||sl>255) { return RET_BADPARM; }
 if(workingpath)
  {
  aaStringLen(workingpath,&sl);
  if(sl==0||sl>255) { return RET_BADPARM; }
  if((ret=aaFileInfoGet(workingpath,&filebytes,&isfold,NULL,NULL,NULL))!=RET_YES) {  return ret; }
  if(isfold==NO||filebytes!=0) {  oof; return RET_FAILED; }
  }
 if(iconfile)
  {
  aaStringLen(iconfile,&sl);
  if(sl==0||sl>255) { return RET_BADPARM; }
  if((ret=aaFileInfoGet(iconfile,&filebytes,&isfold,NULL,NULL,NULL))!=RET_YES) {  return ret; }
  if(isfold==YES) {  return RET_FAILED; }
  if(filebytes==0) { oof; return RET_FAILED; }
  }
 if((lib=LoadLibrary("ole32.dll"))==NULL) { return RET_FAILED; }
 my_coinitialize=(def_coinitialize)         GetProcAddress(lib,"CoInitialize");
 my_couninitialize=(def_couninitialize)     GetProcAddress(lib,"CoUninitialize");
 my_cocreateinstance=(def_cocreateinstance) GetProcAddress(lib,"CoCreateInstance");
 if(my_coinitialize==NULL||my_couninitialize==NULL||my_cocreateinstance==NULL) { FreeLibrary(lib); return RET_FAILED; }
 my_coinitialize(NULL);
 rc=my_cocreateinstance(&CLSID_ShellLink,NULL,CLSCTX_INPROC_SERVER,&HI_IID_IShellLink,(VP)&shell);
 if(!SUCCEEDED(rc)) {   oof; my_couninitialize();  FreeLibrary(lib);  return RET_FAILED;  }
 shell->lpVtbl->SetPath(shell,filename);
 if(workingpath) { shell->lpVtbl->SetWorkingDirectory(shell,workingpath); }
 if(iconfile) { shell->lpVtbl->SetIconLocation(shell,iconfile,iconindex); }
 shell->lpVtbl->SetShowCmd(shell,SW_SHOWMAXIMIZED);
 rc=shell->lpVtbl->QueryInterface(shell,&HI_IID_IPersistFile,(VP)&file);
 if(SUCCEEDED(rc))
  {
  MultiByteToWideChar(CP_ACP,0,(CP)shortcutname,-1,name,MAX_PATH);
  rc=file->lpVtbl->Save(file,name,TRUE);
  if(SUCCEEDED(rc)) { ret=RET_YES; }
  else              { ret=RET_FAILED; }
  file->lpVtbl->Release(file);
  }
 else
  {
  ret=RET_FAILED;
  }
 shell->lpVtbl->Release(shell);
 my_couninitialize();
 FreeLibrary(lib);
 return ret;
 }




 B aaSysUnInstallSet                   (CP applicationname,CP displayname,CP uninstallexepath)
 {
 H sl;
 C dn[129];
 B ret;
 HKEY hOpen;
 HKEY sub;
 DWORD disp;
 DWORD rc;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(uninstallexepath==NULL) { return RET_BADPARM; }
 if(applicationname==NULL) { return RET_BADPARM; }
 aaStringLen(uninstallexepath,&sl);
 if(sl==0||sl>1023) return RET_BADPARM;
 aaStringLen(applicationname,&sl);
 if(sl==0||sl>63) return RET_BADPARM;
 if(displayname)
  {
  aaStringLen(displayname,&sl);
  if(sl==0||sl>63) return RET_BADPARM;
  aaStringCopy(dn,displayname);
  }
 else
  {
  aaStringCopy(dn,applicationname);
  }
 ret=RET_YES;
 if((rc=RegOpenKeyEx(HKEY_LOCAL_MACHINE,"Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall",0,KEY_ALL_ACCESS|0x100,&hOpen))==ERROR_SUCCESS)
  {
  rc=RegCreateKeyEx(hOpen,applicationname,0,NULL,REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,&sub,&disp);
  if(rc!=ERROR_SUCCESS)
   {
   RegCloseKey(hOpen);
   return RET_FAILED;
   }
  aaStringLen(dn,&sl);
  rc=RegSetValueEx(sub,"DisplayName",0,REG_SZ,(BP)dn,sl+1);
  if(rc!=ERROR_SUCCESS)
   {
   RegCloseKey(sub);
   RegDeleteKey(hOpen,applicationname);
   RegCloseKey(hOpen);
   return RET_FAILED;
   }
  aaStringLen(uninstallexepath,&sl);
  rc=RegSetValueEx(sub,"UninstallString",0,REG_SZ,(BP)uninstallexepath,sl+1);
  if(rc!=ERROR_SUCCESS)
   {
   RegCloseKey(sub);
   RegDeleteKey(hOpen,applicationname);
   RegCloseKey(hOpen);
   return RET_FAILED;
   }
  RegCloseKey(sub);
  RegCloseKey(hOpen);
  }
 else ret=RET_FAILED;
 return ret;
 }




 B aaSysUnInstallRemove                (CP applicationname)
 {
 B ret;
 H sl;
 HKEY hOpen;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(applicationname==NULL) { return RET_BADPARM; }
 aaStringLen(applicationname,&sl);
 if(sl==0||sl>63) return RET_BADPARM;

 ret=RET_YES;
 if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,"Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall",0,KEY_ALL_ACCESS|0x100,&hOpen)==ERROR_SUCCESS)
  {
  if(RegDeleteKey(hOpen,applicationname)!=ERROR_SUCCESS) {  RegCloseKey(hOpen);   return RET_FAILED;   }
  RegFlushKey(hOpen);
  if(RegCloseKey(hOpen)!=ERROR_SUCCESS) return RET_FAILED;
  }
 else {  ret=RET_FAILED; }
 return ret;
 }





 B aaSysStartupAppSet                  (VP applicationname,VP applicationexepath)
 {
 B ret;
 HKEY sub;
 H sl,len;
 C buf[_1K+1];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaStringLen(applicationname,&sl))!=YES) { return ret; }
 if(sl==0||sl>63) { return RET_BADPARM; }
 if((ret=aaStringLen(applicationexepath,&sl))!=YES) { return ret; }
 if(sl==0||sl>1023) { return RET_BADPARM; }
 len=sl+1;
 aaStringCopy(buf,applicationexepath);
 if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,"Software\\Microsoft\\Windows\\CurrentVersion\\Run",0L,KEY_ALL_ACCESS|0x100,&sub)!=ERROR_SUCCESS)
  {
  oof;
  oow; oof;
  return RET_FAILED;
  }
 if(RegSetValueEx(sub,applicationname,0,REG_SZ,(BP)buf,len)!=ERROR_SUCCESS)
  {
  RegCloseKey(sub);
  return RET_FAILED;
  }
 RegCloseKey(sub);
 return RET_YES;
 }




 B aaSysStartupAppGet                  (VP applicationname,VP applicationexepath)
 {
 B ret;
 C buf[_1K+1];
 DWORD len,type;
 HKEY sub;
 LONG r;
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(applicationexepath==NULL) { return RET_BADPARM; }
 aaStringNull(applicationexepath);
 if((ret=aaStringLen(applicationname,&sl))!=YES) { return ret; }
 if(sl==0||sl>63) { return RET_BADPARM; }
 if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,"Software\\Microsoft\\Windows\\CurrentVersion\\Run",0L,KEY_READ|0x100,&sub)!=ERROR_SUCCESS) { return RET_FAILED; }
 len=_1K;
 type=REG_SZ;
 r=RegQueryValueEx(sub,applicationname,NULL,&type,(BP)buf,&len);
 RegCloseKey(sub);
 if(r==ERROR_MORE_DATA) { return RET_FAILED;  }
 if(r!=ERROR_SUCCESS)   { return RET_NOTFOUND;  }
 aaStringCopy(applicationexepath,buf);
 return RET_YES;
 }





 B aaSysStartupAppRemove               (VP applicationname)
 {
 B ret;
 C buf[_1K+1];
 LONG r;
 HKEY sub;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(applicationname==NULL) { return RET_BADPARM; }
 if((ret=aaSysStartupAppGet(applicationname,buf))!=RET_YES) { return ret; }
 if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,"Software\\Microsoft\\Windows\\CurrentVersion\\Run",0L,KEY_ALL_ACCESS|0x100,&sub)!=ERROR_SUCCESS) { return RET_FAILED; }
 r=RegDeleteValue(sub,applicationname);
 RegCloseKey(sub);
 if(r!=ERROR_SUCCESS) { return RET_FAILED; }
 return RET_YES;
 }



 B aaSysFileAssociationSet             (CP extension,CP mimetype,CP appcmdline,CP deficon,CP description)
 {
 B ext;
 B mim;
 H sl;
 DWORD disp;
 LONG r;
 HKEY sub,mre;
 H v;
 C txt[_1K];
 C pt[_1K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(appcmdline==NULL) return RET_BADPARM;
 if(extension==NULL) return RET_BADPARM;
 if(extension[0]=='.') { ext=1; }
 else                    { ext=0; }
 aaStringLen(extension,&sl);
 if(ext==1&&sl==1) return RET_BADPARM;
 if(sl>8) return RET_FAILED;
 if(mimetype) { mim=1; }
 else           { mim=0; }
 if(ext==1) { txt[0]=0; }
 else         { txt[0]='.'; txt[1]=0; }
 aaStringAppend(txt,extension);
 aaStringCopy(pt,"Target_");
 aaStringAppend(pt,&txt[1]);
 r=RegCreateKeyEx(HKEY_CLASSES_ROOT,txt,0,NULL,REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,&sub,&disp);
 if(r!=ERROR_SUCCESS) { return RET_FAILED; }
 aaStringCopy(txt,pt);
 aaStringLen(txt,&sl);
 sl++;
 if((r=RegSetValueEx(sub,NULL,0,REG_SZ,(CONST BYTE*)txt,sl))!=ERROR_SUCCESS) {  RegCloseKey(sub);  return RET_FAILED;  }
 if(mim)
  {
  aaStringCopy(txt,mimetype);
  aaStringLen(txt,&sl);
  sl++;
  r=RegSetValueEx(sub,"Content Type",0,REG_SZ,(CONST BYTE*)txt,sl);
  if(r!=ERROR_SUCCESS)  {   RegCloseKey(sub);   return RET_FAILED;   }
  }
 if((r=RegCloseKey(sub))!=ERROR_SUCCESS) {  RegCloseKey(sub);  return RET_FAILED;  }
 if((r=RegCreateKeyEx(HKEY_CLASSES_ROOT,pt,0,NULL,REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,&sub,&disp))!=ERROR_SUCCESS) { return RET_FAILED; }
 if(description)
  {
  aaStringCopy(txt,description);
  aaStringLen(txt,&sl);
  sl++;
  r=RegSetValueEx(sub,NULL,0,REG_SZ,(CONST BYTE*)txt,sl);
  if(r!=ERROR_SUCCESS)   {   RegCloseKey(sub);   return RET_FAILED;   }
  }
 v=1;
 r=RegSetValueEx(sub,"EditFlags",0,REG_DWORD,(CONST BYTE*)&v,4);
 if(r!=ERROR_SUCCESS)  {  RegCloseKey(sub);  return RET_FAILED;  }
 if(deficon)
  {
  r=RegCreateKeyEx(sub,"DefaultIcon",0,NULL,REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,&mre,&disp);
  if(r!=ERROR_SUCCESS)   {   RegCloseKey(sub);   return RET_FAILED;   }
  aaStringCopy(txt,deficon);
  aaStringLen(txt,&sl);
  sl++;
  if((r=RegSetValueEx(mre,NULL,0,REG_SZ,(CONST BYTE*)txt,sl))!=ERROR_SUCCESS)
   {
   RegCloseKey(mre);
   RegCloseKey(sub);
   return RET_FAILED;
   }
  r=RegCloseKey(mre);
  if(r!=ERROR_SUCCESS)
   {
   RegCloseKey(sub);
   return RET_FAILED;
   }
  }
 r=RegCreateKeyEx(sub,"shell",0,NULL,REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,&mre,&disp);
 if(r!=ERROR_SUCCESS)  {  RegCloseKey(sub);  return RET_FAILED;  }
 r=RegCloseKey(mre);
 if(r!=ERROR_SUCCESS)  {  RegCloseKey(sub);  return RET_FAILED;  }
 r=RegCreateKeyEx(sub,"shell\\open",0,NULL,REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,&mre,&disp);
 if(r!=ERROR_SUCCESS)  {  RegCloseKey(sub);  return RET_FAILED;  }
 if((r=RegCloseKey(mre))!=ERROR_SUCCESS) {  RegCloseKey(sub);  return RET_FAILED;  }
 r=RegCreateKeyEx(sub,"shell\\open\\command",0,NULL,REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,&mre,&disp);
 if(r!=ERROR_SUCCESS)  {  RegCloseKey(sub);  return RET_FAILED;  }
 aaStringCopyf(txt,appcmdline);
 aaStringLen(txt,&sl);
 sl++;
 r=RegSetValueEx(mre,NULL,0,REG_SZ,(CONST BYTE*)txt,sl);
 if(r!=ERROR_SUCCESS)  {  RegCloseKey(mre);  RegCloseKey(sub);  return RET_FAILED;  }
 r=RegCloseKey(mre);
 if(r!=ERROR_SUCCESS)  {  RegCloseKey(sub);  return RET_FAILED;  }
 if(RegFlushKey(sub)!=ERROR_SUCCESS) oof;
 if((r=RegCloseKey(sub))!=ERROR_SUCCESS)  {  return RET_FAILED;  }
 SHChangeNotify(SHCNE_ASSOCCHANGED,SHCNF_IDLIST,0,0);
 return RET_YES;
 }




 B aaSysFileAssociationRemove          (CP extension)
 {
 B ext;
 H sl;
 C txt[_1K];
 C pt[_1K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(extension==NULL) return RET_BADPARM;
 if(extension[0]=='.') ext=1;
 else                    ext=0;
 aaStringLen(extension,&sl);
 if(ext==1&&sl==1) return RET_BADPARM;
 if(sl>8) return RET_FAILED;
 if(ext==1) { txt[0]=0; }
 else         { txt[0]='.'; txt[1]=0; }
 aaStringAppend(txt,extension);
 aaStringCopy(pt,"Target_");
 aaStringAppend(pt,&txt[1]);
 if(RegDeleteKey(HKEY_CLASSES_ROOT,txt)!=ERROR_SUCCESS) { return RET_FAILED; }
 if(RegDeleteKey(HKEY_CLASSES_ROOT,pt)!=ERROR_SUCCESS)  { return RET_FAILED; }
 if(RegFlushKey(HKEY_CLASSES_ROOT)!=ERROR_SUCCESS) oof;
  {
  HANDLE mo;
  T V (*_shchnfy) (LONG,UINT,LPVOID,LPVOID);
  _shchnfy shchnfy;
  if((mo=LoadLibrary("shell32.dll"))!=NULL)
   {
   shchnfy=(_shchnfy)GetProcAddress(mo,"SHChangeNotify");
   if(shchnfy!=NULL)    {    shchnfy(SHCNE_ASSOCCHANGED,SHCNF_IDLIST,0,0);    }
   FreeLibrary(mo);
   }
  }
 return RET_YES;
 }







 B aaSysContextMenuSet                 (CP extension,CP menuname,VP deficon,CP appcmdline)
 {
 H sl;
 B txt[_1K];
 B pt[_1K];
 B ext;
 LONG r;
 B tmp[_1K];
 HKEY hkey;
 H dispo;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(menuname==NULL) { return RET_BADPARM; }
 if(appcmdline==NULL) { return RET_BADPARM; }
 if(extension==NULL) return RET_BADPARM;
 if(extension[0]=='.') ext=1;
 else                    ext=0;
 aaStringLen(extension,&sl);
 if(ext==1&&sl==1) return RET_BADPARM;
 if(sl>8) return RET_FAILED;

 if(ext==1) { txt[0]=0; }
 else         { txt[0]='.'; txt[1]=0; }
 aaStringAppend(txt,extension);
 aaStringCopy(pt,"Target_");
 aaStringAppend(pt,&txt[1]);
 aaStringCopyf(tmp,"%s\\shell\\%s\\command",pt,menuname);
 dispo=0;
 r=RegCreateKeyEx(HKEY_CLASSES_ROOT,(CP)tmp,0,"",REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,&hkey,&dispo);
 if(r!=ERROR_SUCCESS) { return RET_FAILED; }
 aaStringLen(appcmdline,&sl);
 RegSetValueEx(hkey,NULL,0,REG_SZ,(CONST BYTE*)appcmdline,sl);
 RegCloseKey(hkey);
 dispo=0;
 r=RegCreateKeyEx(HKEY_CLASSES_ROOT,(CP)txt,0,"",REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,&hkey,&dispo);
 if(r!=ERROR_SUCCESS) { return RET_FAILED; }
 aaStringLen(pt,&sl);
 RegSetValueEx(hkey,NULL,0,REG_SZ,(CONST BYTE*)pt,sl);
 RegCloseKey(hkey);

 if(aaStringIsNull(deficon)==NO)
  {
  aaStringCopyf(tmp,"%s\\DefaultIcon",pt);
  dispo=0;
  r=RegCreateKeyEx(HKEY_CLASSES_ROOT,(CP)tmp,0,"",REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,&hkey,&dispo);
  if(r!=ERROR_SUCCESS) { return RET_FAILED; }
  aaStringLen(deficon,&sl);
  RegSetValueEx(hkey,NULL,0,REG_SZ,(CONST BYTE*)deficon,sl);
  RegCloseKey(hkey);
  }
 return RET_YES;
 }



 B aaSysContextMenuRemove              (CP extension,CP menuname)
 {
 B pt[_1K];
 B ext;
 B tmp[_1K];
 B txt[_1K];
 H sl;
 LONG r;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(menuname==NULL) { return RET_BADPARM; }
 if(extension==NULL) return RET_BADPARM;
 if(extension[0]=='.') ext=1;
 else                    ext=0;
 aaStringLen(extension,&sl);
 if(ext==1&&sl==1) return RET_BADPARM;
 if(sl>8) return RET_FAILED;
 if(ext==1) { txt[0]=0; }
 else         { txt[0]='.'; txt[1]=0; }
 aaStringAppend(txt,extension);
 aaStringCopy(pt,"Target_");
 aaStringAppend(pt,&txt[1]);
 aaStringCopyf(tmp,"%s\\shell\\%s\\command",pt,menuname);
 r=RegDeleteKey(HKEY_CLASSES_ROOT,(CP)tmp);
 if(r!=ERROR_SUCCESS) {  return RET_FAILED; }
 aaStringCopyf(tmp,"%s\\shell\\%s",pt,menuname);
 r=RegDeleteKey(HKEY_CLASSES_ROOT,(CP)tmp);
 if(r!=ERROR_SUCCESS) {  return RET_FAILED; }
 aaStringCopyf(tmp,"%s\\shell",pt);
 r=RegDeleteKey(HKEY_CLASSES_ROOT,(CP)tmp);
 if(r!=ERROR_SUCCESS) {  return RET_FAILED; }
 aaStringCopyf(tmp,"%s",pt);
 r=RegDeleteKey(HKEY_CLASSES_ROOT,(CP)tmp);
 if(r!=ERROR_SUCCESS) {  return RET_FAILED; }
 r=RegDeleteKey(HKEY_CLASSES_ROOT,(CP)txt);
 if(r!=ERROR_SUCCESS) { return RET_FAILED; }
 if(RegFlushKey(HKEY_CLASSES_ROOT)!=ERROR_SUCCESS) { return RET_FAILED; }
 return RET_YES;
 }



 B aaSysSchemeHandlerSet               (VP scheme,VP deficon,VP appcmdline)
 {
 H disp,go;
 HKEY sub,subb;
 _str1k str;
 B path[_1K];
 N r;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 sub=subb=0;
 for(go=0;go<2;go++)
  {
  if(go==0)   { aaStringCopyf(path,"%s",scheme);  }
  else        { aaStringCopyf(path,"SOFTWARE\\Classes\\%s",scheme); }
  if(go==0)   { if((r=RegCreateKeyEx(HKEY_CLASSES_ROOT,(CP)path,0,NULL,REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,&sub,&disp))!=ERROR_SUCCESS)   {  break;    }   }
  else        { if((r=RegCreateKeyEx(HKEY_LOCAL_MACHINE,(CP)path,0,NULL,REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,&sub,&disp))!=ERROR_SUCCESS)  { break; }   }
  aaMemoryFill(str.buf,sizeof(str.buf),0);
  aaStringCopyfLen(str.buf,&str.len,"URL:%s Protocol",scheme);
  str.len++;
  if((r=RegSetValueEx(sub,NULL,0,REG_SZ,str.buf,str.len))!=ERROR_SUCCESS) {  break;  }
  aaMemoryFill(str.buf,sizeof(str.buf),0);
  str.len=1;
  if((r=RegSetValueEx(sub,"URL Protocol",0,REG_SZ,str.buf,str.len))!=ERROR_SUCCESS)  {  break;  }
  if((r=RegCreateKeyEx(sub,"DefaultIcon",0,NULL,REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,&subb,&disp))!=ERROR_SUCCESS) {  break;  }
  aaMemoryFill(str.buf,sizeof(str.buf),0);
  aaStringCopyfLen(str.buf,&str.len,"%s",deficon);
  str.len++;
  if((r=RegSetValueEx(subb,NULL,0,REG_SZ,str.buf,str.len))!=ERROR_SUCCESS)   {   break;   }
  RegCloseKey(subb); subb=0;
  if((r=RegCreateKeyEx(sub,"shell",0,NULL,REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,&subb,&disp))!=ERROR_SUCCESS)   {   break;   }
  RegCloseKey(subb); subb=0;
  if((r=RegCreateKeyEx(sub,"shell\\open",0,NULL,REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,&subb,&disp))!=ERROR_SUCCESS)   {  break; }
  RegCloseKey(subb); subb=0;
  if((r=RegCreateKeyEx(sub,"shell\\open\\command",0,NULL,REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,&subb,&disp))!=ERROR_SUCCESS)   {   break; }
  aaMemoryFill(str.buf,sizeof(str.buf),0);
  aaStringCopyfLen(str.buf,&str.len,"%s",appcmdline);
  str.len++;
  if((r=RegSetValueEx(subb,NULL,0,REG_SZ,str.buf,str.len))!=ERROR_SUCCESS)  {  break;  }
  RegCloseKey(subb); subb=0;
  RegCloseKey(sub); sub=0;
  }
 if(subb!=0) RegCloseKey(subb);
 if(sub!=0) RegCloseKey(sub);
 if(go!=2) { return RET_FAILED; }
 return RET_YES;
 }




 B aaSysTweak                          (V)
 {
 H val,e;
 HKEY sub;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,"SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters",0L,KEY_ALL_ACCESS|0x100,&sub)!=ERROR_SUCCESS) { return RET_FAILED;  }
 e=0;
 val=30;       if(RegSetValueEx(sub,"TcpTimedWaitDelay",0,REG_DWORD,(CONST BYTE*)&val,4)!=ERROR_SUCCESS) { e++; }
 val=65534;    if(RegSetValueEx(sub,"MaxUserPort",0,REG_DWORD,(CONST BYTE*)&val,4)!=ERROR_SUCCESS) { e++; }
 val=32767;    if(RegSetValueEx(sub,"MaxHashTableSize",0,REG_DWORD,(CONST BYTE*)&val,4)!=ERROR_SUCCESS) { e++; }
 val=16000;    if(RegSetValueEx(sub,"MaxFreeTcbs",0,REG_DWORD,(CONST BYTE*)&val,4)!=ERROR_SUCCESS) { e++; }
 val=16777214; if(RegSetValueEx(sub,"TcpNumConnections",0,REG_DWORD,(CONST BYTE*)&val,4)!=ERROR_SUCCESS) { e++; }
 val=1048576;  if(RegSetValueEx(sub,"TcpWindowSize",0,REG_DWORD,(CONST BYTE*)&val,4)!=ERROR_SUCCESS) { e++; }
 val=1048576;  if(RegSetValueEx(sub,"GlobalMaxTcpWindowSize",0,REG_DWORD,(CONST BYTE*)&val,4)!=ERROR_SUCCESS) { e++; }
 val=100;      if(RegSetValueEx(sub,"DefaultTTL",0,REG_DWORD,(CONST BYTE*)&val,4)!=ERROR_SUCCESS) { e++; }
 val=3;        if(RegSetValueEx(sub,"Tcp1323Opts",0,REG_DWORD,(CONST BYTE*)&val,4)!=ERROR_SUCCESS) { e++; }
 val=1;        if(RegSetValueEx(sub,"SackOpts",0,REG_DWORD,(CONST BYTE*)&val,4)!=ERROR_SUCCESS) { e++; }
 RegCloseKey(sub);
 if(e!=0) {  return RET_FAILED; }
 return RET_YES;
 }





 B aaSysProcessHashGet                 (_fileunit*fun,VP hexstr)
 {
 B ret;
 _digestunit dig;
 _fileunit funloc;
 _sysinfo si;
 B digstr[_1K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(hexstr) { aaStringNull(hexstr); }
 if(fun)    { aaMemoryFill(fun,sizeof(_fileunit),0); }
 if((ret=aaSysInfoGet(&si))!=YES) { oops; }
 if((ret=aaFileUnitLoad(&funloc,si.process_filename))!=YES) { oops; }
 if((ret=aaDigestCreate(&dig.handle,aa_DIGESTTYPE_Sha256))!=YES) { oops; }
 if((ret=aaDigestWrite(dig.handle,(H)funloc.bytes,funloc.mem,YES,NULL,(hexstr)?hexstr:digstr))!=YES) { oops; }
 if((ret=aaDigestDestroy(dig.handle))!=YES) { oops; }
 dig.handle=0;
 if(fun)
  {
  aaMemoryCopy(fun,sizeof(_fileunit),&funloc);
  }
 else
  {
  if((ret=aaFileUnitRelease(&funloc))!=YES) { oops; }
  }
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/




 B aaResourceInfoGet                   (H num,HP bytes)
 {
 HRSRC r;
 H b;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bytes!=NULL) { *bytes=0; }
 if((r=FindResource(NULL,MAKEINTRESOURCE(num),RT_RCDATA))==NULL) {  return RET_NOTFOUND;  }
 b=SizeofResource(NULL,r);
 if(b==0) { return RET_FAILED; }
 if(bytes) { *bytes=b; }
 return RET_YES;
 }






 B aaResourceToMemory                  (H num,HP bytes,PP mem)
 {
 HGLOBAL h;
 HRSRC r;
 BP bmp,mm;
 H b;
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bytes!=NULL) { *bytes=0; }
 if((r=FindResource(NULL,MAKEINTRESOURCE(num),RT_RCDATA))==NULL) {  oof; oow; oof; return RET_NOTFOUND;  }
 if((h=LoadResource(NULL,r))==NULL)  {  return RET_NOMEMORY;  }
 if((bmp=LockResource(h))==NULL)
  {
  FreeResource(h);
  return RET_NOMEMORY;
  }
 b=SizeofResource(NULL,r);
 if(bytes!=NULL) { *bytes=b; }
 if(b==0)
  {
  FreeResource(h);
  return RET_FAILED;
  }
 if(mem==NULL) { return RET_YES; }
 if((ret=aaMemoryAllocate((VP)&mm,b))!=RET_YES)
  {
  FreeResource(h);
  return ret;
  }
 aaMemoryCopy(mm,b,bmp);
 FreeResource(h);
 *mem=mm;
 return RET_YES;
 }




 B aaResourceToFile                    (H num,HP bytes,VP filename)
 {
 HGLOBAL h;
 HRSRC r;
 BP bmp;
 B ret;
 H b,fh,todo,done;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bytes!=NULL) { *bytes=0; }
 if(filename==NULL) { return RET_BADPARM; }

 if((r=FindResource(NULL,MAKEINTRESOURCE(num),RT_RCDATA))==NULL) {   return RET_NOTFOUND;  }
 if((h=LoadResource(NULL,r))==NULL)  {  return RET_NOMEMORY;  }
 if((bmp=LockResource(h))==NULL)
  {
  FreeResource(h);
  return RET_NOMEMORY;
  }
 b=SizeofResource(NULL,r);
 if(bytes!=NULL) { *bytes=b; }
 if(b==0)
  {
  FreeResource(h);
  return RET_FAILED;
  }
 if((ret=aaFileStreamCreate(&fh,filename,YES,aa_FILEMODE_RW,aa_FILESHARE_RW,1,NO))!=RET_YES)
  {
  FreeResource(h);
  return ret;
  }
 done=0;
 while(1)
  {
  todo=b-done;
  todo=aaNumRoof(todo,_8K);
  if(todo==0) { break; }
  aaFileStreamWrite(fh,todo,&bmp[done]);
  done+=todo;
  }
 if(bytes) { *bytes=b; }
 FreeResource(h);
 aaFileStreamDestroy(fh);
 return ret;
 }



/*-----------------------------------------------------------------------*/




 B aaDigestCreate                      (HP handle,B type)
 {
 B ret;
 _aa_digestobject*digp;
 Q qv[8];
 H i;
 HP hp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCreate(aa.digest_system.object_id,handle,(VP)&digp))!=RET_YES) { oops; return ret; }
 digp->self_handle=*handle;
 if(type==aa_DIGESTTYPE_Ripemd160)
  {
  digp->len[0]=digp->len[1]=0;
  digp->status.digest[0]=0x67452301UL;
  digp->status.digest[1]=0xefcdab89UL;
  digp->status.digest[2]=0x98badcfeUL;
  digp->status.digest[3]=0x10325476UL;
  digp->status.digest[4]=0xc3d2e1f0UL;
  digp->status.type=type;
  }
 else
 if(type==aa_DIGESTTYPE_Md5)
  {
  digp->len[0]=digp->len[1]=0;
  digp->status.digest[0]=0x67452301UL;
  digp->status.digest[1]=0xefcdab89UL;
  digp->status.digest[2]=0x98badcfeUL;
  digp->status.digest[3]=0x10325476UL;
  digp->counter=0;
  digp->count=0;
  digp->status.type=type;
  }
 else
 if(type==aa_DIGESTTYPE_Sha1)
  {
  digp->len[0]=digp->len[1]=0;
  digp->status.digest[0]=0x67452301UL;
  digp->status.digest[1]=0xefcdab89UL;
  digp->status.digest[2]=0x98badcfeUL;
  digp->status.digest[3]=0x10325476UL;
  digp->status.digest[4]=0xc3d2e1f0UL;
  digp->counter=0;
  digp->count=0;
  digp->status.type=type;
  }
 else
 if(type==aa_DIGESTTYPE_Sha256)
  {
  digp->len[0]=digp->len[1]=0;
  digp->status.digest[0]=0x6a09e667;
  digp->status.digest[1]=0xbb67ae85;
  digp->status.digest[2]=0x3c6ef372;
  digp->status.digest[3]=0xa54ff53a;
  digp->status.digest[4]=0x510e527f;
  digp->status.digest[5]=0x9b05688c;
  digp->status.digest[6]=0x1f83d9ab;
  digp->status.digest[7]=0x5be0cd19;
  digp->counter=0;
  digp->count=0;
  digp->status.type=type;
  }
 else
 if(type==aa_DIGESTTYPE_Sha512)
  {
  digp->len[0]=digp->len[1]=0;
  digp->curlen=0;
  digp->length=0;
  qv[0]=UINT64_C(0x6a09e667f3bcc908);
  qv[1]=UINT64_C(0xbb67ae8584caa73b);
  qv[2]=UINT64_C(0x3c6ef372fe94f82b);
  qv[3]=UINT64_C(0xa54ff53a5f1d36f1);
  qv[4]=UINT64_C(0x510e527fade682d1);
  qv[5]=UINT64_C(0x9b05688c2b3e6c1f);
  qv[6]=UINT64_C(0x1f83d9abfb41bd6b);
  qv[7]=UINT64_C(0x5be0cd19137e2179);
  hp=(HP)&qv[0];
  for(i=0;i<16;i++) {   digp->status.digest[i]=hp[i];   }
  digp->counter=0;
  digp->count=0;
  digp->status.type=type;
  }
 else
  {
  aa_ObjectDestroy(aa.digest_system.object_id,*handle);
  *handle=0;
  return RET_BADPARM;
  }
 return RET_YES;
 }




 B aaDigestDestroy                     (H handle)
 {
 B ret;
 _aa_digestobject*digp;
 B isprot;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.digest_system.object_id,handle,(VP)&digp,&isprot))!=RET_YES) { return ret; }
 if(isprot) { return RET_FORBIDDEN; }
 aa_ObjectDestroy(aa.digest_system.object_id,handle);
 return RET_YES;
 }



 B aaDigestStatus                      (H handle,_digeststatus*digeststatus)
 {
 B ret;
 _aa_digestobject*digp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.digest_system.object_id,handle,(VP)&digp,NULL))!=RET_YES) { return ret; }
 if(digeststatus) { aaMemoryCopy(digeststatus,sizeof(_digeststatus),&digp->status); }
 return RET_YES;
 }





 B aaDigestWrite                       (H handle,H bytes,VP data,B finish,VP rdig,VP rdigstr)
 {
 B ret,temp;
 _aa_digestobject*digp;
 H tocopy,have,oldbytes;
 H totlo,tothi,t;
 H inputLen,by,remainder;
 register H i,j,index,curpos;
 size_t n;
 BP ptr;
 BP buf;
 B finalcount[8];
 B out[64];
 B di[40];
 B txt[256];
 QP qv;
 QP uv;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.digest_system.object_id,handle,(VP)&digp,NULL))!=RET_YES) { return ret; }
 if(rdigstr) { aaStringNull(rdigstr); }
 if(bytes!=0&&data==NULL) { oof; return RET_BADPARM; }
 if(bytes==0&&data!=NULL) { aaStringLen(data,&bytes);  }
 if(digp->requires_reset==YES)  {  if(aaDigestReset(handle)!=YES) oof;  }
 if(digp->status.type==aa_DIGESTTYPE_Md5)
  {
  aa_DigestSystemMd5(digp,data,bytes);
  if(finish)
   {
   aa_DigestSystemMd5(digp,NULL,0);
   tothi=0;
   t=digp->counter;
   if((totlo=t<<6)<t) tothi++;
   tothi+=t>>26;
   t=totlo;
   if((totlo=t+digp->count)<t) tothi++;
   t=totlo;
   if((totlo=t<<3)<t) tothi++;
   tothi+=t>>29;
   if(digp->count<56)
    {
    digp->block[digp->count++]=0x80;
    while(digp->count<56) digp->block[digp->count++]=0;
    }
   else
    {
    digp->block[digp->count++]=0x80;
    while(digp->count<64) digp->block[digp->count++]=0;
    aa_DigestSystemMd5(digp,NULL,0);
    aaMemoryFill(digp->block,56,0);
    }
   digp->block[56]=(B)(totlo);
   digp->block[57]=(B)(totlo>>8);
   digp->block[58]=(B)(totlo>>16);
   digp->block[59]=(B)(totlo>>24);
   digp->block[60]=(B)(tothi);
   digp->block[61]=(B)(tothi>>8);
   digp->block[62]=(B)(tothi>>16);
   digp->block[63]=(B)(tothi>>24);
   aa_DigestSystemCompress((VP)&digp,(HP)digp->block);
   digp->requires_reset=YES;
   }
  }
 else
 if(digp->status.type==aa_DIGESTTYPE_Sha1)
  {
  by=bytes;
  aaCast(ptr,BP,data);
  j=(digp->len[0]>>3)&63;
  if((digp->len[0]+=by<<3)<(by<<3)) { digp->len[1]++; }
  digp->len[1]+=(by>>29);
  if((j+by)>63)
   {
   aaMemoryCopy(&digp->block[j],(i=64-j),ptr);
   aa_DigestSystemCompress((VP)&digp,(HP)digp->block);
   for(;i+63<by;i+=64) {aa_DigestSystemCompress((VP)&digp,(HP)&ptr[i]); }  j=0;
   }
  else i=0;
  aaMemoryCopy(&digp->block[j],by-i,&ptr[i]);
  if(finish)
   {
    for(i=0;i<8;i++) {  finalcount[i]=(B)((digp->len[(i>=4?0:1)]>>((3-(i&3))*8))&255);  }
    aaMemoryCopy(txt,1,(BP)"\200");
    by=1;
    aaCast(ptr,BP,txt);
    j=(digp->len[0]>>3)&63;
    if((digp->len[0]+=by<<3)<(by<<3)) { digp->len[1]++; }
    digp->len[1]+=(by>>29);
    if((j+by)>63)
     {
     aaMemoryCopy(&digp->block[j],(i=64-j),ptr);
     aa_DigestSystemCompress((VP)&digp,(HP)digp->block);
     for(;i+63<by;i+=64) {aa_DigestSystemCompress((VP)&digp,(HP)&ptr[i]); }  j=0;
     }
    else i=0;
    aaMemoryCopy(&digp->block[j],by-i,&ptr[i]);
    while((digp->len[0]&504)!=448)
     {
   txt[0]=0;
    by=1;
    aaCast(ptr,BP,txt);
    j=(digp->len[0]>>3)&63;
    if((digp->len[0]+=by<<3)<(by<<3)) { digp->len[1]++; }
    digp->len[1]+=(by>>29);
    if((j+by)>63)
     {
     aaMemoryCopy(&digp->block[j],(i=64-j),ptr);
     aa_DigestSystemCompress((VP)&digp,(HP)digp->block);
     for(;i+63<by;i+=64) { aa_DigestSystemCompress((VP)&digp,(HP)&ptr[i]); }  j=0;
     }
    else i=0;
    aaMemoryCopy(&digp->block[j],by-i,&ptr[i]);
     }
    by=8;
    aaCast(ptr,BP,finalcount);
    j=(digp->len[0]>>3)&63;
    if((digp->len[0]+=by<<3)<(by<< 3)) { digp->len[1]++; }
    digp->len[1]+=(by>> 29);
    if((j+by)>63)
     {
     aaMemoryCopy(&digp->block[j],(i=64-j),ptr);
     aa_DigestSystemCompress((VP)&digp,(HP)digp->block);
     for(;i+63<by;i+=64) {aa_DigestSystemCompress((VP)&digp,(HP)&ptr[i]); }  j=0;
     }
    else i=0;
    aaMemoryCopy(&digp->block[j],by-i,&ptr[i]);
    for(i=0;i<20;i++)  {  di[i]=(B)((digp->status.digest[i>>2]>>((3-(i&3))*8))&255); }
    aaCast(ptr,BP,&digp->status.digest[0]);
    for(i=0;i<20;i++) ptr[i]=di[i];
   digp->requires_reset=YES;
   }
  }
 else
 if(digp->status.type==aa_DIGESTTYPE_Ripemd160)
  {
  oldbytes=digp->len[0];
  have=oldbytes%64;
  digp->len[0]=(H)(digp->len[0]+bytes);
  if(digp->len[0]<oldbytes) { digp->len[1]++; }
  aaCast(ptr,BP,data);
  while(bytes>0)
   {
   if(have==0&&bytes>=64)  {  aa_DigestSystemCompress((VP)&digp,(VP)ptr);  ptr+=64;   bytes-=64;  continue;   }
   tocopy=64-have;
   if(tocopy>0)
    {
    if(tocopy>bytes)  tocopy=bytes;
    aaMemoryCopy(&digp->block[have],tocopy,ptr);
    ptr+=tocopy;  bytes-=tocopy; have+=tocopy;
    if(have==64)  {  aa_DigestSystemCompress((VP)&digp,(VP)digp->block);   have=0;    }
    }
   }
  if(finish)
   {
   temp=0x80;
   totlo=digp->len[0];
   tothi=digp->len[1];
   bytes=1;
   oldbytes=digp->len[0];
   have=oldbytes%64;
   digp->len[0]=(H)(digp->len[0]+bytes);
   if(digp->len[0]<oldbytes) { digp->len[1]++; }
   aaCast(ptr,BP,&temp);
   while(bytes>0)
    {
    if(have==0&&bytes>=64)  {  aa_DigestSystemCompress((VP)&digp,(VP)ptr);  ptr+=64;   bytes-=64;  continue;   }
    tocopy=64-have;
    if(tocopy>0)
     {
     if(tocopy>bytes)  tocopy=bytes;
     aaMemoryCopy(&digp->block[have],tocopy,ptr);
     ptr+=tocopy;  bytes-=tocopy; have+=tocopy;
     if(have==64)  {  aa_DigestSystemCompress((VP)&digp,(VP)digp->block);   have=0;    }
     }
    }
   have=digp->len[0]%64;
   if(have>56)
    {
    aaMemoryFill(&digp->block[have],64-have,0);
    aa_DigestSystemCompress((VP)&digp,(VP)digp->block);
    have=0;
    }
   tothi<<=3; tothi+=(totlo>>29);  totlo<<=3;
   *(HP)&digp->block[60]=tothi;
   *(HP)&digp->block[56]=totlo;
   if((64-have-8)>0)  {  aaMemoryFill(&digp->block[have],64-have-8,0);   }
   aa_DigestSystemCompress((VP)&digp,(VP)digp->block);
   digp->requires_reset=YES;
   }
  }
 else
 if(digp->status.type==aa_DIGESTTYPE_Sha256)
  {
  inputLen=bytes;
  curpos=0;
  index=((digp->len[0]>>3)&0x3f);
  remainder=(inputLen&0x3f);
  if((digp->len[0]+=(inputLen<<3))<(inputLen<<3)) digp->len[1]++;
  digp->len[1]+=(inputLen>>29);
  ptr=(BP)data;
  for(i=0;i+63<inputLen;i+=64)
   {
   for(j=index;j<64;j++)    {    digp->block[j]=ptr[curpos++];    }
   aa_DigestSystemSha256Transform(digp);
   index=0;
   }
  ptr=(BP)data;
  for(j=0;j<remainder;j++)  {   digp->block[j]=ptr[curpos++];   }

  if(finish)
   {
   index=((digp->len[0]>>3)&0x3f);
   digp->block[index++]=0x80;
   if(index<=56)
    {
    for(i=index;i<56; i++)   {   digp->block[i]=0;   }
    }
   else
    {
    for(i=index;i<64; i++)   { digp->block[i]=0;   }
    aa_DigestSystemSha256Transform(digp);
    for(i=0;i<56; i++)   { digp->block[i]=0;   }
    }
   digp->block[56]=(digp->len[1]>>24)&0xff;
   digp->block[57]=(digp->len[1]>>16)&0xff;
   digp->block[58]=(digp->len[1]>>8)&0xff;
   digp->block[59]= digp->len[1]&0xff;
   digp->block[60]=(digp->len[0]>>24)&0xff;
   digp->block[61]=(digp->len[0]>>16)&0xff;
   digp->block[62]=(digp->len[0]>>8)&0xff;
   digp->block[63]=digp->len[0]&0xff;
   aa_DigestSystemSha256Transform(digp);
   digp->requires_reset=YES;
   for(i=0;i<8;i++)    {    digp->status.digest[i]=aaNumSwapDword(digp->status.digest[i]);    }
   }
  }
 else
 if(digp->status.type==aa_DIGESTTYPE_Sha512)
  {
  //if(digp->curlen>sizeof(digp->buf)) { return 1;    }
  buf=(BP)data;
  while(bytes>0)
   {
   if(digp->curlen==0&&bytes>=128)
    {
    aa_DigestSystemSha512Transform(digp,(BP)buf);
    digp->length+=128*8;
    buf+=128;
    bytes-=128;
    }
   else
    {
    n=aaNumMin(bytes,(128-digp->curlen));
    for(i=0;i<n;i++) { digp->block[i+digp->curlen]=buf[i]; }
    digp->curlen+=n;
    buf+=n;
    bytes-=n;
    if(digp->curlen==128)
     {
     aa_DigestSystemSha512Transform(digp,digp->block);
     digp->length+=8*128;
     digp->curlen=0;
     }
    }
   }
  if(finish)
   {
   digp->length+=digp->curlen*UINT64_C(8);
   digp->block[digp->curlen++]=(B)0x80;
   if(digp->curlen>112)
    {
    while(digp->curlen<128) { digp->block[digp->curlen++]=(B)0;  }
    aa_DigestSystemSha512Transform(digp,digp->block);
    digp->curlen=0;
    }
   while(digp->curlen<120) {  digp->block[digp->curlen++]=(B)0; }
   aaSHA512STORE64H(digp->length,digp->block+120);
   aa_DigestSystemSha512Transform(digp,digp->block);
   qv=(QP)digp->status.digest;
   for(i=0;i<8;i++) { aaSHA512STORE64H(qv[i],out+(8*i));  }
   uv=(QP)out;
   for(i=0;i<8;i++) { qv[i]=uv[i];  }
   }
  }

 if(rdig!=NULL)
  {
  if(digp->status.type==aa_DIGESTTYPE_Ripemd160) {  aaMemoryCopy(rdig,20,digp->status.digest);  }
  else
  if(digp->status.type==aa_DIGESTTYPE_Md5)       {  aaMemoryCopy(rdig,16,digp->status.digest); }
  else
  if(digp->status.type==aa_DIGESTTYPE_Sha1)      {  aaMemoryCopy(rdig,20,digp->status.digest); }
  else
  if(digp->status.type==aa_DIGESTTYPE_Sha256)    {  aaMemoryCopy(rdig,32,digp->status.digest); }
  else
  if(digp->status.type==aa_DIGESTTYPE_Sha512)    {  aaMemoryCopy(rdig,64,digp->status.digest); }
  }
 if(rdigstr)
  {
  aaDigestToString(handle,rdigstr);
  }
 return RET_YES;
 }








 B aaDigestReset                       (H handle)
 {
 B ret;
 _aa_digestobject*digp;
 Q qv[8];
 H i;
 HP hv;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.digest_system.object_id,handle,(VP)&digp,NULL))!=RET_YES) { return ret; }
 if(digp->status.type==aa_DIGESTTYPE_Ripemd160)
  {
  aaMemoryFill(digp->block,64,0);
  digp->len[0]=digp->len[1]=0;
  digp->status.digest[0]=0x67452301UL;
  digp->status.digest[1]=0xefcdab89UL;
  digp->status.digest[2]=0x98badcfeUL;
  digp->status.digest[3]=0x10325476UL;
  digp->status.digest[4]=0xc3d2e1f0UL;
  }
 else
 if(digp->status.type==aa_DIGESTTYPE_Md5)
  {
  aaMemoryFill(digp->block,64,0);
  digp->len[0]=digp->len[1]=0;
  digp->status.digest[0]=0x67452301UL;
  digp->status.digest[1]=0xefcdab89UL;
  digp->status.digest[2]=0x98badcfeUL;
  digp->status.digest[3]=0x10325476UL;
  digp->counter=0;
  digp->count=0;
  }
 else
 if(digp->status.type==aa_DIGESTTYPE_Sha1)
  {
  aaMemoryFill(digp->block,64,0);
  digp->len[0]=digp->len[1]=0;
  digp->status.digest[0]=0x67452301UL;
  digp->status.digest[1]=0xefcdab89UL;
  digp->status.digest[2]=0x98badcfeUL;
  digp->status.digest[3]=0x10325476UL;
  digp->status.digest[4]=0xc3d2e1f0UL;
  digp->counter=0;
  digp->count=0;
  }
 else
 if(digp->status.type==aa_DIGESTTYPE_Sha256)
  {
  aaMemoryFill(digp->block,64,0);
  digp->len[0]=digp->len[1]=0;
  digp->status.digest[0]=0x6a09e667;
  digp->status.digest[1]=0xbb67ae85;
  digp->status.digest[2]=0x3c6ef372;
  digp->status.digest[3]=0xa54ff53a;
  digp->status.digest[4]=0x510e527f;
  digp->status.digest[5]=0x9b05688c;
  digp->status.digest[6]=0x1f83d9ab;
  digp->status.digest[7]=0x5be0cd19;
  digp->counter=0;
  digp->count=0;
  }
 else
 if(digp->status.type==aa_DIGESTTYPE_Sha512)
  {
  aaMemoryFill(digp->block,128,0);
  digp->length=0;
  digp->curlen=0;
  digp->len[0]=digp->len[1]=0;
  qv[0]=UINT64_C(0x6a09e667f3bcc908);
  qv[1]=UINT64_C(0xbb67ae8584caa73b);
  qv[2]=UINT64_C(0x3c6ef372fe94f82b);
  qv[3]=UINT64_C(0xa54ff53a5f1d36f1);
  qv[4]=UINT64_C(0x510e527fade682d1);
  qv[5]=UINT64_C(0x9b05688c2b3e6c1f);
  qv[6]=UINT64_C(0x1f83d9abfb41bd6b);
  qv[7]=UINT64_C(0x5be0cd19137e2179);
  hv=(HP)&qv[0];
  for(i=0;i<16;i++) {   digp->status.digest[i]=hv[i];   }
  digp->counter=0;
  digp->count=0;
  }

 digp->requires_reset=NO;
 return RET_YES;
 }





 B aaDigestToString                    (H handle,VP string)
 {
 B ret;
 _aa_digestobject*digp;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(string==NULL) { return RET_BADPARM; }
 aaStringNull(string);
 if((ret=aa_ObjectCheck(aa.digest_system.object_id,handle,(VP)&digp,NULL))!=RET_YES) { return ret; }
 aaCast(bp,BP,digp->status.digest);
 if(digp->status.type==aa_DIGESTTYPE_Ripemd160)
  {
  aaStringHexFromMemory(string,0,20,bp,YES);
  }
 else
 if(digp->status.type==aa_DIGESTTYPE_Md5)
  {
  aaStringHexFromMemory(string,0,16,bp,YES);
  }
 else
 if(digp->status.type==aa_DIGESTTYPE_Sha1)
  {
  aaStringHexFromMemory(string,0,20,bp,YES);
  }
 else
 if(digp->status.type==aa_DIGESTTYPE_Sha256)
  {
  aaStringHexFromMemory(string,0,32,bp,YES);
  }
 else
 if(digp->status.type==aa_DIGESTTYPE_Sha512)
  {
  aaStringHexFromMemory(string,0,64,bp,YES);
  }
 return RET_YES;
 }





 B aaDigestMac                         (H handle,H keylen,VP key,H bytes,VP data,VP rdig,VP rdigstr)
 {
 B ret;
 B k_ipad[65];
 B k_opad[65];
 B tk[32];
 B cx[32];
 B dx[32];
 B buf[64];
 B isha[32],osha[32];
 H i;
 BP keyptr;
 _aa_digestobject*digp;
 BP src;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.digest_system.object_id,handle,(VP)&digp,NULL))!=RET_YES) { return ret; }
 if(rdigstr) { aaStringNull(rdigstr); }
 if((ret=aaDigestReset(handle))!=RET_YES) { return ret; }
 if(keylen==0) { aaStringLen(key,&keylen); }
 if(keylen==0) { return RET_BADPARM; }
 if(bytes==0) { aaStringLen(data,&bytes); }
 if(bytes==0) { return RET_BADPARM; }
 aaCast(keyptr,BP,key);
 if(digp->status.type==aa_DIGESTTYPE_Ripemd160)
  {
  oof;
  }
 else
 if(digp->status.type==aa_DIGESTTYPE_Sha1)
  {
  aaCast(keyptr,BP,key);
  if(keylen>64)
   {
   aaDigestWrite(handle,keylen,keyptr,YES,tk,0);
   aaCast(keyptr,BP,tk);
   keylen=20;
   }
  for(i=0;i<keylen;++i)  { buf[i]=(B)(keyptr[i]^0x36);  }
  for(i=keylen;i<64;++i) { buf[i]=0x36; }
  aaDigestWrite(handle,64,buf,NO,NULL,0);
  aaDigestWrite(handle,bytes,data,YES,isha,0);
  for(i=0;i<keylen;++i)  { buf[i]=(B)(keyptr[i]^0x5c); }
  for(i=keylen;i<64;++i) { buf[i]=0x5c; }
  aaDigestWrite(handle,64,buf,NO,NULL,0);
  aaDigestWrite(handle,20,isha,YES,osha,rdigstr);
  if(rdig) { aaMemoryCopy(rdig,20,osha); }
  }
 else
 if(digp->status.type==aa_DIGESTTYPE_Sha256)
  {
  H gap=0;
  #define HMAC_IPAD_VAL 0x36
  #define HMAC_OPAD_VAL 0x5C
  B hmac_buf[64+32]={0};
  aaMemoryFill(hmac_buf,sizeof(hmac_buf),0);
  aaCast(src,BP,data);
  if(keylen<64)  {   aaMemoryCopy(hmac_buf,keylen,key);   }
  else   {   oof;   aaDigestReset(handle);   aaDigestWrite(handle,keylen,key,YES,hmac_buf,0);   }
  for(i=0;i<64;i++)   hmac_buf[i]^=HMAC_IPAD_VAL;
  aaDigestReset(handle);
  aaDigestWrite(handle,64,hmac_buf,NO,0,0);
  if(gap<=0) {  aaDigestWrite(handle,bytes,src,YES,&hmac_buf[64],0); }
  else
   {
   oof;
   aaDigestWrite(handle,gap,src,NO,0,0);
   aaDigestWrite(handle,bytes-gap-32,&src[gap+32],YES,&hmac_buf[64],0);
   }
  for(i=0;i<64;i++)   {   hmac_buf[i]^=HMAC_IPAD_VAL^HMAC_OPAD_VAL;   }
  aaDigestReset(handle);
  aaDigestWrite(handle,64+32,hmac_buf,YES,osha,rdigstr);
  if(rdig) { aaMemoryCopy(rdig,32,osha); }
  }
 else
 if(digp->status.type==aa_DIGESTTYPE_Md5)
  {
  if(keylen>64)
   {
   aaDigestWrite(handle,keylen,key,YES,tk,0);
   aaCast(keyptr,BP,tk);
   keylen=16;
   }
  aaMemoryFill(k_ipad,sizeof(k_ipad),0);
  aaMemoryFill(k_opad,sizeof(k_opad),0);
  aaMemoryCopy(k_ipad,keylen,keyptr);
  aaMemoryCopy(k_opad,keylen,keyptr);
  for(i=0;i<64;i++)  {   k_ipad[i]^=0x36;   k_opad[i]^=0x5c;   }
  aaDigestWrite(handle,64,k_ipad,NO,NULL,0);
  aaDigestWrite(handle,bytes,data,YES,cx,0);
  aaDigestWrite(handle,64,k_opad,NO,NULL,0);
  aaDigestWrite(handle,16,cx,YES,dx,rdigstr);
  if(rdig) { aaMemoryCopy(rdig,16,dx); }
  }
 else
 if(digp->status.type==aa_DIGESTTYPE_Sha512)
  {
  oof;
  }

 return RET_YES;
 }



 B aaDigestQuick                       (B type,VP rdig,VP digstr,H bytes,VP data)
 {
 B ret;
 _digestunit digu;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if((ret=aaDigestCreate(&digu.handle,type))!=YES) { return ret; }
 aaDigestReset(digu.handle);
 if(bytes==0&&data!=NULL)  {  aaStringLen(data,&bytes);  }
 ret=aaDigestWrite(digu.handle,bytes,data,YES,rdig,digstr);
 aaDigestDestroy(digu.handle);
 return ret;
 }





 B aaDigestQuickf                      (B type,VP rdig,VP digstr,VP fmt,...)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaVargsf4K(fmt);
 return(aaDigestQuick(type,rdig,digstr,str4k.len,str4k.buf));
 }





 B aaDigestQuickTwice                  (B type,VP rdig,VP digstr,H bytes,VP data)
 {
 B ret;
 _digestunit digu;
 H d_len;
 B the_rdig_bin[128];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaDigestCreate(&digu.handle,type))!=YES) { return ret; }
 if(bytes==0&&data!=NULL)  {  aaStringLen(data,&bytes);  }
 ret=aaDigestWrite(digu.handle,bytes,data,YES,the_rdig_bin,NULL);
 aaDigestReset(digu.handle);
 if(type==aa_DIGESTTYPE_Ripemd160) { d_len=20; }  else
 if(type==aa_DIGESTTYPE_Md5)       { d_len=16; }  else
 if(type==aa_DIGESTTYPE_Sha1)      { d_len=20; }  else
 if(type==aa_DIGESTTYPE_Sha256)    { d_len=32; }  else
 if(type==aa_DIGESTTYPE_Sha512)    { d_len=64; }  else { oof; }
 ret=aaDigestWrite(digu.handle,d_len,the_rdig_bin,YES,(rdig)?rdig:NULL,(digstr)?digstr:NULL);
 aaDigestDestroy(digu.handle);
 return ret;
 }



/*-----------------------------------------------------------------------*/



 B aaCryptoCreate                      (HP handle,B type,B keylen,VP key)
 {
 B ret;
 _aa_cryptoobject*cryp;
 H sl,i;
 B i1,i2,newkey[257],v;
 B rcon;
 BP kp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(key==NULL) { return RET_BADPARM; }
 if(keylen==0) { aaStringLen(key,&sl); if(sl==0||sl>255) { return RET_BADPARM; } keylen=(B)sl; }
 if(type<aa_CRYPTOTYPE_Arc4||type>aa_CRYPTOTYPE_Aes256Ecb) { return RET_BADPARM; }
 if(type==aa_CRYPTOTYPE_Des1&&keylen!=8) { return RET_FAILED; }
 if(type==aa_CRYPTOTYPE_Des2&&keylen!=16) { return RET_FAILED; }
 if(type==aa_CRYPTOTYPE_Des3&&keylen!=24) { return RET_FAILED; }
 if((ret=aa_ObjectCreate(aa.crypto_system.object_id,handle,(VP)&cryp))!=RET_YES) { oops; return ret; }
 cryp->self_handle=*handle;
 aaMemoryCopy(newkey,keylen,key);
 if(type==aa_CRYPTOTYPE_Arc4)
  {
  for(sl=0;sl<256;sl++) cryp->state[2+sl]=(B)sl;
  i1=i2=0;
  for(sl=0;sl<256;sl++)
   {
   i2=(B)((newkey[i1]+cryp->state[2+sl]+i2)%256);
   v=cryp->state[2+i2];
   cryp->state[2+i2]=cryp->state[2+sl];
   cryp->state[2+sl]=v;
   i1=(B)((i1+1)%keylen);
   }
  }
 else
 if(type==aa_CRYPTOTYPE_Des1)
  {
  aa_CryptoSystemProcess(cryp->des_context.esk,newkey);
  for(i=0;i<32;i+=2)
   {
   cryp->des_context.dsk[i]=cryp->des_context.esk[30-i];
   cryp->des_context.dsk[i+1]=cryp->des_context.esk[31-i];
   }
  }
 else
 if(type==aa_CRYPTOTYPE_Des2)
  {
  aa_CryptoSystemProcess(cryp->des3_context.esk,newkey);
  aa_CryptoSystemProcess(cryp->des3_context.dsk+32,&newkey[8]);
  for(i=0;i<32;i+=2)
   {
   cryp->des3_context.dsk[i]=cryp->des3_context.esk[30-i];
   cryp->des3_context.dsk[i+1]=cryp->des3_context.esk[31-i];
   cryp->des3_context.esk[i+32]=cryp->des3_context.dsk[62-i];
   cryp->des3_context.esk[i+33]=cryp->des3_context.dsk[63-i];
   cryp->des3_context.esk[i+64]=cryp->des3_context.esk[i];
   cryp->des3_context.esk[i+65]=cryp->des3_context.esk[1+i];
   cryp->des3_context.dsk[i+64]=cryp->des3_context.dsk[i];
   cryp->des3_context.dsk[i+65]=cryp->des3_context.dsk[1+i];
   }
  }
 else
 if(type==aa_CRYPTOTYPE_Des3)
  {
  aa_CryptoSystemProcess(cryp->des3_context.esk,newkey);
  aa_CryptoSystemProcess(cryp->des3_context.dsk+32,&newkey[8]);
  aa_CryptoSystemProcess(cryp->des3_context.esk+64,&newkey[16]);
  for(i=0;i<32;i+=2)
   {
   cryp->des3_context.dsk[i]=cryp->des3_context.esk[94-i];
   cryp->des3_context.dsk[i+1]=cryp->des3_context.esk[95-i];
   cryp->des3_context.esk[i+32]=cryp->des3_context.dsk[62-i];
   cryp->des3_context.esk[i+33]=cryp->des3_context.dsk[63-i];
   cryp->des3_context.dsk[i+64]=cryp->des3_context.esk[30-i];
   cryp->des3_context.dsk[i+65]=cryp->des3_context.esk[31-i];
   }
  }
 else
 if(type==aa_CRYPTOTYPE_Aes256Ecb)
  {
  rcon=1;
  kp=(BP)key;
  for(i=0;i<sizeof(cryp->aes_context.key);i++) { cryp->aes_context.enc_key[i]=cryp->aes_context.dec_key[i]=kp[i]; }
  for(i=8;--i;)                                { aes_expandEncKey(cryp->aes_context.dec_key,&rcon); }
  }
 cryp->type=type;
 return RET_YES;
 }



 B aaCryptoDestroy                     (H handle)
 {
 B ret;
 _aa_cryptoobject*cryp;
 B isprot;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.crypto_system.object_id,handle,(VP)&cryp,&isprot))!=RET_YES) { return ret; }
 if(isprot) { return RET_FORBIDDEN; }
 aa_ObjectDestroy(aa.crypto_system.object_id,handle);
 return RET_YES;
 }





 B aaCryptoTranscode                   (H handle,H bytes,VP data,B dir)
 {
 B ret;
 _aa_cryptoobject*cryp;
 B v,x,y,xi;
 B i,rcon;
 BP bp;
 B buf[_1K];
 H c,chunk,left;
 H XX,YY,TT;
 HP SK;
 BP inpu,outpu;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.crypto_system.object_id,handle,(VP)&cryp,NULL))!=RET_YES) { return ret; }
 if(bytes==0) { return RET_YES; }
 if(data==NULL) { return RET_BADPARM; }
 aaCast(bp,BP,data);
 if(cryp->type==aa_CRYPTOTYPE_Arc4)
  {
  x=cryp->state[0];
  y=cryp->state[1];
  for(c=0;c<bytes;c++)
   {
   x=(B)((x+1)%256);
   y=(B)((cryp->state[2+x]+y)%256);
   v=cryp->state[2+y];
   cryp->state[2+y]=cryp->state[2+x];
   cryp->state[2+x]=v;
   xi=(B)((cryp->state[2+x]+cryp->state[2+y])%256);
   bp[c]^=cryp->state[2+xi];
   }
     /* rule 1
  if(cryp->crc[0xfe]==0xf119eef1)
   {
   z=(x+(y*(cryp->state[1+x])));
   if(!z) { z++; }
   _asm_
    {
    mov eax,0xfe
    sub edx,eax
    jz _maincryp
    jmp _subscryp
    storsd
   _maincryp:
    jne _maincryp


   }
   */
  cryp->state[0]=x;
  cryp->state[1]=y;
  }
 else
 if(cryp->type==aa_CRYPTOTYPE_Des1)
  {
  aaCast(inpu,BP,data);
  aaCast(outpu,BP,data);
  if(dir) { SK=cryp->des_context.esk; }
  else    { SK=cryp->des_context.dsk; }
  (XX)=((H)(inpu)[(0)]<<24)|((H)(inpu)[(0)+1]<<16)|((H)(inpu)[(0)+2]<<8)|((H)(inpu)[(0)+3]);
  (YY)=((H)(inpu)[(4)]<<24)|((H)(inpu)[(4)+1]<<16)|((H)(inpu)[(4)+2]<<8)|((H)(inpu)[(4)+3]);
  aaDES_IP(XX,YY);
  aaDES_ROUND(YY,XX);  aaDES_ROUND(XX,YY);
  aaDES_ROUND(YY,XX);  aaDES_ROUND(XX,YY);
  aaDES_ROUND(YY,XX);  aaDES_ROUND(XX,YY);
  aaDES_ROUND(YY,XX);  aaDES_ROUND(XX,YY);
  aaDES_ROUND(YY,XX);  aaDES_ROUND(XX,YY);
  aaDES_ROUND(YY,XX);  aaDES_ROUND(XX,YY);
  aaDES_ROUND(YY,XX);  aaDES_ROUND(XX,YY);
  aaDES_ROUND(YY,XX);  aaDES_ROUND(XX,YY);
  aaDES_FP(YY,XX);
  (outpu)[(0)]=(B)((YY)>>24); (outpu)[(0)+1]=(B)((YY)>>16); (outpu)[(0)+2]=(B)((YY)>>8); (outpu)[(0)+3]=(B)((YY));
  (outpu)[(4)]=(B)((XX)>>24); (outpu)[(4)+1]=(B)((XX)>>16); (outpu)[(4)+2]=(B)((XX)>>8); (outpu)[(4)+3]=(B)((XX));
  }
 else
 if(cryp->type==aa_CRYPTOTYPE_Des2||cryp->type==aa_CRYPTOTYPE_Des3)
  {
  aaCast(inpu,BP,data);
  aaCast(outpu,BP,data);
  if(dir) { SK=cryp->des3_context.esk; }
  else    { SK=cryp->des3_context.dsk; }
  (XX)=((H)(inpu)[(0)]<<24)|((H)(inpu)[(0)+1]<<16)|((H)(inpu)[(0)+2]<<8)|((H)(inpu)[(0)+3]);
  (YY)=((H)(inpu)[(4)]<<24)|((H)(inpu)[(4)+1]<<16)|((H)(inpu)[(4)+2]<<8)|((H)(inpu)[(4)+3]);
  aaDES_IP(XX,YY);
  aaDES_ROUND(YY,XX);  aaDES_ROUND(XX,YY);
  aaDES_ROUND(YY,XX);  aaDES_ROUND(XX,YY);
  aaDES_ROUND(YY,XX);  aaDES_ROUND(XX,YY);
  aaDES_ROUND(YY,XX);  aaDES_ROUND(XX,YY);
  aaDES_ROUND(YY,XX);  aaDES_ROUND(XX,YY);
  aaDES_ROUND(YY,XX);  aaDES_ROUND(XX,YY);
  aaDES_ROUND(YY,XX);  aaDES_ROUND(XX,YY);
  aaDES_ROUND(YY,XX);  aaDES_ROUND(XX,YY);
  aaDES_ROUND(XX,YY);  aaDES_ROUND(YY,XX);
  aaDES_ROUND(XX,YY);  aaDES_ROUND(YY,XX);
  aaDES_ROUND(XX,YY);  aaDES_ROUND(YY,XX);
  aaDES_ROUND(XX,YY);  aaDES_ROUND(YY,XX);
  aaDES_ROUND(XX,YY);  aaDES_ROUND(YY,XX);
  aaDES_ROUND(XX,YY);  aaDES_ROUND(YY,XX);
  aaDES_ROUND(XX,YY);  aaDES_ROUND(YY,XX);
  aaDES_ROUND(XX,YY);  aaDES_ROUND(YY,XX);
  aaDES_ROUND(YY,XX);  aaDES_ROUND(XX,YY);
  aaDES_ROUND(YY,XX);  aaDES_ROUND(XX,YY);
  aaDES_ROUND(YY,XX);  aaDES_ROUND(XX,YY);
  aaDES_ROUND(YY,XX);  aaDES_ROUND(XX,YY);
  aaDES_ROUND(YY,XX);  aaDES_ROUND(XX,YY);
  aaDES_ROUND(YY,XX);  aaDES_ROUND(XX,YY);
  aaDES_ROUND(YY,XX);  aaDES_ROUND(XX,YY);
  aaDES_ROUND(YY,XX);  aaDES_ROUND(XX,YY);
  aaDES_FP(YY,XX);
  (outpu)[(0)]=(B)((YY)>>24); (outpu)[(0)+1]=(B)((YY)>>16); (outpu)[(0)+2]=(B)((YY)>>8); (outpu)[(0)+3]=(B)((YY));
  (outpu)[(4)]=(B)((XX)>>24); (outpu)[(4)+1]=(B)((XX)>>16); (outpu)[(4)+2]=(B)((XX)>>8); (outpu)[(4)+3]=(B)((XX));
  }
 else
 if(cryp->type==aa_CRYPTOTYPE_Aes256Ecb)
  {
  aaCast(inpu,BP,data);
  aaCast(outpu,BP,data);
  //if((bytes%256)!=0) { oof; }
  if(dir)
   {
   for(chunk=0;chunk<bytes;chunk+=256)
    {
    left=bytes-chunk;
    aaMemoryFill(buf,256,0);
    if(left>=256) { aaMemoryCopy(buf,256,&inpu[chunk]); }
    else          { aaMemoryCopy(buf,left,&inpu[chunk]); }
    aes_addRoundKey_cpy(buf,cryp->aes_context.enc_key,cryp->aes_context.key);
    for(i=1,rcon=1;i<14;++i)
     {
     aes_subBytes(buf);
     aes_shiftRows(buf);
     aes_mixColumns(buf);
     if(i&1) { aes_addRoundKey(buf,&cryp->aes_context.key[16]); }
     else    { aes_expandEncKey(cryp->aes_context.key,&rcon),aes_addRoundKey(buf,cryp->aes_context.key); }
     }
    aes_subBytes(buf);
    aes_shiftRows(buf);
    aes_expandEncKey(cryp->aes_context.key,&rcon);
    aes_addRoundKey(buf,cryp->aes_context.key);
    if(left>=256) {   aaMemoryCopy(&outpu[chunk],256,buf);  }
    else          {   aaMemoryCopy(&outpu[chunk],left,buf); }
    }
   }
  else
   {
   for(chunk=0;chunk<bytes;chunk+=256)
    {
    left=bytes-chunk;
    aaMemoryFill(buf,256,0);
    if(left>=256) { aaMemoryCopy(buf,256,&inpu[chunk]); }
    else          { aaMemoryCopy(buf,left,&inpu[chunk]); }
    aes_addRoundKey_cpy(buf,cryp->aes_context.dec_key,cryp->aes_context.key);
    aes_shiftRows_inv(buf);
    aes_subBytes_inv(buf);
    for(i=14,rcon=0x80;--i;)
     {
     if((i&1))
      {
      aes_expandDecKey(cryp->aes_context.key,&rcon);
      aes_addRoundKey(buf,&cryp->aes_context.key[16]);
      }
     else
      {
      aes_addRoundKey(buf,cryp->aes_context.key);
      }
     aes_mixColumns_inv(buf);
     aes_shiftRows_inv(buf);
     aes_subBytes_inv(buf);
     }
    aes_addRoundKey(buf,cryp->aes_context.key);
    if(left>=256) {   aaMemoryCopy(&outpu[chunk],256,buf);  }
    else          {   aaMemoryCopy(&outpu[chunk],left,buf); }
    }
   }
  }
 return RET_YES;
 }




 B aaCryptSimple                       (H keylen,BP key,H datalen,BP data)
 {
 B Sbox[257],Sbox2[257];
 H i,j,t,x;
 B temp,k;
 BP kp,dp;

 if(key==NULL)  { return RET_MISSINGPARM; }
 if(data==NULL) { return RET_MISSINGPARM; }
 kp=(BP)key;
 dp=(BP)data;
 i=j=k=t=x=0;
 temp=0;
 aaMemoryFill(Sbox2,sizeof(Sbox2),0);
 for(i=0;i<256;i++) { Sbox[i]=i;}
 j=0;
 if(keylen==0) { return RET_BADPARM; }
 for(i=0;i<256;i++)
  {
  if(j==keylen) { j=0; }
  Sbox2[i]=kp[j++];
  }
 j=0;
 for(i=0;i<256;i++)
  {
  j=(j+(u32)Sbox[i]+(u32)Sbox2[i])%256;
  temp=Sbox[i];
  Sbox[i]=Sbox[j];
  Sbox[j]=temp;
  }
 i=j=0;
 for(x=0;x<datalen;x++)
  {
  i=(i+1)%256;
  j=(j+(u32)Sbox[i])%256;
  temp=Sbox[i];
  Sbox[i]=Sbox[j];
  Sbox[j]=temp;
  t=((u32)Sbox[i]+(u32)Sbox[j])%256;
  k=Sbox[t];
  dp[x]=(dp[x]^k);
  }
 return RET_YES;
 }


/*-----------------------------------------------------------------------*/

 B aaCryptoChaCha20Init                (_chacha20*chacha20,BP key,H len,B nonce[8])
 {
 const CP constants=(len==32)?"expand 32-byte k":"expand 16-byte k";

 if(chacha20==NULL) { return RET_MISSINGPARM; }
 if(key==NULL)      { return RET_MISSINGPARM; }
 if(len==0)         { return RET_BADPARM; }
 aaMemoryFill(chacha20,sizeof(_chacha20),0);
 chacha20->magic=aaHPP(aaCryptoChaCha20Init);
 //if(len==32) constants="expand 32-byte k";
 //else        constants="expand 16-byte k";
 chacha20->schedule[0]=aaChaCha20_LE(constants+0);
 chacha20->schedule[1]=aaChaCha20_LE(constants+4);
 chacha20->schedule[2]=aaChaCha20_LE(constants+8);
 chacha20->schedule[3]=aaChaCha20_LE(constants+12);
 chacha20->schedule[4]=aaChaCha20_LE(key+0);
 chacha20->schedule[5]=aaChaCha20_LE(key+4);
 chacha20->schedule[6]=aaChaCha20_LE(key+8);
 chacha20->schedule[7]=aaChaCha20_LE(key+12);
 chacha20->schedule[8]=aaChaCha20_LE(key+16%len);
 chacha20->schedule[9]=aaChaCha20_LE(key+20%len);
 chacha20->schedule[10]=aaChaCha20_LE(key+24%len);
 chacha20->schedule[11]=aaChaCha20_LE(key+28%len);
 chacha20->schedule[12]=0; //Counter
 chacha20->schedule[13]=0; //Counter
 chacha20->schedule[14]=aaChaCha20_LE(nonce+0);
 chacha20->schedule[15]=aaChaCha20_LE(nonce+4);
 chacha20->available=0;
 return RET_YES;
 }


 B aaCryptoChaCha20CounterSet          (_chacha20*chacha20,Q counter)
 {
 if(chacha20==NULL) { return RET_MISSINGPARM; }
 if(chacha20->magic!=aaHPP(aaCryptoChaCha20Init)) { return RET_NOTSTARTED; }
 chacha20->schedule[12]=counter&UINT32_C(0xFFFFFFFF);
 chacha20->schedule[13]=counter>>32;
 chacha20->available=0;
 return RET_YES;
 }


 B aaCryptoChaCha20Block               (_chacha20*chacha20,u32 output[16])
 {
// u32*const nonce;
 u32*const nonce=chacha20->schedule+12;
 u32 result;
 N i;

 if(chacha20==NULL) { return RET_MISSINGPARM; }
 if(chacha20->magic!=aaHPP(aaCryptoChaCha20Init)) { return RET_NOTSTARTED; }
 //nonce=chacha20->schedule+12;
 i=10;
 memcpy(output,chacha20->schedule,sizeof(chacha20->schedule));
 while (i--)
  {
  aaChaCha20_QROUND(output,0,4,8,12)
  aaChaCha20_QROUND(output,1,5,9,13)
  aaChaCha20_QROUND(output,2,6,10,14)
  aaChaCha20_QROUND(output,3,7,11,15)
  aaChaCha20_QROUND(output,0,5,10,15)
  aaChaCha20_QROUND(output,1,6,11,12)
  aaChaCha20_QROUND(output,2,7,8,13)
  aaChaCha20_QROUND(output,3,4,9,14)
  }
 for(i=0;i<16;++i)
  {
  result=output[i]+chacha20->schedule[i];
  aaChaCha20_FROMLE((BP)(output+i),result);
  }
 if(!++nonce[0]&&!++nonce[1]&&!++nonce[2]) { ++nonce[3]; }
 return RET_YES;
 }



 B aaCryptoChaCha20Encrypt             (_chacha20*chacha20,BP in,BP out,H len)
 {
 H amount;

 if(chacha20==NULL) { return RET_MISSINGPARM; }
 if(chacha20->magic!=aaHPP(aaCryptoChaCha20Init)) { return RET_NOTSTARTED; }
 if(len)
  {
  BP const k=(BP)chacha20->keystream;
   if(chacha20->available)
   {
   amount=aaNumMin(len,chacha20->available);
   aa_CryptoChaCha20Xor(k+(sizeof(chacha20->keystream)-chacha20->available),&in,&out,amount);
   chacha20->available-=amount;
   len-=amount;
   }
  while(len)
   {
   amount=aaNumMin(len,sizeof(chacha20->keystream));
   aaCryptoChaCha20Block(chacha20,chacha20->keystream);
   aa_CryptoChaCha20Xor(k,&in,&out,amount);
   len-=amount;
   chacha20->available=sizeof(chacha20->keystream)-amount;
   }
  }
 return RET_YES;
 }


 B aaCryptoChaCha20Decrypt             (_chacha20*chacha20,BP in,BP out,H len)
 {
 if(chacha20==NULL) { return RET_MISSINGPARM; }
 if(chacha20->magic!=aaHPP(aaCryptoChaCha20Init)) { return RET_NOTSTARTED; }
 aaCryptoChaCha20Encrypt(chacha20,in,out,len);
 return RET_YES;
 }





/*-----------------------------------------------------------------------*/



 B aaBifiNew                           (_bififile*bififile,G clx,H fsu,Q bifisize,Q bifivars,VP prefix,VP path,...)
 {
 B ret;
 B file[_1K];
 G i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMissingParm(bififile);
 objInit(bififile,aaBifiNew);
 aaVargsf4K(path);
 if(bifisize<_1K||bifisize>_1GIG)         { return RET_BOUNDS; }
 if(bifivars>aaBillion(100)) { return RET_BOUNDS; }
 if(fsu==0||fsu>32) { return RET_BOUNDS; }
 bififile->bifi_size=bifisize;
 bififile->bifi_vars=bifivars;
 bififile->fsu_count=fsu;
 if((ret=aaMemoryAllocate((VP)&bififile->fsu,bififile->fsu_count*sizeof(_filestreamunit)))!=YES) { oops; }
 aaMemoryNameSet(bififile->fsu,"bififsu");
 aaStringCopyf(bififile->path,"%s",str4k.buf);
 if(prefix) { aaStringCopyf(bififile->prefix,"%s",prefix); }
 //if(bififile->prefix[0]) { aaStringAppendf(bififile->prefix,"_"); }
 ///aaStringAppendf(bififile->prefix,"%I64d_",bififile->bifi_size);
 ///aaStringAppendf(bififile->prefix,"%I64d_",bififile->bifi_vars);
 bififile->data_off=sizeof(_bifivar)*bifivars;
 if((ret=aaFileFolderExists(bififile->path))!=YES)
  {
  if((ret=aaFileFolderCreate(bififile->path))!=YES) { oops; }
  if((ret=aaFileFolderExists(bififile->path))!=YES) { objClear(bififile);  return ret;   }
  }
 if(clx>=0LL)
  {
  for(i=0;i<clx;i++)
   {
   //aaDebugf("i=%I64d path=%s prefix=%s ",i,bififile->path,bififile->prefix);
   if(bififile->prefix[0]) { aaStringCopyf(file,"%s/%s%I64u.bifi",bififile->path,bififile->prefix,i); }
   else                    { aaStringCopyf(file,"%s/%I64u.bifi",bififile->path,i); }
   ret=aaFileDelete("%s",file);
   aaDebugf("deleting file={%s} ={%s}",file,arets);
   ///aaDebugf("deleting %I64d ret=%s",i,arets);
   }
  }
 return RET_YES;
 }





 B aaBifiDelete                        (_bififile*bififile)
 {
 H i,mx;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bififile,aaBifiNew);
 mx=bififile->fsu_count;
 for(i=0;i<mx;i++)
  {
  if(bififile->fsu[i].handle==0) { continue; }
  aaFileStreamDestroy(bififile->fsu[i].handle);
  bififile->fsu[i].handle=0;
  }
 aaMemoryRelease(bififile->fsu);
 objClear(bififile);
 return RET_YES;
 }






 B aaBifiRead                          (_bififile*bififile,Q off,Q len,VP data)
 {
 B ret;
 H i,mx,han;
 Q div,mod,vol,toe;
 Q todo,done;
 B file[_1K];
 B block[_8K];
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bififile,aaBifiNew);
 mx=bififile->fsu_count;
 aaMissingParm(data);
 bp=(BP)data;
 done=0;
 redo:
 div=off/bififile->bifi_size;
 mod=off%bififile->bifi_size;
 vol=div;
 if(bififile->prefix[0]) { aaStringCopyf(file,"%s/%s%I64u.bifi",bififile->path,bififile->prefix,vol); }
 else                    { aaStringCopyf(file,"%s/%I64u.bifi",bififile->path,vol); }
 //aaDebugf("file=%s",file);
 for(i=0;i<mx;i++)
  {
  if(bififile->fsu[i].handle==0) { continue; }
  if(aaStringICompare(bififile->fsu[i].status.filename,file,0)==YES) { bififile->hits++; break; }
  }
 if(i==mx)
  {
  bififile->misses++;
  for(i=0;i<mx;i++)
   {
   if(bififile->fsu[i].handle==0) { break; }
   }
  if(i==mx)
   {
   i=aaMathRand32(0,mx-1);
   aaFileStreamDestroy(bififile->fsu[i].handle);
   aaMemoryFill(&bififile->fsu[i],sizeof(_filestreamunit),0);
   }
  if((ret=aaFileStreamOpenQuick(&han,file))!=YES) { return ret; }
  bififile->fsu[i].handle=han;
  }

 aaFileStreamStatus(bififile->fsu[i].handle,&bififile->fsu[i].status);
 if(bififile->fsu[i].status.bytes>bififile->bifi_size)
  {
  aaNote(0,"is too big %I64u",bififile->fsu[i].status.bytes);
  }
 else
 if(bififile->fsu[i].status.bytes<bififile->bifi_size)
  {
  if((ret=aaFileStreamSizeSet(bififile->fsu[i].handle,bififile->bifi_size))!=RET_YES) { oops; }
  aaFileStreamStatus(bififile->fsu[i].handle,&bififile->fsu[i].status);
  }
 if(bififile->fsu[i].status.offset!=(Q)mod)
  {
  if((ret=aaFileStreamOffsetSet(bififile->fsu[i].handle,(Q)mod))!=YES) { oops; }
  aaFileStreamStatus(bififile->fsu[i].handle,&bififile->fsu[i].status);
  }
 toe=bififile->fsu[i].status.bytes-mod;
 while(1)
  {
  if(toe==0)
   {
   aaFileStreamStatus(bififile->fsu[i].handle,&bififile->fsu[i].status);
   goto redo;
   }
  todo=len-done;
  if(todo==0) { break; }
  todo=aaNumRoof(todo,sizeof(block));
  todo=aaNumRoof(todo,toe);
  if(todo!=0)
   {
   if((ret=aaFileStreamRead(bififile->fsu[i].handle,(H)todo,bp))!=YES) { oops; }
   bp+=(H)todo;
   done+=todo;
   toe-=todo;
   }
  }
 aaFileStreamStatus(bififile->fsu[i].handle,&bififile->fsu[i].status);
 return RET_YES;
 }




 B aaBifiWritef                        (_bififile*bififile,Q off,QP len,VP fmt,...)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bififile,aaBifiNew);
 aaVargsf4K(fmt);
 if(len) { *len=0; }
 if((ret=aaBifiWrite(bififile,off,(Q)str4k.len,str4k.buf))!=RET_YES) { return ret; }
 if(len) { *len=(Q)str4k.len; }
 return RET_YES;
 }








 B aaBifiWrite                         (_bififile*bififile,Q off,Q len,VP data)
 {
 B ret;
 H i,mx,han;
 Q div,mod,vol,toe;
 Q todo,done;
 B file[_1K];
 B block[_16K];
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bififile,aaBifiNew);
 mx=bififile->fsu_count;
 bp=(BP)data;
 done=0;
 redo:
 div=off/bififile->bifi_size;
 mod=off%bififile->bifi_size;
 vol=div;
 if(bififile->prefix[0]) { aaStringCopyf(file,"%s/%s%I64u.bifi",bififile->path,bififile->prefix,vol); }
 else                    { aaStringCopyf(file,"%s/%I64u.bifi",bififile->path,vol); }
 //aaDebugf("file=%s",file);

 for(i=0;i<mx;i++)
  {
  if(bififile->fsu[i].handle==0) { continue; }
  if(aaStringICompare(bififile->fsu[i].status.filename,file,0)==YES) { bififile->hits++;  break; }
  }
 if(i==mx)
  {
  bififile->misses++;
  for(i=0;i<mx;i++)
   {
   if(bififile->fsu[i].handle==0) { break; }
   }
  if(i==mx)
   {
   i=aaMathRand32(0,mx-1);
   aaFileStreamDestroy(bififile->fsu[i].handle);
   aaMemoryFill(&bififile->fsu[i],sizeof(_filestreamunit),0);
   }
  if((ret=aaFileStreamCreateQuick(&han,file))!=YES) { return ret; }
  bififile->fsu[i].handle=han;
  }
 aaFileStreamStatus(bififile->fsu[i].handle,&bififile->fsu[i].status);
 if(bififile->fsu[i].status.bytes>bififile->bifi_size)
  {
  aaNote(0,"is too big %I64u",bififile->fsu[i].status.bytes);
  }
 else
 if(bififile->fsu[i].status.bytes<bififile->bifi_size)
  {
  if((ret=aaFileStreamSizeSet(bififile->fsu[i].handle,bififile->bifi_size))!=YES) { oops; }
  }
 if(bififile->fsu[i].status.offset!=(Q)mod)
  {
  if((ret=aaFileStreamOffsetSet(bififile->fsu[i].handle,(Q)mod))!=YES) { oops; }
  aaFileStreamStatus(bififile->fsu[i].handle,&bififile->fsu[i].status);
  }
 toe=bififile->fsu[i].status.bytes-mod;
 if(bp==NULL) { aaMemoryFill(block,sizeof(block),0); }
 while(1)
  {
  if(toe==0)
   {
   aaFileStreamStatus(bififile->fsu[i].handle,&bififile->fsu[i].status);
   goto redo;
   }
  todo=len-done;
  if(todo==0) { break; }
  todo=aaNumRoof(todo,sizeof(block));
  todo=aaNumRoof(todo,toe);
  if(todo!=0)
   {
   if(bp==NULL)    {    if((ret=aaFileStreamWrite(bififile->fsu[i].handle,(H)todo,block))!=YES) { oops; }    }
   else            {    if((ret=aaFileStreamWrite(bififile->fsu[i].handle,(H)todo,bp))!=YES)    { oops; }    }
   if(bp!=NULL)    {  bp+=(H)todo;  }
   done+=todo;
   toe-=todo;
   }
  }
 aaFileStreamStatus(bififile->fsu[i].handle,&bififile->fsu[i].status);
 return RET_YES;
 }







 B aaBifiVarSet                        (_bififile*bififile,VP name,H bytes,VP data)
 {
 B ret;
 H sl;
 B rdig[32];
 _bifivar var;
 Q hash,hi,off;
 HP hp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bififile,aaBifiNew);
 if(name==NULL)             { return RET_BADPARM;      }
 aaStringLen(name,&sl);
 if(sl==0||sl>32)           { return RET_BADPARM;      }
 if(bytes>sizeof(var.data)) { return RET_BOUNDS;       }
 if(data==NULL)             { return RET_BADPARM;      }
 if(bififile->bifi_vars==0) { return RET_NOTSUPPORTED; }

 ret=aaBifiVarGet(bififile,name,&var);
 if(ret==RET_NOTFOUND) { aaMemoryFill(&var,sizeof(_bifivar),0); }
 else
 if(ret!=RET_YES)      { oops; }

 if((ret=aaDigestQuick(aa_DIGESTTYPE_Sha256,rdig,NULL,sl,name))!=RET_YES) { oops; }
 hp=(HP)&hash;
 hp[0]=*(HP)&rdig[0];
 hp[1]=*(HP)&rdig[4];
 hi=hash%bififile->bifi_vars;
 off=hi*sizeof(_bifivar);
 aaTimeUtcExGet(&hi);
 hi=hi/1000000LL;
 var.update_utc=(H)hi;
 var.update_counter++;
 aaStringCopy(var.name,name);
 aaMemoryCopy(var.data,bytes,data);

 //aaDebugf("%s about to call bifiwrite off=%I64d len=%i %I64d",var.name,off,sizeof(_bifivar),*(QP)var.data);
 if((ret=aaBifiWrite(bififile,off,sizeof(_bifivar),&var))!=YES) { oops; }
 return RET_YES;
 }






 B aaBifiVarSetf                       (_bififile*bififile,VP name,VP fmt,...)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bififile,aaBifiNew);
 aaVargsf4K(fmt);
 return(aaBifiVarSet(bififile,name,str4k.len,str4k.buf));
 }





 B aaBifiVarGet                        (_bififile*bififile,VP name,_bifivar*bifivar)
 {
 B ret;
 H sl;
 B rdig[32];
 Q hash,hi,off;
 HP hp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bififile,aaBifiNew);
 if(bifivar==NULL) { return RET_BADPARM; }
 aaMemoryFill(bifivar,sizeof(_bifivar),0);
 if(name==NULL)   { return RET_BADPARM; }
 aaStringLen(name,&sl);
 if(sl==0||sl>32) { return RET_BADPARM; }
 if(bififile->bifi_vars==0) { return RET_NOTSUPPORTED; }
 if((ret=aaDigestQuick(aa_DIGESTTYPE_Sha256,rdig,NULL,sl,name))!=RET_YES) { oops; }
 hp=(HP)&hash;
 hp[0]=*(HP)&rdig[0];
 hp[1]=*(HP)&rdig[4];
 hi=hash%bififile->bifi_vars;
 off=hi*sizeof(_bifivar);

 //aaDebugf("%s about to call bifiRead off=%I64d len=%i",name,off,sizeof(_bifivar));

 if((ret=aaBifiRead(bififile,off,sizeof(_bifivar),bifivar))!=YES) { return ret; }

// aaDebugf("=%I64d",*(QP)bifivar->data);


 if(aaStringICompare(bifivar->name,name,0)!=YES) { return RET_NOTFOUND; }
 /*
 if(aaStringIsNumerical(bifivar->data,YES,YES,0)==YES)
  {
  if(aaStringToDouble(bifivar->data,0,&bifinum->num)==YES)
   {

   }
  bifinum->
  }
 */
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/




 B aaJsonCreate                        (HP handle,B encflag)
 {
 B ret;
 _aa_jsonobject*jsonp;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCreate(aa.json_system.object_id,handle,(VP)&jsonp))!=RET_YES) { oops; return ret; }
 jsonp->self_handle=*handle;
 if(encflag)  {  jsonp->status.is_encode=YES;  }
 else  {  jsonp->status.is_encode=NO;  }
 return RET_YES;
 }



 B aaJsonDestroy                       (H handle)
 {
 B ret;
 _aa_jsonobject*jsonp;
 B isprot;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.json_system.object_id,handle,(VP)&jsonp,&isprot))!=RET_YES) { return ret; }
 if(isprot) { return RET_FORBIDDEN; }
 if(jsonp->bytes_allocated) { if(aa_MemoryRelease(jsonp->status.mem)!=YES) oof; }
 if(jsonp->lines_allocated) { if(aaMemoryRelease(jsonp->status.line)!=YES) oof; }
 aa_ObjectDestroy(aa.json_system.object_id,handle);
 return RET_YES;
 }



 B aaJsonStatus                        (H handle,_jsonstatus*jsonstatus)
 {
 B ret;
 _aa_jsonobject*jsonp;
 H go;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.json_system.object_id,handle,(VP)&jsonp,NULL))!=RET_YES) { return ret; }
 if(jsonp->status.is_decoding==YES)
  {
  go=0;
   while(1)
    {
    if((go++)>1000) break;
    if((ret=aa_jsonSystemDecode((VP)&jsonp))!=YES) { oops; break; }
    if(jsonp->status.is_decoding==NO)      {      break;      }
    }
  }
 if(jsonstatus) { aaMemoryCopy(jsonstatus,sizeof(_jsonstatus),&jsonp->status); }
 return RET_YES;
 }




 B aaJsonReset                         (H handle,B encflag)
 {
 B ret;
 _aa_jsonobject*jsonp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.json_system.object_id,handle,(VP)&jsonp,NULL))!=RET_YES) { return ret; }
 if(encflag)  {  jsonp->status.is_encode=YES;  }
 else  {  jsonp->status.is_encode=NO;  }
 jsonp->status.is_decoding=NO;
 jsonp->status.decode_success=NO;
 jsonp->status.decode_failure=NO;
 jsonp->status.mem_bytes=0;
 jsonp->status.lines=0;
 jsonp->bytes_left=jsonp->bytes_allocated;
 jsonp->dec_stage=0;
 return RET_YES;
 }





 B aaJsonAppendf                       (H handle,VP fmt,...)
 {
 B ret;
 _aa_jsonobject*jsonp;
 va_list argptr;
 B txt[_32K+_8K];
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.json_system.object_id,handle,(VP)&jsonp,NULL))!=RET_YES) { return ret; }
 if(jsonp->status.is_encode==YES) { return RET_FORBIDDEN; }
 aaFmt(fmt,argptr,txt);
 aaStringLen(txt,&sl);
 if(sl==0) { return RET_YES; }
 if((sl+_1K)>=jsonp->bytes_left) { if(aa_JsonSystemExtendMemory((VP)&jsonp,sl+_4K)!=YES) oof; }
 aaStringNCopy(&jsonp->status.mem[jsonp->status.mem_bytes],txt,sl,YES);
 jsonp->status.mem_bytes+=sl;
 jsonp->bytes_left=jsonp->bytes_allocated-jsonp->status.mem_bytes;
 return RET_YES;
 }





 B aaJsonAppendBytes                   (H handle,H bytes,VP data)
 {
 B ret;
 _aa_jsonobject*jsonp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.json_system.object_id,handle,(VP)&jsonp,NULL))!=RET_YES) { return ret; }
 if(jsonp->status.is_encode==YES) { return RET_FORBIDDEN; }
 if(data==NULL) { return RET_BADPARM; }
 if(bytes==0) { aaStringLen(data,&bytes); }
 if(bytes==0) { return RET_YES; }
 if((bytes+_1K)>=jsonp->bytes_left) { if(aa_JsonSystemExtendMemory((VP)&jsonp,bytes+_4K)!=YES) oof; }
 aaStringNCopy(&jsonp->status.mem[jsonp->status.mem_bytes],data,bytes,YES);
 jsonp->status.mem_bytes+=bytes;
 jsonp->bytes_left=jsonp->bytes_allocated-jsonp->status.mem_bytes;
 return RET_YES;
 }




 B aaJsonDecode                        (H handle)
 {
 B ret;
 _aa_jsonobject*jsonp;
 B inq;
 H i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.json_system.object_id,handle,(VP)&jsonp,NULL))!=RET_YES) { return ret; }
 if(jsonp->status.is_decoding) { return RET_INUSE; }
 if(jsonp->dec_stage!=0)
  {
  if(jsonp->dec_stage==600&&jsonp->status.decode_success==YES&&jsonp->status.decode_failure==NO)
   {
  return RET_YES;
   }
  aaNote(0,"stag=%i,s=%i f=%i",jsonp->dec_stage,jsonp->status.decode_success,jsonp->status.decode_failure);
  }
 if(jsonp->status.mem_bytes==0) { return RET_NOTREADY; }
 jsonp->status.is_decoding=YES;
 jsonp->status.decode_success=NO;
 jsonp->status.decode_failure=NO;
 i=0;
 inq=NO;
   while(1)
    {
    if(jsonp->status.mem[i]==0)
     {
     jsonp->status.mem_bytes=i;
     aaParserInit(&jsonp->pa,jsonp->status.mem,(H)jsonp->status.mem_bytes);
     break;
     }
    if(i>=jsonp->status.mem_bytes) { aaNote(0,"line=%i i=%i",__LINE__,i); break; }
    if(inq==0)
     {
     if(jsonp->status.mem[i]==DQUOTE_CHAR) { inq=jsonp->status.mem[i]; i++; continue; }
     }
    else
     {
     if(jsonp->status.mem[i]==BSLASH_CHAR&&jsonp->status.mem[i+1]==inq) { i+=2; continue; }
     if(jsonp->status.mem[i]==inq) { inq=0; i++; continue; }
     }
    if(inq==0)
     {
     if(aaCharIsVisible(jsonp->status.mem[i])==NO&&aaCharIsVisible(jsonp->status.mem[i+1])==NO)
      {
      aaStringDeleteChars(jsonp->status.mem,0,i,1);
      continue;
      }
     }
    i++;
    }
 aaStringLen(jsonp->status.mem,&jsonp->status.mem_bytes);
 return RET_YES;
 }





 B aaJsonEncodeObjectOpen              (H handle)
 {
 B ret;
 _aa_jsonobject*jsonp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.json_system.object_id,handle,(VP)&jsonp,NULL))!=RET_YES) { return ret; }
 if(jsonp->status.is_encode==NO) { return RET_FORBIDDEN; }
 jsonp->status.is_encode=NO;
 if(jsonp->last_enc_type==JSON_TYPE_KEY)
  {
  if((ret=aaJsonAppendf(handle,":"))!=YES) { oops; }
  }
 jsonp->status.is_encode=NO;
 if((ret=aaJsonAppendf(handle,"{"))!=YES) { oops; }
 jsonp->last_enc_type=JSON_TYPE_OBJOPEN;
 jsonp->status.is_encode=YES;
 jsonp->in_array=NO;
 return RET_YES;
 }




 B aaJsonEncodeObjectClose             (H handle)
 {
 B ret;
 _aa_jsonobject*jsonp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.json_system.object_id,handle,(VP)&jsonp,NULL))!=RET_YES) { return ret; }
 if(jsonp->status.is_encode==NO) { return RET_FORBIDDEN; }
 jsonp->status.is_encode=NO;
 if((ret=aaJsonAppendf(handle,"}"))!=YES) { oops; }
 jsonp->last_enc_type=JSON_TYPE_OBJCLOSE;
 jsonp->status.is_encode=YES;
 jsonp->in_array=NO;
 return RET_YES;
 }




 B aaJsonEncodeArrayOpen               (H handle)
 {
 B ret;
 _aa_jsonobject*jsonp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.json_system.object_id,handle,(VP)&jsonp,NULL))!=RET_YES) { return ret; }
 if(jsonp->status.is_encode==NO) { return RET_FORBIDDEN; }
 jsonp->status.is_encode=NO;
 if(jsonp->last_enc_type==JSON_TYPE_KEY)
  {
  if((ret=aaJsonAppendf(handle,":"))!=YES) { oops; }
  }
 jsonp->status.is_encode=NO;
 if((ret=aaJsonAppendf(handle,"["))!=YES) { oops; }
 jsonp->last_enc_type=JSON_TYPE_ARRAYOPEN;
 jsonp->in_array=YES;
 jsonp->status.is_encode=YES;
 return RET_YES;
 }



 B aaJsonEncodeArrayClose              (H handle)
 {
 B ret;
 _aa_jsonobject*jsonp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.json_system.object_id,handle,(VP)&jsonp,NULL))!=RET_YES) { return ret; }
 if(jsonp->status.is_encode==NO) { return RET_FORBIDDEN; }
 jsonp->status.is_encode=NO;
 if((ret=aaJsonAppendf(handle,"]"))!=YES) { oops; }
 jsonp->last_enc_type=JSON_TYPE_ARRAYCLOSE;
 jsonp->status.is_encode=YES;
 return RET_YES;
 }




 B aaJsonEncodeKey                     (H handle,VP fmt,...)
 {
 B ret;
 _aa_jsonobject*jsonp;
 va_list argptr;
 B txt[_32K+_8K];
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.json_system.object_id,handle,(VP)&jsonp,NULL))!=RET_YES) { return ret; }
 if(jsonp->status.is_encode==NO) { return RET_FORBIDDEN; }
 aaFmt(fmt,argptr,txt);
 aaStringLen(txt,&sl);
 if(sl==0) { return RET_FAILED; }
 jsonp->status.is_encode=NO;
 if(jsonp->last_enc_type!=JSON_TYPE_KEY)
  {
  if(jsonp->last_enc_type>=JSON_TYPE_STRING||jsonp->last_enc_type==JSON_TYPE_ARRAYCLOSE||jsonp->last_enc_type==JSON_TYPE_OBJCLOSE)
   {
   if((ret=aaJsonAppendf(handle,","))!=YES) { oops; }
   }
  }
 jsonp->status.is_encode=NO;
 if((ret=aaJsonAppendf(handle,"\"%s\"",txt))!=YES) { oops; }
 jsonp->last_enc_type=JSON_TYPE_KEY;
 jsonp->status.is_encode=YES;
 return RET_YES;
 }





 B aaJsonEncodeString                  (H handle,VP fmt,...)
 {
 B ret;
 _aa_jsonobject*jsonp;
 va_list argptr;
 B txt[_32K+_8K];
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.json_system.object_id,handle,(VP)&jsonp,NULL))!=RET_YES) { return ret; }
 if(jsonp->status.is_encode==NO) { return RET_FORBIDDEN; }
 aaFmt(fmt,argptr,txt);
 aaStringLen(txt,&sl);
 if(sl==0) { return RET_FAILED; }
 jsonp->status.is_encode=NO;
 if(jsonp->last_enc_type==JSON_TYPE_KEY)
  {
  if((ret=aaJsonAppendf(handle,":"))!=YES) { oops; }
  }
 else
 if(jsonp->last_enc_type!=JSON_TYPE_KEY)
  {
  if((ret=aaJsonAppendf(handle,","))!=YES) { oops; }
  }
 jsonp->status.is_encode=NO;
 if((ret=aaJsonAppendf(handle,"\"%s\"",txt))!=YES) { oops; }
 jsonp->last_enc_type=JSON_TYPE_STRING;
 jsonp->status.is_encode=YES;
 return RET_YES;
 }




 B aaJsonEncodeFloat                   (H handle,D val)
 {
 B ret;
 _aa_jsonobject*jsonp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.json_system.object_id,handle,(VP)&jsonp,NULL))!=RET_YES) { return ret; }
 if(jsonp->status.is_encode==NO) { return RET_FORBIDDEN; }
 jsonp->status.is_encode=NO;
 if(jsonp->last_enc_type==JSON_TYPE_KEY)
  {
  if((ret=aaJsonAppendf(handle,":"))!=YES) { oops; }
  }
 else
 if(jsonp->last_enc_type!=JSON_TYPE_KEY)
  {
  if((ret=aaJsonAppendf(handle,","))!=YES) { oops; }
  }
 jsonp->status.is_encode=NO;
 if((ret=aaJsonAppendf(handle,",%f",val))!=YES) { oops; }
 jsonp->last_enc_type=JSON_TYPE_FLOAT;
 jsonp->status.is_encode=YES;
 return RET_YES;
 }




 B aaJsonEncodeInt                     (H handle,G val)
 {
 B ret;
 _aa_jsonobject*jsonp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.json_system.object_id,handle,(VP)&jsonp,NULL))!=RET_YES) { return ret; }
 if(jsonp->status.is_encode==NO) { return RET_FORBIDDEN; }
 jsonp->status.is_encode=NO;
 if(jsonp->last_enc_type==JSON_TYPE_KEY)
  {
  if((ret=aaJsonAppendf(handle,":"))!=YES) { oops; }
  }
 else
 if(jsonp->last_enc_type!=JSON_TYPE_KEY)
  {
  if((ret=aaJsonAppendf(handle,","))!=YES) { oops; }
  }
 jsonp->status.is_encode=NO;
 if((ret=aaJsonAppendf(handle,",%I64d",val))!=YES) { oops; }
 jsonp->last_enc_type=JSON_TYPE_INT;
 jsonp->status.is_encode=YES;
 return RET_YES;
 }




 B aaJsonEncodeBool                    (H handle,B val)
 {
 B ret;
 _aa_jsonobject*jsonp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.json_system.object_id,handle,(VP)&jsonp,NULL))!=RET_YES) { return ret; }
 if(jsonp->status.is_encode==NO) { return RET_FORBIDDEN; }
 if(val=='t'||val=='T') { val=1; } else
 if(val=='f'||val=='F') { val=0; }
 if(val!=0&&val!=1) { return RET_BADPARM; }
 jsonp->status.is_encode=NO;
 if(jsonp->last_enc_type==JSON_TYPE_KEY)
  {
  if((ret=aaJsonAppendf(handle,":"))!=YES) { oops; }
  }
 else
 if(jsonp->last_enc_type!=JSON_TYPE_KEY)
  {
  if((ret=aaJsonAppendf(handle,","))!=YES) { oops; }
  }
 jsonp->status.is_encode=NO;
 if(val==0)
  {
  if((ret=aaJsonAppendf(handle,",false"))!=YES) { oops; }
  }
 else
 if(val==1)
  {
  if((ret=aaJsonAppendf(handle,",true"))!=YES) { oops; }
  }
 jsonp->last_enc_type=JSON_TYPE_FALSE+val;
 jsonp->status.is_encode=YES;
 return RET_YES;
 }




 B aaJsonEncodeNull                    (H handle)
 {
 B ret;
 _aa_jsonobject*jsonp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.json_system.object_id,handle,(VP)&jsonp,NULL))!=RET_YES) { return ret; }
 if(jsonp->status.is_encode==NO) { return RET_FORBIDDEN; }
 jsonp->status.is_encode=NO;
 if(jsonp->last_enc_type==JSON_TYPE_KEY)
  {
  if((ret=aaJsonAppendf(handle,":"))!=YES) { oops; }
  }
 else
 if(jsonp->last_enc_type!=JSON_TYPE_KEY)
  {
  if((ret=aaJsonAppendf(handle,","))!=YES) { oops; }
  }
 jsonp->status.is_encode=NO;
 if((ret=aaJsonAppendf(handle,",null"))!=YES) { oops; }
 jsonp->last_enc_type=JSON_TYPE_NULL;
 jsonp->status.is_encode=YES;
 return RET_YES;
 }




 B aaJsonEncodeKeyString               (H handle,VP key,VP fmt,...)
 {
 B ret;
 _aa_jsonobject*jsonp;
 va_list argptr;
 B txt[_32K+_8K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.json_system.object_id,handle,(VP)&jsonp,NULL))!=RET_YES) { return ret; }
 if(jsonp->status.is_encode==NO) { oops; return RET_FORBIDDEN; }
 if(aaStringIsNull(key)!=NO) { return RET_BADPARM; }
 aaFmt(fmt,argptr,txt);
 if((ret=aaJsonEncodeKey(handle,"%s",key))!=YES) { oops; return ret; }
 if((ret=aaJsonEncodeString(handle,"%s",txt))!=YES) {oops;  return ret; }
 return RET_YES;
 }







 B aaJsonEncodeKeyFloat                (H handle,VP key,D val)
 {
 B ret;
 _aa_jsonobject*jsonp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.json_system.object_id,handle,(VP)&jsonp,NULL))!=RET_YES) { return ret; }
 if(jsonp->status.is_encode==NO) { return RET_FORBIDDEN; }
 if(aaStringIsNull(key)!=NO) { return RET_BADPARM; }
 if((ret=aaJsonEncodeKey(handle,"%s",key))!=YES) { return ret; }
 if((ret=aaJsonEncodeFloat(handle,val))!=YES) { return ret; }
 return RET_YES;
 }




 B aaJsonEncodeKeyInt                  (H handle,VP key,G val)
 {
 B ret;
 _aa_jsonobject*jsonp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.json_system.object_id,handle,(VP)&jsonp,NULL))!=RET_YES) { return ret; }
 if(jsonp->status.is_encode==NO) { return RET_FORBIDDEN; }
 if(aaStringIsNull(key)!=NO) { return RET_BADPARM; }
 if((ret=aaJsonEncodeKey(handle,"%s",key))!=YES) { return ret; }
 if((ret=aaJsonEncodeInt(handle,val))!=YES) { return ret; }
 return RET_YES;
 }



 B aaJsonEncodeKeyBool                 (H handle,VP key,B val)
 {
 B ret;
 _aa_jsonobject*jsonp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.json_system.object_id,handle,(VP)&jsonp,NULL))!=RET_YES) { return ret; }
 if(jsonp->status.is_encode==NO) { return RET_FORBIDDEN; }
 if(aaStringIsNull(key)!=NO) { return RET_BADPARM; }
 if((ret=aaJsonEncodeKey(handle,"%s",key))!=YES) { return ret; }
 if((ret=aaJsonEncodeBool(handle,val))!=YES) { return ret; }
 return RET_YES;
 }





 B aaJsonEncodeKeyNull                 (H handle,VP key)
 {
 B ret;
 _aa_jsonobject*jsonp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.json_system.object_id,handle,(VP)&jsonp,NULL))!=RET_YES) { return ret; }
 if(jsonp->status.is_encode==NO) { return RET_FORBIDDEN; }
 if(aaStringIsNull(key)!=NO) { return RET_BADPARM; }
 if((ret=aaJsonEncodeKey(handle,"%s",key))!=YES) { return ret; }
 if((ret=aaJsonEncodeNull(handle))!=YES) { return ret; }
 return RET_YES;
 }






 B aaJsonParserLineGet                 (H handle,H line,_jsonline*jsonline,VP str)
 {
 B ret;
 _aa_jsonobject*jsonp;
 H sl;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.json_system.object_id,handle,(VP)&jsonp,NULL))!=RET_YES) { return ret; }
 if(str) { aaStringNull(str); }
 if(jsonp->status.decode_success!=YES) { return RET_NOTREADY; }
 if(line>=jsonp->status.lines) { return RET_BOUNDS; }
 if(jsonline)
  {
  aaMemoryCopy(jsonline,sizeof(_jsonline),&jsonp->status.line[line]);
  }
 if(str==NULL) { return RET_YES;  }
 sl=jsonp->status.line[line].len;
 if(str&&sl){  aaStringNCopy(str,&jsonp->status.mem[jsonp->status.line[line].off],sl,YES);  }
 return RET_YES;
 }




 B aaJsonParserKeyFind                 (H handle,HP line,H from,Z depth,VP val,VP fmt,...)
 {
 B ret;
 _aa_jsonobject*jsonp;
 va_list argptr;
 B str[_4K];
 B txt[_4K];
 H sl,l;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.json_system.object_id,handle,(VP)&jsonp,NULL))!=RET_YES) { return ret; }
 if(val) { aaStringNull(val); }
 if(jsonp->status.decode_success!=YES) { return RET_NOTREADY; }
 if(line) { *line=0xffffffff; }
 aaFmt(fmt,argptr,str);
 aaStringLen(str,&sl);
 if(sl==0) { return RET_BADPARM; }
 if(from>=jsonp->status.lines) { return RET_BOUNDS; }
 for(l=from;l<jsonp->status.lines;l++)
  {
  if(jsonp->status.line[l].type!=JSON_TYPE_KEY) { continue; }
  if(depth!=-1&&jsonp->status.line[l].depth!=depth) { continue; }
  aaStringNCopy(txt,&jsonp->status.mem[jsonp->status.line[l].off],jsonp->status.line[l].len,YES);
  if(aaStringCompare(str,txt,0)!=YES) { continue; }
  if(line) { *line=l; }
  if(val)  { aaStringNCopy(val,&jsonp->status.mem[jsonp->status.line[l+1].off],jsonp->status.line[l+1].len,YES);   }
  return RET_YES;
  }
 return RET_NOTFOUND;
 }



 B aaJsonDumpLineGet                   (H handle,HP line,H maxchars,VP str)
 {
 B ret;
 _aa_jsonobject*jsonp;
 _jsonline jl;
 _jsonline jlb;
 B spc[_1K];
 B aok[_1K];
 H li,sl;
 BP bp;
 BP tmp=NULL_POINTR;
 BP bmp=NULL_POINTR;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.json_system.object_id,handle,(VP)&jsonp,NULL))!=RET_YES) { return ret; }
 if(str) { aaStringNull(str); }
 if(aa.is_ready!=YES)  {  return RET_NOTREADY; }
 if(jsonp->status.decode_success!=YES) { return RET_NOTREADY; }
 if((ret=aa_MemoryTemp((VP)&tmp,maxchars+_1K,aa_MEMORYTEMP_JsonDumpA))!=RET_YES) { return ret; }
 if((ret=aa_MemoryTemp((VP)&bmp,_1MEG,aa_MEMORYTEMP_JsonDumpB))!=RET_YES) { return ret; }
 if(line==NULL) { return RET_BADPARM; }
 li=*line;
 if(li>=jsonp->status.lines) { return RET_BOUNDS; }
 if((ret=aaJsonParserLineGet(handle,li,&jl,aok))!=RET_YES) { oops; }
 if(jl.depth<1) { aaStringNull(spc); }
 else           { aaStringFill(spc,jl.depth,32,YES); }
 if(jsonp->status.line[li].type==JSON_TYPE_KEY||jsonp->status.line[li].type==JSON_TYPE_STRING)
  {
  aaStringQuotify(aok,0,DQUOTE_CHAR);
  }
 if(jsonp->status.line[li].type==JSON_TYPE_KEY)
  {
  if(jsonp->status.line[li+1].type==JSON_TYPE_STRING||jsonp->status.line[li+1].type==JSON_TYPE_INT||
     jsonp->status.line[li+1].type==JSON_TYPE_FLOAT||jsonp->status.line[li+1].type==JSON_TYPE_FALSE||
     jsonp->status.line[li+1].type==JSON_TYPE_TRUE||jsonp->status.line[li+1].type==JSON_TYPE_NULL)
     {
     if((ret=aaJsonParserLineGet(handle,li+1,&jlb,bmp))!=RET_YES) { oops; }
     if(jl.depth!=jlb.depth) oof;
     if(jlb.type==JSON_TYPE_STRING) { aaStringQuotify(bmp,0,DQUOTE_CHAR); }
     aaStringCopyf(tmp,"%5i/%-5i %-3i %-5i %i,%i,%i %s %s : %s",li,jsonp->status.lines,jl.type,jl.depth,jl.is_keyobj,jl.is_keyarray,jl.is_keyvalue,spc,aok,bmp);
     tmp[maxchars]=NULL_CHAR;
     aaStringLen(tmp,&sl);
     if(str) { aaMemoryCopy(str,sl+1,tmp); }
     if(str) { bp=(BP)str; bp[sl+1]=NULL_CHAR; }
     li+=2;
     *line=li;
     return RET_YES;
     }
  }
 aaStringCopyf(tmp,"%5i/%-5i %-3i %-5i %i,%i,%i %s %s",li,jsonp->status.lines,jl.type,jl.depth,jl.is_keyobj,jl.is_keyarray,jl.is_keyvalue,spc,aok);
 tmp[maxchars]=NULL_CHAR;
 aaStringLen(tmp,&sl);
 if(str) { aaMemoryCopy(str,sl+1,tmp); }
 if(str) { bp=(BP)str; bp[sl+1]=NULL_CHAR; }
 li++;
 *line=li;
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/




 B aa_HtmlParserProcess                (_htmlparser*htmlparser)
 {
 B ret;
 B out[_32K];
 B cmd[_32K];
 H pos,flag;
 H posx[5];
 H cando,sl;
 _htmlrow row;
 N which;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(htmlparser,aaHtmlParserNew);
 if(htmlparser->tidy.bytes==0)  {  if((ret=aaMemoryUnitAllocate(&htmlparser->tidy,240000))!=YES) { oops; }   aaMemoryNameSet(htmlparser->tidy.mem,"bottidymem"); }
 if(htmlparser->row.bytes==0)   {  if((ret=aaMemoryUnitAllocate(&htmlparser->row,sizeof(_htmlrow)*5000))!=YES)  { oops; }   aaMemoryNameSet(htmlparser->row.mem,"botrowmem"); }

 sl=htmlparser->chars;
 aaStringNCopy(out,&htmlparser->html.mem[htmlparser->start],sl,YES);

 while(1)
  {
  flag=0;
  while(1) {   if(aaStringRemoveMultipleSpaces(out,0,NO)!=YES)        { break; } flag=1;  }
  while(1) {   if(aaStringFirstCharNonVisibleRemove(out,0)!=YES)      { break; } flag=1;  }
  while(1) {   if(aaStringLastCharNonVisibleRemove(out,0)!=YES)       { break; } flag=1;  }
  while(1) {   if(aaStringFindFirstIString(out,0,"\r\n",2,&pos)!=YES) { break; } flag=1;  out[pos+0]=SPACE_CHAR;  out[pos+1]=SPACE_CHAR;   }
  if(htmlparser->stage==200||htmlparser->stage==300)
   {
   while(1) {   if(aaStringFindFirstIString(out,0," />",3,&pos)!=YES) { break; } flag=1; aaStringDeleteChars(out,0,pos+0,1);   }
   while(1) {   if(aaStringFindFirstIString(out,0," >",2,&pos)!=YES)  { break; } flag=1; aaStringDeleteChars(out,0,pos+0,1);    }
   while(1) {   if(aaStringFindFirstIString(out,0," =",2,&pos)!=YES)  { break; } flag=1; aaStringDeleteChars(out,0,pos+0,1);    }
   while(1) {   if(aaStringFindFirstIString(out,0,"= ",2,&pos)!=YES)  { break; } flag=1; aaStringDeleteChars(out,0,pos+1,1);    }
   }
  if(flag==0) break;
  }


 flag=0;
 while(1)
  {
  if(htmlparser->stage!=200) { break; }
  flag=HTML_ROW_FLAG_OPEN;
  if(aaStringNISolidCompare(out,"<!",2,0)==YES)                    {   flag=HTML_ROW_FLAG_DOC;   break;  }
  if(aaStringNISolidCompare(out,"</",2,0)==YES)                    {   flag=HTML_ROW_FLAG_CLOSE;   break;  }
  if((ret=aaStringFindCharVisible(out,0,&posx[0],YES,1,NO))!=YES)  {   break;            }
  if(aaStringNISolidCompare(&out[posx[0]],"/>",2,0)==YES)          {   flag=HTML_ROW_FLAG_SELF;   break;  }
  break;
  }

 aaStringLen(out,&sl);
 if(htmlparser->stage==200)  {  aaStringReplaceChar(out,sl,SQUOTE_CHAR,DQUOTE_CHAR);  }

 cando=htmlparser->row.bytes-htmlparser->row.used;
 cando=cando/sizeof(_htmlrow);
 if(cando<100)      {  if((ret=aaMemoryUnitReAllocate(&htmlparser->row,htmlparser->row.bytes+(1000*sizeof(_htmlrow))))!=YES) { oops; }  }
 cando=htmlparser->tidy.bytes-htmlparser->tidy.used;
 if((sl+_1K)>cando) {  if((ret=aaMemoryUnitReAllocate(&htmlparser->tidy,htmlparser->tidy.bytes+sl+_64K))!=YES) { oops; }  }

 aaMemoryFill(&row,sizeof(_htmlrow),0);
 row.num=htmlparser->row_count;
 row.start=htmlparser->tidy.used;
 row.chars=sl;
 switch(htmlparser->stage)
  {
  case 200: row.type=HTML_ROW_TYPE_HTML; break;
  case 220: row.type=HTML_ROW_TYPE_COMMENT; flag=HTML_ROW_FLAG_COMMENT; break;
  case 250: row.type=HTML_ROW_TYPE_TEXT;    flag=HTML_ROW_FLAG_TEXT;    break;
  case 300: row.type=HTML_ROW_TYPE_JS;      flag=HTML_ROW_FLAG_JS;      break;
  case 350: row.type=HTML_ROW_TYPE_CSS;     flag=HTML_ROW_FLAG_CSS;     break;
  default: oof; break;
  }

 if(row.type==HTML_ROW_TYPE_HTML)
  {
  if(flag==HTML_ROW_FLAG_CLOSE)
   {
   if((ret=aaStringFindCharVisible(out,0,&posx[2],YES,2,YES))!=YES)  { oops; }
   if((ret=aaStringFindCharList(&out[posx[2]],0,&posx[3]," >",YES,0,YES))!=YES)  { oops; }
   aaStringNCopy(cmd,&out[posx[2]],(posx[3]),YES);
   aaStringIsIString(cmd,&which,"input","img","meta","br","hr","link",NULL);
   if(which!=-1)
    {
    return RET_YES;
    }
   }
  }

 if(row.type==HTML_ROW_TYPE_HTML)
  {
  if(flag==HTML_ROW_FLAG_OPEN)
   {
   if((ret=aaStringFindCharVisible(out,0,&posx[2],YES,1,YES))!=YES)  { oops; }
   if((ret=aaStringFindCharList(&out[posx[2]],0,&posx[3]," >",YES,0,YES))!=YES)  { oops; }
   aaStringNCopy(cmd,&out[posx[2]],(posx[3]),YES);
   aaStringIsIString(cmd,&which,"input","img","meta","br","hr","link",NULL);
   if(which!=-1)
    {
    if((ret=aaStringFindCharVisible(out,0,&posx[4],YES,1,NO))!=YES)  { oops; }
    out[posx[4]+1]='/';
    out[posx[4]+2]='>';
    out[posx[4]+3]=NULL_CHAR;
    row.chars+=1;
    sl=row.chars;
    flag=HTML_ROW_FLAG_SELF;
    }
   }
  }

 row.flag=flag;
 aaMemoryCopy(&htmlparser->row.mem[htmlparser->row.used],sizeof(_htmlrow),&row);
 htmlparser->row.used+=sizeof(_htmlrow);
 aaMemoryCopy(&htmlparser->tidy.mem[row.start],sl+1,out);
 htmlparser->tidy.used+=(sl+2);
 htmlparser->row_count=htmlparser->row.used/sizeof(_htmlrow);
 if(aaAboutEvery(50))
  {
//  appLogf("%i %i %i %i",htmlparser->row_count,htmlparser->row.used,htmlparser->tidy.used,htmlparser->html.used);
  }
 return RET_YES;
 }





/*-----------------------------------------------------------------------*/



 B aaHtmlParserNew                     (_htmlparser*htmlparser)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objInit(htmlparser,aaHtmlParserNew);
 return RET_YES;
 }





 B aaHtmlParserDelete                  (_htmlparser*htmlparser)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(htmlparser,aaHtmlParserNew);
 if(htmlparser->html.bytes)  { aaMemoryUnitRelease(&htmlparser->html); }
 if(htmlparser->tidy.bytes)  { aaMemoryUnitRelease(&htmlparser->tidy); }
 if(htmlparser->row.bytes)   { aaMemoryUnitRelease(&htmlparser->row); }
 objClear(htmlparser);
 return RET_YES;
 }





 B aaHtmlParserAppend                  (_htmlparser*htmlparser,H bytes,VP buf)
 {
 B ret;
 H have,used,left,want,add,i;
 BP hmem;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(htmlparser,aaHtmlParserNew);
 if(htmlparser->html.bytes==0)
  {
  if((ret=aaMemoryUnitAllocate(&htmlparser->html,240000))!=YES) { oops; }
  aaMemoryNameSet(htmlparser->html.mem,"htmlmem");
  }
 redo:
 have=htmlparser->html.bytes;
 used=htmlparser->html.used;
 left=have-used;
 want=bytes+_1K;
  add=have+(have/5)+want;
 hmem=(BP)htmlparser->html.mem;
 if(want>left)
  {
  if((ret=aaMemoryUnitReAllocate(&htmlparser->html,add))!=YES) { oops; }
  htmlparser->html.bytes=add;
  goto redo;
  }
 if(buf)
  {
  aaMemoryCopy(&hmem[used],bytes,buf);
  for(i=0;i<bytes;i++)
   {
   if(hmem[used+i]>13) { continue; }
   if(hmem[used+i]!=HTAB_CHAR&&hmem[used+i]!=CR_CHAR&&hmem[used+i]!=LF_CHAR) { continue;  }
   hmem[used+i]=SPACE_CHAR;
   //aaStringReplaceChar(&hmem[used],bytes,HTAB_CHAR,SPACE_CHAR);
   //aaStringReplaceChar(&hmem[used],bytes,CR_CHAR,SPACE_CHAR);
   //aaStringReplaceChar(&hmem[used],bytes,LF_CHAR,SPACE_CHAR);
   }
  }
 else
  {
  aaMemoryFill(&hmem[used],bytes,0);
  }
 used+=bytes;
 hmem[used]=NULL_CHAR;
 htmlparser->html.used=used;
 aaHtmlParserParse(htmlparser);
 return RET_YES;
 }







 B aaHtmlParserParse                   (_htmlparser*htmlparser)
 {
 B ret;
 H cando,need,coff;
 B hch,hiv;
 H posx[8];
 BP out;
 //B out[_32K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(htmlparser,aaHtmlParserNew);
 while(1)
  {
  cando=htmlparser->html.used-htmlparser->off;
  if(cando==0)   {  break; }
  hch=htmlparser->html.mem[htmlparser->off];
  hiv=aaCharIsVisible(hch);

  switch(htmlparser->stage)
   {
   case 0:
   htmlparser->stage=100;
   break;


   case 100: // grab first character
   if(htmlparser->in_quote!=NO) { oof; }
   htmlparser->chars=0;
   if(hiv==NO)  { htmlparser->off++; break; }
   htmlparser->start=htmlparser->off;
   htmlparser->off++;
   htmlparser->chars++;
   if(hch=='<') { htmlparser->stage=200;   }
   else         { htmlparser->stage=250;   }
   break;



   case 200: // grab html part
   htmlparser->off++;
   htmlparser->chars++;

   if(htmlparser->chars>=4)
    {
    if(aaStringNICompare(&htmlparser->html.mem[htmlparser->start],"<!--",4,0)==YES)
     {
     htmlparser->dash_count=0;
     htmlparser->dash_state=1;
     htmlparser->in_comment=YES;
     htmlparser->stage=220;
     break;
     }
    }

   if(htmlparser->in_quote!=NO)
    {
    if(hch!=htmlparser->in_quote) { break; }
    htmlparser->in_quote=NO;
    }
   else
    {
    if(hch==SQUOTE_CHAR||hch==DQUOTE_CHAR)
     {
     htmlparser->in_quote=hch;
     break;
     }
    }

   if(hch!='>')  { break; }

   //aaStringNCopy(out,&htmlparser->html.mem[htmlparser->start],htmlparser->chars,YES);
   out=(BP)&htmlparser->html.mem[htmlparser->start];

   aa_HtmlParserProcess(htmlparser);

   if(out[1]=='s'&&(out[2]=='c'||out[2]=='t'))
    {
    if(aaStringNISolidCompare(out,"<script",7,0)==YES)
     {
     if((ret=aaStringFindCharVisible(out,htmlparser->chars,&posx[0],YES,1,NO))!=YES) { oops; }
     if(aaStringNISolidCompare(&out[posx[0]],"/>",2,0)!=YES)
      {
      htmlparser->start=htmlparser->off;
      htmlparser->chars=0;
      htmlparser->cloff=0;
      htmlparser->stage=300;
      break;
      }
     }
    if(aaStringNISolidCompare(out,"<style",6,0)==YES)
     {
     if((ret=aaStringFindCharVisible(out,htmlparser->chars,&posx[0],YES,1,NO))!=YES) { oops; }
     if(aaStringNISolidCompare(&out[posx[0]],"/>",2,0)!=YES)
      {
      htmlparser->start=htmlparser->off;
      htmlparser->chars=0;
      htmlparser->cloff=0;
      htmlparser->stage=350;
      break;
      }
     }
    }
   htmlparser->stage=100; // back to first character processor
   break;


   case 220: // grab comment
   if(htmlparser->dash_state==0)
    {
    if(hch=='>')
     {
     htmlparser->off++;
     htmlparser->chars++;
     aa_HtmlParserProcess(htmlparser);
     htmlparser->in_comment=NO;
     htmlparser->dash_state=0;
     htmlparser->dash_count=0;
     htmlparser->stage=100;
     break;
     }
    }
   if(hch!='-')
    {
    htmlparser->off++;
    htmlparser->chars++;
    htmlparser->dash_count=0;
    }
   else
    {
    htmlparser->off++;
    htmlparser->chars++;
    htmlparser->dash_count++;
    if((htmlparser->dash_count%2)==0)  { htmlparser->dash_state^=1;   }
    }
   break;





   case 250: // grab text part
   if(hch=='<')
    {
    aa_HtmlParserProcess(htmlparser);
    htmlparser->stage=100; // back to first character processor
    break;
    }
   htmlparser->off++;
   htmlparser->chars++;
   break;






   case 300: // grab script part
   case 350: // grab style part
   if(htmlparser->chars==0&&hiv==NO) {  htmlparser->off++;   break;        }
   if(htmlparser->chars==0)          {  htmlparser->start=htmlparser->off; }
   //if(hch!='>')                      {  htmlparser->off++;  htmlparser->chars++;    break;    }

   if(htmlparser->stage==300) { need=9; } else
   if(htmlparser->stage==350) { need=8; }

   coff=htmlparser->start+htmlparser->cloff;
   if(htmlparser->chars>=(need+htmlparser->cloff))
    {
    if(htmlparser->html.mem[coff]=='<')
     {
     //aaStringNCopy(out,&htmlparser->html.mem[coff],(htmlparser->chars-htmlparser->cloff)+0,YES);
     out=(BP)&htmlparser->html.mem[coff];
     if(htmlparser->stage==300) { ret=aaStringNICompare(out,"</script>",need,0); } else
     if(htmlparser->stage==350) { ret=aaStringNICompare(out,"</style>",need,0);  } else { oof; }
     if(ret==RET_YES)
      {
      htmlparser->chars=htmlparser->cloff;
      if(htmlparser->chars!=0)  {   aa_HtmlParserProcess(htmlparser);       }
      htmlparser->off=htmlparser->start+htmlparser->cloff;
      htmlparser->stage=100;
      break;
      }
     }
    htmlparser->cloff++;
    }

   htmlparser->off++;
   htmlparser->chars++;
   break;

   }
  }

 return RET_YES;
 }












 B aaHtmlParserRead                    (_htmlparser*htmlparser,H index,_htmlrow*htmlrow,_htmlarg*htmlarg,PP ptr)
 {
 _htmlrow gm;
 H pos,pot,len,s,e,sl;
 BP str;
 //B str[_32K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(htmlparser,aaHtmlParserNew);
 if(ptr) {  *ptr=NULL;  }
 if(htmlarg)
  {
  htmlarg->parm=0;
  htmlarg->tag[0]=htmlarg->id[0]=htmlarg->cls[0]=htmlarg->src[0]=htmlarg->href[0]=htmlarg->content[0]=htmlarg->name[0]=htmlarg->value[0]=NULL_CHAR;
  }
 aaHtmlParserParse(htmlparser);

 if(index>=htmlparser->row_count)      { return RET_BOUNDS;    }
 aaMemoryCopy(&gm,sizeof(_htmlrow),&htmlparser->row.mem[index*sizeof(_htmlrow)]);
 if(htmlrow) { aaMemoryCopy(htmlrow,sizeof(_htmlrow),&gm); }

 if(gm.type==HTML_ROW_TYPE_HTML&&htmlarg)
  {
  //aaStringNCopy(str,&htmlparser->tidy.mem[gm.start],gm.chars,YES);
  str=(BP)&htmlparser->tidy.mem[gm.start];

  pos=0;
  len=0;
  while(1)
   {
   if(str[pos]==0)   { break; }
   if(str[pos]=='>') { break; }
   if(str[pos]=='<') { pos++; continue; }
   if(str[pos]=='!') { pos++; continue; }
   if(str[pos]=='/') { pos++; continue; }
   if(len==0&&aaCharIsVisible(str[pos])!=YES) { pos++; continue; }
   else
   if(len!=0&&aaCharIsVisible(str[pos])!=YES) { break; }
   htmlarg->tag[len]=str[pos];
   len++;
   htmlarg->tag[len]=NULL_CHAR;
   pos++;
   }
  if(htmlarg->tag[0]!=NULL_CHAR)
   {
   htmlarg->parm|=HTML_ARG_PARM_TAG;
   }


  while(1)
   {
   pos=0;             if(aaStringFindFirstIString(&str[pos],0," id=",4,&pot)!=YES)      { break; }
   //pos+=pot+4;        if(aaStringFindFirstIString(&str[pos],0,"\"",1,&pot)!=YES)        { break; }
   pos+=pot+4;        if(aaStringFindChar(&str[pos],0,&pot,DQUOTE_CHAR,YES,0,YES)!=YES) { break; }
   //pos+=pot+1; s=pos; if(aaStringFindFirstIString(&str[pos],0,"\"",1,&pot)!=YES)        { break; }
   pos+=pot+1; s=pos; if(aaStringFindChar(&str[pos],0,&pot,DQUOTE_CHAR,YES,0,YES)!=YES) { break; }
   pos+=pot+1; e=pos-1;
   sl=e-s;
   if(sl>=sizeof(htmlarg->id)) { aaNote(0,"a sl=%i max=%i",sl,sizeof(htmlarg->id)); }
   aaStringNCopy(htmlarg->id,&str[s],sl,YES);
   htmlarg->parm|=HTML_ARG_PARM_ID;
   break;
   }
  while(1)
   {
   pos=0;             if(aaStringFindFirstIString(&str[pos],0," class=",7,&pot)!=YES)   { break; }
   //pos+=pot+7;        if(aaStringFindFirstIString(&str[pos],0,"\"",1,&pot)!=YES)        { break; }
   pos+=pot+7;        if(aaStringFindChar(&str[pos],0,&pot,DQUOTE_CHAR,YES,0,YES)!=YES) { break; }
   //pos+=pot+1; s=pos; if(aaStringFindFirstIString(&str[pos],0,"\"",1,&pot)!=YES)        { break; }
   pos+=pot+1; s=pos; if(aaStringFindChar(&str[pos],0,&pot,DQUOTE_CHAR,YES,0,YES)!=YES) { break; }
   pos+=pot+1; e=pos-1;
   sl=e-s;
   if(sl>=sizeof(htmlarg->cls)) { aaNote(0,"b sl=%i max=%i",sl,sizeof(htmlarg->cls)); }
   aaStringNCopy(htmlarg->cls,&str[s],sl,YES);
   htmlarg->parm|=HTML_ARG_PARM_CLASS;
   break;
   }
  while(1)
   {
   pos=0;             if(aaStringFindFirstIString(&str[pos],0," src=",5,&pot)!=YES)     { break; }
   //pos+=pot+5;        if(aaStringFindFirstIString(&str[pos],0,"\"",1,&pot)!=YES)        { break; }
   pos+=pot+5;        if(aaStringFindChar(&str[pos],0,&pot,DQUOTE_CHAR,YES,0,YES)!=YES) { break; }
   //pos+=pot+1; s=pos; if(aaStringFindFirstIString(&str[pos],0,"\"",1,&pot)!=YES)        { break; }
   pos+=pot+1; s=pos; if(aaStringFindChar(&str[pos],0,&pot,DQUOTE_CHAR,YES,0,YES)!=YES) { break; }
   pos+=pot+1; e=pos-1;
   sl=e-s;
   if(sl>=sizeof(htmlarg->src)) { aaNote(0,"c sl=%i max=%i",sl,sizeof(htmlarg->src)); }
   aaStringNCopy(htmlarg->src,&str[s],sl,YES);
   htmlarg->parm|=HTML_ARG_PARM_SRC;
   break;
   }
  while(1)
   {
   pos=0;             if(aaStringFindFirstIString(&str[pos],0," href=",6,&pot)!=YES)    { break; }
   //pos+=pot+6;        if(aaStringFindFirstIString(&str[pos],0,"\"",1,&pot)!=YES)        { break; }
   pos+=pot+6;        if(aaStringFindChar(&str[pos],0,&pot,DQUOTE_CHAR,YES,0,YES)!=YES) { break; }
   //pos+=pot+1; s=pos; if(aaStringFindFirstIString(&str[pos],0,"\"",1,&pot)!=YES)        { break; }
   pos+=pot+1; s=pos; if(aaStringFindChar(&str[pos],0,&pot,DQUOTE_CHAR,YES,0,YES)!=YES) { break; }
   pos+=pot+1; e=pos-1;
   sl=e-s;
   if(sl>=sizeof(htmlarg->href)) { aaNote(0,"d sl=%i max=%i",sl,sizeof(htmlarg->href)); }
   aaStringNCopy(htmlarg->href,&str[s],sl,YES);
   htmlarg->parm|=HTML_ARG_PARM_HREF;
   break;
   }
  while(1)
   {
   pos=0;             if(aaStringFindFirstIString(&str[pos],0," style=",7,&pot)!=YES)   { break; }
   //pos+=pot+6;        if(aaStringFindFirstIString(&str[pos],0,"\"",1,&pot)!=YES)        { break; }
   pos+=pot+6;        if(aaStringFindChar(&str[pos],0,&pot,DQUOTE_CHAR,YES,0,YES)!=YES) { break; }
   //pos+=pot+1; s=pos; if(aaStringFindFirstIString(&str[pos],0,"\"",1,&pot)!=YES)        { break; }
   pos+=pot+1; s=pos; if(aaStringFindChar(&str[pos],0,&pot,DQUOTE_CHAR,YES,0,YES)!=YES) { break; }
   pos+=pot+1; e=pos-1;
   sl=e-s;
   if(sl>=sizeof(htmlarg->style)) { aaNote(0,"e sl=%i max=%i",sl,sizeof(htmlarg->style)); }
   aaStringNCopy(htmlarg->style,&str[s],sl,YES);
   htmlarg->parm|=HTML_ARG_PARM_STYLE;
   break;
   }
  while(1)
   {
   pos=0;             if(aaStringFindFirstIString(&str[pos],0," content=",9,&pot)!=YES)   { break; }
   pos+=pot+8;        if(aaStringFindChar(&str[pos],0,&pot,DQUOTE_CHAR,YES,0,YES)!=YES) { break; }
   //pos+=pot+1; s=pos; if(aaStringFindFirstIString(&str[pos],0,"\"",1,&pot)!=YES)        { break; }
   pos+=pot+1; s=pos; if(aaStringFindChar(&str[pos],0,&pot,DQUOTE_CHAR,YES,0,YES)!=YES) { break; }
   pos+=pot+1; e=pos-1;
   sl=e-s;
   if(sl>=sizeof(htmlarg->content)) { aaNote(0,"e sl=%i max=%i",sl,sizeof(htmlarg->content)); }
   aaStringNCopy(htmlarg->content,&str[s],sl,YES);
   htmlarg->parm|=HTML_ARG_PARM_CONTENT;
   break;
   }
  while(1)
   {
   pos=0;             if(aaStringFindFirstIString(&str[pos],0," name=",6,&pot)!=YES)   { break; }
   pos+=pot+5;        if(aaStringFindChar(&str[pos],0,&pot,DQUOTE_CHAR,YES,0,YES)!=YES) { break; }
   //pos+=pot+1; s=pos; if(aaStringFindFirstIString(&str[pos],0,"\"",1,&pot)!=YES)        { break; }
   pos+=pot+1; s=pos; if(aaStringFindChar(&str[pos],0,&pot,DQUOTE_CHAR,YES,0,YES)!=YES) { break; }
   pos+=pot+1; e=pos-1;
   sl=e-s;
   if(sl>=sizeof(htmlarg->name)) { aaNote(0,"e sl=%i max=%i",sl,sizeof(htmlarg->name)); }
   aaStringNCopy(htmlarg->name,&str[s],sl,YES);
   htmlarg->parm|=HTML_ARG_PARM_NAME;
   break;
   }

  while(1)
   {
   pos=0;             if(aaStringFindFirstIString(&str[pos],0," value=",7,&pot)!=YES)   { break; }
   pos+=pot+6;        if(aaStringFindChar(&str[pos],0,&pot,DQUOTE_CHAR,YES,0,YES)!=YES) { break; }
   //pos+=pot+1; s=pos; if(aaStringFindFirstIString(&str[pos],0,"\"",1,&pot)!=YES)        { break; }
   pos+=pot+1; s=pos; if(aaStringFindChar(&str[pos],0,&pot,DQUOTE_CHAR,YES,0,YES)!=YES) { break; }
   pos+=pot+1; e=pos-1;
   sl=e-s;
   if(sl>=sizeof(htmlarg->value)) { aaNote(0,"e sl=%i max=%i",sl,sizeof(htmlarg->value)); }
   aaStringNCopy(htmlarg->value,&str[s],sl,YES);
   htmlarg->parm|=HTML_ARG_PARM_VALUE;
   break;
   }

  }
 if(ptr)
  {
  *ptr=&htmlparser->tidy.mem[gm.start];
  }
 return RET_YES;
 }







 B aaHtmlParserFind                    (_htmlparser*htmlparser,H index,_htmlrow*htmlrow,_htmlarg*htmlarg,PP ptr,VP fmt,...)
 {
 B ret;
 H i;
 _htmlrow hr;
 _htmlarg ha;
 BP hp;
 _htmlrow*rp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(htmlparser,aaHtmlParserNew);
 aaVargsf4K(fmt);
 if(index>=htmlparser->row_count)      { return RET_BOUNDS;    }
 i=index;
 while(1)
  {
  if(i>=htmlparser->row_count) { break; }
  rp=(_htmlrow*)&htmlparser->row.mem[i*sizeof(_htmlrow)];
  if(rp->type!=HTML_ROW_TYPE_HTML) { i++; continue; }
  if(rp->flag!=HTML_ROW_FLAG_OPEN) { i++; continue; }
  if((ret=aaHtmlParserRead(htmlparser,i,&hr,&ha,(VP)&hp))!=YES) { oops; }
  if(aaStringICompare(ha.id,str4k.buf,0)!=YES) { i++; continue; }
  if(htmlrow) { aaMemoryCopy(htmlrow,sizeof(_htmlrow),&hr); }
  if(htmlarg) { aaMemoryCopy(htmlarg,sizeof(_htmlarg),&ha); }
  if(ptr)     { *ptr=hp;  }
  return RET_YES;
  }
 return RET_NOTFOUND;
 }










 B aaHtmlParserReadEx                  (_htmlparser*htmlparser,H index,_htmlrorg*htmlrorg)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(htmlparser,aaHtmlParserNew);
 aaMissingParm(htmlrorg);
 htmlrorg->which=-2;
 ret=aaHtmlParserRead(htmlparser,index,&htmlrorg->row,&htmlrorg->arg,(VP)&htmlrorg->ptr);
 if(ret!=YES) { oops; }
 if(htmlrorg->row.type==HTML_ROW_TYPE_HTML)
  {
  htmlrorg->which=-1;                               //     0    1     2   3      4     5    6       7        8
  aaStringIsIString(htmlrorg->arg.tag,&htmlrorg->which,"table","tr","td","span","div","a","input","tbody","thead",NULL);
  }
 return RET_YES;
 }







 B aaHtmlParserEzy                     (_htmlparser*htmlparser,H bytes,VP mem)
 {
 B ret;
 Q todo,len,done;
 B block[_8K];
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(htmlparser->magic==aaHPP(aaHtmlParserNew)) { oof; }
 if((ret=aaHtmlParserNew(htmlparser))!=YES) { oops; }
 todo=(Q)bytes;
 bp=(BP)mem;
 done=0;
 while(1)
  {
  len=todo-done;
  if(len==0) { break; }
  len=aaNumRoof(len,sizeof(block));
  aaMemoryCopy(block,(H)len,&bp[done]);
  if(aaHtmlParserAppend(htmlparser,(H)len,block)!=YES) { oof; }
  if((ret=aaHtmlParserParse(htmlparser))!=RET_YES) { oops; }
  done+=len;
  }
 if((ret=aaHtmlParserParse(htmlparser))!=RET_YES) { oops; }
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/



 B aaClipBoardTextWritef               (B global,VP fmt,...)
 {
 B ret;
 H sl;
 HGLOBAL h;
 CP string;
 va_list argptr;
 B txt[_16K+_8K];
 BP tmp=NULL_POINTR;
 HWND wnd;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaCast(tmp,BP,txt);
 if(aa.is_ready==YES)
  {
  if((ret=aa_MemoryTemp((VP)&tmp,_128K,aa_MEMORYTEMP_ClipWritef))!=RET_YES) { return ret; }
  }
 aaFmt(fmt,argptr,tmp);
 if((ret=aaStringLen(tmp,&sl))!=RET_YES) { return ret; }
 tmp[sl]=NULL_CHAR;
 if((h=GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT,sl+32))==NULL) { return RET_NOMEMORY; }
 if((string=GlobalLock(h))==NULL) {  GlobalFree(h);  return RET_FAILED; }
 aaStringCopy(string,tmp);
 if(GlobalUnlock(h)==TRUE) {  GlobalFree(h);  return RET_FAILED; }
 if(global)  {  wnd=GetDesktopWindow();  } else { wnd=NULL; }
 if(OpenClipboard(wnd)==FALSE)  {  GlobalFree(h);  return RET_FAILED; }
 if(EmptyClipboard()==FALSE)  {  CloseClipboard();  GlobalFree(h);  return RET_FAILED; }
 if(SetClipboardData(CF_OEMTEXT,h)==NULL)  {  GlobalFree(h);  CloseClipboard();  return RET_FAILED; }
 if(CloseClipboard()==FALSE) {  GlobalFree(h);  return RET_FAILED; }
 return RET_YES;
 }



 B aaClipBoardTextWrite                (B global,H chars,VP text)
 {
 HGLOBAL h;
 CP string;
 HWND wnd;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(text==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(text,&chars); }
 global&=1;
 if(chars==0) { return(aaClipBoardDiscard(global)); }
 if((h=GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT,chars+32))==NULL) { return RET_NOMEMORY; }
 if((string=GlobalLock(h))==NULL) {  GlobalFree(h);  return RET_FAILED; }
 aaMemoryCopy(string,chars,text);
 if(GlobalUnlock(h)==TRUE) {  GlobalFree(h);  return RET_FAILED; }
 if(global)  {  wnd=GetDesktopWindow();  } else { wnd=NULL; }
 if(OpenClipboard(wnd)==FALSE)  {  GlobalFree(h);  return RET_FAILED; }
 if(EmptyClipboard()==FALSE)  {  CloseClipboard();  GlobalFree(h);  return RET_FAILED; }
 if(SetClipboardData(CF_OEMTEXT,h)==NULL)  {  GlobalFree(h);  CloseClipboard();  return RET_FAILED; }
 if(CloseClipboard()==FALSE) {  GlobalFree(h);  return RET_FAILED; }
 return RET_YES;
 }




 B aaClipBoardTextRead                 (B global,HP chars,H maxchars,VP text)
 {
 HGLOBAL hh;
 CP string;
 H sl;
 HWND wnd;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(chars!=NULL) { *chars=0; }
 if(maxchars!=0&&text==NULL) { return RET_BADPARM; }
 if(text!=NULL)  { aaStringNull(text); }
 if(global)  {  wnd=GetDesktopWindow();  } else { wnd=NULL; }
 if(OpenClipboard(wnd)==0) { return RET_NOTREADY; }
 if((hh=GetClipboardData(CF_TEXT))==NULL) { CloseClipboard(); return RET_NOTREADY; }
 if((string=GlobalLock(hh))==NULL)  { oow; CloseClipboard(); return RET_FAILED; }
 aaStringLen(string,&sl);
 if(chars)                   { *chars=sl; }
 if(sl>maxchars)              { sl=maxchars; }
 if(sl!=0&&text!=NULL)        { aaStringNCopy(text,string,sl,YES);  }
 if(GlobalUnlock(hh)==FALSE)  { oow; CloseClipboard(); return RET_FAILED; }
 if(CloseClipboard()==FALSE)  { return RET_NOTREADY; }
 return RET_YES;
 }




 B aaClipBoardDiscard                  (B global)
 {
 BOOL x;
 HWND wnd;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(global)  {  wnd=GetDesktopWindow();  } else { wnd=NULL; }
 if((x=OpenClipboard(wnd))==FALSE) {  return RET_FAILED; }
 x=EmptyClipboard();
 CloseClipboard();
 if(x==FALSE) {  return RET_FAILED; }
 return RET_YES;
 }





 B aaClipBoardTextPaste                (B global,VP fmt,...)
 {
 B txt[_1K];
 va_list argptr;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,txt);
 aaClipBoardTextWritef(global,"%s",txt);
 aaInputKeySimulate(VK_CONTROL,NO,YES);
 aaInputKeySimulate('V',NO,YES);
 aaSleep(30);
 aaInputKeySimulate('V',NO,NO);
 aaInputKeySimulate(VK_CONTROL,NO,NO);
 aaInputKeySimulate(VK_RETURN,NO,YES);
 aaSleep(30);
 aaInputKeySimulate(VK_RETURN,NO,NO);
 return RET_YES;
 }





 B aaClipBoardFileSet                  (B global,VP filename)
 {
 B ret;
 H sl,i,off;
 HGLOBAL h;
 BP string;
 B txt[_4K];
 BP bp;
 DROPFILES df;
 HWND wnd;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(filename==NULL) { return RET_BADPARM; }
 aaStringCopy(txt,filename);
 if((ret=aaStringLen(txt,&sl))!=RET_YES) { return ret; }
 if(sl==0) { return RET_BADPARM; }
 if((ret=aaFileInfoGet(txt,NULL,NULL,NULL,NULL,NULL))!=RET_YES) { return ret; }
 aaMemoryFill(&df,sizeof(df),0);
 df.pFiles=20;
 df.fWide=TRUE;
 if((h=GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT,sizeof(df)+((sl*2)+5)))==NULL) { return RET_NOMEMORY; }
 if((string=GlobalLock(h))==NULL) {  GlobalFree(h);  return RET_FAILED; }
 aaCast(bp,BP,string);
 aaMemoryCopy(bp,sizeof(df),&df);
 bp+=sizeof(df);
 off=0;
 for(i=0;i<sl;i++)
  {
  bp[off++]=txt[i];
  bp[off++]=0;
  }
 if(GlobalUnlock(h)==TRUE) {  GlobalFree(h);  return RET_FAILED; }
 if(global)  {  wnd=GetDesktopWindow();  } else { wnd=NULL; }
 if(OpenClipboard(wnd)==FALSE)  {  GlobalFree(h);  return RET_FAILED; }
 if(EmptyClipboard()==FALSE)  {  CloseClipboard();  GlobalFree(h);  return RET_FAILED; }
 if(SetClipboardData(CF_HDROP,h)==NULL)  {  GlobalFree(h);  CloseClipboard();  return RET_FAILED; }
 if(CloseClipboard()==FALSE) {  GlobalFree(h);  return RET_FAILED; }
 return RET_YES;
 }




 B aaClipBoardFileRead                 (B global,HP chars,H maxchars,VP text)
 {
 HGLOBAL hh;
 H sl;
 H count;
 B tmp[_2K];
 HWND wnd;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(chars!=NULL) { *chars=0; }
 if(maxchars!=0&&text==NULL) { return RET_BADPARM; }
 if(text!=NULL) { aaStringNull(text); }
 if(global)  {  wnd=GetDesktopWindow();  } else { wnd=NULL; }
 if(OpenClipboard(wnd)==FALSE) { return RET_FAILED; }
 if((hh=GetClipboardData(CF_HDROP))==NULL) {  CloseClipboard(); return RET_NOTREADY; }
 count=DragQueryFile(hh,-1,NULL,0);
 if(count==0) {  CloseClipboard(); return RET_NOTREADY; }
 if(DragQueryFile(hh,0,(CP)tmp,_1K)!=0)
  {
  aaStringLen(tmp,&sl);
  if(chars) { *chars=sl; }
  if(sl>maxchars) { sl=maxchars; }
  if(sl!=0)  {  aaStringNCopy(text,tmp,sl,YES);  }
  }
 if(CloseClipboard()==FALSE)  {  return RET_FAILED; }
 return RET_YES;
 }





/*-----------------------------------------------------------------------*/



 B aaDesktopCreate                     (HP handle,VP fmt,...)
 {
 B ret;
 _aa_desktopobject*detp;
 va_list argptr;
 B txt[_2K];
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,txt);
 if(handle==NULL) { return RET_BADPARM; }
 *handle=0;
 aaStringLen(txt,&sl);
 if(sl<4||sl>63) { return RET_BADPARM; }
 if((ret=aa_ObjectCreate(aa.desktop_system.object_id,handle,(VP)&detp))!=RET_YES) { oops; return ret; }
 detp->self_handle=*handle;
 aaStringCopy(detp->status.name,txt);
 detp->thread_id=GetCurrentThreadId();
 detp->original_handle=GetThreadDesktop(detp->thread_id);
 detp->desk_handle=CreateDesktop((CP)txt,0,0,0,GENERIC_ALL,0);
 detp->status.tid=detp->thread_id;
 detp->status.initial_handle=detp->original_handle;
 detp->status.desktop_handle=detp->desk_handle;
 detp->status.is_active=NO;
 return RET_YES;
 }






 B aaDesktopDestroy                    (H handle)
 {
 B ret;
 _aa_desktopobject*detp;
 B isprot;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.desktop_system.object_id,handle,(VP)&detp,&isprot))!=RET_YES) { return ret; }
 if(isprot==YES) { return RET_FORBIDDEN; }
 aa_ObjectDestroy(aa.desktop_system.object_id,handle);
 return RET_YES;
 }





 B aaDesktopStatus                     (H handle,_desktopstatus*desktopstatus)
 {
 B ret;
 _aa_desktopobject*detp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.desktop_system.object_id,handle,(VP)&detp,NULL))!=RET_YES) { return ret; }
 if(desktopstatus)  {  aaMemoryCopy(desktopstatus,sizeof(_desktopstatus),&detp->status); }
 return RET_YES;
 }








 B aaDesktopSwitch                     (H handle,B state)
 {
 B ret;
 _aa_desktopobject*detp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.desktop_system.object_id,handle,(VP)&detp,NULL))!=RET_YES) { return ret; }
 if(state)
  {
  if(detp->status.is_active==NO)
   {
   SwitchDesktop(detp->desk_handle);
   detp->status.is_active=YES;
   }
  }
 else
  {
  if(detp->status.is_active==YES)
   {
   SwitchDesktop(detp->original_handle);
   detp->status.is_active=NO;
   }
  }
 return RET_YES;
 }





/*------------------------------------------------------------------------*/


/*
if incoming is EITHER, than it will create in either incoming or outgoing mode,
whatever is possible
*/


 B aaIpcCreate                         (HP handle,H bytes,VP name,...)
 {
 B ret;
 _aa_ipcobject*ipcp;
 B xname[_1K];
 _ipcramhdr ramhdr;
 _ipcramhdr*ramhdrptr;
 //H bytes;
 DWORD e;
 BP bp;
 _aa_objectinstanceheader*oih;
 Q v;
 B isroot;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaVargsf4K(name);
 if(aaStringIsNull(str4k.buf)!=NO) { return RET_BADPARM; }
 if(bytes==0) { isroot=0; }
 else         { isroot=1; }
 if(isroot)
  {
  if(bytes<4||bytes>_16MEG) { return RET_BOUNDS; }
  }
 if((ret=aa_ObjectCreate(aa.ipc_system.object_id,handle,(VP)&ipcp))!=RET_YES) { oops; return ret; }
 ipcp->self_handle=*handle;
 ipcp->object_handle=NULL;
 ipcp->mutex_handle=NULL;
 ipcp->page_memory=NULL;
 ipcp->status.is_exited=NO;
 aaStringCopy(xname,str4k.buf);
 aaStringCopyf(ipcp->status.name,"%s",str4k.buf);

 if(isroot)//||incoming==EITHER)
  {
  while(1)
   {
   //bytes=aa_IPCUSER_BYTES+sizeof(_ipcramhdr);
   if((ipcp->object_handle=CreateFileMapping((HANDLE)0xffffffff,NULL,PAGE_EXECUTE_READWRITE,0,bytes+sizeof(_ipcramhdr),(LPCTSTR)xname))==NULL) { ret=RET_FAILED; break; }
   e=GetLastError();
   if(e==ERROR_ALREADY_EXISTS) { ret=RET_EXISTS; break; }
   if(e!=0) { ret=RET_FAILED; break; }
   if((ipcp->page_memory=MapViewOfFile(ipcp->object_handle,FILE_MAP_ALL_ACCESS,0,0,bytes+sizeof(_ipcramhdr)))==NULL) { ret=RET_FAILED; break; }
   xname[0]+=(B)1; ipcp->mutex_handle=CreateMutex(NULL,TRUE,(LPCTSTR)xname);  xname[0]-=(B)1;
   e=GetLastError();
   if(ipcp->mutex_handle==NULL)  {   if(e==ERROR_ALREADY_EXISTS||e==ERROR_INVALID_HANDLE)  {oof; }    ret=RET_FAILED;    break;    }
   if(e!=0) {  ret=RET_FAILED; break; }
   aaCast(ramhdrptr,_ipcramhdr*,&ipcp->page_memory[0]);
   ramhdrptr->total_bytes=bytes+sizeof(_ipcramhdr);
   ramhdrptr->user_bytes=bytes;//ramhdrptr->total_bytes-sizeof(_ipcramhdr);
   ipcp->status.is_root=YES;
   ipcp->status.is_locked=YES;
   ret=RET_YES;
   break;
   }
  }
 //else
 if(isroot==NO)//||incoming==EITHER)
  {
  while(1)
   {
   //if(incoming==EITHER&&ipcp->status.is_locked==YES&&ret==RET_YES) { oof; break; }  // either mode worked, so skip
   ipcp->object_handle=OpenFileMapping(FILE_MAP_ALL_ACCESS,FALSE,(LPCTSTR)xname);
   e=GetLastError();

   if(ipcp->object_handle==NULL&&e==ERROR_FILE_NOT_FOUND) {  ret=RET_NOTFOUND; break; }
   if(ipcp->object_handle==NULL&&e!=ERROR_FILE_NOT_FOUND) {  ret=RET_FAILED; break; }
   //bytes=sizeof(_ipcramhdr);
   if((ipcp->page_memory=MapViewOfFile(ipcp->object_handle,FILE_MAP_ALL_ACCESS,0,0,sizeof(_ipcramhdr)))==NULL) { oof; ret=RET_FAILED;  break; }
   aaMemoryCopy(&ramhdr,sizeof(_ipcramhdr),ipcp->page_memory);
   bytes=ramhdr.user_bytes;
   if(UnmapViewOfFile(ipcp->page_memory)!=TRUE) { oof; }
   if(bytes<4||bytes>_16MEG) { oof; return RET_BOUNDS; }
   ipcp->page_memory=NULL;
   if((ipcp->page_memory=MapViewOfFile(ipcp->object_handle,FILE_MAP_ALL_ACCESS,0,0,bytes+sizeof(_ipcramhdr)))==NULL) { ret=RET_FAILED;  break; }
   xname[0]+=(B)1; ipcp->mutex_handle=OpenMutex(MUTEX_ALL_ACCESS,FALSE,(LPCTSTR)xname); xname[0]-=(B)1;
   e=GetLastError();
   if(ipcp->mutex_handle==NULL) { aaNote(0,"e=%i",e); ret=RET_FAILED; break; }
   ipcp->status.is_root=NO;
   ipcp->status.is_locked=NO;
   ret=RET_YES;
   break;
   }
  }
 if(ret!=YES)
  {
  if(ipcp->mutex_handle!=NULL)  { CloseHandle(ipcp->mutex_handle); ipcp->mutex_handle=NULL; }
  if(ipcp->page_memory!=NULL)   { if(UnmapViewOfFile(ipcp->page_memory)!=TRUE) { oof; } ipcp->page_memory=NULL; }
  if(ipcp->object_handle!=NULL) { CloseHandle(ipcp->object_handle); ipcp->object_handle=NULL; }
  aa_ObjectDestroy(aa.ipc_system.object_id,*handle);
  *handle=0;
  return ret;
  }
 aaCast(bp,BP,ipcp);
 bp-=sizeof(_aa_objectinstanceheader);
 aaCast(oih,_aa_objectinstanceheader*,bp);
 aaCast(ramhdrptr,_ipcramhdr*,&ipcp->page_memory[0]);
// aaQuadSet(&ipcp->status.session,oih->sesh.lo,aa.core_system.process_id);
 //v=((Q)aa.core_system.process_id<<32);
 v=(Q)aa.core_system.process_id<<32;//*42949672946;
 v=(v+(oih->sesh>>32));
 ipcp->status.session=v;//(aa.core_system.process_id<<32)+(H)(oih->sesh>>32);//session,oih->sesh; //ashot
 ipcp->status.bytes=ramhdrptr->user_bytes;
 //aa_ObjectHandleToIndex(aa.ipc_system.object_id,*handle,&ipcp->status.index);
 return RET_YES;
 }






#if 0

 B aaIpcSpawn                          (HP handle,_ipcstatus*ipcstatus,VP exefile,...)
 {
 B ret;
 H count;
 B exe[_1K];
 B tok[_1K];
 _sysinfo si;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMissingParm(handle);
 aaVargsf4K(exefile);
 *handle=0;
 if(str4k.buf[0]==NULL_CHAR)
  {
  if((ret=aaSysInfoGet(&si))!=YES) { oops; }
  aaStringCopyf(exe,"%s",si.process_file);
  }
 else
  {
  aaStringCopyf(exe,"%s",str4k.buf);
  }
 if((ret=aaProcessIsRunning(exe,&count))!=YES) { oops; }
 aaStringCopyf(tok,"%s",exe);
 aaStringReplaceChar(tok,0,BSLASH_CHAR,'$');
 aaStringReplaceChar(tok,0,FSLASH_CHAR,'$');
 aaStringReplaceChar(tok,0,'.','$');
 if(count==0)
  {
  oof;
  }
 else
 if(count==1)
  {
  if((ret=aaIpcCreate(handle,YES,_64K,tok))!=RET_YES) { oops; }
  //if((ret=aaProcessSpawn(exe,si.command_line,SW_SHOW,NULL,NULL))!=RET_YES) { oops; }
  if((ret=aaProcessSpawn(exe,NULL,SW_SHOW,NULL,NULL))!=RET_YES) { oops; }
  }
 else
 if(count>=2)
  {
  if((ret=aaIpcCreate(handle,NO,0,tok))!=RET_YES) { oops; }
  }
 if(ipcstatus)
  {
  aaIpcStatus(*handle,ipcstatus,0);
  }
 return RET_YES;
 }



#endif

 B aaIpcDestroy                        (H handle)
 {
 B ret;
 _aa_ipcobject*ipcp;
 B isprot;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.ipc_system.object_id,handle,(VP)&ipcp,&isprot))!=RET_YES) { return ret; }
 if(isprot) { return RET_FORBIDDEN; }
 if(UnmapViewOfFile(ipcp->page_memory)!=TRUE) { oof; }
 CloseHandle(ipcp->object_handle);
 aa_ObjectDestroy(aa.ipc_system.object_id,handle);
 return RET_YES;
 }





 B aaIpcStatus                         (H handle,_ipcstatus*ipcstatus,B state)
 {
 B ret;
 _aa_ipcobject*ipcp;
 DWORD res;
 _ipcramhdr*ramhdrptr;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if((ret=aa_ObjectCheck(aa.ipc_system.object_id,handle,(VP)&ipcp,NULL))!=RET_YES) { return ret; }
 aaCast(ramhdrptr,_ipcramhdr*,&ipcp->page_memory[0]);
 ipcp->status.hog_level=ramhdrptr->lock_deny_count;
 if(ipcstatus)
  {
  aaMemoryCopy(ipcstatus,sizeof(_ipcstatus),&ipcp->status);
  ipcstatus->ram=&ipcp->page_memory[sizeof(_ipcramhdr)];
  }

 if(state>aa_IPCSTATE_Both)   { return RET_BADPARM; }
 if(state==aa_IPCSTATE_None)  { return RET_YES;  }
 aaCast(ramhdrptr,_ipcramhdr*,&ipcp->page_memory[0]);


 // why would i do a lock + release at the same time ??  - im sure there was a reason
 if(aaBitGet(state,0)) // lock
  {
  if(ipcp->status.is_locked==YES) { return RET_YES; }
  if((res=WaitForSingleObject(ipcp->mutex_handle,0))==WAIT_FAILED) { oof; oow; oof; return RET_FAILED; }
  if(res==WAIT_TIMEOUT)
   {
   ramhdrptr->lock_deny_count++;
   ipcp->status.hog_level=ramhdrptr->lock_deny_count;
   if(ipcstatus)  { ipcstatus->hog_level=ipcp->status.hog_level; }
   return RET_DENIED;
   }
  if(res==WAIT_ABANDONED)
   {
   ipcp->status.is_locked=NO;
   ipcp->status.is_exited=YES;
   if(ipcstatus)  { aaMemoryCopy(ipcstatus,sizeof(_ipcstatus),&ipcp->status); }
   if(ipcstatus)  { ipcstatus->ram=&ipcp->page_memory[sizeof(_ipcramhdr)]; }
   }
  else
   {
   if(res!=WAIT_OBJECT_0)  { oof; oow; oof; }
   ipcp->status.is_locked=YES;
   ipcp->status.hog_level=ramhdrptr->lock_deny_count;
   if(ipcstatus)  { aaMemoryCopy(ipcstatus,sizeof(_ipcstatus),&ipcp->status); }
   if(ipcstatus)  { ipcstatus->ram=&ipcp->page_memory[sizeof(_ipcramhdr)]; }
   }
  }

 if(aaBitGet(state,1)) // release
  {
  if(ipcp->status.is_locked==NO)   {   return RET_YES;   }
  ramhdrptr->lock_deny_count=0;
  if(ReleaseMutex(ipcp->mutex_handle)==0) { oof; oow; oof; return RET_FAILED; }
  ipcp->status.is_locked=NO;
  ipcp->status.hog_level=ramhdrptr->lock_deny_count;
  if(ipcstatus)  { aaMemoryCopy(ipcstatus,sizeof(_ipcstatus),&ipcp->status); }
  if(ipcstatus)  { ipcstatus->ram=&ipcp->page_memory[sizeof(_ipcramhdr)]; }
  }
 return RET_YES;
 }




 B aaIpcWrite                          (H handle,_ipcstatus*ipcstatus,H offset,H bytes,VP data)
 {
 B ret;
 _aa_ipcobject*ipcp;
 _ipcstatus is;
// B was_locked;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.ipc_system.object_id,handle,(VP)&ipcp,NULL))!=RET_YES) { return ret; }

 /*
 if((ret=aaIpcStatus(handle,&is,aa_IPCSTATE_None))!=RET_YES)
  {
  if(ipcstatus) { aaMemoryCopy(ipcstatus,sizeof(_ipcstatus),&is); }
  return ret;
  }
 was_locked=is.is_locked;
 */
 if((ret=aaIpcStatus(handle,&is,aa_IPCSTATE_Lock))!=RET_YES)
  {
  if(ipcstatus) { aaMemoryCopy(ipcstatus,sizeof(_ipcstatus),&is); }
  return ret;
  }
 if(is.is_locked!=YES) { oof; }
 if(data==NULL) { aaMemoryFill(&is.ram[offset],bytes,0); }
 else           { aaMemoryCopy(&is.ram[offset],bytes,data); }
 /*
 if(!was_locked)
  {
  if((ret=aaIpcStatus(handle,&is,aa_IPCSTATE_Release))!=RET_YES) { oops; }
  if(is.is_locked!=NO)  { oof; }
  }
 else
  {
  if((ret=aaIpcStatus(handle,&is,aa_IPCSTATE_None))!=RET_YES) { oops; }
  }
  */
 if((ret=aaIpcStatus(handle,&is,aa_IPCSTATE_Release))!=RET_YES) { oops; }
 if(is.is_locked!=NO)  { oof; }
 if(ipcstatus) { aaMemoryCopy(ipcstatus,sizeof(_ipcstatus),&is); }
 return RET_YES;
 }





 B aaIpcWritef                         (H handle,_ipcstatus*ipcstatus,H offset,VP fmt,...)
 {
 B ret;
 _aa_ipcobject*ipcp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.ipc_system.object_id,handle,(VP)&ipcp,NULL))!=RET_YES) { return ret; }
 aaVargsf4K(fmt);
 return(aaIpcWrite(handle,ipcstatus,offset,str4k.len+1,str4k.buf));
 }



 B aaIpcRead                           (H handle,_ipcstatus*ipcstatus,H offset,H bytes,VP data)
 {
 B ret;
 _aa_ipcobject*ipcp;
 _ipcstatus is;
// B was_locked;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.ipc_system.object_id,handle,(VP)&ipcp,NULL))!=RET_YES) { return ret; }
 /*
 if((ret=aaIpcStatus(handle,&is,aa_IPCSTATE_None))!=RET_YES)
  {
  if(ipcstatus) { aaMemoryCopy(ipcstatus,sizeof(_ipcstatus),&is); }
  return ret;
  }
 was_locked=is.is_locked;
 */
 if((ret=aaIpcStatus(handle,&is,aa_IPCSTATE_Lock))!=RET_YES)
  {
  if(ipcstatus) { aaMemoryCopy(ipcstatus,sizeof(_ipcstatus),&is); }
  return ret;
  }
 if(is.is_locked!=YES) { oof; }
 aaMemoryCopy(data,bytes,&is.ram[offset]);
 /*
 if(!was_locked)
  {
  if((ret=aaIpcStatus(handle,&is,aa_IPCSTATE_Release))!=RET_YES) { oops; }
  if(is.is_locked!=NO)  { oof; }
  }
 else
  {
  if((ret=aaIpcStatus(handle,&is,aa_IPCSTATE_None))!=RET_YES) { oops; }
  }
  */
  if((ret=aaIpcStatus(handle,&is,aa_IPCSTATE_Release))!=RET_YES) { oops; }
  if(is.is_locked!=NO)  { oof; }



 if(ipcstatus) { aaMemoryCopy(ipcstatus,sizeof(_ipcstatus),&is); }
 return RET_YES;
 }

/*------------------------------------------------------------------------*/



 B aaIoqueNew                          (_ioque*ioque)
 {
 B ret;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMissingParm(ioque);
 aaMemoryFill(ioque,sizeof(_ioque),0);
 ioque->magic=aaHPP(aaIoqueNew);
 if((ret=aaQueCreate(&ioque->rcve.handle))!=YES) { oops; }
 if((ret=aaQueCreate(&ioque->xmit.handle))!=YES) { oops; }
 aaQueStatus(ioque->rcve.handle,&ioque->rcve.status);
 aaQueStatus(ioque->xmit.handle,&ioque->xmit.status);
 return RET_YES;
 }




 B aaIoqueDelete                       (_ioque*ioque)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMissingParm(ioque);
 if(ioque->magic!=aaHPP(aaIoqueNew)) { return RET_NOTINITIALIZED; }
 if(ioque->rcve.handle) { aaQueDestroy(ioque->rcve.handle); }
 if(ioque->xmit.handle) { aaQueDestroy(ioque->xmit.handle); }
 aaMemoryFill(ioque,sizeof(_ioque),0);
 return RET_YES;
 }



 B aaIoqueWrite                        (_ioque*ioque,B who,H bytes,VP buf)
 {
 B ret;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMissingParm(ioque);
 if(ioque->magic!=aaHPP(aaIoqueNew)) { return RET_NOTINITIALIZED; }
 if(who>IOQUE_XMIT)                  { return RET_BADPARM; }
 if(who==IOQUE_RCVE)
  {
  if((ret=aaQueWrite(ioque->rcve.handle,bytes,buf))!=YES)  { return ret; }
  }
 else
 if(who==IOQUE_XMIT)
  {
  if((ret=aaQueWrite(ioque->xmit.handle,bytes,buf))!=YES)  { return ret; }
  }
 aaQueStatus(ioque->rcve.handle,&ioque->rcve.status);
 aaQueStatus(ioque->xmit.handle,&ioque->xmit.status);
 return RET_YES;
 }



 B aaIoqueRead                         (_ioque*ioque,B who,H bytes,VP buf)
 {
 B ret;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMissingParm(ioque);
 if(ioque->magic!=aaHPP(aaIoqueNew)) { return RET_NOTINITIALIZED; }
 if(who>IOQUE_XMIT)                  { return RET_BADPARM; }
 if(who==IOQUE_RCVE)
  {
  if((ret=aaQueRead(ioque->rcve.handle,bytes,buf))!=YES)  { return ret; }
  }
 else
 if(who==IOQUE_XMIT)
  {
  if((ret=aaQueRead(ioque->xmit.handle,bytes,buf))!=YES)  { return ret; }
  }
 aaQueStatus(ioque->rcve.handle,&ioque->rcve.status);
 aaQueStatus(ioque->xmit.handle,&ioque->xmit.status);
 return RET_YES;
 }



 B aaIoquePeek                         (_ioque*ioque,B who,H offset,H bytes,VP buf)
 {
 B ret;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMissingParm(ioque);
 if(ioque->magic!=aaHPP(aaIoqueNew)) { return RET_NOTINITIALIZED; }
 if(who>IOQUE_XMIT)                  { return RET_BADPARM; }
 if(who==IOQUE_RCVE)
  {
  if((ret=aaQuePeek(ioque->rcve.handle,offset,bytes,buf))!=YES)  { return ret; }
  }
 else
 if(who==IOQUE_XMIT)
  {
  if((ret=aaQuePeek(ioque->xmit.handle,offset,bytes,buf))!=YES)  { return ret; }
  }
 aaQueStatus(ioque->rcve.handle,&ioque->rcve.status);
 aaQueStatus(ioque->xmit.handle,&ioque->xmit.status);
 return RET_YES;
 }



 B aaIoqueDiscard                      (_ioque*ioque,B who,H bytes)
 {
 B ret;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMissingParm(ioque);
 if(ioque->magic!=aaHPP(aaIoqueNew)) { return RET_NOTINITIALIZED; }
 if(who>IOQUE_XMIT)                  { return RET_BADPARM; }
 if(who==IOQUE_RCVE)
  {
  if((ret=aaQueDiscard(ioque->rcve.handle,bytes))!=YES)  { return ret; }
  }
 else
 if(who==IOQUE_XMIT)
  {
  if((ret=aaQueDiscard(ioque->xmit.handle,bytes))!=YES)  { return ret; }
  }
 aaQueStatus(ioque->rcve.handle,&ioque->rcve.status);
 aaQueStatus(ioque->xmit.handle,&ioque->xmit.status);
 return RET_YES;
 }





 B aaIoqueReturn                       (_ioque*ioque,B who,H bytes)
 {
 B ret;
 B block[_4K];
 H todo;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMissingParm(ioque);
 if(ioque->magic!=aaHPP(aaIoqueNew)) { return RET_NOTINITIALIZED; }
 if(who>IOQUE_XMIT)                  { return RET_BADPARM; }
 if(who==IOQUE_RCVE)
  {
  if(bytes==0xffffffff) { bytes=ioque->rcve.status.bytes; }
  if(bytes>ioque->rcve.status.bytes)  { return RET_BOUNDS; }
  if(bytes==ioque->rcve.status.bytes) { return RET_YES;    }
  while(1)
   {
   if(bytes==0) { break; }
   todo=aaNumRoof(bytes,_4K);
   if((ret=aaQueRead(ioque->rcve.handle,todo,block))!=RET_YES)  { oops; }
   if((ret=aaQueWrite(ioque->rcve.handle,todo,block))!=RET_YES) { oops; }
   bytes-=todo;
   }
  }
 else
 if(who==IOQUE_XMIT)
  {
  if(bytes==0xffffffff) { bytes=ioque->xmit.status.bytes; }
  if(bytes>ioque->xmit.status.bytes)  { return RET_BOUNDS; }
  if(bytes==ioque->xmit.status.bytes) { return RET_YES;    }
  while(1)
   {
   if(bytes==0) { break; }
   todo=aaNumRoof(bytes,_4K);
   if((ret=aaQueRead(ioque->xmit.handle,todo,block))!=RET_YES)  { oops; }
   if((ret=aaQueWrite(ioque->xmit.handle,todo,block))!=RET_YES) { oops; }
   bytes-=todo;
   }
  }
 aaQueStatus(ioque->rcve.handle,&ioque->rcve.status);
 aaQueStatus(ioque->xmit.handle,&ioque->xmit.status);
 return RET_YES;
 }






#if 0

 B aaIoqueRelay                        (_ioque*ioque,H bytes,B direction)
 {
 B ret;
 B buf[_4K];
 H todo;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMissingParm(ioque);
 if(ioque->magic!=aaHPP(aaIoqueNew)) { return RET_NOTINITIALIZED; }
 direction&=1;
 if(direction==0)
  {
  if(bytes>ioque->rcve.status.bytes) { return RET_BOUNDS; }
  while(1)
   {
   todo=aaNumRoof(bytes,sizeof(buf));
   if(todo==0) { break; }
   if((ret=aaIoqueRcveRead(ioque,todo,buf))!=YES)  { oops; }
   if((ret=aaIoqueXmitWrite(ioque,todo,buf))!=YES) { oops; }
   bytes-=todo;
   }
  }
 else
 if(direction==1)
  {
  if(bytes>ioque->xmit.status.bytes) { return RET_BOUNDS; }
  while(1)
   {
   todo=aaNumRoof(bytes,sizeof(buf));
   if(todo==0) { break; }
   if((ret=aaIoqueXmitRead(ioque,todo,buf))!=YES)  { oops; }
   if((ret=aaIoqueRcveWrite(ioque,todo,buf))!=YES) { oops; }
   bytes-=todo;
   }
  }
 return RET_YES;
 }








 B aaIoqueRelayTcpCall                 (_ioque*ioque,_tcpcallunit*tcpcall,HP readed,HP wroted)
 {
 B ret;
 H flag,todo,w,r;
 B buf[_4K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMissingParm(ioque);
 if(ioque->magic!=aaHPP(aaIoqueNew)) { return RET_NOTINITIALIZED; }
 if(readed) { *readed=0; }
 if(wroted) { *wroted=0; }
 w=r=0;
 if(tcpcall==NULL) { return RET_MISSINGPARM; }
 if((ret=aaNetTcpCallStatus(tcpcall->handle,&tcpcall->status))!=YES) { return ret; }
 flag=0;
 if((todo=aaNumRoof(ioque->xmit.status.bytes,sizeof(buf)))!=0)
  {
  w=todo;
  if((ret=aaIoqueXmitRead(ioque,todo,buf))!=YES) { oops; }
  if((ret=aaNetTcpCallWrite(tcpcall->handle,todo,buf))!=YES) { oops; }
  flag=1;
  }
 if((todo=aaNumRoof(tcpcall->status.rcve_bytes,sizeof(buf)))!=0)
  {
  r=todo;
  if((ret=aaNetTcpCallRead(tcpcall->handle,todo,buf))!=YES) { oops; }
  if((ret=aaIoqueRcveWrite(ioque,todo,buf))!=YES) { oops; }
  flag=1;
  }
 if(flag) { aaNetTcpCallStatus(tcpcall->handle,&tcpcall->status);  }
 if(readed) { *readed=r; }
 if(wroted) { *wroted=w; }
 return RET_YES;
 }


 #endif


/*-----------------------------------------------------------------------*/
/*-----------------------------------------------------------------------*/
/*-----------------------------------------------------------------------*/
/*-----------------------------------------------------------------------*/


 B aaZapYield                          (_zap*zap)
 {
 B ret;
 H i;
 N logh;
 B mpi,msi,mli;
 _rect r1,r2,r3;
 _size s1,s2,s3;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(zap==NULL) { return RET_MISSINGPARM; }
 if(zap->magic!=aaHPP(aaZapYield))
  {
  aaMemoryFill(zap,sizeof(_zap),0);
  zap->magic=aaHPP(aaZapYield);
  aaFocusToDbg(0);
  aaInfoGet(&zap->info);
  for(i=0;i<4;i++)  {  logh=10+(i*3);  if((ret=aaFontCreate(&zap->font[i+0].handle,"consolas",0,-logh,58,NO,NO,5,0))!=YES)       { oops; }  }  //0-3
  for(i=0;i<4;i++)  {  logh=10+(i*3);  if((ret=aaFontCreate(&zap->font[i+4].handle,"courier new",0,-logh,58,NO,NO,5,0))!=YES)    { oops; }  }  //4-7
  for(i=0;i<4;i++)  {  logh=10+(i*3);  if((ret=aaFontCreate(&zap->font[i+8].handle,"lucida console",0,-logh,58,NO,NO,5,0))!=YES) { oops; }  }  //8-11
  for(i=0;i<4;i++)  {  logh=10+(i*3);  if((ret=aaFontCreate(&zap->font[i+12].handle,"arial",0,-logh,80,NO,NO,5,0))!=YES)         { oops; }  }  //12-15
  for(i=0;i<aaElementCount(zap->font);i++)  {  if(zap->font[i].handle!=0)   {   aaFontStatus(zap->font[i].handle,&zap->font[i].status);   }  }
  mpi=zap->info.display_info.monitor_primary_index;
  msi=zap->info.display_info.monitor_smallest_index;
  mli=zap->info.display_info.monitor_largest_index;
  aaSizeCopy(&s2,(_size*)&zap->info.display_info.monitor_rect[msi].w);
  aaSizeSet(&s2,s2.w*0.50,s2.h*0.50);
  aaSizeCopy(&s3,(_size*)&zap->info.display_info.monitor_rect[mli].w);
  aaSizeSet(&s1,s2.w+(s2.w*0.25),s2.h+(s2.h*0.25));
  s1.w=aaNumRoof(s1.w,zap->info.display_info.monitor_rect[mpi].w);
  s1.h=aaNumRoof(s1.h,zap->info.display_info.monitor_rect[mpi].h);
  if((ret=aaSurfaceMinMaxCreate(&zap->surface.handle,&s1,&s2,&s3))!=YES) { oops; }
  if((ret=aaSurfaceCreate(&zap->canvas.handle,&s3))!=YES) { oops; }
  aaSurfaceStatus(zap->canvas.handle,&zap->canvas.status);
  aaSurfaceCenter(zap->surface.handle,0);
  aaSurfaceVisualize(zap->surface.handle,0,0);
  aaSurfaceIconSetUsingResource(zap->surface.handle,1000,0xffffffff);
  aaSurfaceFocus(zap->surface.handle);
  aaSurfaceMoveAreaSet(zap->surface.handle,40);
  aaSurfaceTitleSet(zap->surface.handle,"%s",zap->info.sys_info.product_name);
  aaSurfaceStatus(zap->surface.handle,&zap->surface.status);
  if(aaSizeEqualsSize(&zap->surface.status.min_size,&zap->surface.status.max_size)==NO)
   {
   if(aaSurfaceSizeableSet(zap->surface.handle,1)!=YES) oof;
   if(aaSurfaceResizeBorderSet(zap->surface.handle,8)!=YES) oof;
   aaSurfaceStatus(zap->surface.handle,&zap->surface.status);
   }
  aaSurfaceRectSet(zap->surface.handle,&zap->surface.status.rect);
  aaSurfaceUpdateAreaAdd(zap->surface.handle,0,0);
  if(aaTextboxInit(&zap->text_box,zap->surface.handle,zap->font[2].handle)!=YES) { oof; }
  aaRectSet(&r1,5,zap->surface.status.size.h-42,zap->surface.status.max_size.w-10,40);
  aaTextboxRectSet(&zap->text_box,&r1);
  aaQueCreate(&zap->text_que.handle);
  aaQueStatus(zap->text_que.handle,&zap->text_que.status);
  aaStatusGet(&zap->status);
  }
 if((aa_cycle%10)==0) { aaStatusGet(&zap->status); }
 aaSurfaceStatus(zap->surface.handle,&zap->surface.status);
 aaTextboxYield(&zap->text_box,&zap->ie);
 if(zap->text_box.is_enter)
  {
  if((ret=aaQueWrite(zap->text_que.handle,sizeof(_str4k),&zap->text_box.str))!=YES) { oops; }
  aaQueStatus(zap->text_que.handle,&zap->text_que.status);
  aaTextboxReset(&zap->text_box);
  }
 aaQueStatus(zap->text_que.handle,&zap->text_que.status);
 if(zap->surface.status.update_area.state||zap->surface.status.resize_counter||zap->text_box.needs_paint||zap->surface.status.is_focus!=zap->is_focus)
  {
  if(zap->surface.status.resize_counter||zap->surface.status.is_focus!=zap->is_focus)
   {
   aaSurfaceResizeCounterReset(zap->surface.handle);
   aaRectSet(&r1,0,0,zap->surface.status.size.w,45);
   aaSurfaceClear(zap->surface.handle,&col_pastelblue[4]);
   aaSurfaceCaption(zap->surface.handle,&r1,zap->font[15].handle,0,0,0,zap->surface.status.is_focus,"%s",zap->surface.status.title);
   aaSurfaceUpdateAreaAdd(zap->surface.handle,0,NO);
   aaSurfaceStatus(zap->surface.handle,&zap->surface.status);
   aaRectSet(&r3,(r1.x+r1.w)-30,r1.y+6,20,20);
   aaSurfaceCloseButton(zap->surface.handle,&r3,NO,&col_null,&col_gray[22]);
   aaRectCopy(&zap->sysbut_rect[0],&r3);
   aaRectAdjust(&r3,-30,0,0,0);
   if(zap->surface.status.is_maximized)    {    aaSurfaceRestoreButton(zap->surface.handle,&r3,NO,&col_null,&col_gray[22]);    }
   else                                    {    aaSurfaceMaximizeButton(zap->surface.handle,&r3,NO,&col_null,&col_gray[22]);   }
   aaRectCopy(&zap->sysbut_rect[1],&r3);
   aaRectAdjust(&r3,-30,0,0,0);
   aaSurfaceMinimizeButton(zap->surface.handle,&r3,NO,&col_null,&col_gray[22]);
   aaRectCopy(&zap->sysbut_rect[2],&r3);
   aaRectSet(&r1,5,zap->surface.status.size.h-42,zap->surface.status.max_size.w-10,40);
   aaTextboxRectSet(&zap->text_box,&r1);
   }
  aaRectSet(&r1,0,46,zap->surface.status.size.w,zap->surface.status.size.h-90);
  aaRectSet(&r2,0,46,zap->surface.status.size.w,zap->surface.status.size.h-90);
  aaSurfaceImageDrawUsingSurface(zap->surface.handle,&r1,zap->canvas.handle,&r2,0,0,255);
  if(zap->text_box.magic!=0)  {  aaTextboxForcePaint(&zap->text_box);     }
  aaSurfaceUpdate(zap->surface.handle);
  if(zap->surface.status.is_shown!=YES) { aaSurfaceShow(zap->surface.handle,YES); }
  aaSurfaceStatus(zap->surface.handle,&zap->surface.status);
  zap->is_focus=zap->surface.status.is_focus;
  }
 if(aaYield(1000.0)!=RET_YES)
  {
  aaSurfaceDestroy(zap->surface.handle);
  aaSurfaceDestroy(zap->canvas.handle);
  for(i=0;i<16;i++) { aaFontDestroy(zap->font[i].handle); }
  aaQueDestroy(zap->text_que.handle);
  aaFocusToCodeBlocks();
  return RET_NO;
  }
 aaInputEngine(&zap->ie,15,0,15,15);
 if(aaIeIsKeyDown(zap->ie,VK_ESCAPE))
  {
  if(zap->surface.handle!=0&&zap->ie.curr->focus_handle==zap->surface.handle)  { aa_is_esc=YES;  }
  else
  if(zap->surface.handle==0)                                                 { aa_is_esc=YES;  }
  }
 if(zap->ie.is_ok)
  {
  if(zap->ie.event_byt[aa_IE_Click])
   {
   while(1)
    {
    if(aaCordIsWithinRect(&zap->ie.curr->focus_cord,&zap->sysbut_rect[0])==YES)
     {
     aa_is_esc=YES;
     break;
     }
    if(aaCordIsWithinRect(&zap->ie.curr->focus_cord,&zap->sysbut_rect[1])==YES)
     {
     aaSurfaceMaximize(zap->surface.handle,TOGGLE);
     aaSurfaceStatus(zap->surface.handle,&zap->surface.status);
     if(zap->surface.status.is_maximized)
      {
      if(aaSurfaceRequiresResize(zap->surface.handle,&r1)==YES)
       {
       aaSurfaceRectSet(zap->surface.handle,&r1);
       aaSurfaceStatus(zap->surface.handle,&zap->surface.status);
       }
      }
     break;
     }
    if(aaCordIsWithinRect(&zap->ie.curr->focus_cord,&zap->sysbut_rect[2])==YES)
     {
     aaSurfaceMinimize(zap->surface.handle);
     aaSurfaceStatus(zap->surface.handle,&zap->surface.status);
     break;
     }
    break;
    }
   }
  }

 if(aa_is_esc) { aaQuit(); return RET_NO; }
 return RET_YES;
 }





 B aaZapTextRead                       (_zap*zap,_str4k*str)
 {
 B ret;
 H have;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(zap,aaZapYield);
 if(str==NULL) { return RET_MISSINGPARM; }
 aaQueStatus(zap->text_que.handle,&zap->text_que.status);
 have=zap->text_que.status.bytes/sizeof(_str4k);
 if(have==0) { return RET_NOTREADY; }
 if((ret=aaQueRead(zap->text_que.handle,sizeof(_str4k),str))!=YES) { oops; }
 aaQueStatus(zap->text_que.handle,&zap->text_que.status);
 return RET_YES;
 }




 B aaZapUpdate                         (_zap*zap,_rect*rect)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(zap,aaZapYield);
 if(rect==NULL)   {  aaSurfaceUpdateAreaAdd(zap->surface.handle,0,0);  }
 else             {    aaSurfaceUpdateAreaAdd(zap->surface.handle,rect,0);  }
 aaSurfaceStatus(zap->surface.handle,&zap->surface.status);
 return RET_YES;
 }

 /*-----------------------------------------------------------------------*/



 B aaMingyNew                          (_mingy*mingy,VP fmt,...)
 {
 _fileparts fpa;
 N which;
 B pat[_1K];
 H i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objInit(mingy,aaMingyNew);
 aaVargsf4K(fmt);
 mingy->stage=100;
 aaStringCopyf(mingy->out_file,"%s",str4k.buf);
 aaFilePartsGet(mingy->out_file,&fpa);
 aaStringIsIString(fpa.extension,&which,"exe","dll",0);
 if(which==0) { }
 else
 if(which==1) { mingy->is_dll=YES; }
 else         { return RET_FAILED; }
 aaStringCopyf(pat,"%c:",fpa.drive);
 for(i=0;i<fpa.path_count;i++) { aaStringAppendf(pat,"/%s",fpa.path[i]); }
 aaFileFolderCreate("%s",pat);
 aaMingyPathOutSet(mingy,"%s",pat);
 mingy->is_c99=YES;
 mingy->is_fpack_struct=YES;
 mingy->is_strict_aliasing=YES;
 mingy->is_warnings=YES;
 aaListNew(&mingy->error,YES,_64K,NO,NO);
 return RET_YES;
 }




 B aaMingyDelete                       (_mingy*mingy)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(mingy,aaMingyNew);
 if(mingy->cgi.handle!=0) { aaNetCgiClientDestroy(mingy->cgi.handle); }
 if(mingy->error.magic!=0) { aaListDelete(&mingy->error); }
 objClear(mingy);
 return RET_YES;
 }



 B aaMingyProgGccSet                   (_mingy*mingy,VP path,...)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(mingy,aaMingyNew);
 aaVargsf4K(path);
 aaStringCopyf(mingy->prog_gcc,"%s",str4k.buf);
 return RET_YES;
 }


 B aaMingyProgWindresSet               (_mingy*mingy,VP path,...)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(mingy,aaMingyNew);
 aaVargsf4K(path);
 aaStringCopyf(mingy->prog_windres,"%s",str4k.buf);
 return RET_YES;
 }


 B aaMingyPathOutSet                   (_mingy*mingy,VP path,...)
 {
 B ascii;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(mingy,aaMingyNew);
 aaVargsf4K(path);
 aaStringCopyf(mingy->path_out,"%s",str4k.buf);
 while(1)
  {
  aaStringLastCharGet(mingy->path_out,0,&ascii);
  if(ascii==BSLASH_CHAR) { aaStringLastCharSet(mingy->path_out,0,0,1); continue; }
  if(ascii==FSLASH_CHAR) { aaStringLastCharSet(mingy->path_out,0,0,1); continue; }
  break;
  }
 aaStringAppendf(mingy->path_out,"/");
 return RET_YES;
 }


 B aaMingyPathIncludeAdd               (_mingy*mingy,VP path,...)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(mingy,aaMingyNew);
 aaVargsf4K(path);
 aaStringCopyf(mingy->path_include[mingy->path_include_count],"%s",str4k.buf);
 mingy->path_include_count++;
 return RET_YES;
 }


 B aaMingyPathLibraryAdd               (_mingy*mingy,VP path,...)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(mingy,aaMingyNew);
 aaVargsf4K(path);
 aaStringCopyf(mingy->path_library[mingy->path_library_count],"%s",str4k.buf);
 mingy->path_library_count++;
 return RET_YES;
 }



 B aaMingyStandardLibrariesAdd         (_mingy*mingy)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(mingy,aaMingyNew);
 if((ret=aaMingyLibraryAdd(mingy,"ws2_32"))!=YES)   { return ret; }
 if((ret=aaMingyLibraryAdd(mingy,"gdi32"))!=YES)    { return ret; }
 if((ret=aaMingyLibraryAdd(mingy,"kernel32"))!=YES) { return ret; }
 if((ret=aaMingyLibraryAdd(mingy,"user32"))!=YES)   { return ret; }
 if((ret=aaMingyLibraryAdd(mingy,"winmm"))!=YES)    { return ret; }
 if((ret=aaMingyLibraryAdd(mingy,"vfw32"))!=YES)    { return ret; }
 if((ret=aaMingyLibraryAdd(mingy,"netapi32"))!=YES) { return ret; }
 if((ret=aaMingyLibraryAdd(mingy,"version"))!=YES)  { return ret; }
 return RET_YES;
 }




 B aaMingyLibraryAdd                   (_mingy*mingy,VP path,...)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(mingy,aaMingyNew);
 aaVargsf4K(path);
 aaStringCopyf(mingy->library[mingy->library_count],"%s",str4k.buf);
 mingy->library_count++;
 return RET_YES;
 }


 B aaMingyResourceAdd                  (_mingy*mingy,VP path,...)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(mingy,aaMingyNew);
 aaVargsf4K(path);
 aaStringCopyf(mingy->resource[mingy->resource_count],"%s",str4k.buf);
 mingy->resource_count++;
 return RET_YES;
 }


 B aaMingySourceAdd                    (_mingy*mingy,VP path,...)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(mingy,aaMingyNew);
 aaVargsf4K(path);
 aaStringCopyf(mingy->source[mingy->source_count],"%s",str4k.buf);
 mingy->source_count++;
 return RET_YES;
 }



 B aaMingyPluginSourceAdd              (_mingy*mingy,VP path,...)
 {
 B ret;
 B pat[_1K];
 B fname[_1K];
 B out[_32K];
 H ol;
 _fileunit fun;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(mingy,aaMingyNew);
 aaVargsf4K(path);
 GetTempPath(sizeof(pat),(CP)pat);
 if((ret=aaFileUniqueCreate(fname,pat,10,1,1,"c",NO))!=YES) { oops; }
 aaStringCopyf(fname,"%s%s",pat,fname);
 aaStringReplaceChar(fname,0,BSLASH_CHAR,FSLASH_CHAR);
 aaStringNull(out);
 aaStringAppendf(out,"#undef   UNICODE\r\n");
 aaStringAppendf(out,"#define  WINVER                       0x0500\r\n");
 aaStringAppendf(out,"#define  NODRAWDIB\r\n");
 aaStringAppendf(out,"#define  NOMCIWND\r\n");
 aaStringAppendf(out,"#define  NOMETAFILE\r\n");
 aaStringAppendf(out,"#define  NOSCROLL\r\n");
 aaStringAppendf(out,"#define  NOKANJI\r\n");
 aaStringAppendf(out,"#define  NOHELP\r\n");
 aaStringAppendf(out,"#define  NOCOMM\r\n");
 aaStringAppendf(out,"#define  NOPROFILER\r\n");
 aaStringAppendf(out,"#define  _WIN32_WINNT                 0x0501\r\n");
 aaStringAppendf(out,"#include <windows.h>\r\n");
 aaStringAppendf(out,"\r\n");
 aaStringAppendf(out,"//------------------------------------------------------------------------------\r\n");
 aaStringAppendf(out,"\r\n");
 aaStringAppendf(out,"#define structure                     typedef struct\r\n");
 aaStringAppendf(out,"#define dllExport                     __declspec(dllexport)\r\n");
 aaStringAppendf(out,"\r\n");
 aaStringAppendf(out,"//------------------------------------------------------------------------------\r\n");
 aaStringAppendf(out,"\r\n");
 aaStringAppendf(out,"typedef void                          vd;\r\n");
 aaStringAppendf(out,"typedef char                          s8;\r\n");
 aaStringAppendf(out,"typedef short                         s16;\r\n");
 aaStringAppendf(out,"typedef long                          s32;\r\n");
 aaStringAppendf(out,"typedef unsigned char                 u8;\r\n");
 aaStringAppendf(out,"typedef unsigned short                u16;\r\n");
 aaStringAppendf(out,"typedef unsigned long                 u32;\r\n");
 aaStringAppendf(out,"typedef void           *              vdp;\r\n");
 aaStringAppendf(out,"typedef char           *              s8p;\r\n");
 aaStringAppendf(out,"typedef short          *              s16p;\r\n");
 aaStringAppendf(out,"typedef long           *              s32p;\r\n");
 aaStringAppendf(out,"typedef unsigned char  *              u8p;\r\n");
 aaStringAppendf(out,"typedef unsigned short *              u16p;\r\n");
 aaStringAppendf(out,"typedef unsigned long  *              u32p;\r\n");
 aaStringAppendf(out,"typedef long long                     s64;\r\n");
 aaStringAppendf(out,"typedef unsigned long long            u64;\r\n");
 aaStringAppendf(out,"typedef s64            *              s64p;\r\n");
 aaStringAppendf(out,"typedef u64            *              u64p;\r\n");
 aaStringAppendf(out,"\r\n");
 aaStringAppendf(out,"\r\n");
 aaStringAppendf(out,"#define RET_NO                        0\r\n");
 aaStringAppendf(out,"#define RET_OK                        1\r\n");
 aaStringAppendf(out,"#define RET_YES                       1\r\n");
 aaStringAppendf(out,"#define RET_BADPARM                   2\r\n");
 aaStringAppendf(out,"#define RET_FAILED                    3\r\n");
 aaStringAppendf(out,"#define RET_BOUNDS                    4\r\n");
 aaStringAppendf(out,"#define RET_FORBIDDEN                 5\r\n");
 aaStringAppendf(out,"#define RET_NOMEMORY                  6\r\n");
 aaStringAppendf(out,"#define RET_BADHANDLE                 7\r\n");
 aaStringAppendf(out,"#define RET_NOTFOUND                  8\r\n");
 aaStringAppendf(out,"#define RET_NOTREADY                  9\r\n");
 aaStringAppendf(out,"#define RET_EXISTS                    10\r\n");
 aaStringAppendf(out,"#define RET_ALREADYOPEN               11\r\n");
 aaStringAppendf(out,"#define RET_NOTOPEN                   12\r\n");
 aaStringAppendf(out,"#define RET_INUSE                     13\r\n");
 aaStringAppendf(out,"#define RET_NOTSTARTED                14\r\n");
 aaStringAppendf(out,"#define RET_CORRUPTED                 15\r\n");
 aaStringAppendf(out,"#define RET_NOTSUPPORTED              16\r\n");
 aaStringAppendf(out,"#define RET_DENIED                    17\r\n");
 aaStringAppendf(out,"#define RET_TIMEOUT                   18\r\n");
 aaStringAppendf(out,"#define RET_FATAL                     19\r\n");
 aaStringAppendf(out,"#define RET_BADSTATE                  20\r\n");
 aaStringAppendf(out,"#define RET_FINISHED                  21\r\n");
 aaStringAppendf(out,"#define RET_NOTINITIALIZED            22\r\n");
 aaStringAppendf(out,"#define RET_PARTIAL                   23\r\n");
 aaStringAppendf(out,"#define RET_ALREADYSTARTED            24\r\n");
 aaStringAppendf(out,"#define RET_ATTENTION                 25\r\n");
 aaStringAppendf(out,"#define RET_BADFORMAT                 26\r\n");
 aaStringAppendf(out,"#define RET_CANCELLED                 27\r\n");
 aaStringAppendf(out,"#define RET_WORKING                   28\r\n");
 aaStringAppendf(out,"#define RET_COLLISION                 29\r\n");
 aaStringAppendf(out,"#define RET_POSSIBLE                  30\r\n");
 aaStringAppendf(out,"#define RET_IGNORE                    31\r\n");
 aaStringAppendf(out,"#define RET_INCOMPLETE                32\r\n");
 aaStringAppendf(out,"#define RET_OTHER                     33\r\n");
 aaStringAppendf(out,"#define RET_MISSINGPARM               34\r\n");
 aaStringAppendf(out,"\r\n");
 aaStringAppendf(out,"//------------------------------------------------------------------------------\r\n");
 aaStringAppendf(out,"static u8(*getProcEntry)              (HANDLE handle,vdp name,vdp*address)=NULL;\r\n");
 aaStringAppendf(out,"HANDLE                                plugin_handle=NULL;\r\n");
 aaStringAppendf(out,"u32                                   plugin_stage=0;\r\n");
 aaStringAppendf(out,"//------------------------------------------------------------------------------\r\n");
 aaStringAppendf(out,"\r\n");
 aaStringAppendf(out,"dllExport u8 pluginInit               (HANDLE handle,u8(*getProcEntryProc)(HANDLE,vdp,vdp*))\r\n");
 aaStringAppendf(out,"{\r\n");
 aaStringAppendf(out,"plugin_handle=handle;\r\n");
 aaStringAppendf(out,"getProcEntry=getProcEntryProc;\r\n");
 aaStringAppendf(out,"return RET_YES;\r\n");
 aaStringAppendf(out,"}\r\n");
 aaStringAppendf(out,"\r\n");
 aaStringAppendf(out,"\r\n");
 aaStringAppendf(out,"BOOL WINAPI DllMain                   (HINSTANCE hinst,DWORD fdwReason,LPVOID lpReserved)\r\n");
 aaStringAppendf(out,"{\r\n");
 aaStringAppendf(out,"if(hinst)      {}\r\n");
 aaStringAppendf(out,"if(lpReserved) {}\r\n");
 aaStringAppendf(out,"switch( fdwReason )\r\n");
 aaStringAppendf(out," {\r\n");
 aaStringAppendf(out," case DLL_PROCESS_ATTACH:  break;\r\n");
 aaStringAppendf(out," case DLL_THREAD_ATTACH:   break;\r\n");
 aaStringAppendf(out," case DLL_THREAD_DETACH:   break;\r\n");
 aaStringAppendf(out," case DLL_PROCESS_DETACH:  break;\r\n");
 aaStringAppendf(out," }\r\n");
 aaStringAppendf(out,"return TRUE;\r\n");
 aaStringAppendf(out,"}\r\n");
 aaStringAppendf(out,"\r\n");
 aaStringLen(out,&ol);
 if((ret=aaFileUnitLoad(&fun,"%s",str4k.buf))!=YES) { oops; }
 if((ret=aaFileSaveFromMemory(fname,ol,out))!=YES) { oops; }
 if((ret=aaFileAppendFromMemory(fname,(H)fun.bytes,fun.mem))!=YES) { oops; }
 aaFileUnitRelease(&fun);
 if((ret=aaMingySourceAdd(mingy,fname))!=YES) { oops; }
 mingy->is_temp[mingy->source_count-1]=YES;
 return RET_YES;
 }






 B aaMingyCompile                      (_mingy*mingy,B delobject)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(mingy,aaMingyNew);
 if(mingy->stage!=100) { return RET_BADSTATE; }
 delobject&=1;
 mingy->is_del_obj=delobject;
 mingy->stage=200;
 return RET_YES;
 }





 B aaMingyYield                        (_mingy*mingy)
 {
 B ret;
 B isp;
 _str4k str;
 _fileparts fpa;
 H i,count;
 B out[_8K];
 _mingyerr mingyerr;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(mingy,aaMingyNew);
 switch(mingy->stage)
  {
  case 100:
  break;

  case 200:
  if((ret=aaNetCgiClientCreate(&mingy->cgi.handle,1,0,0,"cmd.exe",0))!=YES) { oops; }
  aaNetCgiClientStatus(mingy->cgi.handle,&mingy->cgi.status);
  mingy->next=400;
  mingy->line_count=0;
  mingy->stage=300;
  break;


  case 300:
  aaNetCgiClientStatus(mingy->cgi.handle,&mingy->cgi.status);
  ret=aaNetCgiClientStringReadQuick(mingy->cgi.handle,20,&str.len,&isp,NULL,sizeof(str.buf),str.buf);
  if(ret==RET_NOTREADY) { break; }
  mingy->line_count++;
  if(isp) { mingy->stage=mingy->next; break; }
  if(str.len==0) { break; }
  if(mingy->next!=400)
   {
   aaStringCountVisibleChars(str.buf,str.len,&count,YES,0,1);
   if(count>1)
    {
    aaMemoryFill(&mingyerr,sizeof(_mingyerr),0);
    aaListAppend(&mingy->error,0,str.buf,sizeof(_mingyerr),&mingyerr);
    //aaDebugf("%i %s",mingy->line_count,str.buf);
    }
   }
  break;


  case 400:
  if(mingy->source_index>=mingy->source_count)   {    mingy->source_index=0;    mingy->stage=500;    break;    }
  aaStringNull(out);
  aaStringAppendf(out,"%s ",mingy->prog_gcc);
  if(mingy->is_c99)             { aaStringAppendf(out,"-std=c99 "); }
  if(mingy->is_fpack_struct)    { aaStringAppendf(out,"-fpack-struct "); }
  if(mingy->is_strict_aliasing) { aaStringAppendf(out,"-fno-strict-aliasing "); }
  if(mingy->is_warnings)        { aaStringAppendf(out,"-Wall "); }
  if(mingy->is_warnings)        { aaStringAppendf(out,"-Wextra "); }
  aaStringAppendf(out,"-mwindows ");
  aaStringAppendf(out,"-c ");
  for(i=0;i<mingy->path_include_count;i++)
   {
   aaStringAppendf(out,"-I\"%s\" ",mingy->path_include[i]);
   }
  aaFilePartsGet(mingy->source[mingy->source_index],&fpa);
  //aaStringAppendf(out,"-x c ");
  aaStringAppendf(out,"-o \"%s%s.o\" ",mingy->path_out,fpa.file);
  aaStringAppendf(out,"\"%s\" ",mingy->source[mingy->source_index]);
  //aaDebugf("%s",out);
  if((ret=aaNetCgiClientWritef(mingy->cgi.handle,"%s\r\n",out))!=YES) { oops; }
  mingy->next=420; //==================
  mingy->line_count=0;
  mingy->stage=300;
  break;

  case 420:
  mingy->source_index++;
  mingy->stage=400;
  break;

  case 500:
  if(mingy->source_index>=mingy->resource_count)   {   mingy->source_index=0;   mingy->stage=600;   break;   }
  //appLog(3,0,0,"* resource compile %s",mingy->res[mingy->source_index]);
  aaStringNull(out);
  aaStringAppendf(out,"%s ",mingy->prog_windres);
  aaFilePartsGet(mingy->resource[mingy->source_index],&fpa);
  //aaStringAppendf(out,"-dwdw ");
  aaStringAppendf(out,"-i %s ",mingy->resource[mingy->source_index]);
  aaStringAppendf(out,"-o \"%s%s.o\" ",mingy->path_out,fpa.file);
  //aaDebugf("%s",out);
  if((ret=aaNetCgiClientWritef(mingy->cgi.handle,"%s\r\n",out))!=YES) { oops; }
  mingy->next=520; //==================
  mingy->line_count=0;
  mingy->stage=300;
  break;



  case 520:
  mingy->source_index++;
  mingy->stage=500;
  break;


  case 600:
  aaStringNull(out);
  //appLog(3,0,0,"* link %s",out_file);
  aaStringAppendf(out,"%s -s ",mingy->prog_gcc);
  for(i=0;i<mingy->path_library_count;i++)
   {
   aaStringAppendf(out,"-L\"%s\" ",mingy->path_library[i]);
   }
  if(mingy->is_dll)   {   aaStringAppendf(out,"-shared ");   }
  for(i=0;i<mingy->library_count;i++)
   {
   aaStringAppendf(out,"-l%s ",mingy->library[i]);
   }
  aaFileDelete(mingy->out_file);
  aaStringAppendf(out,"-o\"%s\" ",mingy->out_file);
  for(i=0;i<mingy->source_count;i++)
   {
   aaFilePartsGet(mingy->source[i],&fpa);
   aaStringAppendf(out,"\"%s%s.o\" ",mingy->path_out,fpa.file);
   }
  for(i=0;i<mingy->resource_count;i++)
   {
   aaFilePartsGet(mingy->resource[i],&fpa);
   aaStringAppendf(out,"\"%s%s.o\" ",mingy->path_out,fpa.file);
   }
  //aaDebugf("%s",out);
  if((ret=aaNetCgiClientWritef(mingy->cgi.handle,"%s\r\n",out))!=YES) { oops; }
  mingy->next=620; //==================
  mingy->line_count=0;
  mingy->stage=300;
  break;


  case 620:
  aaNetCgiClientDestroy(mingy->cgi.handle);
  mingy->cgi.handle=0;
  if(mingy->is_del_obj)
   {
   for(i=0;i<mingy->source_count;i++)
    {
    aaFilePartsGet(mingy->source[i],&fpa);
    aaStringCopyf(out,"%s%s.o",mingy->path_out,fpa.file);
    aaStringReplaceChar(out,0,BSLASH_CHAR,FSLASH_CHAR);
    if((ret=aaFileDelete("%s",out))!=YES) { oops; }
    if(mingy->is_temp[i])
     {
     aaFileDelete("%s",mingy->source[i]);
     }
    }
   for(i=0;i<mingy->resource_count;i++)
    {
    aaFilePartsGet(mingy->resource[i],&fpa);
    aaStringCopyf(out,"%s%s.o",mingy->path_out,fpa.file);
    aaStringReplaceChar(out,0,BSLASH_CHAR,FSLASH_CHAR);
    if((ret=aaFileDelete("%s",out))!=YES) { oops; }
    }
   }


  if(aaFileExists(mingy->out_file)==YES)
   {
   mingy->is_success=YES;
   mingy->is_complete=YES;
   mingy->stage=777;
   break;
   }
  mingy->is_failure=YES;
  mingy->is_complete=YES;
  mingy->stage=777;
  break;

  case 777:
  return RET_YES;


  }
 return RET_NOTREADY;
 }


/**----------------------------------------------------------------------*/

 B aaInfoGet                           (_info*info)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(info==NULL) { return RET_MISSINGPARM; }
 aaMemoryFill(info,sizeof(_info),0);
 if((ret=aaSysInfoGet(&info->sys_info))!=YES) { return ret; }
 if((ret=aaSysPathGet(&info->sys_path))!=YES) { return ret; }
 if((ret=aaSysRgbaGet(&info->sys_rgba))!=YES) { return ret; }
 if((ret=aaSysMetricsGet(&info->sys_metrics))!=YES) { return ret; }
 if((ret=aaSysVarsGet(&info->sys_vars))!=YES) { return ret; }
 if((ret=aaDisplayInfoGet(&info->display_info,F8))!=YES) { return ret; }
 if((ret=aaNetLocalIpGet(&info->local_ip,0,1))!=YES) { return ret; }
 if((ret=aaNetInfoGet(&info->net_info))!=YES) { return ret; }
 if((ret=aaDriveListGet(&info->drive_list))!=YES) { return ret; }
 return RET_YES;
 }


/**----------------------------------------------------------------------*/

 B aaStatusGet                         (_status*status)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(status==NULL) { return RET_MISSINGPARM; }
 aaMemoryFill(status,sizeof(_status),0);
 aaMemoryStatus(&status->mem_status);
 aaNetStatus(&status->net_status);
 status->ie_events_waiting=aa_ie_events_waiting;
 status->stage=aa_stage;
 status->i_am=aa_i_am;
 status->cycle=aa_cycle;
 status->curhz=aa_curhz;
 status->askhz=aa_askhz;
 status->rathz=aa_rathz;
 status->curcpuload=aa_curcpuload;
 status->curproload=aa_curproload;
 status->avgcpuload=aa_avgcpuload;
 status->avgproload=aa_avgproload;
 status->msrunning=aa_msrunning;
 status->microsecsrunning=aa_microsecsrunning;
 return RET_YES;
 }





/**----------------------------------------------------------------------*/

 #define aa_BIGINT_OPTIMIZATION        0


 B aaBigintNew                         (_bigint*bigint)
 {
 _bigint*bip;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bigint==NULL) { return RET_MISSINGPARM; }
 bip=bigint;
 bip->magic=aaHPP(aaBigintNew);
 bip->is_local=YES;
 bip->size=1;
 bip->capacity=aaElementCount(bip->local);
 bip->data=bip->local;
 //bip->data[0]=0;//bip->data[1]=0;
 aaMemoryFill(bigint->data,(bigint->capacity)*sizeof(u32),0);
 return RET_YES;
 }






 B aaBigintDelete                      (_bigint*bigint)
 {
 _bigint*bip;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bigint,aaBigintNew);
 bip=bigint;
 if(bip->is_local==NO)    {    aaMemoryRelease(bip->data);    }
 bip->magic=0;
 return RET_YES;
 }





 B aaBigintDump                        (_bigint*bigint,H base,VP fmt,...)
 {
 B out[_16K];
 B dat[_8K];
 B tok[_1K];
 B bin[_4K];
 H sl,i;
 H msb,lsb,bc;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bigint,aaBigintNew);
 aaVargsf4K(fmt);
 if(base!=10&&base!=16&&base!=2) { return RET_FAILED; }
 aaStringNull(out);
 aaStringCopyf(tok,"sz=%i/%i",bigint->size,bigint->capacity);
 aaBigintMsb(bigint,&msb,0);
 aaBigintLsb(bigint,&lsb,0);
 aaBigintBitCount(bigint,&bc);
 aaStringAppendf(out,"%s %-9s %c  ",str4k.buf,tok,aaBoolChars(aaBigintIsZero(bigint)==YES,'z',' '));
 aaStringAppendf(out,"lsb=%-5i msb=%-5i bits=%-5i ",lsb,msb,bc);
 if(base==2)
  {
  aaStringNull(dat);
  for(i=0;i<bigint->size;i++)
   {
   if(1) { aaStringFromBinary(bin,0,32,32,1,&bigint->data[i]); }
   else  { aaStringFromBinary(bin,0,32,32,0,&bigint->data[bigint->size-i-1]); }
   aaStringAppendf(dat,"%s",bin);
   }
  aaStringLastCharSet(dat,0,0,1);
  aaStringReverse(dat,0,0,1);
  aaStringLen(dat,&sl);
  sl-=(i-1);
  aaStringAppendf(out,"  len=%-6i   bin=%s",sl,dat);
  }
 else
  {
  aaBigintToString(bigint,base,0,sizeof(tok),tok);
  aaStringLen(tok,&sl);
  if(base==10) { aaStringAppendf(out,"  len=%-6i   dec=%s",sl,tok);   }
  else         { aaStringAppendf(out,"  len=%-6i   hex=0x%s",sl,tok); }
  }
 aaDebugf("%s",out);
 return RET_YES;
 }





 B aaBigintPretty                      (_bigint*bigint,H parm,H margin)
 {
 H k,sl;
 B out[_8K];
 B tok[_8K];
 B side[_8K];
 B spc[_8K];
 B fmt[_1K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bigint,aaBigintNew);
 aaStringNull(side);
 aaStringNull(spc);
 aaStringCopyf(fmt,"%%%is",margin);
 //include margin
 if(margin)//aaBitGet(parm,4)==1) // 16
  {
  aaBigintToString(bigint,10,0,sizeof(spc),spc);
  aaStringAppendf(spc," ");
  aaStringCopyf(side,fmt,spc);
  aaStringLen(side,&sl);
  aaStringFill(spc,sl,32,YES);
  }
 //num info and decimal
 if(aaBitGet(parm,0)==1||aaBitGet(parm,1)==1)  // 1 || 2
  {
  if(aaBitGet(parm,0)==1)
   {
   aaBigintToString(bigint,0,0,sizeof(out),out);
   aaBigintToString(bigint,10,0,sizeof(tok),tok);
   aaStringAppendf(out," ");
   aaStringAppendf(out,fmt,tok);
   aaStringAppendf(out," ");
   aaDebugf("%s%s",spc,out);
   }
  if(aaBitGet(parm,1)==1)
   {
   aaBigintToString(bigint,0,0,sizeof(out),out);
   aaBigintToString(bigint,16,0,sizeof(tok),tok);
   aaStringAppendf(out," ");
   aaStringAppendf(out,fmt,tok);
   aaStringAppendf(out," ");
   aaDebugf("%s%s",spc,out);
   }
  }
 //binary grid
 if(aaBitGet(parm,2)==1)  // 4
  {
  aaStringNull(out);
  for(k=0;k<bigint->size;k++) { aaStringAppendf(out,"|---+---+---+---+---+---+---+---"); }
  aaDebugf("%s%s",spc,out);
  }
 //binary
 if(aaBitGet(parm,3)==1)  // 8
  {
  aaBigintToString(bigint,2,1,sizeof(out),out);
  aaDebugf("%s%s",side,out);
  }
 return RET_YES;
 }





 B aaBigintReset                       (_bigint*bigint)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bigint,aaBigintNew);
 if(bigint->size) { aaMemoryFill(bigint->data,bigint->size*sizeof(u32),0); }
 bigint->size=1;
 return RET_YES;
 }








 B aaBigintCapacitySet                 (_bigint*bigint,H capacity)
 {
 B ret;
 H i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bigint,aaBigintNew);
 if(bigint->capacity>=capacity)  { return RET_YES; }
 ///if(capacity>100) aaNote(0,"%i %i %i",bigint->capacity,bigint->size,capacity);
 if(bigint->is_local)
  {
  if((ret=aaMemoryAllocate((VP)&bigint->data,capacity*sizeof(u32)))!=YES) { oops; }
  for(i=0;i<bigint->capacity;i++) { bigint->data[i]=bigint->local[i]; }
  bigint->is_local=NO;
  }
 else
  {
  aaDebugf("realloc %i to %i",bigint->capacity,capacity);
  if((ret=aaMemoryReAllocate((VP)&bigint->data,capacity*sizeof(u32)))!=YES) { oops; }
  }
 bigint->capacity=capacity;
 for(i=bigint->size;i<bigint->capacity;i++) { bigint->data[i]=0; }
 return RET_YES;
 }




 B aaBigintSizeSet                     (_bigint*bigint,H size)
 {
 B ret;
 H i,os;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bigint,aaBigintNew);
 os=bigint->size;
 if(size>=bigint->capacity)
  {
  if((ret=aaBigintCapacitySet(bigint,size+4))!=YES) { oops; }
  }
 if(size>os)
  {
  bigint->size=size;
  if(bigint->size>os)  {  aaMemoryFill(&bigint->data[bigint->size],(bigint->size-os)*sizeof(u32),0); }
  }
 else
  {
  for(i=bigint->size-1;i>0;i-- )
   {
   if(bigint->data[i]!=0) { break; }
   }
  i++;
  if(i<bigint->size)    {  i=bigint->size;    }
  bigint->size=i;
  if(bigint->size<os)  {  aaMemoryFill(&bigint->data[bigint->size],(os-bigint->size)*sizeof(u32),0); }
  }
 return RET_YES;
 }






 B aaBigintCopy                        (_bigint*bigint,_bigint*bidst)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bigint,aaBigintNew);
 objTest(bidst,aaBigintNew);
 bidst->size=bigint->size;
 if(bidst->capacity<bigint->capacity) {  aaBigintCapacitySet(bidst,bigint->capacity);  }
 aaMemoryCopy(bidst->data,bidst->size*sizeof(u32),bigint->data);
 return RET_YES;
 }




 B aaBigintFromDword                   (_bigint*bigint,H val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bigint==NULL) { return RET_MISSINGPARM; }
 if(bigint->magic!=aaHPP(aaBigintNew))  {  aaBigintNew(bigint);  }
 objTest(bigint,aaBigintNew);
 bigint->size=1;
 aaBigintCapacitySet(bigint,bigint->size);
 bigint->data[0]=val;
 return RET_YES;
 }




 B aaBigintFromQuad                    (_bigint*bigint,Q val)
 {
 Q hi,lo;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bigint==NULL) { return RET_MISSINGPARM; }
 if(bigint->magic!=aaHPP(aaBigintNew))  {  aaBigintNew(bigint);  }
 objTest(bigint,aaBigintNew);
 bigint->size=1;
 aaBigintCapacitySet(bigint,2);
 hi=val/0xFFFFFFFFLL;
 lo=hi*0xFFFFFFFFLL;
 lo=val-lo;
 bigint->data[0]=(H)lo;
 if(hi!=0LL)
  {
  bigint->data[1]=(H)hi;
  bigint->size=2;
  }
 return RET_YES;
 }





 B aaBigintToQuad                      (_bigint*bigint,QP val)
 {
 Q v;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bigint==NULL) { return RET_MISSINGPARM; }
 if(bigint->magic!=aaHPP(aaBigintNew))  {  aaBigintNew(bigint);  }
 objTest(bigint,aaBigintNew);
 if(bigint->size>2) { return RET_BOUNDS; }
 if(bigint->size==1)
  {
  v=(Q)bigint->data[0];
  }
 else
 if(bigint->size==2)
  {
  v=(Q)bigint->data[1];
  v=v<<32LL;
  v=v+(Q)bigint->data[0];
  }
 if(val) { *val=v; }
 return RET_YES;
 }






 B aaBigintFromString                  (_bigint*bigint,H base,VP fmt,...)
 {
 H i;
 B c;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bigint==NULL) { return RET_MISSINGPARM; }
 if(bigint->magic!=aaHPP(aaBigintNew))  {  aaBigintNew(bigint);  }
 objTest(bigint,aaBigintNew);
 aaVargsf4K(fmt);
 if(base!=10&&base!=16) { return RET_FAILED; }
 aaBigintReset(bigint);
 for(i=0;i<str4k.len;i++)
  {
  if(i)   {   aaBigintIMul(bigint,&big_val[base]);   }
  c=str4k.buf[i];
  if(c>='0'&&c<='9') { c=c-'0';    }   else
  if(c>='a')         { c=c-'a'+10; }   else
  if(c>='A')         { c=c-'A'+10; }   else   { oof; }
  aaBigintIAdd(bigint,&big_val[c]);
  }
 return RET_YES;
 }







 B aaBigintToString                    (_bigint*bigint,H base,H parm,H maxchars,VP str)
 {
 H len,i,k,sl;
 H msb,lsb,bc,v;
 B buf[_32K];
 B bin[_8K];
 B dat[_8K];
 B tok[_8K];
 _bigint cpy;
 _bigint rem;
 BP bp;
 B ascii;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bigint,aaBigintNew);
 if(base!=0&&base!=10&&base!=16&&base!=2) { return RET_BADPARM;     }
 if(str==NULL)                            { return RET_MISSINGPARM; }
 aaStringNull(str);
 if(base==0)
  {
  aaStringCopyf(tok,"sz=%i/%i",bigint->size,bigint->capacity);
  aaBigintMsb(bigint,&msb,0);
  aaBigintLsb(bigint,&lsb,0);
  aaBigintBitCount(bigint,&bc);
  aaStringAppendf(str,"%-9s %c  ",tok,aaBoolChars(aaBigintIsZero(bigint)==YES,'z',' '));
  aaStringAppendf(str,"lsb=%-5i msb=%-5i bits=%-5i ",lsb,msb,bc);
  return RET_YES;
  }

 if(base==2)
  {
  bp=(BP)str;
  aaStringNull(dat);
  len=0;
  if(aaBitGet(parm,0)==0&&aaBitGet(parm,1)==0) { v=0; } else
  if(aaBitGet(parm,0)==1&&aaBitGet(parm,1)==0) { v=1; } else
  if(aaBitGet(parm,0)==0&&aaBitGet(parm,1)==1) { v=2; } else
  if(aaBitGet(parm,0)==1&&aaBitGet(parm,1)==1) { v=3; } else { v=0; }
  for(i=0;i<bigint->size;i++)
   {
   if(maxchars!=0&&(len+2)>=maxchars) { break; }
   if(v==0) { aaStringFromBinary(bin,0,32,33,0,&bigint->data[i]);                 } else
   if(v==1) { aaStringFromBinary(bin,0,32,33,0,&bigint->data[bigint->size-i-1]);  } else
   if(v==2) { aaStringFromBinary(bin,0,32,33,1,&bigint->data[i]);                 } else
   if(v==3) { aaStringFromBinary(bin,0,32,33,1,&bigint->data[bigint->size-i-1]);  }
   aaStringLen(bin,&sl);
   if(aaBitGet(parm,2)==0) { aaStringAppendf(dat,"%s",bin);  }
   else                    { aaStringAppendf(dat,"%s,",bin); }
   len+=sl;
   }
  aaStringLastCharDeleteIfChar(dat,0,',');
  ///if(aaBitGet(parm,2)) { aaStringReverse(dat,0,0,1);  }
  aaStringAppendf(bp,"%s",dat);
  return RET_YES;
  }

 if(aaBigintIsZero(bigint)==YES) { bp=(BP)str; bp[0]='0'; bp[1]=NULL_CHAR;  return RET_YES;  }
 aaBigintNew(&cpy);
 aaBigintNew(&rem);
 aaBigintCopy(bigint,&cpy);
 len=0;
 while(aaBigintIsZero(&cpy)==NO)
  {
  //aaBigintIDiv(&cpy,&rem,&cpy,&big_val[base]);
  aaBigintIDivR(&cpy,&big_val[base],&rem);
  buf[len++]=rem.data[0];
  if(len>=sizeof(buf)) { oof; }
  aaBigintReset(&rem);
  if(maxchars!=0&&(len+2)>=maxchars) { break; }
  }
 bp=(BP)str;
 k=0;
 for(i=len;i--;)
  {
  ascii=buf[i];
  if(ascii<10) { ascii+='0';    }
  else         { ascii+='a'-10; }
  bp[k++]=ascii;
  }
 bp[k]=NULL_CHAR;
 aaBigintDelete(&cpy);
 aaBigintDelete(&rem);
 return RET_YES;
 }





 B aaBigintIsZero                      (_bigint*bigint)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bigint,aaBigintNew);
 if(bigint->size==0)    { return RET_YES; }
 if(bigint->size>1)     { return RET_NO;  }
 if(bigint->data[0]!=0) { return RET_NO;  }
 return RET_YES;
 }





 B aaBigintIsEqual                     (_bigint*bigint,_bigint*bi1)
 {
 H i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bigint,aaBigintNew);
 objTest(bi1,aaBigintNew);
 if(bigint->size<=1||bi1->size<=1)
  {
  if(aaBigintIsZero(bigint)==YES&&aaBigintIsZero(bi1)==YES) { return RET_YES;  }
  if(aaBigintIsZero(bigint)==YES)                           { return RET_NO;   }
  if(aaBigintIsZero(bi1)==YES)                              { return RET_NO;   }
  }
 if(bigint->size!=bi1->size)                               { return RET_NO;   }
 for(i=bigint->size;i--;)
  {
  if(bigint->data[i]!=bi1->data[i])  { return RET_NO; }
  }
 return RET_YES;
 }





 B aaBigintIsLesser                    (_bigint*bigint,_bigint*bi1)
 {
 H i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bigint,aaBigintNew);
 objTest(bi1,aaBigintNew);
 if(bigint->size<=1||bi1->size<=1)
  {
  if(aaBigintIsZero(bigint)==YES&&aaBigintIsZero(bi1)==YES) { return RET_NO;  }
  if(aaBigintIsZero(bigint)==YES)                           { return RET_YES; }
  if(aaBigintIsZero(bi1))                                   { return RET_NO;  }
  }
 if(bigint->size!=bi1->size)
  {
  if(bigint->size<bi1->size) { return RET_YES; }
  return RET_NO;
  }
 for(i=bigint->size;i--;)
  {
  if(bigint->data[i]!=bi1->data[i])
   {
   if(bigint->data[i]<bi1->data[i]) { return RET_YES; }
   return RET_NO;
   }
  }
 return RET_NO;
 }







 B aaBigintIsGreater                   (_bigint*bigint,_bigint*bi1)
 {
 H i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bigint,aaBigintNew);
 objTest(bi1,aaBigintNew);
 if(bigint->size<=1||bi1->size<=1)
  {
  if(aaBigintIsZero(bigint)==YES&&aaBigintIsZero(bi1)==YES) { return RET_NO;  }
  if(aaBigintIsZero(bigint)==YES)                           { return RET_NO;  }
  if(aaBigintIsZero(bi1))                                   { return RET_YES; }
  }
 if(bigint->size!=bi1->size)
  {
  if(bigint->size>bi1->size) { return RET_YES; }
  return RET_NO;
  }
 for(i=bigint->size;i--;)
  {
  if(bigint->data[i]!=bi1->data[i])
   {
   if(bigint->data[i]>bi1->data[i]) { return RET_YES; }
   return RET_NO;
   }
  }
 return RET_NO;
 }






 B aaBigintIsLesserEqual               (_bigint*bigint,_bigint*bi1)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bigint,aaBigintNew);
 objTest(bi1,aaBigintNew);
 if(aaBigintIsGreater(bigint,bi1)==RET_YES) { return RET_NO; }
 return RET_YES;
 }







 B aaBigintIsGreaterEqual              (_bigint*bigint,_bigint*bi1)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bigint,aaBigintNew);
 objTest(bi1,aaBigintNew);
 if(aaBigintIsLesser(bigint,bi1)==RET_YES) { return RET_NO; }
 return RET_YES;
 }






 B aaBigintMsb                         (_bigint*bigint,HP pos,H extra)
 {
 H i,k,mask;
 H bs;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bigint,aaBigintNew);
 if(pos) { *pos=0; }
 if(bigint->size==0) { return RET_NOTFOUND;  }
 bs=bigint->size+extra;
 if(bs>=bigint->capacity) { bs=bigint->capacity; }
 for(i=bs-1;i>0;i--)
  {
  if(bigint->data[i]!=0) { break; }
  }
 mask=(H)1<<(32-1);
 for(k=0;k<32;k++)
  {
  if(!(bigint->data[i]&mask)) { mask>>=1; continue; }
  if(pos) { *pos=(i*32)+(31-k); }
  return RET_YES;
  }
 return RET_NOTFOUND;
 }

 /*
static size_t mbedtls_clz( const mbedtls_mpi_uint x )
{
    u32 j;
    u32 mask = (u32) 1 << (32 - 1);

    for( j = 0; j < biL; j++ )
    {
        if( x & mask ) break;

        mask >>= 1;
    }

    return j;

size_t mbedtls_mpi_bitlen( const mbedtls_mpi *X )
{
    u32 i, j;

    if( X->size == 0 )        return( 0 );

    for( i = X->size - 1; i > 0; i-- )
     {
        if( X->data[i] != 0 )            break;
        }

    j = 32 - mbedtls_clz( X->data[i] );

    return( ( i * 32 ) + j );
}
*/




 B aaBigintLsb                         (_bigint*bigint,HP pos,H extra)
 {
 H i,j,mask;
 H bs;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bigint,aaBigintNew);
 if(pos) { *pos=0; }
 if(bigint->size==0) { return RET_NOTFOUND;  }
 bs=bigint->size+extra;
 if(bs>=bigint->capacity) { bs=bigint->capacity; }
 for(i=0;i<bs;i++)
  {
  if(bigint->data[i]!=0)
   {
   mask=1;
   for(j=0;j<32;j++)
    {
    if(!(bigint->data[i]&mask)) { mask<<=1; continue; }
    if(pos) { *pos=(i*32)+j; }
    return RET_YES;
    }
   oof;
   }
  }
 return RET_NOTFOUND;
 }







 B aaBigintBitCount                    (_bigint*bigint,HP count)
 {
 H i,j,mask,c;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bigint,aaBigintNew);
 c=0;
 if(count) { *count=0; }
 if(bigint->size==0) { return RET_YES;  }
 for(i=0;i<bigint->size;i++)
  {
  if(bigint->data[i]==0) { continue; }
  mask=1;
  for(j=0;j<32;j++)
   {
   if(bigint->data[i]&mask) { c++; }
   mask<<=1;
   }
  }
 if(count) { *count=c; }
 return RET_YES;
 }






 B aaBigintBitGet                      (_bigint*bigint,H pos,BP state)
 {
 H off,idx;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bigint,aaBigintNew);
 if(state) { *state=0; }
 off=pos/32;
 idx=pos%32;
 if(off<bigint->size)
  {
  if(aaBitGet(bigint->data[off],idx))
   {
   if(state) { *state=1; }
   }
  }
 return RET_YES;
 }





 B aaBigintBitSet                      (_bigint*bigint,H pos,B state)
 {
 H off,idx;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bigint,aaBigintNew);
 state&=1;
 off=pos/32;
 idx=pos%32;
 if((off+1)<bigint->size)
  {
  if(state)   {   bigint->data[off]=aaBitSet(bigint->data[off],idx);   }
  else        {   bigint->data[off]=aaBitClr(bigint->data[off],idx);   }
  return RET_YES;
  }
 if(state)
  {
  if((off+1)>=bigint->capacity) { aaBigintCapacitySet(bigint,off+1); }
  bigint->data[off]=aaBitSet(bigint->data[off],idx);
  bigint->size=off+1;
  return RET_YES;
  }
 bigint->data[off]=aaBitClr(bigint->data[off],idx);
 if(bigint->data[off]==0)  {  aaBigintMsb(bigint,&idx,0);  bigint->size=(idx/32)+1;    }
 return RET_YES;
 }







 B aaBigintIShlDword                   (_bigint*bigint,H count)
 {
 register H r0,r1,i,v0,t1;
 H bitlen;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bigint,aaBigintNew);
 if(count==0) { return RET_YES; }
 r0=0;
 v0=count/(aa_BIGINT_DATA_BITS);
 t1=count&(aa_BIGINT_DATA_BITS-1);
 aaBigintMsb(bigint,&bitlen,0);
 //aaDebugf("msb=%i+%i=%i",bitlen,count,bitlen+count);
 bitlen+=count;
 i=aa_BIGINT_BITS_TO_SIZE(bitlen);
 if(i>bigint->capacity)
  {
  aaBigintCapacitySet(bigint,i);
  }
 bigint->size=(bitlen/(aa_BIGINT_DATA_BITS))+1;
 if(v0>0)
  {
  for(i=bigint->size;i>v0;i--)
   {
   bigint->data[i-1]=bigint->data[i-v0-1];
   }
  for(;i>0;i--)
   {
   bigint->data[i-1]=0;
   }
  }
 if(t1>0)
  {
  for(i=v0;i<bigint->size;i++)
   {
   r1=bigint->data[i]>>(aa_BIGINT_DATA_BITS-t1);
   bigint->data[i]<<=t1;
   bigint->data[i]|=r0;
   r0=r1;
   }
  }

// aaDebugf("bitlen=%i",bitlen);
 //if(bitlen%aa_BIGINT_DATA_BITS) { i++; }
 //if(i==0)                       { i++; }
 //bigint->size=i;
 return RET_YES;
 }





 B aaBigintIShrDword                   (_bigint*bigint,H count)
 {
 register H r0,r1,i,v0,v1;
 H bitlen;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bigint,aaBigintNew);
 if(count==0)                     { return RET_YES;  }
 if(aaBigintIsZero(bigint)==YES)  { return RET_YES;  }

 r0=0;
 v0=count/aa_BIGINT_DATA_BITS;
 v1=count&(aa_BIGINT_DATA_BITS-1);
 aaBigintMsb(bigint,&bitlen,0);
 if(count>=bitlen)
  {
  bigint->size=1;
  bigint->data[0]=0;
  //aaBigintFromDword(bigint,0);
  return RET_YES;
  }
 else
  {
  //aaBigintSizeSet(bigint,(bitlen/(aa_BIGINT_DATA_BITS))+1);
  if(v0>0)
   {
   for(i=0;i<bigint->size-v0;i++)
    {
    bigint->data[i]=bigint->data[i+v0];
    }
   for(;i<bigint->size;i++)
    {
    bigint->data[i]=0;
    }
   }
  if(v1>0)
   {
   for(i=bigint->size;i>0;i--)
    {
    r1=bigint->data[i-1]<<(aa_BIGINT_DATA_BITS-v1);
    bigint->data[i-1]>>=v1;
    bigint->data[i-1]|=r0;
    r0=r1;
    }
   }
  }
 bigint->size=(bitlen/(aa_BIGINT_DATA_BITS))+1;
 while(bigint->size>1&&!bigint->data[bigint->size-1]) { bigint->size--; }
 return RET_YES;
 }






 B aaBigintMul                         (_bigint*bigint,_bigint*bi1,_bigint*bi2)
 {
 H comp_size,i,j,k;
 u64 prod;
 u32 carry,temp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bigint,aaBigintNew);
 objTest(bi1,aaBigintNew);
 objTest(bi2,aaBigintNew);

 #if (aa_BIGINT_OPTIMIZATION>=1)
 if(bi2->size==1)
  {
  H c,val;
  val=bi2->data[0];
  if(aaMathIsPowerOfTwo(val)==YES)
   {
   c=0;  while(val>>=1) { c++; }
   aaBigintCopy(bi1,bigint);
   return(aaBigintIShlDword(bigint,c));
   }
  }
 #endif
 #if (aa_BIGINT_OPTIMIZATION>=2)
 else
 if(bi2->size>=2)
  {
  H c;
  aaBigintBitCount(bi2,&c);
  if(c==1)
   {
   aaBigintMsb(bi2,&c,0);
   aaBigintCopy(bi1,bigint);
   return(aaBigintIShlDword(bigint,c));
   }
  }
 #endif

 comp_size=bi1->size+bi2->size;
 if(bigint->capacity<comp_size)
  {
  aaBigintCapacitySet(bigint,comp_size);
  }
 aaMemoryFill(bigint->data,comp_size*sizeof(u32),0);
 for(i=0;i<bi1->size;i++)
  {
  for(j=0;j<bi2->size;j++)
   {
   prod=bi1->data[i]*(u64)bi2->data[j]+(u64)bigint->data[i+j];
   carry=(u32)(prod/BIGINT_RADIX);
   k=1;
   while(carry)
    {
    temp=bigint->data[i+j+k]+carry;
    carry=temp<bigint->data[i+j+k]?1:0;
    bigint->data[i+j+k]=temp;
    k++;
    }
   prod=(bigint->data[i+j]+bi1->data[i]*(u64)bi2->data[j])%BIGINT_RADIX;
   bigint->data[i+j]=(u32)prod;
   }
  }
 bigint->size=comp_size;
 if(bigint->size&&!bigint->data[bigint->size-1])
  {
  bigint->size--;
  }
 return RET_YES;
 }





 B aaBigintIMul                        (_bigint*bigint,_bigint*bi1)
 {
 _bigint temp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bigint,aaBigintNew);
 objTest(bi1,aaBigintNew);
 aaBigintNew(&temp);
 aaBigintMul(&temp,bigint,bi1);
 aaBigintCopy(&temp,bigint);
 aaBigintDelete(&temp);
 return RET_YES;
 }




 B aaBigintMulDword                    (_bigint*bigint,_bigint*bi1,u32 bi2)
 {
 _bigint temp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bigint,aaBigintNew);
 objTest(bi1,aaBigintNew);
 aaBigintNew(&temp);
 aaBigintFromDword(&temp,bi2);
 aaBigintMul(bigint,bi1,&temp);
 aaBigintDelete(&temp);
 return RET_YES;
 }



 B aaBigintIMulDword                   (_bigint*bigint,u32 bi1)
 {
 _bigint temp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bigint,aaBigintNew);
 aaBigintNew(&temp);
 aaBigintFromDword(&temp,bi1);
 aaBigintIMul(bigint,&temp);
 aaBigintDelete(&temp);
 return RET_YES;
 }





 B aaBigintAdd                         (_bigint*bigint,_bigint*bi1,_bigint*bi2)
 {
 H n,i,carry,sum;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bigint,aaBigintNew);
 objTest(bi1,aaBigintNew);
 objTest(bi2,aaBigintNew);
 n=max(bi1->size,bi2->size);
 aaBigintCapacitySet(bigint,n+1);
 carry=0;
 for(i=0;i<n;i++)
  {
  sum=carry;
  if(i<bi1->size) { sum+=bi1->data[i]; }
  if(i<bi2->size) { sum+=bi2->data[i]; }
  bigint->data[i]=sum;
  if(i<bi1->size) { carry=sum<bi1->data[i]; }
  else            { carry=sum<bi2->data[i]; }
  }
 if(carry==1)
  {
  bigint->size=n+1;
  bigint->data[n]=1;
  }
 else
  {
  bigint->size=n;
  }
 return RET_YES;
 }






 B aaBigintIAdd                        (_bigint*bigint,_bigint*bi1)
 {
 _bigint temp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bigint,aaBigintNew);
 objTest(bi1,aaBigintNew);
 aaBigintNew(&temp);
 aaBigintAdd(&temp,bigint,bi1);
 aaBigintCopy(&temp,bigint);
 aaBigintDelete(&temp);
 return RET_YES;
 }




 B aaBigintAddDword                    (_bigint*bigint,_bigint*bi1,u32 bi2)
 {
 _bigint temp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bigint,aaBigintNew);
 objTest(bi1,aaBigintNew);
 aaBigintNew(&temp);
 aaBigintFromDword(&temp,bi2);
 aaBigintAdd(bigint,bi1,&temp);
 aaBigintDelete(&temp);
 return RET_YES;
 }




 B aaBigintIAddDword                   (_bigint*bigint,u32 bi1)
 {
 _bigint temp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bigint,aaBigintNew);
 aaBigintNew(&temp);
 aaBigintFromDword(&temp,bi1);
 aaBigintIAdd(bigint,&temp);
 aaBigintDelete(&temp);
 return RET_YES;
 }



 B aaBigintSub                         (_bigint*bigint,_bigint*bi1,_bigint*bi2)
 {
 H i,length,carry,dif,temp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bigint,aaBigintNew);
 objTest(bi1,aaBigintNew);
 objTest(bi2,aaBigintNew);
 length=0;
 carry=0;
 aaBigintCapacitySet(bigint,bi1->size);
 for(i=0;i<bi1->size;i++)
  {
  temp=carry;
  if(i<bi2->size) { temp+=bi2->data[i]; }
  dif=bi1->data[i]-temp;
  carry=temp>bi1->data[i];
  bigint->data[i]=dif;
  if(bigint->data[i]) { length=i; }
  }
 bigint->size=length+1;
 return RET_YES;
 }







 B aaBigintISub                        (_bigint*bigint,_bigint*bi1)
 {
 _bigint temp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bigint,aaBigintNew);
 objTest(bi1,aaBigintNew);
 aaBigintNew(&temp);
 aaBigintSub(&temp,bigint,bi1);
 aaBigintCopy(&temp,bigint);
 aaBigintDelete(&temp);;
 return RET_YES;
 }





 B aaBigintSubDword                    (_bigint*bigint,_bigint*bi1,u32 bi2)
 {
 _bigint temp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bigint,aaBigintNew);
 objTest(bi1,aaBigintNew);
 aaBigintNew(&temp);
 aaBigintFromDword(&temp,bi2);
 aaBigintSub(bigint,bi1,&temp);
 aaBigintDelete(&temp);
 return RET_YES;
 }



 B aaBigintISubDword                   (_bigint*bigint,u32 bi1)
 {
 _bigint temp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bigint,aaBigintNew);
 aaBigintNew(&temp);
 aaBigintFromDword(&temp,bi1);
 aaBigintISub(bigint,&temp);
 aaBigintDelete(&temp);
 return RET_YES;
 }





 B aaBigintDiv                         (_bigint*bigint,_bigint*rem,_bigint*bi1,_bigint*bi2)
 {
 register H i,j,k;
 H ref_size,i2;
 u32 part1,part2;
 u32 borrow_in,borrow_out;
 register u32 temp;
 u32 subbuf[5000];
 u32*sub_buf;
 _bigint trem;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bigint,aaBigintNew);
 if(rem)  {  objTest(rem,aaBigintNew);  }
 objTest(bi1,aaBigintNew);
 objTest(bi2,aaBigintNew);

 if(aaBigintIsLesser(bi1,bi2)==YES)
  {
  aaBigintCopy(&big_val[0],bigint);
  if(rem) { aaBigintCopy(bi1,rem); }
  return RET_YES;
  }
 if(aaBigintIsZero(bi1)==YES||aaBigintIsZero(bi2)==YES)
  {
  aaBigintCopy(&big_val[0],bigint);
  if(rem) { aaBigintCopy(&big_val[0],rem); }
  return RET_YES;
  }
 if(bi1->size==1&&bi2->size==1)
  {
  part1=bi1->data[0]/bi2->data[0];
  if(rem)
   {
   part2=bi1->data[0]%bi2->data[0];
   rem->data[0]=part2;
   rem->size=1;
   }
  bigint->data[0]=part1;
  bigint->size=1;
  return RET_YES;
  }

 #if (aa_BIGINT_OPTIMIZATION>=1)
 if(bi2->size==1)
  {
  H c,val;
  val=bi2->data[0];
  if(aaMathIsPowerOfTwo(val)==YES)
   {
   c=0;  while(val>>=1) { c++; }
   aaBigintCopy(bi1,bigint);
   if((ret=aaBigintIShrDword(bigint,c))!=YES) { oops; }
   if(rem==NULL) { return RET_YES; }
   return(aaBigintSub(rem,bi1,bigint));
   }
  }
 #endif


 //if(rem) { aaBigintCopy(rem,&trem); }
 aaBigintNew(&trem);
 ref_size=bi1->size;
 aaBigintCopy(bi1,&trem);
 //if(rem->capacity<(rem->size+1))   {   aaBigintCapacitySet(rem,rem->size+1);   }
 if(trem.capacity<(trem.size+1))   {   aaBigintCapacitySet(&trem,trem.size+1);   }
 trem.size++;
 trem.data[ref_size]=0;
 sub_buf=subbuf;
 bigint->size=ref_size-bi2->size+1;
 if(bigint->capacity<bigint->size)  {  aaBigintCapacitySet(bigint,bigint->size);  }
 aaMemoryFill(bigint->data,bigint->size*sizeof(u32),0);
 i=bigint->size;
 while(i)
  {
  i--;
  bigint->data[i]=0;
  i2=32;
  while(i2>0)
   {
   i2--;
   for(j=0,k=i,borrow_in=0;j<=bi2->size;j++,k++)
    {
    if(j==0||i2==0)  { part1=0; }
    else             { part1=bi2->data[j-1]>>(32-i2); }
    if(j==bi2->size) { part2=0; }
    else             { part2=bi2->data[j]<<i2;        }
    temp=trem.data[k]-(part1|part2);
    borrow_out=temp>trem.data[k];
    if(borrow_in)
     {
     if(temp==0) { borrow_out|=1; }
     else        { borrow_out|=0; }
     temp--;
     }
    sub_buf[k]=temp;
    borrow_in=borrow_out;
    }
    for(;k<ref_size&&borrow_in;k++)
     {
     borrow_in=!trem.data[k];
     sub_buf[k]=trem.data[k]-1;
     }
   if(borrow_in==0)
    {
    bigint->data[i]|=1<<i2;
    while(k>i) { k--; trem.data[k]=sub_buf[k];      }
    }
   }
  }
 while(bigint->size>1&&!bigint->data[bigint->size-1]) { bigint->size--; }
 while(trem.size>1&&!trem.data[trem.size-1])          { trem.size--;    }
 if(rem) { aaBigintCopy(&trem,rem); }
 aaBigintDelete(&trem);
 return RET_YES;
 }






 B aaBigintDivDword                    (_bigint*bigint,_bigint*rem,_bigint*bi1,u32 bi2)
 {
 _bigint temp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bigint,aaBigintNew);
 aaBigintNew(&temp);
 aaBigintFromDword(&temp,bi2);
 aaBigintDiv(bigint,rem,bi1,&temp);
 aaBigintDelete(&temp);
 return RET_YES;
 }




 B aaBigintIDiv                        (_bigint*bigint,_bigint*div)
 {
 _bigint q;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bigint,aaBigintNew);
 objTest(div,aaBigintNew);
 aaBigintNew(&q);
 aaBigintDiv(&q,NULL,bigint,div);
 aaBigintCopy(&q,bigint);
 aaBigintDelete(&q);
 return RET_YES;
 }






 B aaBigintIDivDword                   (_bigint*bigint,u32 bi1)
 {
 _bigint temp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bigint,aaBigintNew);
 aaBigintNew(&temp);
 aaBigintFromDword(&temp,bi1);
 aaBigintIDiv(bigint,&temp);
 aaBigintDelete(&temp);
 return RET_YES;
 }





 B aaBigintIDivR                       (_bigint*bigint,_bigint*div,_bigint*rem)
 {
 _bigint q,r;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bigint,aaBigintNew);
 aaBigintNew(&q);
 aaBigintNew(&r);
 aaBigintDiv(&q,&r,bigint,div);
 aaBigintCopy(&q,bigint);
 aaBigintCopy(&r,rem);
 aaBigintDelete(&q);
 aaBigintDelete(&r);
 return RET_YES;
 }





 B aaBigintMod                         (_bigint*bigint,_bigint*div,_bigint*mod)
 {
 _bigint q;
 H part;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bigint,aaBigintNew);
 objTest(div,aaBigintNew);
 objTest(mod,aaBigintNew);
 if(div->size==1&&bigint->size==1)
  {
  part=bigint->data[0]%div->data[0];
  mod->size=1;
  mod->data[0]=part;
  return RET_YES;
  }
 aaBigintNew(&q);
 aaBigintDiv(&q,mod,bigint,div);
 aaBigintDelete(&q);
 return RET_YES;
 }




 B aaBigintIMod                        (_bigint*bigint,_bigint*mod)
 {
 _bigint q,r;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bigint,aaBigintNew);
 objTest(mod,aaBigintNew);
 aaBigintNew(&q);
 aaBigintNew(&r);
 aaBigintDiv(&q,&r,bigint,mod);
 aaBigintCopy(&r,bigint);
 aaBigintDelete(&q);
 aaBigintDelete(&r);
 return RET_YES;
 }








 B aaBigintPow                         (_bigint*bigint,_bigint*exp,_bigint*res)
 {
 _bigint a,b;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bigint,aaBigintNew);
 aaBigintNew(&a);
 aaBigintNew(&b);
 //aaBigintNew(&discard);
 aaBigintCopy(bigint,&a);
 aaBigintCopy(exp,&b);
 aaBigintFromDword(res,1);
 while(aaBigintIsGreater(&b,&big_val[0])==YES)
  {
  if(b.data[0]&1)
   {
   aaBigintIMul(res,&a);
   }
  #if 1
  aaBigintIDiv(&b,&big_val[2]);
  #else
  aaBigintIShrDword(&b,1);
  #endif
  aaBigintIMul(&a,&a);
///  aaBigintCopy(&a,&discard); //???
  //aaBigintIMul(&a,&discard);
  }
 aaBigintDelete(&a);
 aaBigintDelete(&b);
 //aaBigintDelete(&discard);
 return RET_YES;
 }








 B aaBigintModPow                      (_bigint*bigint,_bigint*exp,_bigint*mod,_bigint*res)
 {
 _bigint a,b,c;
 _bigint discard;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bigint,aaBigintNew);
 aaBigintNew(&a);
 aaBigintNew(&b);
 aaBigintNew(&c);
 aaBigintNew(&discard);
 aaBigintCopy(bigint,&a);
 aaBigintCopy(exp,&b);
 aaBigintCopy(mod,&c);
 aaBigintFromDword(res,1);
 while(aaBigintIsGreater(&b,&big_val[0])==YES)
  {
  if(b.data[0]&1)
   {
   aaBigintIMul(res,&a);
   aaBigintIMod(res,&c);
   }
  #if 1
  aaBigintIDiv(&b,&big_val[2]);
  #else
  aaBigintIShrDword(&b,1);
  #endif
  aaBigintIMul(&a,&a);
  //aaBigintCopy(&a,&discard);     // discard=a
  //aaBigintIMul(&a,&discard);     // a=a*discard
  aaBigintIMod(&a,&c);           // a*=c
  }
 aaBigintDelete(&a);
 aaBigintDelete(&b);
 aaBigintDelete(&c);
 aaBigintDelete(&discard);
 return RET_YES;
 }





 B aaBigintISqroot                     (_bigint*bigint,_bigint*sqr)
 {
 _bigint bm;
 _bigint bp;
 _bigint ans;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bigint,aaBigintNew);
 objTest(sqr,aaBigintNew);
 aaBigintNew(&bm);
 aaBigintNew(&bp);
 aaBigintCopy(bigint,&bm);
 aaBigintCopy(bigint,&bp);
 aaBigintNew(&ans);
 while(1)
  {
  aaBigintDiv(&ans,NULL,&bp,&bm);
  aaBigintIAdd(&ans,&bm);
  #if 1
  aaBigintIDiv(&ans,&big_val[2]);
  #else
  aaBigintIShrDword(&ans,1);
  #endif
  if(aaBigintIsGreaterEqual(&ans,&bm)==RET_YES) { break; }
  aaBigintCopy(&ans,&bm);
  }
 aaBigintCopy(&bm,sqr);
 aaBigintDelete(&ans);
 aaBigintDelete(&bm);
 aaBigintDelete(&bp);
 return RET_YES;
 }




 B aaBigintGcd                         (_bigint*bigint,_bigint*bi1,_bigint*result)
 {
 _bigint a,b;
 _bigint remainder,temp,discard;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bigint,aaBigintNew);
 objTest(bi1,aaBigintNew);
 aaBigintNew(&a);
 aaBigintNew(&b);
 aaBigintNew(&remainder);
 aaBigintNew(&temp);
 aaBigintNew(&discard);
 aaBigintCopy(bigint,&a);
 aaBigintCopy(bi1,&b);
 while(aaBigintIsEqual(&b,&big_val[0])!=YES)
  {
  aaBigintCopy(&b,&temp);
  aaBigintIMod(&a,&b);
  aaBigintCopy(&a,&b);
  aaBigintCopy(&temp,&a);
  }
 aaBigintCopy(&a,result);
 aaBigintDelete(&a);
 aaBigintDelete(&b);
 aaBigintDelete(&remainder);
 aaBigintDelete(&temp);
 aaBigintDelete(&discard);
 return RET_YES;
 }








 B aaBigintInv                         (_bigint*bigint,_bigint*bi1,_bigint*result)
 {
 _bigint remprev,rem,aux,auxprev;
 _bigint rcur,qcur,acur;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bigint,aaBigintNew);
 objTest(bi1,aaBigintNew);
 aaBigintNew(&remprev);
 aaBigintNew(&rem);
 aaBigintNew(&aux);
 aaBigintNew(&auxprev);
 aaBigintNew(&rcur);
 aaBigintNew(&qcur);
 aaBigintNew(&acur);
 aaBigintCopy(bi1,&remprev);
 aaBigintCopy(bigint,&rem);
 aaBigintFromDword(&auxprev,0);
 aaBigintFromDword(&aux,1);
 while(aaBigintIsGreater(&rem,&big_val[1])==YES)
  {
  aaBigintDiv(&qcur,&rcur,&remprev,&rem);
  aaBigintSub(&acur,bi1,&qcur);
  aaBigintIMul(&acur,&aux);
  aaBigintIAdd(&acur,&auxprev);
  aaBigintIMod(&acur,bi1);
  aaBigintCopy(&rem,&remprev);
  aaBigintCopy(&aux,&auxprev);
  aaBigintCopy(&rcur,&rem);
  aaBigintCopy(&acur,&aux);
  }
 aaBigintCopy(&acur,result);
 aaBigintDelete(&remprev);
 aaBigintDelete(&rem);
 aaBigintDelete(&aux);
 aaBigintDelete(&auxprev);
 aaBigintDelete(&rcur);
 aaBigintDelete(&qcur);
 aaBigintDelete(&acur);
 return RET_YES;
 }








 B aaBigintJacobi                      (_bigint*bigint,_bigint*bi1,ZP res)
 {
 _bigint remainder,twos,temp,a,n;
 Z mult,result;
 H val;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bigint,aaBigintNew);
 objTest(bi1,aaBigintNew);
 aaBigintNew(&remainder);
 aaBigintNew(&twos);
 aaBigintNew(&temp);
 aaBigintNew(&a);
 aaBigintNew(&n);
 aaBigintCopy(bigint,&a);
 aaBigintCopy(bi1,&n);
 mult=1;
 result=0;
 while(aaBigintIsGreater(&a,&big_val[1])==YES&&aaBigintIsEqual(&a,&n)!=YES)
  {
  if(a.size==1&&n.size==1)  {  val=a.data[0]%n.data[0];  a.data[0]=val;   }
  else                      {  aaBigintIMod(&a,&n);                       }
  if(aaBigintIsLesserEqual(&a,&big_val[1])==YES||aaBigintIsEqual(&a,&n)==YES) { break; }
  aaBigintFromDword(&twos,0);
  while((a.data[0]%2)==0)
   {
   if((twos.data[0]&1)==0&&twos.size==1)    {    twos.data[0]=aaBitSet(twos.data[0],0);    }
   else                                     {    aaBigintIAdd(&twos,&big_val[1]);          }
   #if 1
   aaBigintIDiv(&a,&big_val[2]);
   #else
   aaBigintIShrDword(&a,1);
   #endif
   }
  if(aaBigintIsGreater(&twos,&big_val[0])==YES&&(twos.data[0]%2)==1)
   {
   aaBigintMod(&n,&big_val[8],&remainder);
   if(aaBigintIsEqual(&remainder,&big_val[1])!=YES&&aaBigintIsEqual(&remainder,&big_val[7])!=YES)  {  mult*=-1;    }
   }
  if(aaBigintIsLesserEqual(&a,&big_val[1])==YES||aaBigintIsEqual(&a,&n)==YES) { break; }
  aaBigintMod(&n,&big_val[4],&remainder);
  aaBigintMod(&a,&big_val[4],&temp);
  if(aaBigintIsEqual(&remainder,&big_val[1])!=YES&&aaBigintIsEqual(&temp,&big_val[1])!=YES)   {   mult*=-1;   }
  aaBigintCopy(&a,&temp);
  aaBigintCopy(&n,&a);
  aaBigintCopy(&temp,&n);
  }
 if(aaBigintIsEqual(&a,&big_val[1])==YES) { result=mult; }
 else                                     { result=0;    }
 aaBigintDelete(&remainder);
 aaBigintDelete(&twos);
 aaBigintDelete(&temp);
 aaBigintDelete(&a);
 aaBigintDelete(&n);
 *res=result;
 return RET_YES;
 }




#if 0
 B aaBigintPrimality                   (_bigint*bigint,H accuracy)
 {
 B ret;
 _bigint mx,i,x,y,z,p,d,m;
 H k;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(accuracy==0) { return RET_BADPARM; }
 objTest(bigint,aaBigintNew);
 aaBigintNew(&y);
 aaBigintMod(bigint,&big_val[2],&y);
 if(aaBigintIsZero(&y)==YES)
  {
  aaBigintDelete(&y);
  return RET_NO;
  }
 aaBigintNew(&p);
 aaBigintNew(&m);
 aaBigintNew(&d);
 ret=RET_YES;
 for(k=0;k<10000;k++)
  {
  if(accuracy==0) { break; }
  aaBigintFromDword(&p,aa_math_system_smallprime[k]);
  aaBigintDiv(&d,&m,bigint,&p);
  if(aaBigintIsZero(&m)==YES) {  ret=RET_NO;   break;   }
  accuracy--;
  }
 if(ret==RET_NO&&accuracy==0)
  {
  aaBigintDelete(&d);
  aaBigintDelete(&m);
  aaBigintDelete(&p);
  aaBigintDelete(&y);
  return ret;
  }
 ret=RET_YES;
 aaBigintNew(&mx);
 aaBigintNew(&i);
 aaBigintNew(&x);
 aaBigintNew(&z);
 aaBigintISqroot(bigint,&mx);
 aaBigintFromDword(&i,2);
 aaBigintFromDword(&z,5);
 while(aaBigintIsLesser(&i,&mx)==YES)
  {
  if(accuracy==0) { break;   }
  //aaBigintMul(&x,&i,&big_val[2]);
  //aaBigintIAdd(&x,&big_val[1]);
  //aaBigintMod(bigint,&x,&y);
  aaBigintMod(bigint,&z,&y);
  if(aaBigintIsZero(&y)==YES)  {  ret=RET_NO;   break;   }
  aaBigintIAdd(&i,&big_val[1]);
  aaBigintISub(&z,&big_val[1]);
  aaBigintMul(&z,&i,&big_val[2]);
  aaBigintIAdd(&z,&big_val[1]);
  accuracy--;
  }
 aaBigintDelete(&d);
 aaBigintDelete(&m);
 aaBigintDelete(&p);
 aaBigintDelete(&mx);
 aaBigintDelete(&i);
 aaBigintDelete(&x);
 aaBigintDelete(&y);
 aaBigintDelete(&z);
 return ret;
 }
#endif


 B aaBigintIsPrime                     (_bigint*bigint,H accuracy)
 {
 B ret;
 _bigint ab,rs,pw,mp;
 Z result,x;
 H rm,rmax,wit,k;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bigint,aaBigintNew);
 if(accuracy==0||accuracy>100)                                        { return RET_BOUNDS; }
 if(aaBigintIsEqual(bigint,&big_val[2])==YES)                         { return RET_YES;    }
 if((bigint->data[0]%2)==0||aaBigintIsEqual(bigint,&big_val[1])==YES) { return RET_NO;     }

 aaBigintNew(&pw);
 aaBigintNew(&ab);
 aaBigintNew(&rs);
 aaBigintNew(&mp);

 ret=RET_YES;
 for(k=0;k<100;k++)
  {
  aaBigintFromDword(&pw,aa_math_system_smallprime[k]);
  aaBigintDiv(&rs,&mp,bigint,&pw);
  if(aaBigintIsZero(&mp)==YES) {  ret=RET_NO;   break;   }
  }
 if(ret==RET_NO)
  {
  aaBigintDelete(&pw);
  aaBigintDelete(&ab);
  aaBigintDelete(&rs);
  aaBigintDelete(&mp);
  return RET_NO;
  }

 result=1;
 rm=RAND_MAX;
 while(accuracy--)
  {
  rmax=bigint->size<=1?bigint->data[0]:rm;
  wit=aaMathRand32(0,rmax-1);
  wit=wit%(rmax-2)+2;
  aaBigintFromDword(&ab,wit);
  aaBigintJacobi(&ab,bigint,&x);
  if(x==-1) { aaBigintSub(&rs,bigint,&big_val[1]);  }  else
  if(x==0)  { rs.size=1; rs.data[0]=0;              }  else
  if(x==1)  { rs.size=1; rs.data[0]=1;              }  else
            { aaBigintFromDword(&rs,x);    oof;     }
  aaBigintCopy(bigint,&pw);
  aaBigintISub(&pw,&big_val[1]);
  #if 1
  aaBigintIDiv(&pw,&big_val[2]);
  #else
  aaBigintIShrDword(&pw,1);
  #endif

  aaBigintModPow(&ab,&pw,bigint,&mp);
  if(aaBigintIsZero(&rs)!=YES)
   {
   if(aaBigintIsEqual(&mp,&rs)!=YES) { result=0; break; }
   }
  aaBigintReset(&ab);
  aaBigintReset(&rs);
  aaBigintReset(&pw);
  aaBigintReset(&mp);
  }
 aaBigintDelete(&ab);
 aaBigintDelete(&rs);
 aaBigintDelete(&pw);
 aaBigintDelete(&mp);
 if(!result) { return RET_NO; }
 return RET_YES;
 }








 B aaBigintRandPrime                   (_bigint*bigint,H bits,H accuracy)
 {
 B str[_16K];
 B ascii;
 H i,c,val,hexlen;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bigint,aaBigintNew);
 if(bits==0||bits>16384)            { return RET_BOUNDS;     }
 if((bits%32)!=0)                   { return RET_BADPARM;    }
 hexlen=bits/4;
 if(accuracy==0||accuracy>100)      { return RET_BOUNDS;     }
 i=0;
 c=hexlen;
 while(1)
  {
  if(c==0) { break;}
  val=aaMathRand32(0,0xffffffff);
  bp=(BP)&val;
  if(c>=4)
   {
   ascii=bp[0]%10;   str[i++]=aa_hexchar[ascii];
   ascii=bp[1]%10;   str[i++]=aa_hexchar[ascii];
   ascii=bp[2]%10;   str[i++]=aa_hexchar[ascii];
   ascii=bp[3]%10;   str[i++]=aa_hexchar[ascii];
   c-=4;
   continue;
   }
  ascii=bp[0]%16;   str[i++]=aa_hexchar[ascii];
  if((c--)==0) { break; }
  ascii=bp[1]%16;   str[i++]=aa_hexchar[ascii];
  if((c--)==0) { break; }
  ascii=bp[2]%16;   str[i++]=aa_hexchar[ascii];
  if((c--)==0) { break; }
  ascii=bp[3]%16;   str[i++]=aa_hexchar[ascii];
  if((c--)==0) { break; }
  }
        str[0]=aa_hexchar[((aaMathRand32(2,6)*2)+1)];
 str[hexlen-1]=aa_hexchar[((aaMathRand32(2,6)*2)+1)];
 str[hexlen]=NULL_CHAR;
 aaBigintFromString(bigint,16,str);
 while(1)
  {
  if(aaBigintIsPrime(bigint,accuracy)==YES) { break; }
  aaBigintIAdd(bigint,&big_val[2]);
  }
 return RET_YES;
 }





 B aaBigintRandExponent                (_bigint*bigint,_bigint*bi1,u32 n)
 {
 _bigint gcd;
 u32 e;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(bigint,aaBigintNew);
 objTest(bi1,aaBigintNew);
 aaBigintNew(&gcd);
 e=aaMathRand32(0,n-1);
 while(1)
  {
  aaBigintFromDword(bi1,e);
  aaBigintGcd(bi1,bigint,&gcd);
  if(aaBigintIsEqual(&gcd,&big_val[1])==YES)  { break; }
  e=(e+1)%n;
  if(e<=2) { e=3; }
  }
 aaBigintDelete(&gcd);
 return RET_YES;
 }


/*-----------------------------------------------------------------------*/



 B aaPacketNew                         (_packet*packet)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(packet==NULL) { return RET_MISSINGPARM; }
 packet->magic=aaHPP(aaPacketNew);
 packet->is_local_data=YES;
 packet->size=0;
 packet->data_capacity=sizeof(packet->local_data);
 packet->data=packet->local_data;
 packet->data[0]=0;
 return RET_YES;
 }



 B aaPacketDelete                      (_packet*packet)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(packet,aaPacketNew);
 if(packet->is_local_data==NO)    {  if(aaMemoryRelease(packet->data)!=YES) oof;    }
 packet->is_local_data=YES;
 packet->data=NULL;
 packet->magic=0;
 return RET_YES;
 }





 B aaPacketReset                       (_packet*packet)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(packet==NULL) { return RET_MISSINGPARM; }
 if(packet->magic!=aaHPP(aaPacketNew)) { return RET_NOTINITIALIZED; }
 packet->offset=0;
 packet->size=0;
 packet->data[0]=0;
 return RET_YES;
 }




 B aaPacketIsValid                     (_packet*packet)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(packet==NULL) { return RET_MISSINGPARM; }
 objTest(packet,aaPacketNew);
 return RET_YES;
 }




 B aaPacketTrim                        (_packet*packet,H bytes)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(packet,aaPacketNew);
 if(bytes>packet->size) { return RET_BOUNDS; }
 if(bytes==0)           { return RET_YES; }
 packet->size-=bytes;
 packet->data[packet->size]=NULL_CHAR;
 return RET_YES;
 }





 B aaPacketAppend                      (_packet*packet,H bytes,VP data)
 {
 B ret;
 H left,need,i,add;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(packet,aaPacketNew);
 if(bytes==0&&data==NULL) { return RET_YES; }
 left=packet->data_capacity-packet->size;
 need=bytes+8;
 if(need>left)
  {
  add=packet->data_capacity+need+128;
  if(packet->is_local_data)
   {
   //aaNote(0,"a %i,%i->%i",packet->data_capacity,packet->size,add);
   #ifdef aa_VERSION
   aa_ZIAG("aaPacketAppendAllocate");
   #endif
   if((ret=aaMemoryAllocate((VP)&packet->data,add))!=YES) { oops; }
   for(i=0;i<packet->data_capacity;i++) { packet->data[i]=packet->local_data[i]; }
   aaMemoryNameSet(packet->data,"pktdata");
   }
  else
   {
   //aaNote(0,"b %i,%i->%i",packet->data_capacity,packet->size,add);
   #ifdef aa_VERSION
   aa_ZIAG("aaPacketAppendReAllocate");
   #endif
   if(packet->data==packet->local_data) oof;
   if((ret=aaMemoryReAllocate((VP)&packet->data,add))!=YES) { oops; }
   }
  packet->is_local_data=NO;
  packet->data_capacity=add;
  }
 if(data==NULL) { aaMemoryFill(&packet->data[packet->size],bytes,0);      }
 else           { aaMemoryCopy(&packet->data[packet->size],bytes,data);   }
 packet->size+=bytes;
 return RET_YES;
 }




 B aaPacketAppendf                     (_packet*packet,B prependlen,B appendnull,VP fmt,...)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(packet,aaPacketNew);
 aaVargsf4K(fmt);

 if(appendnull!=0&&appendnull!=1)                               { return RET_BADPARM; }
 if(prependlen!=0&&prependlen!=1&&prependlen!=2&&prependlen!=4) { return RET_BADPARM; }
 if(prependlen==1) { aaPacketAppendByte(packet,(B)str4k.len);   } else
 if(prependlen==2) { aaPacketAppendWord(packet,(W)str4k.len);   } else
 if(prependlen==4) { aaPacketAppendDword(packet,(H)str4k.len);  }
 if(str4k.len)   { aaPacketAppend(packet,str4k.len,str4k.buf); }
 if(appendnull)  { aaPacketAppendByte(packet,NULL_CHAR);       }
 return RET_YES;
 }





 B aaPacketAppendfTwo                  (_packet*packet,B prependlen,B appendnull,VP first,VP fmt,...)
 {
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(packet,aaPacketNew);
 aaVargsf4K(fmt);
 if(appendnull!=0&&appendnull!=1)                               { return RET_BADPARM; }
 if(prependlen!=0&&prependlen!=1&&prependlen!=2&&prependlen!=4) { return RET_BADPARM; }
 if(first==NULL)                                                { return RET_MISSINGPARM; }
 aaStringLen(first,&sl);
 if(prependlen==1&&sl>254)          { oof; return RET_FAILED; }
 if(prependlen==2&&sl>65534)        { oof; return RET_FAILED; }
 if(prependlen==1&&str4k.len>254)   { oof; return RET_FAILED; }
 if(prependlen==2&&str4k.len>65534) { oof; return RET_FAILED; }
 //-----------------------
 if(prependlen==1) { aaPacketAppendByte(packet,(B)sl);} else
 if(prependlen==2) { aaPacketAppendWord(packet,(W)sl);   } else
 if(prependlen==4) { aaPacketAppendDword(packet,(H)sl);  }
 if(sl)            { aaPacketAppend(packet,sl,first);    }
 if(appendnull)    { aaPacketAppendByte(packet,NULL_CHAR);  }
 //-----------------------
 sl=str4k.len;
 if(prependlen==1) { aaPacketAppendByte(packet,(B)sl);    } else
 if(prependlen==2) { aaPacketAppendWord(packet,(W)sl);    } else
 if(prependlen==4) { aaPacketAppendDword(packet,(H)sl);   }
 if(sl)            { aaPacketAppend(packet,sl,str4k.buf); }
 if(appendnull)    { aaPacketAppendByte(packet,NULL_CHAR);  }
 return RET_YES;
 }




 B aaPacketAppendOneAndHexMem          (_packet*packet,B prependlen,B appendnull,VP first,H bytes,VP mem)
 {
 H sl;
 B hex[_2K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(packet,aaPacketNew);
 if(appendnull!=0&&appendnull!=1)                               { return RET_BADPARM; }
 if(prependlen!=0&&prependlen!=1&&prependlen!=2&&prependlen!=4) { return RET_BADPARM; }
 if(first==NULL)                                                { return RET_MISSINGPARM; }
 if(mem==NULL)                                                  { return RET_MISSINGPARM; }
 aaStringLen(first,&sl);
 if(prependlen==1&&sl>254)          { oof; return RET_FAILED; }
 if(prependlen==2&&sl>65534)        { oof; return RET_FAILED; }
 if(prependlen==1&&(bytes/2)>254)   { oof; return RET_FAILED; }
 if(prependlen==2&&(bytes/2)>65534) { oof; return RET_FAILED; }
 //-----------------------
 if(prependlen==1) { aaPacketAppendByte(packet,(B)sl);} else
 if(prependlen==2) { aaPacketAppendWord(packet,(W)sl);   } else
 if(prependlen==4) { aaPacketAppendDword(packet,(H)sl);  }
 if(sl)            { aaPacketAppend(packet,sl,first);    }
 if(appendnull)    { aaPacketAppendByte(packet,NULL_CHAR);  }
 //-----------------------
 aaStringHexFromMemory(hex,&sl,bytes,mem,YES);
 if(prependlen==1) { aaPacketAppendByte(packet,(B)sl);} else
 if(prependlen==2) { aaPacketAppendWord(packet,(W)sl);   } else
 if(prependlen==4) { aaPacketAppendDword(packet,(H)sl);  }
 if(sl)            { aaPacketAppend(packet,sl,hex); }
 if(appendnull)    { aaPacketAppendByte(packet,NULL_CHAR);  }
 return RET_YES;
 }




 B aaPacketAppendByte                  (_packet*packet,u8 val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(packet,aaPacketNew);
 return(aaPacketAppend(packet,1,&val));
 }





 B aaPacketAppendWord                  (_packet*packet,u16 val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(packet,aaPacketNew);
 return(aaPacketAppend(packet,2,&val));
 }





 B aaPacketAppendDword                 (_packet*packet,u32 val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(packet,aaPacketNew);
 return(aaPacketAppend(packet,4,&val));
 }



 B aaPacketAppendQuad                  (_packet*packet,u64 val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(packet,aaPacketNew);
 return(aaPacketAppend(packet,8,&val));
 }



 B aaPacketOffsetSet                   (_packet*packet,H offset)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(packet,aaPacketNew);
 if(offset>=packet->size)      { oof; return RET_BOUNDS; }
 packet->offset=offset;
 return RET_YES;
 }




 B aaPacketRead                        (_packet*packet,H bytes,VP data)
 {
 H left;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(packet,aaPacketNew);
 left=packet->size-packet->offset;
 if(bytes>left) { return RET_BOUNDS; }
 if(bytes==0)   { return RET_YES; }
 if(data==NULL) { return RET_MISSINGPARM; }
 aaMemoryCopy(data,bytes,&packet->data[packet->offset]);
 packet->offset+=bytes;
 return RET_YES;
 }





 B aaPacketDataPtr                     (_packet*packet,H offset,BP*ptr)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(packet,aaPacketNew);
 if(ptr==NULL)                 { return RET_MISSINGPARM; }
 if(offset>=packet->size)      { oof; return RET_BOUNDS; }
 *ptr=&packet->data[offset];
 return RET_YES;
 }






 B aaPacketToString                    (_packet*packet,VP string)
 {
 B ret;
 _packet*pkt;
 B out[_32K];
 B hex[_4K];
 H off,todo;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(string) { aaStringNull(string); }
 if((ret=aaPacketIsValid(packet))!=YES) { oops;  return ret; }
 pkt=packet;
 aaStringNull(out);
 off=0;
 while(1)
  {
  if(off>=pkt->size) { break; }
  if((ret=aaPacketDataPtr(pkt,off,&bp))!=YES) {  oops; }
  todo=pkt->size-off;
  todo=aaNumRoof(todo,32);
  aaStringHexDump(hex,1,todo,32,0,1,bp,0);
  aaStringAppendf(out,"%04x:  %s\n",off,hex);
  off+=(todo+1);
  }
 if(string!=NULL) { aaStringCopy(string,out); }
 else             { aaDebugf("%s",out);       }
 return RET_YES;
 }




 B aaPacketFieldGet                    (_packet*packet,H index,HP offset,HP bytes,VP data)
 {
 H off,len,i;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(packet,aaPacketNew);
 if(bytes)  { *bytes=0;  }
 if(offset) { *offset=0; }
 if(data)   { aaStringNull(data); }
 off=i=0;
 while(off<packet->size)
  {
  bp=&packet->data[off];
  len=bp[0];
  if(i==index)
   {
   if(offset) { *offset=off+1; }
   if(bytes)  { *bytes=len;  }
   if(data)   { aaMemoryCopy(data,len,&bp[1]); bp=(BP)data; bp[len]=NULL_CHAR; }
   return RET_YES;
   }
  off+=(len+1);
  i++;
  }
 return RET_NOTFOUND;
 }





 B aaPacketFieldTwoGet                 (_packet*packet,H index,HP offset,HP bytes,VP data,HP offset2,HP bytes2,VP data2)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 objTest(packet,aaPacketNew);
 if(offset)  { *offset=0; }
 if(bytes)   { *bytes=0;  }
 if(data)    { (*(BP)data)=NULL_CHAR; }
 if(offset2) { *offset2=0; }
 if(bytes2)  { *bytes2=0;  }
 if(data2)   { (*(BP)data2)=NULL_CHAR; }
 if((ret=aaPacketFieldGet(packet,index+0,offset,bytes,data))!=YES)    { return ret; }
 if((ret=aaPacketFieldGet(packet,index+1,offset2,bytes2,data2))!=YES)
  {
  if(ret==RET_NOTFOUND) { return RET_PARTIAL; }
  return ret;
  }
 return RET_YES;
 }








/**----------------------------------------------------------------------*/



/*-----------------------------------------------------------------------*/

 V aaDummyFunction2                    (){} // this function is the first function offset, useful for aaFuncInfoGet

/*-----------------------------------------------------------------------*/

 #if aa_DIAGNOSE == YES
 #if __LINE__>aa_SHOW_DIAG_LINES
 #error "ALLOCATE MORE LINES TO DIAGNOSTICS"
 #endif
 #endif



